                           ГЛАВА 5.

                         ПОТОКИ С++.

     Эта глава делится на два раздела:  полный обзор использо-
вания  потоков  В/В С++ и раздел ссылок на указанные классы из
библиотеки класса потоков С++.
     Поток В/В  в  C++ используется для преобразования типиро-
ванных объектов в читаемый текст и наоборот. Это позволяет Вам
определять функции В/В,  которые затем автоматически использу-
ются для соответствующих,  определенных пользователем,  типов.
Дополнительные примеры можно найти в Руководстве "Начало рабо-
ты".

                       Что такое поток?

     Поток - это абстракция,  относящаяся к любому потоку дан-
ных от источника к назначению.  Мы говорим о получении (извле-
чении) когда обсуждаем  входные  символы  из  источника;  и  о
вставке (помещении или хранении),  когда говорим о выводе сим-
волов в назначение. Предоставляются классы, поддерживающие бу-
феры    памяти   (iostream.h),   файлы   (fstream.h),   строки
(strstream.h) как источники или назначения (или оба).

                     Библиотека iostream.

     Библиотека iostream имеет 2 параллельных  класса:  порож-
денные от streambuf и порожденные от ios. Оба являются низкоу-
ровневыми классами,  выполняющими различные задачи. Все классы
потоков имеют один из этих двух классов как базовый.

                       Класс streambuf.

     Класс streambuf предоставляет основные методы для буфери-
зации и управления потоками,  когда требуется небольшое форма-
тирование  (или  не требуется вовсе).  streambuf - это базовый
класс,  обслуживающий и другие части библиотеки iostream, хотя
Вы можете так же порождать классы от своих собственных функций
и библиотек.  Классы strstreambuf и filebuf являются производ-
ными от streambuf.

                          Класс ios.

     Класс ios  содержит указатель на streambuf.  Он выполняет
форматирование В/В с проверкой ошибок, используя streambuf.
     Диаграмма наследования  для  семейства  классов ios нахо-
дится на рисунке 5.2.  Например,  класс ifstream  порожден  от
классов  istream  и  fstreambase,  и  istrstream  порожден  от
istream и strstreambase. Эта диаграмма не является простой ие-
рархией из-за использования наследования нескольких предков. С
таким наследованием один класс может наследовать от более  чем
одного базового класса.  Например,  это означает6 что все эле-
менты  (данные  и  функции)  из  iostream,  istream,  ostream,
fstreambase,  ios являются частью объектов класса fstream. Все
классы  сети  ios  используют  streambuf  (или  filebuf,   или
strstreambuf, которые являются особыми классами streambuf) как
свой источник и/или назначение.

                         Рисунок 5.2.
           Класс ios и порожденные от него классы.

    ┌────────────────────>┌─────┐<──────────────────────┐
    │                 ┌──>│ ios │<─────┐                │
    │                 │   └─────┘      │                │
┌───┴───┐      ┌──────┴────┐      ┌────┴─────┐      ┌───┴───┐
│istream│<┐┌──>│fstreambase│<────┐│streambase│<─┐┌> │ostream│<┐
└───────┘ ││   └───────────┘<─┐  │└──────────┘  ││  └───────┘ │
^ ^ ^     ││                  │  │   ^ ┌───^ ───┼┘    ^    ^  │
│ │ └─────┼┼────────┐  ┌──────┼──┼───┘ │   │    │     │    │  │
│ │ ┌─────┴┴─┐   ┌──┴──┴───┐  │┌─┴─────┴┐  │┌───┴─────┴┐   │  │
│ │ │ifstream│   │istrtream│  ││ofstream│  ││ostrstream│   │  │
│ │ └────────┘   └─────────┘  │└────────┘  │└──────────┘   │  │
└─┼───────────────────┐       │    ┌───────┘               │  │
┌─┴────────────────┐  │  ┌────┴──┐ │                       │  │
│istream_withassign│  │  │fstream│ │                       │  │
└──────────────────┘  │  └─┬─────┘ │                       │  │
                      │    │┌──────┴──┐   ┌────────────────┴─┐│
                      │    ││strstream│   │ostream_withassign││
                      │    │└────┬────┘   └──────────────────┘│
                      │    │     │                            │
                      │    V     V                            │
                      │ ┌───────────┐                         │
                      └─┤  iostream ├─────────────────────────┘
                        └───────────┘
                              ^
                    ┌─────────┴─────────┐
                    │iostream_withassign│
                    └───────────────────┘

     Примечание. По  принятой практике,  стрелки проводятся ОТ
порожденного класса К базовому классу.
     Программы C++  начинаются  с  открытия 4 предопределенных
потоков, объявленных как объекты классов withassign:
     extern istream_withassign cin;  // соответствует stdin
     extern ostream_withassign cout; // соответствует stdout
     extern ostream_withassign cerr; //соответствует stderr
     extern ostream_withassign clog; // буферизованный cerr

                            Вывод.

     Выходной поток связан с оператором вывода <<. Стандартный
оператор  сдвига влево << перегружен для операций вывода.  Его
левый операнд - это объект типа класс ostream. Его правый опе-
ранд - это любой тип,  для которого был определен выходной по-
ток (то есть встроенный тип или любой тип,  для которого  была
перегрузка). Например,
     cout<<"Hello!\n";
     выводит "Hello!"  в  cout  (стандартный  выходной  поток,
обычно экран).
     Оператор << возвращает ссылку на объект ostream,  для ко-
торого он вызван. Это позволяет использовать несколько каскад-
ных вставок:
     void function_display(int i, double d)
     {
       cout << "i=" << i << ", d=" << d << "\n";
     }
на стандартный вывод будет выведено подобное
     i = 8, d = 2.34

                       Встроенные типы.

     Прямо поддерживаемые  типы  для  вставки:  char (signed и
unsigned), short (signed и unsigned), int (signed и unsigned),
long (signed и unsigned), char* (интерпретируется как строка),
float, double, long double и void*. Целые типы преобразуются в
соответствии  с правилами по умолчанию для printf (если только
Вы не изменили эти правила с помощью  флагов  ios).  Например,
для объявлений int i; long l;, операторы
     cout<<i<<" "<<l;
     printf("%d %ld", i, l);
дают одинаковый результат.
     Вставка указателя (void*) так же предопределена:
     int i = 1;
     cout<<&i;  // выводит указатель в 16-ричном виде.

                    Форматированный вывод.

     Форматирование для  ввода  и  вывода определяется флагами
формата, определенными в классе ios. Флаги определены:
 public:
 enum {
   skipws      = 0x0001, // пропускает пробелы при вводе
   left        = 0x0002, // выровненный слева вывод
   right       = 0x0004, // выровненный справа вывод
   internal    = 0x0008, // заполнение после указателя знака
                         // или базы
   dec         = 0x0010, // десятичное преобразование
   oct         = 0x0020, // восьмеричное преобразование
   hex         = 0x0040, // шестнадцатиричное преобразование
   showbase    = 0x0080, // показывает указатель базы на вывод
   showpoint   = 0x0100, // показывает десятичную точку
                         // (вывод fp)
   uppercase   = 0x0200, // вывод в 16-ричном формате
                         // прописными буквами
   showpos     = 0x0400, // показывает '+' с положительными
                         // целыми числами
   scientific  = 0x0800, // использует 1.2345Е2 fp
                         // представление и вывод Е
   fixed       = 0x1000, // использует 123.45 fp
                         // представление
   unitbuf     = 0x2000, // освобождает все потоки после
                         // вставки
   stdio       = 0x4000, // освобождает stdout, stderr
                         // после вставки
 };
     Эти флаги  читаются  и  устанавливаются с помощью элемен-
тов-функций rdstate и clear соответственно.

                         Манипуляции.

     Более простой способ  изменить  некоторые  из  переменных
формата - в использовании специального оператора,  называемого
манипулятором.  Манипуляторы используют поток как  аргумент  и
возвращают ссылку на тот же поток,  следовательно манипуляторы
могут быть включены в цепочку вывода (или ввода) для изменения
состояния  потока  в качестве побочного эффекта,  без действи-
тельного вывода (или ввода). Например
     cout<<setw(4)<<i<<setw(6)<<j;
эквивалентно
     cout.width(4);
     cout<<i;
     cout.width(6);
     cout<<j;
     setw -  это параметризованный манипулятор,  объявленный в
iomanip.h.  Другие  параметризованные  манипуляторы   setbase,
setfill,  setprecision,  setiosflags  и resetiosflags работают
так же.  Чтобы использовать их в Вашей программе  должен  быть
включен iomanip.h. Вы можете написать собственные манипуляторы
без параметров:
     ostream& dingy( ostream& os)
     {
       return os << "\a\a";
     }
     ...
     cout << i << dingy << j;
     Непараметризованные манипуляторы  dec,  hex и oct (объяв-
ленные в iostream.h) не имеют  параметров  и  просто  изменяют
основание преобразования (и оставляют ее измененной):
     int i = 36;
     cout << dec << i << " "
          << hex << i << "
          << oct << i << endl;
     // показывает 36  24  44

                         Таблица 5.1.
                     Манипуляторы потока.
______________________________________________________________
   манипулятор                 действие
______________________________________________________________
 dec                 установить флаг формата с 10-тичным осно-
                     ванием
 hex                 установить флаг формата с 16-ричным осно-
                     ванием
 oct                 установить флаг формата с 8-ричным  осно-
                     ванием
 ws                  удалить разделители
 endl                вставить новую строку и вытолкнуть поток
 ends                вставить терминальный ноль в строку
 flash               вытолкнуть поток
 setbase(int)        установить формат основания в основание n
                     (0,  8, 10 и16). 0 - по умолчанию означа-
                     ет:  10-тичная при выводе,  правила С для
                     литеральных целых при вводе.
 resetiosflags(long) Очистить биты форматирования,  заданные в
                     ins и outs.
 setiosflags(long)   Установить биты форматирования,  заданные
                     в ins и outs.
 setfill(int)        Установить символ заполнения в n
 setprecision(int)   Установить точность  плавающей  точки в n
                     цифр
 setw(int)           Установить длину поля в n.
______________________________________________________________
     Манипулятор endl вставляет символ новой строки и выталки-
вает  поток.  Вы можете так же вытолкнуть поток вывода в любое
время с помощью
     ostream<<flash;

                   Заполнение и дополнение.

     Символ заполнения  и  направление  дополнения  зависят от
установки символа заполнения и левого,  правого и  внутреннего
флагов.
     По умолчанию символ заполнения - пробел.  Вы можете изме-
нить его с помощью функции fill:
     int i = 123;
     cout.fill('*');
     cout.width(6);
     cout << i;          // показывает ***123
     По умолчанию направление дополнения дает правое  выравни-
вание  (дополняет  слева).  Вы  можете  изменить это с помощью
функций setf и unsetf:
     int i = 56;
     ...
     cout.width(6);
     cout.fill('#');
     cout.setf(ios::left,ios::adjustfield);
     cout << i;         // показывает 56####
     Второй аргумент  ios::adjustfield говорит setf какие биты
установить.  Первый аргумент ios::left говорит setf куда уста-
навливать эти биты. Альтернативно Вы можете использовать мани-
пуляторы setfill,  setiosflags и resetiosflags для модификации
символа заполнения и режима дополнения.

              Определенный пользователем вывод.

     Вы можете  перегрузить оператор << для вывода Ваших типов
данных. Предположим, у Вас есть тип
     struct info {
       char *name;
       double val;
       char *units;
     };
Вы можете перегрузить <<:
     ostream& operator << (ostream& s, info& m)
     {
       s << m.name << " " m.val << " " << m.units;
     }
операторы
     info x;
     ...
     // инициализация х
     ...
     cout << x;
     будут выводить "capacity 1.25 liters".

                               Ввод.

     Входной поток аналогичен выходному,  но использует перег-
руженный оператор сдвига вправо >>, известный как оператор из-
влечения  (получить  из).  Левый  операнд >> - это объект типа
класс и stream.  Как и для вывода,  правый оператор может быть
любого типа, для которого был определен входной поток.
     По умолчанию  >>  пропускает  разделители   (определенные
функцией  isspace  в  ctype.h),  затем  читает символы,  соот-
ветствующие типу входного объекта. Пропуск разделителей управ-
ляется  флагом  ios::skipws  в перечислении состояния формата.
Флаг skipws обычно установлен на пропуск разделителей. Очистка
этого флага (например через setf) выключает пропуск разделите-
лей.  Заметим так же, что манипулятор ws позволяет Вам удалить
разделители.
     Рассмотрим следующий пример:
     int i;
     double d;
     cin >> i >> d;
     Последняя строка приводит к пропуску разделителей; цифры,
читаемые со стандартного ввода (по умолчанию с клавиатуры) за-
тем преобразуются во внутреннюю двоичную форму и сохраняются в
переменной i;  пропускается больше разделителей,  и,  наконец,
читается число с плавающей точкой, преобразуется и сохраняется
в переменной d.
     Для типа char (signed или unsigned) действие оператора >>
заключается в том, что пропускается разделитель и запоминается
следующий символ (не-разделитель).  Если Вам нужно читать сле-
дующий символ, независимо от того, является ли он разделителем
или нет, Вы можете использовать одну из элементов-функций get.
     Для символа char* (рассматриваемого как строка), оператор
>>  пропускает  разделитель  и  запоминает  следующие  символы
(не-разделители) до тех пор,  пока не встретится другой символ
разделителя. Затем добавляется завершающий нулевой символ. Не-
обходимо избегать "переполнения" строки.  Можно изменить длину
по умолчанию (0, означающий отсутствие предела) используя setw
следующим образом:
     char array[SIZE];
     ...
     // инициализация массива
     ...
     cin.width(sizeof(array));
     cin >> array;
     Для ввода со встроенными типами,  если конец  ввода  про-
исходит  до появления любого символа не-разделителя,  то в buf
не запоминается ничего,  а состояние istream устанавливается в
"fail".  Таким образом,  если выход был не инициализирован, то
он остается не инициализированным.

          Входные типы, определенные пользователем.

     Так же, как и для вывода, Вы можете создать функции ввода
для Ваших типов данных. Для структуры info, определенной выше,
оператор >> может быть перегружен:
     istream& operator >> (istream& s, info& m);
     {
       s >> m.name >> m.val >> m.units;
       return s;
     }
     (В реальной программе Вы, конечно, добавите код для обра-
ботки  ошибок  ввода).  Для  чтения  входной строки,  подобной
"capacity 1.25 liters", используйте
     cin >> m;

                      Простой файл В/В.

     Класс ofstream  наследует  операции вывода из ostream,  а
ifstream наследует операции ввода из istream. Они предоставля-
ют констракторы и функции-элементы для создания файлов и обра-
ботки В/В.  Вы должны включить  fstream.h  во  все  программы,
использующие эти классы.  Рассмотрим пример,  который копирует
файл FILE.IN в файл FILE.OUT:
#include fstream.h
...
char ch;
ifstream fl("file.in");
if (!f1) errmsg("нельзя открыть файл 'file.in' для ввода");
ofstream f2("file.out");
if (!f2) errmsg ("нельзя открыть файл 'file.out' для вывода");
while (f2 && f1.get(ch) ) f2.put(ch);
     Примечание. Заметим, что iostream.h в Borland C++ автома-
тически включается в fstream.h.
     Заметим, что  если констракторы для ifstream или ofstream
недоступны при открытии заданных файлов, устанавливается соот-
ветствующее состояние ошибки для потока.
     Констракторы позволяют Вам объявить файл потока без  ука-
зания имени файла,  позже Вы можете связать поток с каким-либо
файлом:
     ofstream ofile;         // создает поток файла вывода
     ...
     ofile.open("payroll");  // ofile связывается с файлом
                             // "payroll"
     ofile.close();          // закрыть поток ofile
     ofile.open("employee"); //ofile можно использовать снова
     По умолчанию файл открывается в текстовом режиме. Это оз-
начает, что при вводе последовательность возврат каретки/пере-
вод строки преобразуется в символ \n.  При выводе производится
обратное преобразование.  Эти преобразования не производятся в
двоичном режиме.  Режим файла устанавливается с помощью необя-
зательного третьего параметра функции open, выбранного из сле-
дующей таблицы:
                         Таблица 5.2.
                        Режимы файлов.
────────────────────────────────────────────────────────────
 режим                        действие
────────────────────────────────────────────────────────────
 ios::app        добавление данных - всегда пишет в конец
                 файла
 ios::ate        переходит на конец файла при открытии
 ios::in         открывает на ввод (по умолчанию для
                 ifstream)
 ios::out        открывает на вывод (по умолчанию для
                 оfstream)
 ios::binary     открывает файл в двоичном режиме
 ios::trunc      удаляет содержимое, если файл существует
                 (подразумевается для ios::out и, если не
                 заданы ни ios::atе, ни ios::app)
 ios::nocreate   если файл не существует, open с ошибкой
 ios::noreplace  если файл существует, open для выходного
                 файла с ошибкой, если не заданы ate или
                 app
────────────────────────────────────────────────────────────

                Работа со строковыми потоками.

     Функции, заданные в strstream.h,  поддерживают форматиро-
вание в памяти,  подобно sscanf и sprintf, но являются гораздо
более гибкими.  Все функции из istream  допустимы  для  класса
istrstream;   также  для  вывода:  ostrstream  наследуется  от
ostream.
     Пример программы  читает текстовый файл со следующим фор-
      матом: 101 191 Cedar Chest
             102 1999.99 Livingroom Set
     Каждая строка разбивается на три  компоненты:  целый  ID,
цена в формате с плавающей точкой и описание. Вывод:
      1: 101 191.00 Cedar Chest
      2: 102 1999.99 Livingroom Set
     Ниже приведена программа:
     #include <fstream.h>
     #include <strstream.h>
     #include <iomanip.h>
     #include <string.h>

     void main(int argc, char **argv)
     {
       int id;
       float amount;
       char description[41];
       ifstream inf(argv[1], ios::in);

       if (inf)
       {
         char inbuf[81];
         int lineno = 0;

        // Числа с плавающей точкой печатаются как фиксирован-
        // ная точка
         cout.setf(ios::fixed, ios::Floatfield);

        // Числа с плавающей точкой всегда имеют десятичную
        // точку
         cout.setf(ios::showpoint);

         while (inf.getline(inbuf,81))
         {
           //'ins' является строкрвым потоком:
           istrstream ins(inbuf, strlen(inbuf));

           ++lineno;
           ins >> id >> amount >> ws;
           ins.getline(description,41); //Хранит новую строку!
           cout << lineno << ": "
               << id << '\t'
               << setprecision(2) << amount << '\t'
               << description
         }
       }
     }
     Отметим использование  флагов  формата  и манипуляторов в
выше  приведенном  примере.   Вызовы   setf   объединяются   с
setprecision,  позволяя  напечатать числа с плавающей точкой в
формате денег.  Манипулятор ws  пропускает  разделители  перед
чтением строки описания.

                 Справочник классов потоков.

     Библиотека класса  потоков  С++  содержит несколько сотен
классов.  Этот  справочник  описывает  некоторые  из  наиболее
используемых  классов,  организованных  в  алфавитном порядке.
Следующие списки перекрестных ссылок говорят, какие классы ка-
ким файлам заголовков принадлежат.
  iostream.h    ios, iostream, iostream_withassign, istream,
                istream_withassign, ostream, ostream_withassign,
                streambut.
  fstream.h     filebuf, fstream, fstreambase, ifstream, ofstream.
  strstream.h   istrstream, ostrstream, strstream, strstreambase,
                strstreambuf.

     filebuf                                    <fstream.h>
______________________________________________________________
 Порожден от    streambuf
 Основание для  Нет
 Описание       Специализирует streambuf для обработки файлов.
 Констракторы   filebuf() Делает filebuf,  не присоединенный к
                файлу.

                filebuf(int fd) Делает filebuf, присоединенный
                к файлу через описание файла.

                filebuf(int fd,  char*, int n) Делает filebuf,
                присоединенный  к  файлу и использует заданный
                n-символьный буфер.

 Элементы-      filebuf* attach(int)     Связывает    закрытый
 функции        filebuf с дескриптором открытого файла.

                filebuf* close() Освобождает и закрывает файл.
                При ошибке возвращает 0.

                int fd() Возвращает дескриптор файла или EOF.

                int is_open() Если файл открыт,  возвращает не
                0.

                filebuf* open(const char*,  int mode, int prot
                = filebuf::openprot) Открывает заданный файл и
                связывается с ним.

                virtual long seekoff(long,  seek_dir, int) Пе-
                редвигает указатель файла соответственно теку-
                щей позиции.

                virtual streambuf*  setbuf(char*,  int) Задает
                буфер для этого filebuf.


     fstream                                  <fstream.h>
______________________________________________________________
 Порожден от    fstreambase, iostream
 Основание для  Нет
 Описание       Обеспечивает одновременный ввод  и  вывод  для
                filebuf

 Констракторы   fstream() Делает fstream,  не присоединенный к
                файлу

                fstream(const char*,      int,      int      =
                filebuf::openprot) Делает  fstream,  открывает
                файл и связывается с ним.

                fstream(int) Делает   fstream,  связывается  с
                описателем открытого файла.

                fstream(int_f, char*,  int)  Делает   fstream,
                связанный  с  открытым файлом и использует за-
                данный буфер.

Элементы-       void open(const     char*,    int,    int    =
функции         filebuf::openprot) Открывает файл для fstream.

                filebuf* rdbuf()  Возвращает  используемый бу-
                фер.


     fstreambase                               <fstream.h>
______________________________________________________________
 Порожден от    ios
 Основание для  fstream, ifstream, ofstream
 Описание       Предоставляет операции, общие для потоков фай-
                лов.

 Констракторы   fstreambase() Делает fstreambase, не присоеди-
                ненный к файлу.

                fstreambase(const char*,     int,     int    =
                filebuf::openprot) Делает fstreambase,  откры-
                вает файл и связывается с ним.

                fstreambase(int) Делает fstreambase,  связыва-
                ется с описателем открытого файла.

                fstreambase(int_f, char*,     int)      Делает
                fstreambase,  связанный  с  открытым  файлом и
                использует заданный буфер.

 Элементы-      void attach(int) Связывается с дескриптором
 функции        открытого файла.

                void close()  Закрывает  соединенный filebuf и
                файл.

                void open(const    char*,    int,    int     =
                filebuf::openprot)    Открывает    файл    для
                fstreambase.

                filebuf* rdbuf() Возвращает  используемый  бу-
                фер.

                void setbuf(char*,int) Использует заданный бу-
                фер.


     ifstream                                   <fstream.h>
______________________________________________________________
 Порожден от    fstreambase, istream
 Основание для  Нет
 Описание       Предоставляет операции ввода по filebuf.
 Констракторы   ifstream() Делает ifstream,  не присоединенный
                к файлу.

                ifstream(const char*,      int,      int     =
                filebuf::openprot)  Делаетifstream,  открывает
                файл и связывается с ним.

                ifstream(int) Делает  ifstream,  связывается с
                описателем открытого файла.

                ifstream(int fd,  char*, int) Делает ifstream,
                связанный  с  открытым файлом и использует за-
                данный буфер.

 Элементы-      void open(const     char*,    int,    int    =
 функции        filebuf::openprot)    Открывает    файл    для
                ifstream.

                filebuf* rdbuf() Возвращает  используемый  бу-
                фер.

     ios                                        <iostream.h>
______________________________________________________________
 Порожден от    Нет
 Основание для  istream, ostream, fstreambase, strstrembase
 Описание       Класс ios предоставляет  операции,  общие  для
                ввода и вывода.  Он порождает классы (istream,
                ostream,  iоstream), специализирующиеся на В/В
                с операциями форматирования на высоком уровне.

 Констракторы   ios (streambuf)cc Связывает данный streambuf с
                потоком.

 Элементы-      int bad() Если случилась ошибка, не 0.
 функции
                void clear(int=0) Устанавливает значение пото-
                ка на данное значение.

                int eof() Не 0 на конце файла.

                int fail() Не 0, если операция неудачна.

                char fill()  Возвращает  текущий   заполняющий
                символ.

                char fill(char) Устанавливает заполняющий сим-
                вол; возвращает предыдущее значение.

                long flags() Возвращает текущие флаги формата.

                long flags(long) Устанавливает флаги  формата,
                идентичные данным long;  возвращает предыдущие
                флаги.

                int good() Не 0, если установлены биты состоя-
                ния (это значит, что ошибок не было).

                int precision(int) Устанавливает точность пла-
                вающей точки; возвращает предыдущие установки.

                int precision() Возвращает текущую точность  с
                плавающей точкой.

                streambuf* rdbuf()   Возвращает  указатель  на
                присвоенный этому потоку strembuf.

                int rdstate() Возвращает состояние потока.

                long setf(long_setbits,  long_field) Очищаются
                биты,  соответствующие помеченным в _field,  а
                затем  устанавливаются  равными  помеченным  в
                _setbits.

                long setf(long)   Устанавливает  флаги,  соот-
                ветствующие помеченным в long; возвращает пре-
                дыдущие установки.

                ostream* tie()  Возвращает связанный поток,  и
                0,  если его нет. Связанные потоки - это пото-
                ки,  связанные  таким  образом,  что если один
                используется,  то на другой это каким-то обра-
                зом влияет. Например, cin и cout связаны; ког-
                да используется cin,  то первым  выбрасывается
                cout.

                ostream* tie(ostream*)  Связывает другой поток
                с данным и возвращает предыдущие связанные по-
                токи,  если они были.  Когда поток ввода имеет
                символы, которые должны поглощаться, или, если
                поток вывода требует больше символов,  то свя-
                занный поток автоматически выбрасывается  пер-
                вым.  По умолчанию cin,  cerr и clog связаны с
                cout.

                long unsetf(long) Очищает биты,  соответствую-
                щие  помеченным  long;  возвращает  предыдущие
                установки.

                int width() Возвращает текущую установку  дли-
                ны.

                int width()  Устанавливает  длину  на заданное
                значение; возвращает предыдущую длину.

 iostream                                      <iostream.h>
______________________________________________________________
 Порожден от    istream, ostream
 Основание для  fstream, strstream
 Описание       Этот класс  представляет собой просто смешение
                своих базовых классов, допуская и ввод и вывод
                потока.
 Констракторы   iostream(streambuf*) Связывает          данный
                streambuf с потоком.
 Элементы-      Нет
 функции


 iostream_withassign                          <iostream.h>
______________________________________________________________
 Порожден от    iostream
 Основание для  Нет
 Описание       Этот класс  является iostream с дополнительным
                оператором присваивания.
 Констракторы   iostream_withassign(): Null констрактор (вызы-
                вает констрактор iostream)
 Элементы-      Нет (хотя оператор = перегружается).
 функции


 istream                                       <iostream.h>
______________________________________________________________
 Порожден от    ios
 Основание для  ifstream, iostream, istrstream,
                istream_withassign
 Описание       Этот класс  обеспечивает форматированный и не-
                форматированный ввод для  streambuf.  Оператор
                >> перегружается для встроенных, скалярных ти-
                пов, как объяснялось в начале  этой  главы,  а
                здесь не описывается.
 Констракторы   istream(streambuf*) Связывает данный streambuf
                с потоком.
 Элементы-      int gcount Возвращает число последних
 функции        извлеченных символов.

                int get() Извлекает последний символ или  EOF.

                istream& get(signed char*,  int  len,  char  =
                '\n')
                istream& get(unsigned char*,  int len,  char =
                '\n') Извлекают  символы в данный char* до тех
                пор, пока не  встретятся  разделитель  (третий
                параметр) или  конец файла,  или пока не будет
                прочитано (len-1) байт. В строке вывода всегда
                помещается завершающий  нуль.  Разделитель ни-
                когда. Ошибка только в том случае,  если будет
                извлечен не символ.

                istream& get(unsigned char&)
                istream& get(signed char&) Извлекают один сим-
                вол в данную ссылку на символ.

                istream& get(streambuf&, char = '\n') Извлека-
                ет символы в данный streambuf до тех пор, пока
                не встретится разделитель.

                istream&   getline(signed   char*,  int,  char
                ='\n')
                istream& getline(unsigned  char*,  int,
                char = '\n') Как get, за исключением того, что
                извлекается разделитель.

                istream& ignore(int n = 1,  int delim = EOF) В
                потоке вывода пропускаются n символов; остано-
                вка происходит при встрече  delim.

                int peek() Возвращает следующий символ без из-
                влечения.

                istream& putback(char) Заталкивает символ  об-
                ратно в поток.

                istream& read(signed char*, int)
                istream& read(unsigned char*,  int)  Извлекает
                данное количество  символов в массив.  Исполь-
                зуйте gcount() для получения  числа  символов,
                действительно извлеченных в случае ошибки.

                istream& seekg(long)   Передвигает  абсолютную
                позицию (как возвращенную из tellg).

                istream& seekg(long, seek_dir) Передвигает по-
                зицию относительно текущей позиции, следуя оп-
                ределению: enum seek_dir{beg,  cur,  end};

                long tellg() Возвращает текущую позицию  пото-
                ка.


     istream_withassign                         <iostream.h>
______________________________________________________________
 Порожден от    istream
 Основание для  Нет
 Описание       Этот класс  является  istream с дополнительным
                оператором присваивания.
 Констракторы   istream_withassign() - Null констрактор (вызы-
                вает констрактор istream).
 Элементы-      Нет (хотя оператор = перегружен).
 функции


     istrstream                                <strstream.h>
______________________________________________________________
 Порожден от    strstreambase, istream
 Основание для  Нет
 Описание       Обеспечивает операции ввода по strstreambuf.
 Констракторы   istrstream(const char*)  Делает  istrstream  с
                заданной  строкой  (нулевой  символ никогда не
                извлекается).

                istrstream(const char*,    int    n)    Делает
                istrstream, используя n байтов заданной  стро-
                ки.

 Элементы-      Нет
 функции


     ofstream                                   <fstream.h>
______________________________________________________________
 Порожден от    fstreambase, ostream
 Основание для  Нет
 Описание       Обеспечивает операции ввода по filebuf.
 Констракторы   ofstream() Делает ofstream,  не присоединенный
                к файлу.

                ofstream(const char*,      int,      int     =
                filebuf::openprot) Делает ofstream,  открывает
                файл и связывается с ним.

                ofstream(int) Делает  ofstream,  связывается с
                дескриптором открытого файла.

                ofstream(int fd,  char*, int) Делает ofstream,
                связанный с открытым файлом,  и использует за-
                данный буфер.

 Элементы-      void open(const     char*,    int,    int    =
 функции        filebuf::openprot) Открывает файл для ofstream.

                filebuf* rdbuf() Возвращает используемый буфер.


     ostream                                      <iostream.h>
______________________________________________________________
 Порожден от    ios
 Основание для  iostream, ofstream, ostrstream,
                ostream_withassign
 Описание       Этот класс  обеспечивает форматированный и не-
                форматированный вывод для streambuf.  Оператор
                << перегружен для встроенных, скалярных типов.
 Констракторы   ostream(streambuf*) Связывает данный streambuf
                с потоком.
 Элементы-      ostream& flush() Выбрасывает поток.
 функции        ostream& seekp(long)  Передвигает   абсолютную
                позицию (возвращенную из tellp).

                ostream& seekp(long,  seek_dir) Перемещает по-
                зицию относительно  текущей,  следуя определе-
                нию: enumseek_dir{beg, cur, end}

                ostream& put(char) Вставляет символ.

                long tellp() Возвращает текущую позицию  пото-
                ка.

                ostream& write(const signed char*, int n)
                ostream& write(const unsigned  char*,  int  n)
                Вставляет n символов (включая нулевые).


     ostream_withassign                         <iostream.h>
______________________________________________________________
 Порожден от    ostream
 Основание для  Нет
 Описание       Этот класс  является  ostream_withassign с до-
                полнительным оператором присваивания.
 Констракторы   ostream_withassign() - Null констрактор (вызы-
                вает констрактор  ostream).
 Элементы-      Нет (хотя оператор = перегружен).
 функции


     ostrstream                               <strstream.h>
______________________________________________________________
 Порожден от    strstreambase, ostream
 Основание для  Нет
 Описание       Обеспечивает операции вывода по strstreambuf.
 Констракторы   ostrstream() Делает динамический ostrstream.

                ostrstream(char*, int,  int) Делает ostrstream
                с заданным буфером в n байт.  Если mode  явля-
                ется ios::app   или   ios::ate,  то  указатель
                взять/получить позиционирован на нулевом  сим-
                воле строки.

 Элементы-      char *pcount() Возвращает число байт,  находя-
 функции        щихся в буфере.

                char *str() Возвращает и  замораживает  буфер.
                Вы должны освободить его,  если он был динами-
                ческим.


     streambuf                                  <iostream.h>
______________________________________________________________
 Порожден от    Нет
 Основание для  filebuf, strstreambuf
 Описание       Это класс  обработки  буфера. Обычно   он   не
                используется, но от него можно породить классы
                для приложений.
 Констракторы   streambuf() Создает пустой объект буфера.

                streambuf(char*, int) Использует данный массив
                и размер как буфер.

 Элементы-      int in_avail()  Возвращает   число   символов,
 функции        оставшихся в буфере ввода.

                int out_waiting() Возвращает  число  символов,
                оставшихся в буфере вывода.

                int sbumpc()  Возвращает текущий символ из бу-
                фера ввода, затем продвигается вперед.

                virtual long seekoff(long, seek_dir, int =
                (ios::in | ios::out)) Перемещает указатель по-
                лучить и/или взять (третий аргумент, определя-
                ющий и/или) относительно текущей позиции.

                virtual long seekpos(long, int =
                (ios::in | ios::out)) Перемещает указатель по-
                лучить и/или взять на абсолютную позицию.

                int sgetc()  Смотрит следующий символ в буфере
                ввода.

                int sgetn(char*,  int n) Берет первые n симво-
                лов из буфера ввода.

                virtual streambuf*  setbuf(signed char*,  int)
                Связывается с данным буфером.

                int snextc() Продвигается вперед и  возвращает
                следующий символ из буфера ввода.

                int sputbackc(char) Возвращает символ для вво-
                да.

                int sputc(int) Помещает один  символ  в  буфер
                вывода.

                int sputn(const char*,  int n) Помещает n сим-
                волов в буфер вывода.

                void stossc() Продвигается к следующему симво-
                лу в буфере ввода.


     strstreambase                             <strstream.h>
______________________________________________________________
 Порожден от    ios
 Основание для  strstream, istrstream, ostrstream
 Описание       Специализирует ios для строковых потоков.
 Констракторы   strstreambase() Делает пустой strstreambase.

                strsrteambase(const char*,  int,  char *start)
                Делает strstreambase с заданным буфером и  на-
                чальной позицией.

 Элементы-      Нет (использует ios).
 функции


     strstreambuf                              <strstream.h>
______________________________________________________________
 Порожден от    streambuf
 Основание для  Нет
 Описание       Специализирует streambuf для форматирования  в
                памяти.
 Констракторы
                strstreambuf() Делает             динамический
                strstreambuf. Память  будет распределена дина-
                мически.

                strstreambuf(void * (*) (long),
                void *  (*) (void*)) Делает динамический буфер
                с заданным распределением и свободными функци-
                ями.

                strstreambuf(int n)     Делает    динамический
                strstreambuf, вначале  распределяя  буфер   по
                крайней мере в  n байт.

                strstreambuf(char*, int,   char  *end)  Делает
                статический strstreambuf с  заданным  буфером.
                Если end не 0, то он ограничивает буфер.

 Элементы-      void freeze(int = 1) Если  параметр  ввода  не
 функции        нулевой, то  хранение  любых символов в буфере
                запрещено. Размораживается передачей нуля.

                char *str()  Возвращает  указатель  на буфер и
                замораживает его.

                virtual streambuf* setbuf(char*,  int)  Задает
                буфер для использования.

                virtual long seekoff(long, see_dir, int) Пере-
                мещает указатель относительно текущей позиции.


     strstream                               <strstream.h>
______________________________________________________________
 Порожден от    strstreambase, iostream
 Основание для  Нет
 Описание       Обеспечивает одновременный ввод  и  вывод  для
                strstreambuf.
 Констракторы   strstream()  Делает динамический strstream.

                strstream(char*, int   n,   int  mode)  Делает
                strstream с заданным буфером в  n  байт.  Если
                mode равен ios::app или ios::ate, то указатель
                взять/получить позиционируется на нулевой сим-
                вол строки.

 Элементы- char *str() Возвращает и замораживает буфер.  Поль-
 функции        зователь должен освободить его,  если  он  был
                динамическим.
