     sbrk
──────────────────────────────────────────────────────────────
Функция        Изменяет распределение памяти для сегмента дан-
               ных.

Синтаксис      #include <alloc.h>
               void *sbrk(int incr);

Прототип в     alloc.h

Замечания      sbrk добавляет  incr  байтов  к верхней границе
               сегмента и соответственно изменяет распределен-
               ную  память.  incr может быть отрицательным,  в
               этом случае объем распределенной памяти  умень-
               шается.
               sbrk завершится  без  каких-либо  изменений   в
               распределении памяти,  если затребованные изме-
               нения приводят к распределению  большего  коли-
               чества памяти, чем доступно.

Значение       При успешном  завершении sbrk возвращает старое
               значение верхней границы сегмента. При неуспеш-
               ном исходе sbrc возвращает значение -1,  а гло-
               бальная  переменная  errno  устанавливается   в
               ENOMEM Недостаточно основной памяти

Переносимость  Эта функция   доступна  в  системах  UNIX.  Она
               несовместима с Windows.

См. также      brk

Пример         #include <stdio.h>
               #include <alloc.h>

               int main(void)
               {
                printf("Changing allocation with sbrk()\n");
                printf("Before sbrk() call: %lu bytes free\n",
                       (unsigned long) coreleft());
                sbrk(1000);
                printf("After sbrk() call: %lu bytes free\n",
                       (unsigned long) coreleft());
                return 0;
               }

     scanf
──────────────────────────────────────────────────────────────
Функция        Форматный ввод из стандартного входного  потока
               (stdin).

Синтаксис      #include <stdio.h>
               int scanf(const char *format [, address,...]);

Прототип в     stdio.h

Замечания      scanf посимвольно   читает   последовательность
               входных полей из stdin.  Каждое поле форматиру-
               ется в соответствии со  спецификацией  формата,
               передаваемой scanf в строке формата, на которую
               указывает  format.  Наконец,  scanf  записывает
               форматированный  ввод по адресам,  переданным в
               качестве аргументов, следующих за format. Коли-
               чество  спецификаций  формата  и адресов должно
               совпадать с количеством входных полей.

               Строка формата
               Строка формата используется в scanf и связанных
               с ней функциях cscanf,  fscanf, sscanf, vscanf,
               vfscanf и vsscanf для указания того,  как функ-
               ция должна прочитать,  преобразовать и записать
               входные поля.  Адресов должно  быть  не  меньше
               спецификаций  формата.  В  противном случае ре-
               зультаты непредсказуемы и,  возможно, катастро-
               фические.  Избыток адресов (больше,  чем требу-
               ется форматом) просто игнорируется.

         !!!   scanf часто приводит к неожиданным результатам,
               если входное поле расходится с ожидаемым шабло-
               ном. Вы должны не забыть указать, как обрабаты-
               вать конец строки. Комбинация gets или fgets со
               sscanf проста и надежна, поэтому предпочтитель-
               на.

               Строка формата - символьная строка,  содержащая
               объекты трех типов: символы-разделители, основ-
               ные символы и спецификаторы формата.

               - К   символам-разделителям  относятся  пробел,
               символ табуляции (\t)  и  символ  конца  строки
               (\n).  Если  функция  ...scanf  встречает  сим-
               вол-разделитель в строке формата, она будет чи-
               тать,  но  не записывать все последующие симво-
               лы-разделители до следующего основного  символа
               во входном потоке.
               - Основные символы - это все остальные  символы
               ASCII, кроме символа процента (%). Если функция
               ...scanf встречает основной символ в  форматной
               строке,  она  будет  читать,  но не записывать,
               соответствующий основной символ. - Спецификато-
               ры формата заставляют функцию
               ...scanf читать и  преобразовывать  символы  из
               входного поля в значения определенного типа,  а
               затем записывать их по заданным адресам.

               Конечные символы-разделители останутся непрочи-
               танными (включая символ конца строки), если они
               не совпадают с явно указанными в строке  форма-
               та.

               СПЕЦИФИКАТОРЫ ФОРМАТА
               Спецификаторы формата имеют следующую форму:
                  % [*] [width] [F/N] [h/l/L] type_character
               Каждый спецификатор формата начинается с симво-
               ла процента (%).  После %  следуют, в указанном
               порядке:
               - необязательный символ подавления за-
                 писи в память,
                 [*]
               - необязательный спецификатор ширины, [width]
               - необязательный модификатор размера указателя,
                 [F/N]
               - необязательный  модификатор  типа  аргумента,
                 [h/l/L]
               - type_character - символ типа

Необязательные Необязательные    символы    и    спецификаторы
символы        управляют    следующими    общими     аспектами
строки         форматирования:
формата        ───────────────────────────────────────────────
               Символ или           Чем управляет или
               спецификатор         что определяет
               ───────────────────────────────────────────────
                *             Подавляет   запись   в    память
                              следующего входного поля.
                width         Максимальное количество читаемых
                              символов;   меньшее   количество
                              может   быть   прочитано,   если
                              ...scanf               встречает
                              символ-разделитель           или
                              непреобразуемый символ.
                size          Изменяет      принимаемое     по
                              умолчанию значение длины адреса:
                                    N = near pointer
                                    F = far pointer
                argument      Изменяет     принимаемое      по
                type          умолчанию значение типа аргумента
                               h = short int
                               l = long int  (если символ типа
                                   определяет преобразование в
                                   целый тип)
                               l = double  (если  символ  типа
                                   определяет преобразование в
                                   тип с плавающей точкой)
                               L = long    double   (допустимо
                                   только для преобразования в
                                   тип  с   плавающей  точкой)
               ───────────────────────────────────────────────
Символы        Следующая таблица   содержит   символы    типов
типа           ...scanf,  а также для каждого из них ожидаемый
               тип на входе и выходной формат.

               Информация в этой таблице приведена в предполо-
               жении,  что никакого  необязательного  символа,
               спецификатора  или  модификатора (*,  width или
               size) не содержится в строке формата. Чтобы уз-
               нать,  как  добавление необязательных элементов
               влияет на вход ...scanf,  смотрите  последующие
               таблицы.
               ───────────────────────────────────────────────
                Символ    Ожидаемый                Тип
                 типа       ввод                аргумента
               ───────────────────────────────────────────────
               Числовые
                d   Десятичное целое Указатель на int(int*arg)
                D   Десятичное целое Указатель на long
                                     (long *arg)
                o   Восьмеричн.целое Указатель на int(int*arg)
                О   Восьмеричн.целое Указатель на long
                                     (long *arg)
                i   Десятичное,      Указатель на int(int*arg)
                    восьмеричное или
                    шестнадцатеричн.
                    целое
                I   Десятичное,      Указатель на long
                    восьмеричное или (long *arg)
                    шестнадцатеричн.
                    целое
                u   Беззнаковое      Указатель на unsigned int
                    десятичное целое (unsigned int *arg)
                U   Беззнаковое      Указатель   на   unsigned
                    десятичное целое long (unsigned long *arg)
                x   Шестнадцатеричн. Указатель на int(int*arg)
                    целое
                X   Шестнадцатеричн. Указатель на long
                    целое            (long *arg)
                e,E Число с плав.    Указатель на float
                    точкой           (float *arg)
                f   Число с плав.    Указатель на float
                    точкой           (float *arg)
                g,G Число с плав.    Указатель на float
                    точкой           (float *arg)

               Символьные
                s   Строка символов  Указатель на массив
                                     символов (char arg[])
                c   Символ           Указатель  на  символ
                                     (char *arg), если ширина
                                     поля W задана вместе с
                                     символом типа c(например,
                                     %5c).
                                     Указатель на массив из W
                                     символов (char arg[W]).
                %   Символ %         Никакого   преобразования
                                     не делается; записывается
                                     лишь символ %.

               Указатели
                n                    Указатель на int(int*arg)
                                     Количество символов,
                                     успешно   прочитанных  до
                                     %n, передается в указыва-
                                     емый адрес int.
                p   Шестнадцатирич.  Указатель на объект (far*
                    форма YYYY:ZZZZ  или near*).
                    или ZZZZ         %p по  умолчанию преобра-
                                     зует к  указателю,  длина
                                     которого является  основ-
                                     ной для используемой  мо-
                                     дели памяти.
               ───────────────────────────────────────────────
Входные поля
               Любая из следующих последовательностей рассмат-
               ривается как входное поле:
               - все символы до следующего символа-разделителя
               (исключая его самого)
               - все символы до первого, который не может быть
               преобразован  текущим  спецификатором   формата
               (например, 8 или 9 при восьмеричном формате)
               - не более n символов,  где  n  -  указанная  в
               строке формата ширина поля.

Соглашения     Ниже приводятся соглашения, связанные с некото-
               рыми спецификаторами формата.

               %c ПРЕОБРАЗОВАНИЕ
               Этот спецификатор   читает   очередной  символ,
               включая  символ-разделитель.  Чтобы  пропустить
               один  символ-разделитель  и прочитать следующий
               основной символ, используйте %1s.

               %Wc ПРЕОБРАЗОВАНИЕ (W = спецификатор ширины по-
               ля)  Адрес  -  указатель  на  массив  символов,
               состоящий из W элементов (char arg[W]).

               %s ПРЕОБРАЗОВАНИЕ
               Адрес -  указатель  на  массив  символов  (char
               arg[]).  Длина массива  должна  быть  не  менее
               (n+1) байтов,  где n - длина строки s (в симво-
               лах).  Пробел или символ новой строки завершает
               входное поле. Нулевой символ-ограничитель стро-
               ки автоматически присоединяется к строке и  пе-
               редается  в качестве последнего элемента масси-
               ва.

               %[множество_поиска] ПРЕОБРАЗОВАНИЕ
               Множество символов,  заключенное  в  квадратные
               скобки,  может быть подставлено вместо  символа
               типа  s.  Адрес  - указатель на массив символов
               (char arg[]).

               Квадратные скобки ограничивают множество поиска
               возможных символов,  составляющих строку (вход-
               ное поле).  Если первым символом  в  квадратных
               скобках  является "домик" (^),  в множество по-
               иска включаются все символы ASCII,  кроме  тех,
               которые содержатся внутри скобок.  (В этом слу-
               чае символ "домик" (^), как правило, включается
               в множество поиска, за исключением случая, ког-
               да он явно присутствует дальше внутри  скобок).
               Входное  поле - строка,  не ограниченная симво-
               лом-разделителем. ...scanf читает входное поле,
               пока не встретит символ,  отсутствующий во мно-
               жестве поиска.  Два примера этого типа преобра-
               зования:
                  %[abcd]  Отыскивает все символы   a, b, c, d
                           во входном поле.
                  %[^abcd] Отыскивает любые  символы, отличные
                           от a, b, c, d во входном поле.
               Вы можете также использовать возможность  зада-
               ния диапазонов символов (цифр или букв) во мно-
               жестве  поиска.  Например,  чтобы  выбрать  все
               десятичные  цифры,  Вы могли бы определить мно-
               жество поиска как %[012345679],  или  использо-
               вать сокращение %[0-9].  Чтобы выбрать алфавит-
               но-цифровые символы, используйте следующие сок-
               ращения:
                  %[A-Z]        Выбирает все  заглавные  буквы
                  %[0-9A-Za-z]  Выбирает все  десятичные цифры
                                и  все   буквы   (заглавные  и
                                строчные)
                  %[A-FT-Z]     Выбирает все заглавные буквы
                                от A до F и от T до Z.
               Правила  использования таких сокращений неслож-
               ны:
               - Символ,  стоящий перед  дефисом  (-),  должен
               предшествовать символу,  стоящему после дефиса,
               в алфавитном порядке.
               - Дефис  не может быть ни первым,  ни последним
               символом множества (если он является первым или
               последним,  он интерпретируется просто как сим-
               вол -,  но не как элемент,  определяющий диапа-
               зон).
               - Символы  по обе стороны от дефиса должны быть
               концами диапазона и не входить в другие  диапа-
               зоны.  Приведем  несколько примеров,  где дефис
               означает только самого себя,  но не  определяет
               никакого диапазона:
                  %[-+*/]       Четыре арифметических операции.
                  %[z-a]        Символы z, - и a.
                  %[+0-9-A-Z]   Символы + и - и диапазоны  0-9
                                и A-Z
                  %[+0-9A-Z-]   Также символы + и - и диапазо-
                                ны 0-9 и A-Z.
                  %[^-0-9+A-Z]  Все символы, кроме +, - и вхо-
                                дящих в диапазоны 0-9 и A-Z.

               %e, %E,  %f, %g И %G - ПРЕОБРАЗОВАНИЯ С ПЛАВАЮ-
               ЩЕЙ  ТОЧКОЙ
               Числа с плавающей точкой во входном поле должны
               соответствовать следующему общему формату:
               [+/-] ddddddddd [.] dddd [E/e]  [+/-]  ddd  где
               [что-то] означает,  что "что-то" - необязатель-
               ный элемент,  а  ddd  представляет  десятичные,
               восьмеричные или шестнадцатеричные цифры.
INF=Бесконеч-  Кроме того, +INF, -INF, +NAN и -NAN распознают-
    ность      ся как числа с плавающей точкой. Заметьте,  что
NAN=Не-Число   знак и заглавные буквы обязательны!

               %d,  %i,  %o,  %x,  %D,  %I,  %O,  %X,  %c,  %n
               ПРЕОБРАЗОВАНИЯ
               Указатель на unsigned char,  unsigned  int  или
               unsigned long можно использовать в любом преоб-
               разовании, где допустимы указатели на char, int
               или long.

Символ         Символ подавления  записи в память  - звездочка
подавления     (*); его не следует путать с оператором косвен-
записи         ной адресации (оператором указателя) языка C.
в память       Если звездочка следует за символом процента (%)
               в спецификаторе формата, следующее входное поле
               будет  прочитано,  однако  не будет записано по
               очередному адресу.  Пропускаемые входные данные
               предполагаются  соответствующими  символу  типа
               спецификатора формата,  следующему за  звездоч-
               кой. Успешное завершение обработки входного по-
               ля и подавление записи в память непосредственно
               не наблюдаемо.

Спецификаторы  Спецификатор ширины  поля  (n) - десятичное це-
ширины         лое,  устанавливающее  максимальное  количество
               символов,  которое  будет прочитано из текущего
               входного поля. Если входное поле содержит мень-
               ше n символов,...scanf читает все символы поля,
               а затем переходитк следующему полю и специфика-
               тору формата.

               Если символ-разделитель   или   непреобразуемый
               символ  встретится прежде,  чем будет прочитано
               указанное количество символов,  символы  вплоть
               до этого символа читаются,  преобразуются и пе-
               редаются, после чего функция переходит к следу-
               ющему спецификатору формата.
               К непреобразуемым символам относятся такие, ко-
               торые  не  могут  быть  преобразованы  в  соот-
               ветствии с заданным форматом (такие,  как 8 или
               9, когда формат восьмеричный, или J или K, ког-
               да формат  шестнадцатеричный  или  десятичный).
               ───────────────────────────────────────────────
               Спецификатор Как он воздействует на
                 ширины            ширину входного поля
               ───────────────────────────────────────────────
                   n         Не  более  n  символов  читаются,
                             преобразуются и  записываются  по
                             текущему адресу.
               ───────────────────────────────────────────────
Модификаторы   Модификаторы длины  адреса (N и F) и типа аргу-
длины адреса   мента (h, l и L) определяют, как ...scanf будет
и типа         интерпретировать соответствующий адрес arg. F и
аргумента      N перекрывают принимаемый по умолчанию или объ-
               явленный размер arg.

               h, l и L определяют, какой тип (вариант) следу-
               ющих входных  данных  будет  использован  (h  =
               short, l = long, L = long double). Входные дан-
               ные будут преобразованы к  указанному  типу,  и
               arg  для  этого поля должен указывать на объект
               соответствующего размера (short - для %h,  long
               -   для   %l   и   double   long   -  для  %L).
               ───────────────────────────────────────────────
               Модификатор   Какое   преобразование   вызывает
               ───────────────────────────────────────────────
                  F        Перекрывает  принимаемый по умолча-
                           нию  или объявленный размер адреса;
                           arg   интерпретируется   как    far
                           pointer.
                  N        Перекрывает принимаемый по  умолча-
                           нию  или объявленный размер адреса;
                           arg   интерпретируется   как   near
                           pointer. Не может использоваться ни
                           с какими преобразованиями для боль-
                           ших моделей памяти.
                  h        Для типов d, i, o, u, x преобразует
                           входные  данные  в  short int и за-
                           писывает их в short объект. Для ти-
                           пов D,  I, O, U, X не оказывает ни-
                           какого эффекта.  Для типов e, f, g,
                           c,  s,  n,  p не оказывает никакого
                           эффекта.
                  l        Для типов d, i, o, u, x преобразует
                           входные данные в long int и записы-
                           вает их в long объект. Для типов e,
                           f,  g преобразует входные данные  в
                           double  и  записывает  их  в double
                           объект.  Для типов D, I, O, U, X не
                           оказывает никакого эффекта. Для ти-
                           пов c, s, n, p не оказывает никако-
                           го эффекта.
                  L        Для типов e, f, g преобразует вход-
                           ные  данные в long double и записы-
                           вает их в long double объект.  L не
                           оказывает   никакого   эффекта  для
                           остальных форматов.
               ───────────────────────────────────────────────
Когда scanf    scanf может  прекратить обработку текущего поля
прекращает     до достижения обычного символа конца поля (сим-
работу         вола-разделителя),  или  вообще  завершиться по
               различным причинам.
               scanf прекращает  обработку  и  запись текущего
               поля и переходит к следующему входному  полю  в
               любом из следующих случаев:
               - Символ подавления записи в память (*) обнару-
               жен после символа процента в спецификаторе фор-
               мата;  текущее входное поле читается, но не пе-
               редается.
               - width символов уже прочитаны (width =  специ-
               фикатор  ширины поля,  положительное десятичное
               целое в спецификаторе формата).
               - Очередной  прочитанный  символ  не может быть
               преобразован в соответствии с текущим  форматом
               (например, A - если формат десятичный).
               - Очередной  символ входного поля не содержится
               во множестве поиска.

               Когда scanf прекращает обработку текущего вход-
               ного поля по одной из  этих  причин,  очередной
               символ  считается  непрочитанным и рассматрива-
               ется как первый символ следующего входного поля
               или первый символ следующей операции ввода.

               scanf будет  завершаться  при следующих обстоя-
               тельствах:
               - Очередной   символ  входного  поля  не  соот-
               ветствует текущему основному символу  в  строке
               формата.
               - Очередной символ входного поля есть EOF.
               - Строка формата исчерпана.
               Если последовательность символов, не являющаяся
               частью  спецификатора  формата,  встречается  в
               строке формата,  она должна соответствовать те-
               кущей  последовательности символов входного по-
               ля;  scanf будет читать, но не записывать в па-
               мять эти символы. Когда обнаруживается несовпа-
               дающий символ, он остается во входном поле, как
               если бы он вообще не был прочитан.

Значение       scanf возвращает количество  успешно  прочитан-
               ных,  преобразованных  и  записанных  в  память
               входных полей; возвращаемое значение не включа-
               ет прочитанные поля, которые не были записаны в
               память.  Если scanf пытается читать  за  концом
               файла,  возвращается EOF.  Если ни одно поле не
               записано в память, возвращается 0.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie. Эта функция несовместима с Windows.

См. также      atof, cscanf,  fscanf,  getc,  printf,  sscanf,
               vfscanf, vscanf, vsscanf

Пример         #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  char label[20];
                  char name[20];
                  int entries = 0;
                  int loop, age;
                  double salary;
                  struct Entry_struct
                  {
                     char  name[20];
                     int   age;
                     float salary;
                  } entry[20];
               /* Ввести метку как строку, ограниченную 20
                  символами */
                  printf("\n\nPlease enter a label for the "
                         "chart: ");
                  scanf("%20s", label);
               /* подавить входной поток в случае неверных
                  входных данных */
                  fflush(stdin);
               /* Ввести число входных данных как integer */
                  printf("How many entries will there be?
                         (less than 20) ");
                  scanf("%d", &entries);
               /* подавить входной поток в случае неверных
                  входных данных */
                  fflush(stdin);
               /* ввести имя, состоящее только из
                  (прописными или строчных) букв */
                  for (loop = 0; loop < entries; ++loop) {
                     printf("Entry %d\n", loop);
                     printf("  Name   : ");
                     scanf("%[A-Za-z]", entry[loop].name);
               /* подавить входной поток в случае неверных
                  входных данных */
                     fflush(stdin);
               /* ввести возраст как целое число */
                     printf("  Age    : ");
                     scanf("%d", &entry[loop].age);
               /* подавить входной поток в случае неверных
                  входных данных */
                     fflush(stdin);
               /* ввести заработную плату как float */
                     printf("  Salary : ");
                     scanf("%f", &entry[loop].salary);
               /* подавить входной поток в случае неверных
                  входных данных */
                     fflush(stdin);
                  }
               /* Ввести имя, возраст и зарплату как string,
                  integer и double */
                  printf("\nPlease enter your name, "
                         "age and salary\n");
                  scanf("%20s %d %lf", name, &age, &salary);
               /* Распечатать введенные данные */
                  printf("\n\nTable %s\n",label);
                  printf("Compiled by %s  age %d  $%15.2lf\n",
                         name, age, salary);
                  printf("-----------------------------------"
                         "-------------\n");
                  for (loop = 0; loop < entries; ++loop)
                     printf("%4d | %-20s | %5d | %15.2lf\n",
                        loop + 1,
                        entry[loop].name,
                        entry[loop].age,
                        entry[loop].salary);
                  printf("-----------------------------------"
                         "-------------\n");
                  return 0;
               }

     searchpath
──────────────────────────────────────────────────────────────
Функция        Поиск пути к указанному файлу.

Синтаксис      #include <dir.h>
               char *searchpath(const char *file);

Прототип в     dir.h

Примечания     searchpath пытается  обнаружить file,  исследуя
               путь,  указанный в строке PATH=... среды DOS. В
               качестве  значения функция возвращает указатель
               на строку,  содержащую полное имя файла. Прежде
               всего searchpath пытается обнаружить файл в те-
               кущем справочнике на текущем  устройстве.  Если
               файл не обнаружен, используется переменная сре-
               ды PATH,  и каждый справочник,  содержащийся  в
               ней,  поочередно просматривается,  пока файл не
               будет обнаружен или пока список не будет исчер-
               пан.  Если файл обнаружен,  возвращаемая строка
               содержит полное имя  файла.  Эта  строка  может
               быть использована при вызове функций для досту-
               па к файлу (например, fopen или exec...). Возв-
               ращаемая строка располагается в статическом бу-
               фере и перезаписывается при каждом  последующем
               вызове searchpath.

Значение       searchpath возвращает указатель на строку,  со-
               держащую полное имя файла, если файл обнаружен;
               в противном случае searchpath возвращает нуль.

Переносимость  Эта функция доступна только в DOS.

См. также      exec..., findfirst, findnext, spawn..., system

Пример         #include <stdio.h>
               #include <dir.h>

               int main(void)
               {
                 char *p;
                 /*Ищет TLINK и возвращает указатель на путь*/
                 p = searchpath("TLINK.EXE");
                 printf("Search for TLINK.EXE : %s\n", p);
                 /* Ищет несуществующий файл  */
                 p = searchpath("NOTEXIST.FIL");
                 printf("Search for NOTEXIST.FIL : %s\n", p);
                 return 0;
               }

               Вывод программы:

               Search for TLINK.EXE : C:\BIN\TLINK.EXE
               Search for NOTEXIST.FIL : (NULL)

     sector
──────────────────────────────────────────────────────────────
Функция        Рисует и закрашивает эллиптический сектор.

Синтаксис      #include <graphics.h>
               void  far  sector(int  x,  int  y,
                                 int stangle, int endangle,
                                 int xradius, int yradius);

Прототип в     graphics.h

Примечания     Рисует и  закрашивает   эллиптический   сектор,
               используя  (x,y)  в качестве центра,  xradius и
               yradius - в качестве  горизонтальной  и  верти-
               кальной  полуосей  соответственно,  и stangle и
               endangle - в качестве  начального  и  конечного
               углов.  Сектор ограничен контуром текущего цве-
               та,  и закрашен с использованием шаблона и цве-
               та,  установленных посредством setfillstyle или
               setfillpattern.
               Начальный и  конечный  углы  сектора задаются в
               градусах.  Они измеряются против часовой стрел-
               ки,  причем 0 градусов соответствует "3 часам",
               90 градусов - "12 часам" и т.д.
               Если во время  закрашивания  возникнет  ошибка,
               graphresult      возвратит      значение     -6
               (grNoScanMem).

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      arc, circle,       ellipse,       getarccoords,
               getaspectratio,      graphresult,     pieslice,
               setfillpattern, setfillstyle, setgraphbufsize

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy, i;
                  int stangle = 45, endangle = 135;
                  int xrad = 100, yrad = 50;
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode !=grOk) {/*обнаружена ошибка*/
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  /* цикл по шаблонам заполнения */
                  for (i = EMPTY_FILL; i < USER_FILL; i++)
                  {
                     /* установка стиля заполнения */
                     setfillstyle(i, getmaxcolor());
                     /* нарисовать эллиптический сектор */
                     sector(midx, midy, stangle, endangle,
                            xrad, yrad);
                     getch();
                  }
                  /* очистить */
                  closegraph();
                  return 0;
               }

     segread
──────────────────────────────────────────────────────────────
Функция        Чтение регистров сегментов.

Синтаксис      #include <dos.h>
               void segread(struct SREGS *segp);

Прототип в     dos.h

Примечания     segread помещает текущее  содержимое  регистров
               сегментов  в  структуру,  на  которую указывает
               segp. Эта функция предназначена для использова-
               ния совместно с intdosx и int86x.

Значение       Нет.

Переносимость  Эта функция доступна только для процессоров се-
               мейства 8086.

См. также      FP_OFF, int86,  int86x, intdos, intdosx, MK_FP,
               movedata

Пример         #include <stdio.h>
               #include <dos.h>

               int main(void)
               {
                  struct SREGS segs;
                  segread(&segs);
                  printf("Current segment register
                          settings\n\n");
                  printf("CS: %X DS: %X\n", segs.cs, segs.ds);
                  printf("ES: %X SS: %X\n", segs.es, segs.ss);
                  return 0;
               }

     setactivepage
──────────────────────────────────────────────────────────────
Функция        Устанавливает активную страницу для графическо-
               го вывода.

Синтаксис      #include <graphics.h>
               void far setactivepage(int page);

Прототип в     graphics.h

Примечания     setactivepage делает активной графическую стра-
               ницу,  заданную в page. Весь последующий графи-
               ческий вывод будет направлен на указанную стра-
               ницу.
               Активная графическая страница может  не  совпа-
               дать  с той,  которую Bы видите на экране.  Это
               зависит от того,  сколько  графических  страниц
               доступно  в  Bашей системе.  Только графические
               адаптеры EGA,  VGA и Hercules поддерживают  од-
               новременное   существование  нескольких  графи-
               ческих страниц.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      setvisualpage

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                 /* выбрать драйвер и режим,которые поддержи-
                    вают несколько страниц */
                 int gdriver = EGA, gmode = EGAHI, errorcode;
                 int x, y, ht;

                 /* инициализация графики и локальных
                    переменных */
                 initgraph(&gdriver, &gmode, "");

                 /* чтение результата инициализации */
                 errorcode = graphresult();
                 if (errorcode != grOk)
                 {  /* обнаружена ошибка */
                    printf("Graphics error: %s\n",
                           grapherrormsg(errorcode));
                    printf("Press any key to halt:");
                    getch();
                    exit(1); /* выход с кодом ошибки */
                 }
                 x = getmaxx() / 2;
                 y = getmaxy() / 2;
                 ht = textheight("W");
                 /* выбрать графическую страницу для рисова-
                    ния, которая находится вне экрана */
                 setactivepage(1);
                 /* нарисовать линию на странице #1 */
                 line(0, 0, getmaxx(), getmaxy());
                 /* вывести сообщение на странице #1 */
                 settextjustify(CENTER_TEXT, CENTER_TEXT);
                 outtextxy(x, y, "This is page #1:");
                 outtextxy(x,y + ht,"Press any key to halt:");
                 /* сделать активной страницу #0 */
                 setactivepage(0);
                 /* вывести сообщение на страницу #0 */
                 outtextxy(x, y, "This is page #0.");
                 outtextxy(x, y + ht,
                           "Press any key to view page #1:");
                 getch();
                 /* сделать страницу #1 видимой страницей */
                 setvisualpage(1);
                 /* очистить */
                 getch();
                 closegraph();
                 return 0;
               }

     setallpalette
──────────────────────────────────────────────────────────────
Функция        Изменяет все цвета палитры на заданные.

Синтаксис      #include <graphics.h>
               void far setallpalette(struct palettetype
                                      far *palette);

Прототип в     graphics.h

Примечания     setallpalette устанавливает  текущую  палитру в
               соответствии  с  заданной  в   структуре   типа
               palettetype, на которую указывает palette.
               С помощью setallpalette Вы можете частично  или
               полностью сменить цвета в EGA/VGA палитре.
               Константа MAXCOLORS     и     тип     структуры
               palettetype,  используемые в setallpalette, оп-
               ределены в graphics.h следующим образом:

                  #define MAXCOLORS   15
                  struct palettetype  {
                     unsigned char size;
                     signed char colors[MAXCOLORS+1];
                  };

               size задает количество цветов в палитре для те-
               кущего графического драйвера и текущего режима.
               colors -массив из size байтов, содержащий номе-
               ра установленных цветов  для  каждого  элемента
               палитры.  Если  некоторый  элемент colors равен
               -1,  цвет палитры для этого набора  не  изменя-
               ется.

               Элементы массива    colors,   используемого   в
               setallpalette, могут быть представлены символь-
               ными константами, определенными в graphics.h:
Таблица 2.6    ───────────────────────────────────────────────
Таблица цветов            CGA                 EGA/VGA
                Имя            Значение  Имя          Значение
               ───────────────────────────────────────────────
                BLACK              0     EGA_BLACK          0
                BLUE               1     EGA_BLUE           1
                GREEN              2     EGA_GREEN          2
                CYAN               3     EGA_CYAN           3
                RED                4     EGA_RED            4
                MAGENTA            5     EGA_MAGENTA        5
                BROWN              6     EGA_LIGHTGRAY      7
                LIGHTGRAY          7     EGA_BROWN         20
                DARKGRAY           8     EGA_DARKGRAY      56
                LIGHTBLUE          9     EGA_LIGHTBLUE     57
                LIGHTGREEN        10     EGA_LIGHTGREEN    58
                LIGHTCYAN         11     EGA_LIGHTCYAN     59
                LIGHTRED          12     EGA_LIGHTRED      60
                LIGHTMAGENTA      13     EGA_LIGHTMAGENTA  61
                YELLOW            14     EGA_YELLOW        62
                WHITE             15     EGA_WHITE         63
               ───────────────────────────────────────────────
               Заметьте, что допустимые цвета зависят от теку-
               щего графического драйвера и текущего режима.
               Изменения, сделанные  с  помощью setallpalette,
               немедленно видны на экране.  Всякий раз,  когда
               цвета палитры изменяются,  все имеющиеся на эк-
               ране цвета будут изменены на вновь  установлен-
               ные.
         !!!   setallpalette нельзя  использовать для драйвера
               IBM-8514.

Значение       Если в setallpalette переданы недопустимые зна-
               чения  параметров,  graphresult  возвращает -11
               (grError) и текущая палитра не изменяется.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенных дисплеем  с  графическим  адаптером.
               Эта функция несовместима с Windows.

См. также      getpalette, getpalettesize,        graphresult,
               setbkcolor, setcolor, setpalette

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  struct palettetype pal;
                  int color, maxcolor, ht;
                  int y = 10;
                  char msg[80];
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode !=grOk){ /*обнаружена ошибка*/
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  maxcolor = getmaxcolor();
                  ht = 2 * textheight("W");
                  /* взять копию с палитры */
                  getpalette(&pal);
                  /* установить на экране палитру с цветами,
                     принятыми по умолчанию */
                  for (color = 1; color <= maxcolor; color++){
                     setcolor(color);
                     sprintf(msg, "Color: %d", color);
                     outtextxy(1, y, msg);
                     y += ht;
                  }
                  /* ожидать нажатия клавиши */
                  getch();
                  /* установить все цвета в черный */
                  for (color = 1; color <= maxcolor; color++){
                     setpalette(color, BLACK);
                     getch();
                  }
                  /* восстановить цвета палитры */
                  setallpalette(&pal);
                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     setaspectratio
──────────────────────────────────────────────────────────────
Функция        Изменяет стандартное  значение   корректирующих
               коэффициентов сжатия по осям.

Синтаксис      #include <graphics.h>
               void far setaspectratio(int xasp, int yasp);

Прототип в     graphics.h

Примечания     setaspectratio изменяет  стандартное   значение
               коэффициентов  сжатия  по  осям для графических
               систем.  В графических системах  корректирующие
               коэффициенты  сжатия  по  осям используются для
               того,  чтобы окружности выглядели  окружностями
               на экране. Если окружности оказываются эллипса-
               ми,  это означает, что монитор не настроен над-
               лежащим образом. Вы можете исправить это, наст-
               роив монитор, однако легче изменить программное
               обеспечение, используя setaspectratio для уста-
               новки корректирующих коэффициентов. Чтобы полу-
               чить  текущие значения коэффициентов,  вызовите
               getaspectratio.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция несовместима с Windows.

См. также      circle, getaspectratio

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int xasp, yasp, midx, midy;
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode !=grOk) {/*обнаружена ошибка*/
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  setcolor(getmaxcolor());
                  /* получить текущие установки коэффициентов
                     сжатия */
                  getaspectratio(&xasp, &yasp);
                  /* нарисовать окружность */
                  circle(midx, midy, 100);
                  getch();
                  /*очистить экран */
                  cleardevice();
                  /* подобрать коэффициент для "широкой"
                     окружности */
                  setaspectratio(xasp/2, yasp);
                  circle(midx, midy, 100);
                  getch();
                  /* подобрать коэффициент для "узкой"
                     окружности */
                  cleardevice();
                  setaspectratio(xasp, yasp/2);
                  circle(midx, midy, 100);
                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     setbkcolor
──────────────────────────────────────────────────────────────
Функция        Устанавливает цвет фона, используемый палитрой.

Синтаксис      #include <graphics.h>
               void far setbkcolor(int color);

Прототип в     graphics.h

Примечания     setbkcolor устанавливает  заданный  посредством
               color цвет фона. Аргумент color может быть име-
               нем  или  числом,  в  соответствии со следующей
               таблицей:
               ───────────────────────────────────────────────
                Число   Имя          Число      Имя
               ───────────────────────────────────────────────
Эти             0       BLACK         8         DARKGRAY
символические   1       BLUE          9         LIGHTBLUE
имена           2       GREEN        10         LIGHTGREEN
определены      3       CYAN         11         LIGHTCYAN
в graphics.h    4       RED          12         LIGHTRED
                5       MAGENTA      13         LIGHTMAGENTA
                6       BROWN        14         YELLOW
                7       LIGHTGRAY    15         WHITE
               ───────────────────────────────────────────────
               Например, если Вы хотите установить  цвет  фона
               синим, можно написать:
                    setbkcolor(BLUE)  /* или */  setbkcolor(1)
               В системах CGA и EGA setbkcolor  изменяет  цвет
               фона  путем изменения первого элемента в палит-
               ре.
         !!!   Если Вы  используете  EGA  или  VGA и изменяете
               цвета  палитры   с   помощью   setpalette   или
               setallpalette,  приведенные  выше символические
               константы могут  не  обеспечить  Вам  желаемого
               цвета.  Это  связано  с  тем,  что  параметр  в
               setbkcolor относится к номеру элемента в палит-
               ре,  а  не  к конкретному цвету (за исключением
               случая,  когда он равен 0 - в этом случае фоно-
               вый цвет всегда устанавливается в черный).

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      getbkcolor, setallpalette, setcolor, setpalette

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* выбрать драйвер и режим, который поддер-
                     живает несколько цветов для фона */
                  int gdriver = EGA, gmode = EGAHI, errorcode;
                  int bkcol, maxcolor, x, y;
                  char msg[80];
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) /*обнаружена ошибка*/
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  /*максимальный поддерживаемый индекс цвета*/
                  maxcolor = getmaxcolor();
                  /* для центрирования текстового сообщения */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  x = getmaxx() / 2;
                  y = getmaxy() / 2;
                  /* цикл по всем допустимым цветам */
                  for (bkcol = 0;bkcol <= maxcolor; bkcol++) {
                     /* очистить экран */
                     cleardevice();
                     /* выбрать новый фоновый цвет */
                     setbkcolor(bkcol);
                     /* вывести сообщение */
                     if (bkcol == WHITE)
                        setcolor(EGA_BLUE);
                     sprintf(msg,"Background color:%d",bkcol);
                     outtextxy(x, y, msg);
                     getch();
                  }
                  /* очистить */
                  closegraph();
                  return 0;
               }

     setblock
───────────────────────────────────────────────────────────────
Функция        Изменяет размер ранее распределенного блока па-
               мяти.

Синтаксис      #include <dos.h>
               int setblock(unsigned segx, unsigned newsize);

Прототип в     dos.h

Примечания     setblock изменяет размер сегмента памяти.  segx
               - это адрес сегмента, возвращенный при предыду-
               щем обращении к allocmem.  newsize - новый зап-
               рашиваемый размер в параграфах.

Значение       setblock возвращает -1 в случае  успешного  за-
               вершения.  В  случае ошибки возвращается размер
               максимально возможного блока (в  параграфах)  и
               устанавливается      глобальная      переменная
               _doserrno.

Переносимость  Эта функция доступна только в DOS.  Она  несов-
               местима с Windows.

См. также      allocmem, freemem

Пример         #include <dos.h>
               #include <alloc.h>
               #include <stdio.h>
               #include <stdlib.h>

               int main(void)
               {
                  unsigned int size, segp;
                  int stat;
                  size = 64; /* (64 x 16) = 1024 байтов */
                  stat = allocmem(size, &segp);
                  if (stat == -1)
                     printf("Allocated memory at segment:
                             %X\n", segp);
                  else {
                     printf("Failed: maximum number of
                             paragraphs "
                            "available is %d\n",
                            stat);
                     exit(1);
                  }
                  stat = setblock(segp, size * 2);
                  if (stat == -1)
                     printf("Expanded memory block at
                             segment: "
                            "%X\n", segp);
                  else
                     printf("Failed: maximum number of
                             paragraphs "
                            "available is %d\n",
                            stat);
                  freemem(segp);
                  return 0;
               }

     setbuf
──────────────────────────────────────────────────────────────
Функция        Устанавливает буферизацию потока ввода-вывода.

Синтаксис      #include <stdio.h>
               void setbuf(FILE *stream, char *buf);

Прототип в     stdio.h

Примечания     setbuf устанавливает  использование  буфера buf
               для потока ввода-вывода stream вместо автомати-
               чески   распределенного   буфера.  Используется
               после открытия файла stream.  Если buf - пустая
               строка,  ввод-вывод  будет небуферизованным;  в
               противном случае он будет  полностью  буферизо-
               ван.  Буфер  должен  иметь  длину BUFSIZ байтов
               (эта переменная определена в stdio.h).  stdin и
               stdout небуферизованы,  если они не переопреде-
               лены;  в противном случае они полностью буфери-
               зованы.  setbuf можно использовать, чтобы изме-
               нить   способ   буферизации.   Небуферизованный
               ввод-вывод означает,  что символы, направляемые
               в выходной поток,  немедленно выводятся в  файл
               или на внешнее устройство,  в то время, как при
               буферизованном вводе-выводе символы  накаплива-
               ются и выводятся блоками. Вызов setbuf приведет
               к непредсказуемым результатам,  если он не сле-
               дует  непосредственно за открытием файла или за
               вызовом fseek.  Если файл до вызова был небуфе-
               ризован,  вызов setbuf допустим и не будет при-
               водить к неприятностям.  Типичной ошибкой явля-
               ется  использование в качестве буфера автомати-
               ческой (локальной) переменной,  что делает  не-
               возможным  закрытие файла до выхода из функции,
               где эта переменная определена.

Значение       Нет.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      fflush, fopen, fseek, setvbuf

Пример         #include <stdio.h>

               /* BUFSIZ определена в stdio.h */
               char outbuf[BUFSIZ];

               int main(void)
               {
                /* связать буфер со стандартным выходным
                   потоком */
                  setbuf(stdout, outbuf);
                  /* поместить несколько символов в буфер */
                  puts("This is a test of buffered
                        output.\n\n");
                  puts("This output will go into outbuf\n");
                  puts("and won't appear until the buffer\n");
                  puts("fills up or we flush the stream.\n");
                  /* вывести выходной буфер */
                  fflush(stdout);
                  return 0;
               }

     setcbrk
──────────────────────────────────────────────────────────────
Функция        Установка проверки на Ctrl-Break.

Синтаксис      #include <dos.h>
               int setcbrk(int cbrkvalue);

Прототип в     dos.h

Примечания     setcbrk использует  системный  вызов  DOS 0x33,
               чтобы  включить  или  выключить   проверку   на
               Ctrl-Brk.
               
               cbrkvalue=0  Выключает   проверку  (проверяется
                            только  ввод-вывод   на   консоль,
                            принтер  и устройства связи).
               cbrkvalue=1  Включает   проверку   (проверяется
                            каждое обращение к системе).

Значение       setcbrk возвращает      переданное     значение
               cbrkvalue.

Переносимость  Эта функция  доступна  только  в  DOS.

См. также      getcbrk

Пример         #include <dos.h>
               #include <conio.h>
               #include <stdio.h>

               int main(void)
               {
                  int break_flag;
                  printf("Enter 0 to turn control break
                          off\n");
                  printf("Enter 1 to turn control break
                          on\n");
                  break_flag = getch() - 0;
                  setcbrk(break_flag);
                  if (getcbrk())
                     printf("Cntrl-brk flag is on\n");
                  else
                     printf("Cntrl-brk flag is off\n");
                  return 0;
               }

     setcolor
──────────────────────────────────────────────────────────────
Функция        Устанавливает текущий   цвет линий,  используя
               палитру.

Синтаксис      #include <graphics.h>
               void far setcolor(int color);

Прототип в     graphics.h

Примечания     setcolor устанавливает текущий цвет линий,  ко-
               торый задан в color; значение color может изме-
               няться от 0 до getmaxcolor.
               Текущий цвет линий - это цвет,  в который уста-
               навливаются пикселы при рисовании линий или че-
               го-либо  иного.  Следующие  таблицы  показывают
               цвета  изображения,  допустимые  для CGA и EGA,
               соответственно.
               ───────────────────────────────────────────────
                         Константы, присвоенные номерам цветов
               Номер   ───────────────────────────────────────
               палитры   1                2                3
               ───────────────────────────────────────────────
               0 CGA_LIGHTGREEN CGA_LIGHTRED     CGA_YELLOW
               1 CGA_LIGHTCYAN  CGA_LIGHTMAGENTA CGA_WHITE
               2 CGA_GREEN      CGA_RED          CGA_BROWN
               3 CGA_CYAN       CGA_MAGENTA      CGA_LIGHTGRAY
               ───────────────────────────────────────────────
               ───────────────────────────────────────────────
                Число     Имя            Число      Имя
               ───────────────────────────────────────────────
                0         BLACK           8       DARKGRAY
                1         BLUE            9       LIGHTBLUE
                2         GREEN          10       LIGHTGREEN
                3         CYAN           11       LIGHTCYAN
                4         RED            12       LIGHTRED
                5         MAGENTA        13       LIGHTMAGENTA
                6         BROWN          14       YELLOW
                7         LIGHTGRAY      15       WHITE
               ───────────────────────────────────────────────
               Вы выбираете цвет линий, передавая setcolor ли-
               бо сам номер цвета, либо эквивалентное символи-
               ческое имя.  Например,  в режиме CGA C0 палитра
               содержит  4  цвета:  фоновый,   светло-зеленый,
               светло-красный и желтый.  Тогда setcolor(3) или
               setcolor(CGA_YELLOW) установят желтый цвет  ли-
               ний.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция несовместима с Windows.

См. также      getcolor,       getmaxcolor,       graphresult,
               setallpalette, setbkcolor, setpalette

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* выбрать драйвер и режим, который поддер-
                     живает несколько цветов для изображения*/
                  int gdriver = EGA, gmode = EGAHI, errorcode;
                  int color, maxcolor, x, y;
                  char msg[80];
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  /* максимальный поддерживаемый индекс
                     цвета */
                  maxcolor = getmaxcolor();
                  /* для центрирования текстового сообщения */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  x = getmaxx() / 2;
                  y = getmaxy() / 2;
                  /* цикл по всем допустимым цветам */
                  for (color = 1; color <= maxcolor; color++){
                     /* очистить экран */
                     cleardevice();
                     /* выбрать новый цвет изображения */
                     setcolor(color);
                     /* вывести сообщение */
                     sprintf(msg, "Color: %d", color);
                     outtextxy(x, y, msg);
                     getch();
                  }
                  /* очистить */
                  closegraph();
                  return 0;
               }

     _setcursortype
─────────────────────────────────────────────────────────────
Функция        Выбирает тип курсора.

Синтаксис      #include <conio.h>
               void _setcursortype(int cur_t);

Прототип в     conio.h

Примечания     Устанавливает тип курсора в один из следующих:
                  _NOCURSOR       выключает курсор
                  -SOLIDCURSOR    блок-курсор
                  -NORMALCURSOR   обычный курсор-подчеркивание

Значение       Нет.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Она несовместима с Windows.

Пример         #include <conio.h>

               int main(void)
               {
                  /* Выводит обычный курсор */
                  cprintf("\n\rNormal Cursor: ");
                  getch();
                  /* Отключает курсор */
                  _setcursortype(_NOCURSOR);
                  cprintf("\n\rNo Cursor    : ");
                  getch();
                  /* Устанавливает блок-курсор */
                  _setcursortype(_SOLIDCURSOR);
                  cprintf("\n\rSolid Cursor : ");
                  getch();
                  /* Устанавливает снова обычный курсор */
                  _setcursortype(_NORMALCURSOR);
                  cprintf("\n\rNormal Cursor: ");
                  getch();
                  return 0;
               }

     setdate
──────────────────────────────────────────────────────────────
Функция        Устанавливает системную дату DOS.

Синтаксис      #include <dos.h>
               void setdate(struct date *datep);

Прототип в     dos.h

Примечания     setdate устанавливает  системную  дату  (месяц,
               день и год) в значение, представленное структу-
               рой date, на которую указывает datep.
               
               Структура date определена так:
                  struct date  {
                     int da_year;     /* текущий год */
                     char da_day;     /* день месяца */
                     char da_mon;     /* месяц (1 = Январь) */
                  };

Значение       Нет.

Переносимость  Эта функция  доступна  только  в  DOS.

См. также      getdate, gettime, settime

Пример         #include <stdio.h>
               #include <process.h>
               #include <dos.h>

               int main(void)
               {
                  struct date reset;
                  reset.da_year = 2001;
                  reset.da_day = 1;
                  reset.da_mon = 1;
                  setdate(&reset);
                  system("date");
                  return 0;
               }

     setdisk
──────────────────────────────────────────────────────────────
Функция        Устанавливает текущее дисковое устройство.

Синтаксис      #include <dir.h>
               int setdisk(int drive);

Прототип в     dir.h

Примечания     setdisk устанавливает   текущее   устройство  в
               соответствии со значением drive: 0 для A, 1 для
               B, 2 для C и т.д. (равносильно вызову системной
               функции DOS 0x0E).

Значение       setdisk возвращает общее  количество  доступных
               устройств.

Переносимость  Эта функция  доступна  только  в  DOS.

См. также      getdisk

Пример         #include <stdio.h>
               #include <dir.h>

               int main(void)
               {
                  int maxdrives;
                  maxdrives = setdisk(2);
                  printf("The number of logical drives are:
                          %d\n", maxdrives);
                  return 0;
               }

     setdta
──────────────────────────────────────────────────────────────
Функция        Устанавливает адрес  таблицы  ввода-вывода  DOS
               (DTA).

Синтаксис      #include <dos.h>
               void setdta(char far *dta);

Прототип в     dos.h

Примечания     setdta заменяет текущее значение адреса таблицы
               ввода-вывода DOS (DTA) на значение dta.

Значение       Нет.

Переносимость  Эта функция  доступна  только  в  DOS.

См. также      getdta

Пример         #include <process.h>
               #include <string.h>
               #include <stdio.h>
               #include <dos.h>

               int main(void)
               {
                  char line[80], far *save_dta;
                  char buffer[256] = "SETDTA test!";
                  struct fcb blk;
                  int result;
                  /* получить  имя нового файла от
                     пользователя */
                  printf("Enter a file name to create:");
                  gets(line);
                  /* разместить  имя нового файла по адресу
                     dta */
                  parsfnm(line, &blk, 1);
                  printf("%d %s\n", blk.fcb_drive,
                          blk.fcb_name);
                  /* вызов функции DOS для создания файла */
                  if (bdosptr(0x16, &blk, 0) == -1) {
                     perror("Error creating file");
                     exit(1);
                  }
                  /* сохранить старый dta и установить новый
                     dta */
                  save_dta = getdta();
                  setdta(buffer);
                  /* вывести новые записи */
                  blk.fcb_recsize = 256;
                  blk.fcb_random = 0L;
                  result = randbwr(&blk, 1);
                  printf("result = %d\n", result);
                  if (!result)
                     printf("Write OK\n");
                  else {
                     perror("Disk error");
                     exit(1);
                  }
                  /* вызов функции DOS для закрытия файла */
                  if (bdosptr(0x10, &blk, 0) == -1) {
                     perror("Error closing file");
                     exit(1);
                  }
                  /* восстановить старый dta */
                  setdta(save_dta);
                  return 0;
               }

     setfillpattern
──────────────────────────────────────────────────────────────
Функция        Устанавливает определенный пользователем шаблон
               заполнения.

Синтаксис      #include <graphics.h>
               void  far  setfillpattern(char  far  *upattern,
                                         int color);

Прототип в     graphics.h

Примечания     setfillpattern работает    так    же,   как   и
               setfillstyle, только используется она для уста-
               новки шаблона 8х8, определенного пользователем,
               а не  предопределенного  системой.
               upattern - указатель на последовательность из 8
               байтов,  где каждый байт соответствует 8 пиксе-
               лам шаблона. Прорисовываются все пикселы, у ко-
               торых соответствующие биты установлены в 1.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция несовместима с Windows.

См. также      getfillpattern, getfillsettings,   graphresult,
               sector, setfillstyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int maxx, maxy;
                  /* шаблон заполнения, определенный
                     пользователем */
                  char pattern[8] = {0x00, 0x70, 0x20, 0x27,
                                     0x24, 0x24, 0x07, 0x00};
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  maxx = getmaxx();
                  maxy = getmaxy();
                  setcolor(getmaxcolor());
                  /* установить шаблон заполнения,определенный
                     пользователем */
                  setfillpattern(pattern, getmaxcolor());
                  /* заполнить экран по этому шаблону */
                  bar(0, 0, maxx, maxy);
                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     setfillstyle
──────────────────────────────────────────────────────────────
Функция        Устанавливает цвет и шаблон заполнения.

Синтаксис      #include <graphics.h>
               void far setfillstyle(int pattern, int color);

Прототип в     graphics.h

Примечания     setfillstyle устанавливает текущий цвет и  шаб-
               лон заполнения.  Чтобы установить шаблон, опре-
               деленный  пользователем,  НЕ  передавайте  этой
               функции   12(USER_FILL)   в  качестве  значения
               pattern;  вместо этого вызовите setfillpattern.
               Перечисление   fill_patterns,   определенное  в
               graphics.h,  дает имена предопределенным шабло-
               нам заполнения плюс индикатору шаблона, опреде-
               ленного                          пользователем.
               ───────────────────────────────────────────────
                Имя           Значение       Описание
               ───────────────────────────────────────────────
                EMPTY_FILL        0   Заполнение фоновым цветом
                SOLID_FILL        1   Сплошное заполнение
                LINE_FILL         2   Заполнение ───
                LTSLASH_FILL      3   Заполнение ///
                SLASH_FILL        4   Заполнение ///, толстые
                                      линии
                BKSLASH_FILL      5   Заполнение \\\, толстые
                                      линии
                LTBKSLASH_FILL    6   Заполнение \\\
                HATCH_FILL        7   Заполнение редкой
                                      штриховкой
                XHATCH_FILL       8   Заполнение двойной
                                      штриховкой
                INTERLEAVE_FILL   9   Заполнение прерывистой
                                      линией
                WIDE_DOT_FILL    10   Заполнение редкими
                                      точками
                CLOSE_DOT_FILL   11   Заполнение частыми
                                      точками
                USER_FILL        12   Шаблон, определяемый
                                      пользов.
               ───────────────────────────────────────────────
               Все шаблоны, за исключением EMPTY_FILL, исполь-
               зуют  текущий   цвет   заполнения;   EMPTY_FILL
               использует  текущий фоновый цвет.  Если функции
               переданы неверные значения, graphresult возвра-
               тит -11 (grError),  и текущий шаблон и цвет за-
               полнения не изменятся.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      bar, bar3d,        fillpoly,         floodfill,
               getfillsettings, graphresult, pieslice, sector,
               setfillpattern

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <string.h>
               #include <stdio.h>
               #include <conio.h>

               /* Названия поддерживаемых стилей заполнения */
               char*fname[]={"EMPTY_FILL", "SOLID_FILL",
                             "LINE_FILL", "LTSLASH_FILL",
                             "SLASH_FILL", "BKSLASH_FILL",
                             "LTBKSLASH_FILL", "HATCH_FILL",
                             "XHATCH_FILL", "INTERLEAVE_FILL",
                             "WIDE_DOT_FILL","CLOSE_DOT_FILL",
                             "USER_FILL" };

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int style, midx, midy;
                  char stylestr[40];
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  for (style = EMPTY_FILL; style < USER_FILL;
                       style++)
                  {
                     /* выбрать стиль заполнения */
                     setfillstyle(style, getmaxcolor());
                     /* получить наименование стиля */
                     strcpy(stylestr, fname[style]);
                     /* заполнить прямоугольник */
                     bar3d(0, 0, midx-10, midy, 0, 0);
                     /* вывести сообщение */
                     outtextxy(midx, midy, stylestr);
                     /* ожидать нажатия клавиши */
                     getch();
                     cleardevice();
                  }
                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     setftime
──────────────────────────────────────────────────────────────
Функция        Устанавливает дату и время создания / модифика-
               ции файла.

Синтаксис      #include <io.h>
               int setftime(int handle, struct ftime *ftimep);

Прототип в     io.h

Примечания     setftime устанавливает  дату и время создания /
               модификации файла,  связанного с handle, в зна-
               чения, содержащиеся в структуре ftime, на кото-
               рую указывает ftimep.
               
               Структура ftime определена следующим образом:
                  struct ftime  {
                     unsigned ft_tsec: 5;   /* пары секунд */
                     unsigned ft_min: 6;    /* минуты */
                     unsigned ft_hour: 5;   /* часы */
                     unsigned ft_day: 5;    /* дни */
                     unsigned ft_month: 4;   /* месяцы */
                     unsigned ft_year: 7;    /* год - 1980 */
                  };

Значение       setftime возвращает 0 в случае успешного завер-
               шения.  В  случае ошибки возвращается -1 и гло-
               бальная переменная errno устанавливается в одно
               из следующих значений:
                  EINVFNC       Неверный номер функции
                  EBADF         Неверный номер файла

Переносимость  Эта функция  доступна  только  в  DOS.

См. также      gettime

Пример         #include <stdio.h>
               #include <process.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
                  struct ftime filet;
                  FILE *fp;
                  if ((fp = fopen("TEST.$$$", "w")) == NULL) {
                     perror("Error:");
                     exit(1);
                  }
                  fprintf(fp, "testing...\n");
                  /* загрузить в структуру ftime новое
                     время и дату */
                  filet.ft_tsec = 1;
                  filet.ft_min = 1;
                  filet.ft_hour = 1;
                  filet.ft_day = 1;
                  filet.ft_month = 1;
                  filet.ft_year = 21;
                  /* показать время и дату в текущем
                     справочнике */
                  system("dir TEST.$$$");
                  /* изменить время и дату */
                  setftime(fileno(fp), &filet);
                  system("dir TEST.$$$");
                  /* закрыть и удалить временный файл */
                  fclose(fp);
                  unlink("TEST.$$$");
                  return 0;
               }

     setgraphbufsize
──────────────────────────────────────────────────────────────
Функция        Изменяет размер  внутреннего графического буфе-
               ра.

Синтаксис      #include <graphics.h>
               unsigned far setgraphbufsize(unsigned bufsize);

Прототип в     graphics.h

Примечания     Некоторые графические   функции   (такие,   как
               floodfill) используют буфер в  памяти,  который
               размещается  при  вызове initgraph и освобожда-
               ется при вызове closegraph. Размер буфера, раз-
               мещаемого посредством _graphgetmem,  по умолча-
               нию принят 4096 байтов.
               У Вас может возникнуть желание уменьшить (чтобы
               сэкономить память) или увеличить (если,  напри-
               мер,  floodfill выдает ошибку -7:  Недостаточно
               памяти) размер этого буфера.
               setgraphbufsize сообщает в  initgraph,  сколько
               памяти следует выделить для этого буфера, когда
               последний будет обращаться к _graphgetmem.
         !!!   setgraphbufsize должна быть вызвана  ДО  вызова
               initgraph. После вызова initgraph все обращения
               к setgraphbufsize  игнорируются  до  следующего
               вызова closegraph.

Значение       setgraphbufsize возвращает   предыдущий  размер
               буфера.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция несовместима с Windows.

См. также      closegraph, _graphfreemem,        _graphgetmem,
               initgraph, sector

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               #define BUFSIZE 1000
               /* размер внутреннего графического буфера */

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int x, y, oldsize;
                  char msg[80];
                  /* установить размер внутреннего графи-
                     ческого буфера перед вызовом initgraph.*/
                  oldsize = setgraphbufsize(BUFSIZE);
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  x = getmaxx() / 2;
                  y = getmaxy() / 2;
                  /* вывести несколько сообщений */
                  sprintf(msg, "Graphics buffer size: %d",
                          BUFSIZE);
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  outtextxy(x, y, msg);
                  sprintf(msg, "Old graphics buffer size: %d",
                          oldsize);
                  outtextxy(x, y + textheight("W"), msg);
                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     setgraphmode
──────────────────────────────────────────────────────────────
Функция        Устанавливает  графический режим  и очищает эк-
               ран.

Синтаксис      #include <graphics.h>
               void far setgraphmode(int mode);

Прототип в     graphics.h

Примечания     setgraphmode устанавливает  графический  режим,
               отличный от установленного по умолчанию функци-
               ей initgraph.  Значение mode  должно  быть  до-
               пустимо   для   текущего  драйвера  устройства.
               setgraphmode очищает экран и устанавливает  все
               графические  параметры в значения,  принятые по
               умолчанию (текущую позицию, палитру, цвет, окно
               и т.д.).  Можно использовать setgraphmode в со-
               четании  с  restorecrtmode,  чтобы  переключать
               текстовый режим на графический и обратно.

Значение       Если setgraphmode передано недопустимое для те-
               кущего  драйвера  устройства   значение   mode,
               graphresult возвратит -10 (grInvalidMode).

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      getgraphmode, getmoderange,        graphresult,
               initgraph, restorecrtmode

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int x, y;
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  x = getmaxx() / 2;
                  y = getmaxy() / 2;
                  /* вывести сообщение */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  outtextxy(x, y,
                           "Press any key to exit graphics:");
                  getch();
                  /* установить систему в текстовый режим */
                  restorecrtmode();
                  printf("We're now in text mode.\n");
                  printf("Press any key to return "
                         "to graphics mode:");
                  getch();
                  /* вернуться в графический режим */
                  setgraphmode(getgraphmode());
                  /* вывести сообщение */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  outtextxy(x, y, "We're back in graphics
                            mode.");
                  outtextxy(x, y + textheight("W"),
                            "Press any key to halt:");
                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     setjmp
──────────────────────────────────────────────────────────────
Функция        Устанавливает "метку" для нелокального перехо-
               да.

Синтаксис      #include <setjmp.h>
               int setjmp(jmp_buf jmpb);

Прототип в     setjmp.h

Примечания     setjmp запоминает полную информацию о состоянии
               задачи в jmpb и возвращает 0.
               Последующий вызов longjmp с jmpb восстанавлива-
               ет сохраненное состояние и завершается  переда-
               чей  управления в точку возврата из setjmp так,
               что setjmp как бы возвращает некоторое значение
               val.  Состояние задачи включает: - все регистры
               сегментов (CS,  DS, ES, SS) - регистровые пере-
               менные (SI, DI) - указатель стека (SP) - указа-
               тель базы (BP) - флаги Информация,  заключенная
               в  состоянии  задачи,  полностью достаточна для
               того,  чтобы использовать setjmp при реализации
               сопрограмм. setjmp должна быть вызвана до вызо-
               ва longjmp.  Процедура, которая вызывает setjmp
               и устанавливает jmpb,  должна оставаться актив-
               ной и не может быть завершена прежде, чем будет
               вызван  longjmp.  В противном случае результаты
               непредсказуемы.  setjmp полезна  для  обработки
               ошибок и исключительных ситуаций,  обнаруживае-
               мых в процедуре нижнего уровня.
         !!!   Нельзя использовать setjmp и longjmp для реали-
               зации сопрограмм,  если Ваша программа -  овер-
               лейная.  В  обычной  ситуации  setjmp и longjmp
               сохраняют и восстанавливают все регистры,  тре-
               буемые для реализации сопрограмм. Однако менед-
               жер оверлеев  отслеживает  содержимое  стека  и
               предполагает, что имеется только один стек. При
               реализации сопрограмм обычно используются  либо
               два стека,  либо две части одного стека,  и ме-
               неджер оверлеев не сможет  правильно  отследить
               их. У Вас могут быть фоновые задачи, работающие
               со своим собственным стеком или  частью  стека,
               но Вы должны быть уверены,  что эти фоновые за-
               дачи не будут активизировать никакие оверлейные
               программы, и Вы не должны использовать оверлей-
               ные версии setjmp и  longjmp  для  переключения
               управления  на фоновые задачи и обратно.  Когда
               Вы исключите использование оверлейных  программ
               или процедур, наличие фоновых стеков не помеша-
               ет менеджеру оверлеев работать.

Значение       setjmp возвращает 0  при  первичном  обращении.
               Если  возврат  происходит  из  longjmp,  setjmp
               возвращает некоторое (ненулевое) значение  (как
               в примере ниже).

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C. Она несовместима с Windows.

См. также      longjmp, signal

Пример         #include <stdio.h>
               #include <process.h>
               #include <setjmp.h>

               void subroutine(void);
               jmp_buf jumper;

               int main(void)
               {
                  int value;
                  value = setjmp(jumper);
                  if (value != 0) {
                     printf("Longjmp with value %d\n", value);
                     exit(value);
                  }
                  printf("About to call subroutine ... \n");
                  subroutine();
                  return 0;
               }
               void subroutine(void)
               {
                  longjmp(jumper,1);
               }

     setlinestyle
──────────────────────────────────────────────────────────────
Функция        Устанавливает текущую толщину и тип линии.

Синтаксис      #include <graphics.h>
               void   far   setlinestyle(int   linestyle,
                      unsigned upattern, int thickness);

Прототип в     graphics.h

Примечания     setlinestyle устанавливает  тип   всех   линий,
               рисуемых  функциями  line,  lineto,  rectangle,
               drawpoly и т.д.
               Структура linesettingstype     определена     в
               graphics.h следующим образом:
                  struct linesettingstype  {
                     int linestyle;
                     unsigned upattern;
                     int thickness;
                  };

               linestyle определяет тип  (например,  сплошная,
               пунктирная,  штрих-пунктирная,  прерывистая), в
               котором будут изображаться линии.
               Перечисление line_style,     определенное     в
               graphics.h,     дает    имена    этим    типам:
               ───────────────────────────────────────────────
               Наименование          Значение         Описание
               ───────────────────────────────────────────────
               SOLID_LINE 0 Сплошная линия DOTTED_LINE 1 Пунк-
               тирная линия CENTER_LINE 2 Штрих-пунктирная ли-
               ния    DASHED_LINE    3    Прерывистая    линия
               USERBIT_LINE 4  Тип  линии,  опред.  пользоват.
               ───────────────────────────────────────────────
               thickness определяет, будет ли толщина вычерчи-
               ваемых    линий    обычной   или   увеличенной.
               ───────────────────────────────────────────────
                 Наименование   Значение       Описание
               ───────────────────────────────────────────────
                 NORM_WIDTH         1         Ширина 1 пиксел
                 THICK_WIDTH        3         Ширина 3 пиксела
               ───────────────────────────────────────────────
               upattern - 16-битовый шаблон, который использу-
               ется   только   если   установлен   тип   линии
               USERBIT_LINE (4).  В этом случае пикселы, кото-
               рым соответствует 1,  изображаются текущим цве-
               том изображения. Например, сплошная линия соот-
               ветствует значению upattern  0xFFFF  (изобража-
               ются  все  пикселы),  а  прерывистая - значению
               0x3333 или 0x0F0F.  Если linestyle,  переданный
               setlinestyle не есть USERBIT_LINE (другими сло-
               вами,  не равен 4),  Вы можете задать upattern,
               но его значение будет проигнорировано.
         !!!   Параметр linestyle  не  влияет  на вычерчивание
               дуг,  окружностей,  эллипсов и секторов. В этих
               случаях используется только параметр thickness.

Значение       Если setlinestyle  получает недопустимые значе-
               ния параметров,  graphresult возвращает  -11  и
               текущие параметры линии не изменяются.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      arc, bar3d,    circle,    drawpoly,    ellipse,
               getlinesettings,  graphresult,  line,  linerel,
               lineto, pieslice, rectangle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <string.h>
               #include <stdio.h>
               #include <conio.h>

               /* Наименования поддерживаемых типов линий */
               char *lname[] = { "SOLID_LINE", "DOTTED_LINE",
                                 "CENTER_LINE", "DASHED_LINE",
                                 "USERBIT_LINE" };

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int style, midx, midy, userpat;
                  char stylestr[40];
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  /* шаблон, определенный пользователем */
                  /* побитно: "0000000000000001"  */
                  userpat = 1;
                  for (style = SOLID_LINE; style <=
                       USERBIT_LINE; style++)
                  {
                     /* установить тип линии */
                     setlinestyle(style, userpat, 1);
                     /* строковое представление типа */
                     strcpy(stylestr, lname[style]);
                     /* начертить линию */
                     line(0, 0, midx-10, midy);
                     /* начертить прямоугольник */
                     rectangle(0, 0, getmaxx(), getmaxy());
                     /* вывести сообщение */
                     outtextxy(midx, midy, stylestr);
                     /* ожидать нажатия клавиши */
                     getch();
                     cleardevice();
                  }
                  /* очистить */
                  closegraph();
                  return 0;
               }

     setlocale
──────────────────────────────────────────────────────────────
Функция        Устанавливает местность (т.е.  национальные ат-
               рибуты данной местности -  обозначение  валюты,
               разделитель тысяч и т.п.)

Синтаксис      #include <locale.h>
               char *setlocale(int category, char *locale);

Прототип в     locale.h

Примечания     Borland C++  поддерживает  в  настоящее   время
               только  код местности "C",  поэтому обращение к
               этой функции не дает никакого эффекта.
               
               Возможные значения параметра category:
                  LC_ALL
                  LC_COLLATE
                  LC_CTYPE
                  LC_MONETARY
                  LC_NUMERIC
                  LC_TIME

Значение       Если выбор  завершился  успешно,   возвращаемая
               строка указывает на код местности, имевший силу
               перед обращением к этой  функции.  В  противном
               случае возвращается нулевой указатель.

Переносимость  Эта функция совместима с ANSI C.

См. также      localeconv

Пример         #include <locale.h>
               #include <stdio.h>

               int main(void)
               {
                  char *old_locale;
                  /* Только код местности "C" поддерживается в
                     Borland C++  */
                  old_locale = setlocale(LC_ALL,"C");
                  printf("Old locale was %s\n",old_locale);
                  return 0;
               }

     setmem
──────────────────────────────────────────────────────────────
Функция        Заполняет заданным значением область памяти.

Синтаксис      #include <mem.h>
               void setmem(void *dest, unsigned length,
                           char value);

Прототип в     mem.h

Примечания     setmem заполняет блок длины length,указанный  в
               dest, значением value.

Значение       Нет.

Переносимость  Эта функция доступна только для процессоров се-
               мейства 8086.

См. также      memset, strset

Пример         #include <stdio.h>
               #include <alloc.h>
               #include <mem.h>

               int main(void)
               {
                  char *dest;
                  dest = calloc(21, sizeof(char));
                  setmem(dest, 20, 'c');
                  printf("%s\n", dest);
                  return 0;
               }

     setmode
──────────────────────────────────────────────────────────────
Функция        Устанавливает режим открытия файла.

Синтаксис      #include <fcntl.h>
               int setmode(int handle, int amode);

Прототип в     io.h

Примечания     setmode устанавливает  режим  открытия   файла,
               связанного  с  handle  -  либо  двоичный,  либо
               текстовый.  Аргумент amode может принимать одно
               из  двух  значений:  O_BINARY или O_TEXT.  (Эти
               символические константы определены в fcntl.h).

Значение       setmode возвращает 0 в случае успешного  завер-
               шения. В случае ошибки он возвращает -1 и уста-
               навливает глобальную переменную errno в  EINVAL
               Неверный аргумент

Переносимость  Эта функция доступна в системах UNIX.

См. также      _creat, creat, _open, open

Пример         #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
                  int result;
                  result = setmode(fileno(stdprn), O_TEXT);
                  if (result == -1)
                     perror("Mode not available\n");
                  else
                     printf("Mode successfully switched\n");
                  return 0;
               }

     setpalette
──────────────────────────────────────────────────────────────
Функция        Изменяет один из цветов палитры.

Синтаксис      #include <graphics.h>
               void far setpalette(int colornum, int color);

Прототип в     graphics.h

Примечания     setpalette изменяет  цвет  в  элементе colornum
               текущей палитры на цвет,  задаваемый  в  color.
               Например,  setpalette(0,5) изменяет первый цвет
               в палитре (цвет фона) на цвет с фактическим но-
               мером 5. Если size - количество элементов в те-
               кущей палитре,  colornum может принимать значе-
               ния  от 0 до (size-1).  С помощью setpalette Вы
               можете частично (или полностью) заменить  цвета
               в  палитре  EGA/VGA.  В  палитре  CGA с помощью
               setpalette Вы  можете  изменить  только  первый
               цвет  (colornum = 0,  цвет фона).  Передаваемый
               setpalette параметр color может быть  представ-
               лен символическими константами, определенными в
               graphics.h.
               ───────────────────────────────────────────────
                          CGA                 EGA/VGA
                Имя           Значение  Имя           Значение
               ───────────────────────────────────────────────
                BLACK             0     EGA_BLACK         0
                BLUE              1     EGA_BLUE          1
                GREEN             2     EGA_GREEN         2
                CYAN              3     EGA_CYAN          3
                RED               4     EGA_RED           4
                MAGENTA           5     EGA_MAGENTA       5
                BROWN             6     EGA_LIGHTGRAY     7
                LIGHTGRAY         7     EGA_BROWN        20
                DARKGRAY          8     EGA_DARKGRAY     56
                LIGHTBLUE         9     EGA_LIGHTBLUE    57
                LIGHTGREEN       10     EGA_LIGHTGREEN   58
                LIGHTCYAN        11     EGA_LIGHTCYAN    59
                LIGHTRED         12     EGA_LIGHTRED     60
                LIGHTMAGENTA     13     EGA_LIGHTMAGENTA 61
                YELLOW           14     EGA_YELLOW       62
                WHITE            15     EGA_WHITE        63
               ───────────────────────────────────────────────
               Заметьте, что допустимые цвета зависят от теку-
               щего графического драйвера  и  текущего  графи-
               ческого режима.
               Изменения, сделанные в палитре, немедленно вид-
               ны  на  экране.  Каждый раз при изменении цвета
               палитры все участки этого цвета на экране  при-
               обретают новый цвет.
         !!!   setpalette нельзя   использовать  для  драйвера
               IBM-8514;  вместо  этого  следует  использовать
               setrgbpalette.

Значение       Если недопустимые       параметры      переданы
               setpalette,  graphresult возвратит -11, и теку-
               щая палитра не изменится.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      getpalette, graphresult,         setallpalette,
               setbkcolor, setcolor, setrgbpalette

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int color, maxcolor, ht;
                  int y = 10;
                  char msg[80];
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  maxcolor = getmaxcolor();
                  ht = 2 * textheight("W");
                  /* изображение в цветах, принятых по
                     умолчанию */
                  for (color = 1; color <= maxcolor; color++){
                     setcolor(color);
                     sprintf(msg, "Color: %d", color);
                     outtextxy(1, y, msg);
                     y += ht;
                  }
                  /* ожидать нажатия клавиши */
                  getch();
                  /* заменить каждый цвет на черный */
                  for (color = 1; color <= maxcolor; color++){
                     setpalette(color, BLACK);
                     getch();
                  }
                  /* очистить */
                  closegraph();
                  return 0;
               }

     setrgbpalette
──────────────────────────────────────────────────────────────
Функция        Позволяет пользователю  определить  цвета   для
               IBM-8514.

Синтаксис      #include <graphics.h>
               void  far setrgbpalette(int  colornum,
                         int  red, int green, int blue);

Прототип в     graphics.h

Примечания     setrgbpalette может    быть    использована   с
               IBM-8514 и драйвером VGA.
               colornum определяет номер элемента палитры, ко-
               торый должен быть загружен, а red, green и blue
               - цветовые компоненты для этого элемента.
               Для монитора  IBM-8514  (и  VGA  в  режиме 256K
               цветном) colornum может принимать значения от 0
               до 255.  В остальных режимах VGA colornum лежит
               в пределах от 0 до 15.  В параметрах red, green
               и  blue используется только младший байт,  и из
               каждого байта только  6  наиболее  значительных
               битов загружаются в палитру.
         !!!   Для совместимости  с другими графическими адап-
               терами IBM,  драйвер BGI  загружает  первые  16
               элементов палитры IBM-8514 по умолчанию цветами
               EGA/VGA.  Эти значения могут быть использованы,
               как есть, или изменены с помощью setrgbpalette.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      setpalette

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* установить драйвер и режим, который
                     поддерживает функцию setrgbpalette */
                  int gdriver = VGA, gmode = VGAHI, errorcode;
                  struct palettetype pal;
                  int i, ht, y, xmax;
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  /* взять копию палитры */
                  getpalette(&pal);
                  /* создать шкалу полутонов */
                  for (i = 0; i < pal.size; i++)
                     setrgbpalette(pal.colors[i],i*4,i*4,i*4);
                  /* вывести шкалу полутонов */
                  ht = getmaxy() / 16;
                  xmax = getmaxx();
                  y = 0;
                  for (i = 0; i < pal.size; i++) {
                     setfillstyle(SOLID_FILL, i);
                     bar(0, y, xmax, y + ht);
                     y += ht;
                  }
                  /* выйти из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     settextjustify
──────────────────────────────────────────────────────────────
Функция        Устанавливает тип  выравнивания текста для гра-
               фических функций.

Синтаксис      #include <graphics.h>
               void far settextjustify(int horiz, int vert);

Прототип в     graphics.h

Примечания     Текст, выводимый      после     обращения     к
               settextjustify,  выравнивается по  отношению  к
               текущей позиции (ТП) по горизонтали и по верти-
               кали,  как  задано.  По  умолчанию  принимается
               LEFT_TEXT по горизонтали и TOP_TEXT по вертика-
               ли. Перечисление text_just в graphics.h опреде-
               ляет имена для horiz и vert,  которые можно пе-
               редавать                        settextjustify.
               ───────────────────────────────────────────────
                Описание Имя        Значение    Действие
               ───────────────────────────────────────────────
                horiz    LEFT_TEXT     0   Выравнивать влево
                         CENTER_TEXT   1   Центрировать текст
                         RIGHT_TEXT    2   Выравнивать вправо
                vert     BOTTOM_TEXT   0   Выравнивать снизу
                         CENTER_TEXT   1   Центрировать текст
                         TOP_TEXT      2   Выравнивать сверху
               ───────────────────────────────────────────────
               Если horiz равно LEFT_TEXT,  а direction  равно
               HORIZ_DIR,  x-компонента  ТП продвигается после
               вызова     outtext(string)     на      величину
               textwidth(string).
               settextjustify оказывает влияние на текст,  вы-
               водимый по outtext, и не может быть использова-
               на для текстового режима или вывода потоком.

Значение       Если недопустимые       значения       переданы
               settextjustify,  graphresult возвратит  -11,  и
               текущее выравнивание останется неизменным.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      gettextsettings,     graphresult,      outtext,
               settextstyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               /* прототип функции */
               void xat(int x, int y);
               /* наименования типов горизонтального
                                 выравнивания текста */
               char *hjust[] = { "LEFT_TEXT", "CENTER_TEXT",
                                 "RIGHT_TEXT" };
               /* наименования типов вертикального
                                 выравнивания текста */
               char *vjust[] = { "LEFT_TEXT", "CENTER_TEXT",
                                 "RIGHT_TEXT" };

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy, hj, vj;
                  char msg[80];
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  /* цикл по типам выравнивания текста */
                  for (hj = LEFT_TEXT; hj <= RIGHT_TEXT; hj++)
                     for (vj = LEFT_TEXT;
                          vj <= RIGHT_TEXT; vj++) {
                        cleardevice();
                        /* установить выравнивание текста */
                        settextjustify(hj, vj);
                        /* создать строку сообщения */
                        sprintf(msg, "%s  %s", hjust[hj],
                                vjust[vj]);
                        /* сделать перекрестие на экране */
                        xat(midx, midy);
                        /* вывести сообщение */
                        outtextxy(midx, midy, msg);
                        getch();
                     }
                  /* выйти из графики */
                  closegraph();
                  return 0;
               }
               /* нарисовать "x" в (x, y) */
               void xat(int x, int y)
               {
                 line(x-4, y, x+4, y);
                 line(x, y-4, x, y+4);
               }

     settextstyle
──────────────────────────────────────────────────────────────
Функция        Устанавливает текущие характеристики текста для
               графического вывода.

Синтаксис      #include <graphics.h>
               void far settextstyle(int font, int direction,
                                     int charsize);

Прототип в     graphics.h

Примечания     settextstyle устанавливает  шрифт,  направление
               отображения и размер символов текста. Обращение
               к settextstyle влияет на любой текст, выводимый
               посредством outtext и outtextxy.
               Далее описываются  параметры font,  direction и
               charsize, передаваемые settextstyle:

               font: доступны один растровый шрифт 8х8 точек и
               несколько "штриховых". По умолчанию принимается
               растровый   шрифт   8х8   точек.   Перечисление
               font_names,  определенное в graphics.h,  вводит
               имена       для       различных        шрифтов:
               ───────────────────────────────────────────────
                Имя          Значение   Описание
               ───────────────────────────────────────────────
                DEFAULT_FONT    0  Растровый шрифт 8х8 точек
                TRIPLEX_FONT    1  Штриховый тройной шрифт
                SMALL_FONT      2  Штриховый малый шрифт
                SANS_SERIF_FONT 3  Штриховый гротесковый шрифт
                GOTHIC_FONT     4  Штриховый готический шрифт
               ───────────────────────────────────────────────
               Растровый точечный шрифт,  принимаемый по умол-
               чанию, встроен в графическую систему. Штриховые
               шрифты хранятся  в  дисковых  файлах  *.CHR,  и
               только  один из них в данный момент времени мо-
               жет находиться в памяти. Поэтому, если Вы выби-
               раете  штриховый  шрифт (отличный от последнего
               выбранного перед этим штрихового шрифта), соот-
               ветствующий  *.CHR  файл должен быть загружен с
               диска.
               Чтобы избежать этого, если Вам необходимо рабо-
               тать с несколькими штриховыми шрифтами одновре-
               менно,  можно  поместить эти файлы в Вашу прог-
               рамму при редактировании связей. Для этого сле-
               дует  преобразовать  их в объектные файлы с по-
               мощью утилиты BGIOBJ,  а затем зарегистрировать
               их  с  помощью  registerbgifont,  как описано в
               UTIL.DOC на Вашей дистрибутивной дискете.

               direction: поддерживаются    два    направления
               текста: горизонтальное (слева направо) и верти-
               кальное (горизонтальное,  повернутое на 90 гра-
               дусов  против  часовой  стрелки).  По умолчанию
               принимается                          HORIZ_DIR.
               ───────────────────────────────────────────────
                Имя        Значение    Описание
               ───────────────────────────────────────────────
                HORIZ_DIR      0       Справа налево
                VERT_DIR       1       Снизу вверх
               ───────────────────────────────────────────────
               charsize: Размер каждого символа может быть из-
               менен с  помощью  коэффициента  charsize.  Если
               charsize отличен от нуля, он действует и на то-
               чечный шрифт,  и на штриховый. Нулевое значение
               charsize можно использовать только со штриховы-
               ми шрифтами.
               - Если charsize = 1,  outtext и outtextxy выво-
               дят символы растрового 8х8-точечного  шрифта  в
               экранный прямоугольник 8х8 пикселов.
               - Если charsize = 2, эти функции выводят симво-
               лы  того  же  шрифта  в  экранный прямоугольник
               16х16 пикселов,  и т.д.  (предельно  допустимое
               увеличение 10).
               - Если  charsize  =  0,   функции   outtext   и
               outtextxy при выводе штрихового текста устанав-
               ливают размер символов, используя либо значение
               коэффициента, принимаемое по умолчанию (4), ли-
               бо размер символов,  определенный пользователем
               посредством setusercharsize.
               Чтобы определить реальные размеры текста, всег-
               да    пользуйтесь    функциями   textheight   и
               textwidth.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      gettextsettings, graphresult,  installuserfont,
               settextjustify,   setusercharsize,  textheight,
               textwidth

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               /* наименования поддерживаемых шрифтов */
               char *fname[]={ "DEFAULT font", "TRIPLEX font",
                               "SMALL font","SANS SERIF font",
                               "GOTHIC font" };

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int style, midx, midy;
                  int size = 1;
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  /* цикл по всем допустимым шрифтам */
                  for (style = DEFAULT_FONT;
                       style <= GOTHIC_FONT; style++)
                  {
                     cleardevice();
                     if (style == TRIPLEX_FONT)
                        size = 4;
                     /* установить стиль текста */
                     settextstyle(style, HORIZ_DIR, size);
                     /* вывести сообщение */
                     outtextxy(midx, midy, fname[style]);
                     getch();
                  }
                  /* выйти из графики */
                  closegraph();
                  return 0;
               }

     settime
──────────────────────────────────────────────────────────────
Функция        Устанавливает системное время.

Синтаксис      #include <dos.h>
               void settime(struct time *timep);

Прототип в     dos.h

Примечания     Устанавливает системное  время в значение,  со-
               держащееся в структуре time,  на которую указы-
               вает timep. Структура time определена так:
                struct time  {
                  unsined char ti_min;   /* минуты */
                  unsined char ti_hour;  /* часы  */
                  unsined char ti_hund; /* сотые секунд */
                  unsined char ti_sec;   /* секунды */
                };

Значение       Нет.

Переносимость  Эта функция доступна только в DOS.

См. также      ctime, getdate, gettime, setdate, time

Пример         #include <stdio.h>
               #include <dos.h>

               int main(void)
               {
                  struct  time t;
                  gettime(&t);
                  printf("The current minute is: %d\n",
                          t.ti_min);
                  printf("The current hour is: %d\n",
                          t.ti_hour);
                  printf("The current hundredth of a
                          second is: "
                         "%d\n", t.ti_hund);
                  printf("The current second is: %d\n",
                          t.ti_sec);
                  /* Добавить одну минуту в элемент структуры
                     и вызвать settime  */
                  t.ti_min++;
                  settime(&t);
                  return 0;
               }

     setusercharsize
──────────────────────────────────────────────────────────────
Функция        Изменяет ширину  и  высоту  символов  штриховых
               шрифтов.

Синтаксис      #include <graphics.h>
               void far setusercharsize(int multx, int divx,
                                        int multy, int divy);

Прототип в     graphics.h

Примечания     setusercharsize предоставляет  Вам удобную воз-
               можность управлять размерами  текста  штриховых
               шрифтов,  используемых  графическими функциями.
               Значения,      устанавливаемые      посредством
               setusercharsize, действуют ТОЛЬКО если charsize
               установлено в  0  при  предыдущем  обращении  к
               settextstyle.
               При использовании setusercharsize Вы указываете
               коэффициенты масштабирования по ширине и  высо-
               те. Принимаемая по умолчанию ширина масштабиру-
               ется коэффициентом multx:divx, а принимаемая по
               умолчанию  высота  масштабируется коэффициентом
               multy:divy.  Например, чтобы получить текст уд-
               военной ширины и на 50%  выше обычного, устано-
               вите
                  multx = 2; divx = 1;
                  multy = 3; divy = 2;

Значение       Нет.

Переносимость
               Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      gettextsettings, graphresult, settextstyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  /* установить стиль текста */
                  settextstyle(TRIPLEX_FONT, HORIZ_DIR, 4);
                  /* перейти в начальную текстовую позицию */
                  moveto(0, getmaxy() / 2);
                  /* вывести обычный текст */
                  outtext("Norm ");
                  /* установить ширину для текста, равную 1/3
                     от обычной ширины */
                  setusercharsize(1, 3, 1, 1);
                  outtext("Short ");
                  /* увеличить ширину текста в 3 раза
                     от обычной ширины */
                  setusercharsize(3, 1, 1, 1);
                  outtext("Wide");
                  /* выйти из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     setvbuf
──────────────────────────────────────────────────────────────
Функция        Устанавливает буферизацию потока ввода-вывода.

Синтаксис      #include <stdio.h>
               int setvbuf(FILE *stream, char *buf, int type,
                           size_t size);

Прототип в     stdio.h

Примечания     setbuf устанавливает  использование  буфера buf
               для потока ввода-вывода stream вместо автомати-
               чески   распределенного   буфера.  Используется
               после открытия файла stream.
               Если buf   есть   0,   буфер   будет   размещен
               посредством malloc;  он будет использовать size
               в качестве размещаемого  объема  памяти.  Буфер
               будет  автоматически  освобожден  при  закрытии
               файла.  Параметр size определяет длину буфера и
               должен быть больше нуля.
         !!!   Максимальное значение   параметра  size  32767.
               stdin и stdout небуферизованы,  если они не пе-
               реопределены;  в противном случае они полностью
               буферизованы.
               Небуферизованный ввод-вывод означает,  что сим-
               волы, направляемые в выходной поток, немедленно
               выводятся в файл или на внешнее  устройство,  в
               то  время,  как при буферизованном вводе-выводе
               символы накапливаются и выводятся блоками.

               Параметр type может принимать одно из следующих
               значений:
               _IOFBF  Файл ПОЛНОСТЬЮ БУФЕРИЗОВАН. Когда буфер
                       пуст,  очередная  операция  ввода будет
                       пытаться заполнить весь входной  буфер.
                       При выводе буфер будет полностью запол-
                       нен, прежде чем данные будут записаны в
                       файл.
               _IOLBF  Файл ПОСТРОЧНО БУФЕРИЗОВАН. Когда буфер
                       пуст,  очередная операция  ввода  также
                       будет  пытаться  заполнить весь входной
                       буфер.  При выводе, однако, буфер будет
                       выводиться  при  записи  в файл символа
                       конца строки.
               _IONBF  Файл НЕБУФЕРИЗОВАН.   Параметры  buf  и
                       size игнорируются. Каждая операция вво-
                       да  читает непосредственно из файла,  и
                       каждая операция вывода  непосредственно
                       записывает данные в файл.

               Типичной ошибкой является использование  в  ка-
               честве  буфера автоматической (локальной) пере-
               менной,  что делает невозможным закрытие  файла
               до выхода из функции,  где эта переменная опре-
               делена.

Значение       setvbuf возвращает  0  при успешном завершении.
               Ненулевое значение  означает,  что  либо  недо-
               пустимое  значение  передано для type или size,
               либо недостаточно памяти для размещения буфера.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      fflush, fopen, setbuf

Пример         #include <stdio.h>

               int main(void)
               {
                  FILE *input, *output;
                  char bufr[512];
                  input = fopen("file.in", "r+b");
                  output = fopen("file.out", "w");
                  /* установить входной поток для минимизации
                     доступа к диску, используя наш собствен-
                     ный символьный буфер */
                  if (setvbuf(input, bufr, _IOFBF, 512) != 0)
                     printf("failed to set up buffer for input
                            file\n");
                  else
                     printf("buffer set up for input file\n");
                  /* установить выходной поток в линейную
                     буферизацию, используя память, полученную
                     косвенным вызовом функции malloc */
                  if (setvbuf(output, NULL, _IOLBF, 132) != 0)
                     printf("failed to set up buffer for
                             output file\n");
                  else
                     printf("buffer set up for output
                             file\n");

                  /* осуществить I/O операции здесь */

                  /* закрыть файлы */
                  fclose(input);
                  fclose(output);
                  return 0;
               }

     setvect
──────────────────────────────────────────────────────────────
Функция        Устанавливает один вход вектора прерываний.

Синтаксис      #include <dos.h>
               void setvect(int interruptno,
                            void interrupt(*isr)());

Прототип в     dos.h

Примечания     Каждый процессор  семейства  8086  имеет  набор
               векторов прерываний,  пронумерованных от  0  до
               255. Четырехбайтное значение вектора прерывания
               означает адрес, по которому расположена функция
               обработки данного прерывания.
               setvect устанавливает новое  значение  isr  для
               вектора  прерывания  с номером intrruptno.  isr
               есть far pointer,  указывающий на функцию обра-
               ботки прерывания. Адрес процедуры языка C может
               быть передан посредством isr  только  если  она
               объявлена как процедура прерывания.
         !!!   Если Вы  используете  прототипы,  описанные   в
               dos.h,  просто  передайте setvect адрес функции
               обработки прерывания в любой модели памяти.

Значение       Нет.

Переносимость  Эта функция доступна только для процессоров се-
               мейства 8086.

См. также      getvect

Пример         /*** Примечание:
               Это пользовательская программа обработки преры-
               вания.  Вы не сможете откомпилировать эту прог-
               рамму  с включенным Test Stack Overflow и полу-
               чить выполнимый файл,  который  будет  работать
               корректно. */

               #include <stdio.h>
               #include <dos.h>
               #include <conio.h>

               #define INTR 0X1C   /* прерывание по таймеру */

               void interrupt ( *oldhandler)(void);

               int count = 0;

               void interrupt handler(void)
               {
                  count++;  /* увеличить глобальный счетчик */
                  oldhandler(); /* вызвать старую программу */
               }

               int main(void)
               {
               /* сохранить старый вектор прерывания */
                  oldhandler = getvect(INTR);
               /* установить новый обработчик прерываний */
                  setvect(INTR, handler);
               /* цикл, пока счетчик не достигнет 20 */
                  while (count < 20)
                     printf("count is %d\n",count);
               /* восстановить старый обработчик прерываний */
                  setvect(INTR, oldhandler);
                  return 0;
               }

     setverify
───────────────────────────────────────────────────────────────
Функция        Устанавливает состояние флага верификации DOS.

Синтаксис      #include <dos.h>
               void setverify(int value);

Прототип в     dos.h

Примечания     setverify устанавливает флаг верификации в зна-
               чение value.
                  - value = 0   флаг верификации выключен
                  - value = 1   флаг верификации включен
               Флаг верификации  управляет  выводом  на  диск.
               Если он выключен, правильность вывода не прове-
               ряется;  если включен - весь вывод на диск про-
               веряется на правильность выводимых данных.

Значение       Нет.

Переносимость  Эта функция доступна только в DOS.

См. также      getverify

Пример         #include <stdio.h>
               #include <conio.h>
               #include <dos.h>

               int main(void)
               {
                  int verify_flag;
                  printf("Enter 0 to set verify flag off\n");
                  printf("Enter 1 to set verify flag on\n");
                  verify_flag = getch() - 0;
                  setverify(verify_flag);
                  if (getverify())
                     printf("DOS verify flag is on\n");
                  else
                     printf("DOS verify flag is off\n");
                  return 0;
               }

     setviewport
──────────────────────────────────────────────────────────────
Функция        Устанавливает текущее окно для графического вы-
               вода.

Синтаксис      #include <graphics.h>
               void far setviewport(int left, int top,
                                    int right,
                                    int bottom, int clip);

Прототип в     graphics.h

Примечания     setviewport определяет новое  окно  для  графи-
               ческого вывода.
               Углы окна задаются в абсолютных экранных  коор-
               динатах   посредством  (left,  top)  и  (right,
               bottom).  Текущая  позиция  устанавливается   в
               (0,0) в новом окне.
               Параметр clip определяет,  будут ли линии отсе-
               каться на границах окна. Если clip не равен ну-
               лю,  все линии будут отсекаться границами теку-
               щего окна.

Значение       Если недопустимые       значения       переданы
               setviewport, graphresult возвратит -11, и теку-
               щее окно не изменится.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      clearviewport, getviewsettings, graphresult

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               /* активизирует отсечение на границах окна */
               #define CLIP_ON 1

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  setcolor(getmaxcolor());
                  /* вывести сообщение на полный экран */
                  outtextxy(0, 0,
                            "* <-- (0, 0) in default
                             viewport");
                  /* установить меньшее окно */
                  setviewport(50, 50, getmaxx()-50,
                              getmaxy()-50, CLIP_ON);
                  /* вывести текст */
                  outtextxy(0, 0,
                            "* <-- (0, 0) in smaller
                             viewport");
                  /* выйти из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     setvisualpage
──────────────────────────────────────────────────────────────
Функция        Устанавливает номер текущей видимой графической
               страницы.

Синтаксис      #include <graphics.h>
               void far setvisualpage(int page);

Прототип в     graphics.h

Примечания     setvisualpage устанавливает номер текущей види-
               мой графической страницы равным page.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      graphresult, setactivpage

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* выбрать драйвер и режим, которые
                     поддерживают несколько страниц */
                  int gdriver = EGA, gmode = EGAHI, errorcode;
                  int x, y, ht;
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  x = getmaxx() / 2;
                  y = getmaxy() / 2;
                  ht = textheight("W");
                  /* установить активную страницу вне экрана
                     для изображения */
                  setactivepage(1);
                  /* нарисовать линию на странице #1 */
                  line(0, 0, getmaxx(), getmaxy());
                  /* вывести сообщение на странице #1 */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  outtextxy(x, y, "This is page #1:");
                  outtextxy(x, y + ht, "Press any key to
                            halt:");
                  /* установить активную страницу #0 */
                  setactivepage(0);
                  /* вывести сообщение на странице #0 */
                  outtextxy(x, y, "This is page #0.");
                  outtextxy(x, y+ht,
                            "Press any key to view page #1:");
                  getch();
                  /* установить страницу #1 как видимую */
                  setvisualpage(1);
                  /* выйти из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     setwritemode
──────────────────────────────────────────────────────────────
Функция        Устанавливает способ рисования линий  в  графи-
               ческом режиме.

Синтаксис      #include <graphics.h>
               void far setwritemode(int mode);

Прототип в     graphics.h

Примечания     Определены следующие константы:
                     COPY_PUT = 0;   /* MOV */
                     XOR_PUT  = 1;   /* XOR */
               Каждая константа соответствует битовой операции
               между каждым байтом линии и соответствущим бай-
               том  на  экране.  COPY_PUT  использует  команду
               ассемблера MOV, перекрывая тем самым содержимое
               экрана вычерчиваемой линией. XOR_PUT использует
               команду  ассемблера  XOR,  тем самым комбинируя
               линию с содержимым экрана. Две последовательных
               команды  XOR уничтожат линию и восстановят пер-
               воначальное содержимое экрана.
         !!!   В настоящее время setwritemode работает  только
               с line, linerel, lineto, rectangle и drawpoly.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция несовместима с Windows.

См. также      drawpoly, line, linerel, lineto, putimage

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main()
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int xmax, ymax;
                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* обнаружена
                                              ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }
                  xmax = getmaxx();
                  ymax = getmaxy();
                  /* установить режим вычерчивания XOR */
                  setwritemode(XOR_PUT);
                  /* нарисовать линию */
                  line(0, 0, xmax, ymax);
                  getch();
                  /* стереть линию повторным ее
                     изображением */
                  line(0, 0, xmax, ymax);
                  getch();
                  /* установить режим вычерчивания COPY_PUT */
                  setwritemode(COPY_PUT);
                  /* нарисовать линию */
                  line(0, 0, xmax, ymax);
                  /* выйти из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     signal
──────────────────────────────────────────────────────────────
Функция        Специфицирует действия по обработке сигнала.

Синтаксис      #include <signal.h>
               void (*signal (int sig,
                     void (*func)(int sig [,int subcode])))
                                                      (int);

Прототип в     signal.h

Примечания signal определяет,  как в  дальнейшем  следует  от-
               носиться к получению сигнала номер sig.  Вы мо-
               жете установить  процедуру  обработки  сигнала,
               определенную пользователем или использовать од-
               ну из двух,  определенных в signal.h, - SIG_DFL
               или                                    SIG_IGN.
               ───────────────────────────────────────────────
                Указатель функции   Значение
               ───────────────────────────────────────────────
                SIG_DFL        Прекращает выполнение программы
                SIG_IGN        Игнорирует этот тип сигнала
                SIG_ERR        Указывает на ошибочный возврат
                               из signal
               ───────────────────────────────────────────────
                Типы сигналов и действия, принимаемые
                           по умолчанию:
               ───────────────────────────────────────────────
                Тип сигнала    Значение
               ───────────────────────────────────────────────
                SIGABRT   Аварийное  завершение.  Действие  по
                          умолчанию     эквивалентно    вызову
                          _exit(3).
                SIGFPE    Арифметическая  ошибка  типа деления
                          на  0, недопустимой  операции и т.п.
                          Действие  по  умолчанию эквивалентно
                          вызову _exit(1).
                SIGILL    Неверная   операция.   Действие   по
                          умолчанию     эквивалентно    вызову
                          _exit(1).
                SIGINT    Прерывание   CTRL-C.   Действие   по
                          умолчанию - выполнить INT 23h.
                SIGSEGV   Неверное    обращение    к   памяти.
                          Действие  по  умолчанию эквивалентно
                          вызову _exit(1).
                SIGTERM   Запрос  на   прекращение  выполнения
                          программы.  Действие   по  умолчанию
                          эквивалентно вызову _exit(1).
                ──────────────────────────────────────────────
               В signal.h определен тип sig_atomic_t  -  самый
               длинный  целый тип,  который процессор способен
               считать или записать в оперативную память  еди-
               новременно  при  наличии асинхронных прерываний
               (для семейства 8086 это 16-битное слово,  т.е.,
               в терминах Borland С++, integer).
               Когда сигнал генерируется  функцией  raise  или
               внешним событием, происходит следующее:
               1. Если для этого сигнала уже установлен  обра-
               ботчик,  определенный  пользователем,  действие
               для этого типа сигнала устанавливается SIG_DFL.
               2. Функция, определенная пользователем, вызыва-
               ется и получает в качестве параметра тип сигна-
               ла.
               Функция обработки сигнала, определенная пользо-
               вателем,  может завершиться  обычным  возвратом
               или вызовом abort, _exit, exit или longjmp.

               В Borland C++ реализовано расширение ANSI C для
               случая,  когда тип сигнала есть SIGFPE, SIGSEGV
               или SIGILL.  Функция обработки сигнала, опреде-
               ленная пользователем, вызывается в этих случаях
               с одним или двумя дополнительными  параметрами.
               Если SIGFPE,  SIGSEGV или SIGILL возникли в ре-
               зультате явного вызова функции  raise,  функция
               обработки сигнала,  определенная пользователем,
               получает один дополнительный параметр -  целое,
               показывающее, что обработчик сигнала был вызван
               явным обращением.  Значения этого параметра для
               явного  активирования SIGFPE,  SIGSEGV и SIGILL
               таковы    (см.     описания     в     float.h):
               ───────────────────────────────────────────────
                Сигнал           Значение
               ───────────────────────────────────────────────
                SIGFPE           FPE_EXPLICITGEN
                SIGSEGV          SEGV_EXPLICITGEN
                SIGILL           ILL_EXPLICITGEN
               ───────────────────────────────────────────────
               Если SIGFPE возник в результате  исключительной
               ситуации  плавающей  точки,  функция  обработки
               сигнала вызывается с одним дополнительным пара-
               метром, который показывает тип сигнала FPE_xxx.
               Если же SIGSEGV, SIGILL или целочисленные вари-
               анты    сигнала   SIGFPE   (FPE_INTOVFLOW   или
               FPE_INTDIV0) возникли в результате исключитель-
               ной  ситуации  процессора,  обработчик сигналов
               получает два дополнительных параметра:
               1. Тип   исключительной  ситуации  для  SIGFPE,
               SIGSEGV или SIGILL (см.  описание этих типов  в
               float.h). Этот первый параметр есть обычный тип
               сигнала в смысле ANSI.
               2. Integer  pointer,  указывающий на стек обра-
               ботчика прерываний, которым был вызван обработ-
               чик  сигналов.  Этот  указатель адресует список
               регистров процессора, сохраненных во время воз-
               никновения  исключительной  ситуации.  Регистры
               следуют в том же порядке, что и параметры функ-
               ции прерывания: BP, DI, SI, DS, ES, DX, CX, BX,
               AX,  IP, CS, FLAGS. Чтобы изменить значение ре-
               гистра  при  возврате  из обработчика сигналов,
               измените   соответствующий   компонент    этого
               списка. Например, чтобы иметь новое значение SI
               при возврате, напишите что-нибудь вроде:
               *((int *)list_pointer + 2) = new_SI_value;  Та-
               ким способом обработчик сигналов может  исполь-
               зовать  и  изменять значения любых регистров по
               желанию пользователя.  (См.  демонстрацию  этой
               возможности в Примере 2).

               Следующие типы  сигналов  для SIGFPE могут воз-
               никнуть (или  быть  сгенерированы).  Они  соот-
               ветствуют исключительным ситуациям, распознава-
               емым процессорами семейства 8087, а также ситу-
               ациям "Целочисленное деление на нуль" и "Преры-
               вание по  переполнению"  основного  процессора.
               (Описания  всего  этого  находятся  в float.h).
               ───────────────────────────────────────────────
                Сигнал SIGFPE     Значение
               ───────────────────────────────────────────────
                FPE_INTOVFLOW   Выполнено INTO с включ.
                                флагом OF
                FPE_INTDIV0     Целочисленное деление на ноль
                FPE_INVALID     Недопустимая операция
                FPE_ZERODIVIDE  Деление на ноль
                FPE_OVERFLOW    Численное переполнение
                FPE_UNDERFLOW   Численное исчезновение порядка
                FPE_INEXACT     Точность
                FPE_EXPLICITGEN Обращение к raise(SIGFPE)
               ───────────────────────────────────────────────
         !!!   Сигналы FPE_INTOVFLOW и  FPE_INTDIV0  возникают
               при выполнении целочисленных операций,  осталь-
               ные - при выполнении операций с плавающей  точ-
               кой. Будут ли возникать исключительные ситуации
               с плавающей точкой -  зависит  от  управляющего
               слова сопроцессора,  которое может быть модифи-
               цировано посредством _control87. Исключительные
               ситуации ненормализации обрабатываются системой
               Borland C++ и не передаются обработчику  сигна-
               лов.

               Следующие типы сигналов SIGSEGV  могут  возник-
               нуть:
                SEGV_BOUND    Нарушение   ограничения
                SEGV_EXPLICITGEN Обращение к raise(SIGSEGV)
               Процессоры 8088 и 8086 НЕ ИМЕЮТ  ограничивающих
               команд.  Процессоры серий 186, 286, 386 и NEC V
               ИМЕЮТ такие команды.  Поэтому  для  процессоров
               8088 и 8086 никогда не возникнет тип SEGV_BOUND
               сигнала SIGSEGV.  Borland C++ не генерирует ог-
               раничивающих команд, однако они могут использо-
               ваться в inline-коде или в отдельно скомпилиро-
               ванных процедурах на ассемблере, присоединяемых
               при редактировании связей.

               Следующие типы сигналов  SIGILL  могут  возник-
               нуть:
                ILL_EXECUTION       Попытка выполнить недопус-
                                    тимую операцию
                ILL_EXPLICITGEN     Обращение к raise(SIGILL)
               Процессоры 8088,  8086,  NEC  V20,  NEC  V30 НЕ
               РАСПОЗНАЮТ исключительную ситуацию  "недопусти-
               мая операция".  Процессоры 186,  286,  386, NEC
               V40 и NEC V50 РАСПОЗНАЮТ эту исключительную си-
               туацию.  Таким  образом,  для процессоров 8088,
               8086,  NEC V20 и NEC V30 никогда  не  возникнет
               тип ILL_EXECUTION сигнала SIGILL.

               Если тип   сигнала  есть  SIGFPE,  SIGSEGV  или
               SIGILL,  возврат из обработчика сигнала, вообще
               говоря,  не рекомендуется, поскольку: состояние
               8087 некорректно;  результат целочисленного де-
               ления неверен; операция, которая не должна была
               привести к переполнению, выполнена; ограничива-
               ющая команда отвергнута; попытка выполнения не-
               допустимой операции уже произведена. Единствен-
               ный  случай,  когда  возврат имеет смысл - если
               обработчик сигналов изменяет регистры так,  что
               возникает  осмысленный  контекст  для возврата,
               ИЛИ ЖЕ тип сигнала показывает,  что сигнал выз-
               ван явным обращением к функции raise (например,
               FPE_EXPLICITGEN,      SEGV_EXPLICITGEN      или
               ILL_EXPLICITGEN). Вообще в этом случае Вы могли
               бы напечатать сообщение об ошибке и  прекратить
               выполнение программы, используя _exit, exit или
               abort.  Если возврат выполняется при любых иных
               обстоятельствах,  действия программы будут, ве-
               роятно, непредсказуемы по своим результатам.

Значение       Если обращение прошло успешно, signal возвраща-
               ет указатель на предыдущую процедуру  обработки
               сигнала указанного типа. Если обращение отверг-
               нуто,  signal возвращает SIG_ERR,  и глобальная
               переменная errno принимает значение EINVAL.

Переносимость  Эта функция совместима с ANSI C.

См. также      abort, _control87,   ctrlbrk,   exit,  longjmp,
               raise, setjmp

Пример 1       /* Этот пример устанавливает программу обработ-
                  чика сигналов, которая запускается при нажа-
                  тии Ctrl-Break */

               #include <stdio.h>
               #include <signal.h>
               #include <stdlib.h>

               void catcher(void)
               {
                   printf("\nNow in break routine\n");
                   exit(1);
               }
               int main(void) {
                   signal(SIGINT, catcher);
                   for (;;)
                       printf("\nIn main() program\n");
               }

Пример 2       /* Этот пример устанавливает программу обработ-
               чика сигналов для SIGFPE,  создает ситуацию це-
               лочисленного переполнения в регистре AX и дела-
               ет возврат.  Эта программа может  привести  ваш
               компьютер  к  аварии и будет производить ошибки
               выполнения в зависимости от используемой модели
               памяти */

               #pragma inline
               #include <stdio.h>
               #include <signal.h>

               void Catcher(int *reglist)
               {
                  printf("Caught it!\n");
                  *(reglist + 8) = 3;  /* возвращает AX = 3 */
               }

               int main(void)
               {
                  signal(SIGFPE, Catcher);
                  asm     mov     ax,07FFFH   /* AX = 32767 */
                  asm     inc     ax        /* переполнение */
                  asm     into     /* активация обработчика */
                  /* Обработчик устанавливает АХ в 3 при возв-
                     рате.  Если  этого не произошло,  значит,
                     возникла другая исключительная  ситуация,
                     и  следующий  'into'  был  выполнен после
                     'dec'-инструкции. */
                  asm    dec ax  /* теперь нет переполнения */
                  asm    into    /* не активирует обработчик*/
                  return 0;
               }

     sin
──────────────────────────────────────────────────────────────
Функция        Вычисляет синус.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>       #include <complex.h>
               double sin(double x);   complex sin(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                  complex.h

Примечания     sin вычисляет синус переданного значения.  Углы
               измеряются в радианах.
               Обработка ошибок  для  этой  функции может быть
               модифицирована посредством функции matherr.

Значение       sin возвращает синус переданного значения.
               Синус комплексного аргумента определяется как
                 sin(z) = (exp(i * z) - exp(-i * z)) / (2 * i)

Переносимость  Вещественная версия  доступна в системах UNIX и
               определена в ANSI C.  Комплексная  версия  этой
               функции требует С++ и, вероятно, непереносима.

См. также      acos, asin, atan, atan2, complex, cos, tan

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  double result, x = 0.5;
                  result = sin(x);
                  printf("The sin()of %lf is %lf\n",x,result);
                  return 0;
               }

     sinh
────────────────────────────────────────────────────────────────────
Функция        Вычисляет гиперболический синус.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>      #include <complex.h>
               double sinh(double x); complex sinh(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                 complex.h

Примечания     sinh вычисляет гиперболический синус:
                  (exp x - exp(-x))/2.
               Обработка ошибок для этой  функции  может  быть
               модифицирована посредством функции matherr.
               Гиперболический синус  комплексного   аргумента
               определяется как
                 sinh(z) = (exp(z) - exp(-z)) / 2

Значение       sinh возвращает гиперболический синус от x.
               Когда верное значение функции вызывает перепол-
               нение,  sinh возвращает значение HUGE_VAL соот-
               ветствующего знака. Глобальная переменная errno
               при этом принимает значение ERANGE. См. cosh.

Переносимость  Вещественная версия  доступна в системах UNIX и
               определена в ANSI C.  Комплексная  версия  этой
               функции требует С++ и, вероятно, непереносима.

См. также      acos, asin,  atan,  atan2,  complex, cos, cosh,
               sin, tan, tanh

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  double result, x = 0.5;
                  result = sinh(x);
                  printf("The hyperbolic sin() of %lf is
                          %lf\n", x,
                          result);
                  return 0;
               }

     sleep
──────────────────────────────────────────────────────────────
Функция        Приостанавливает выполнение программы на задан-
               ный интервал (в секундах).

Синтаксис      #include <dos.h>
               void sleep(unsigned seconds);

Прототип в     dos.h

Примечания     При обращении  к sleep выполнение текущей прог-
               раммы приостанавливается на число  секунд,  за-
               данное аргументом seconds.  Интервал выдержива-
               ется с точностью до сотых долей секунды или  до
               точности часов DOS, если они менее точны.

Значение       Нет.

Переносимость  Эта функция   доступна  в  системах  UNIX.  Она
               несовместима с Windows.

См. также      delay

Пример         #include <dos.h>
               #include <stdio.h>

               int main(void)
               {
                  int i;
                  for (i = 1; i < 5; i++) {
                     printf("Sleeping for %d seconds\n", i);
                     sleep(i);
                  }
                  return 0;
               }

     sopen
──────────────────────────────────────────────────────────────
Функция        Открывает файл совместного использования.

Синтаксис      #include <fcntl.h>
               #include <sys\stat.h>
               #include <share.h>
               #include <io.h>
               int  sopen(char *path,  int access,
                          int shflag, int mode);

Прототип в     io.h

Примечания     sopen открывает файл,  заданный путем  path,  и
               готовит  его для совместного чтения или записи,
               как определено в access, shflag и mode.
               sopen - макрос, определенный как
                  open (path, (access) | (shflag), mode)
               Для sopen  аргумент  access составляется пораз-
               рядной дизъюнкцией из следующих  двух  списков.
               Только  один  флаг  первого  списка  может быть
               использован; остальные флаги могут появляться в
               любой логической комбинации.
                Список 1: Флаги чтения/записи
                  O_RDONLY  Открыть только для чтения
                  O_WRONLY  Открыть только для записи
                  O_RDWR    Открыть для чтения и записи
                 Список 2: Другие флаги доступа
                  O_NDELAY  Не используется; только для
                            совместимости с UNIX.
                  O_APPEND  Если этот флаг установлен,  указа-
                            тель файла устанавливается на  ко-
                            нец  файла  перед каждой операцией
                            записи.
                  O_CREAT   Если файл существует, флаг не ока-
                            зывает никакого эффекта. Если фай-
                            ла  не  существует,  он создается.
                            При этом биты  mode  используются,
                            чтобы  установить  атрибуты  файла
                            так, как для chmod.
                  O_TRUNC   Если файл  существует,  его  длина
                            усекается до 0.  Атрибуты файла не
                            изменяются.
                  O_EXCL    Используется только    вместе    с
                            O_CREAT.   Если  файл  существует,
                            возвращается указание на ошибку.
                  O_BINARY  Этот флаг  может  быть установлен,
                            чтобы явно открыть двоичный файл.
                  O_TEXT    Этот флаг  может  быть установлен,
                            чтобы явно открыть текстовый файл.
               
               Эти символические константы O_...  определены в
               fcntl.h.
               Если не заданы ни O_BINARY, ни O_TEXT, файл от-
               крывается  в соответствии со значением глобаль-
               ной переменной _fmode.
               Если в  access  использован  флаг  O_CREAT,  Вы
               должны  указать  аргумент  mode,  выбрав его из
               следующих символических констант,  определенных
               в                                   sys\stat.h:
               ───────────────────────────────────────────────
                Значение mode      Разрешенный доступ
               ───────────────────────────────────────────────
                S_IWRITE           Разрешено чтение
                S_IREAD            Разрешена запись
                S_IREAD|S_IWRITE   Разрешены чтение и запись
               ───────────────────────────────────────────────
               shflag определяет тип совместного использования
               файла path.  Символические константы для shflag
               определены              в              share.h.
               ───────────────────────────────────────────────
                Значение shflag  Что делает
               ───────────────────────────────────────────────
                SH_COMPAT     Устанавливает режим совместности
                SH_DENYRW     Отвергает доступ чтения/записи
                SH_DENYWR     Отвергает доступ записи
                SH_DENYRD     Отвергает доступ чтения
                SH_DENYNONE   Разрешает доступ чтения/записи
                SH_DENYNO     Разрешает доступ чтения/записи
               ───────────────────────────────────────────────

Значение       При успешном выполнении sopen возвращает  неот-
               рицательное  целое  (номер  обработчика файла),
               при этом указатель файла (который указывает  на
               текущую  позицию  файла)  установлен  на начало
               файла.  В случае ошибки возвращается -1, а гло-
               бальная переменная errno принимает одно из сле-
               дующих значений:
               
                 ENOENT       Путь или файл не найден
                 EMFILE       Слишком много открытых файлов
                 EACCES       Запрос на доступ отвергнут
                 EINVACC      Неверный код доступа

Переносимость  Эта функция  доступна  в системах UNIX.  В UNIX
               версии 7 мнемоники O_type не определены. В UNIX
               System  III  используются все мнемоники O_type,
               кроме O_BINARY.

См. также      chmod, close,  creat, lock, lseek, _open, open,
               unlock, unmask

Пример         #include <io.h>
               #include <fcntl.h>
               #include <sys\stat.h>
               #include <process.h>
               #include <share.h>
               #include <stdio.h>

               int main(void)
               {
                  int handle;
                  int status;
                  handle = sopen("c:\\autoexec.bat", O_RDONLY,
                                 SH_DENYNO, S_IREAD);
                  if (handle < 0) {
                     printf("sopen failed\n");
                     exit(1);
                  }
                  status = access("c:\\autoexec.bat", 6);
                  if (status == 0)
                     printf("read/write access allowed\n");
                  else
                     printf("read/write access not
                             allowed\n");
                  close(handle);
                  return 0;
               }

     sound
──────────────────────────────────────────────────────────────
Функция        Включает динамик PC на указанной частоте.

Синтаксис      #include <dos.h>
               void sound(unsigned frequency);

Прототип в     dos.h

Примечания     sound включает  динамик PC на заданной частоте.
               frequency определяет  частоту  звука  в  герцах
               (колебаниях в секунду). Чтобы выключить динамик
               после  обращения  к  sound,  вызовите   функцию
               nosound.

Значение       Нет.

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми. Соответствующая функция имеется в
               Turbo   Pascal.   Эта  функция  несовместима  с
               Windows.

См. также      delay, nosound

Пример         /* Издает звук с частотой 7 гц в течение 10 се-
                  кунд. Ваш PC, возможно, этого не делает. */

               #include <dos.h>

               int main(void)
               {
                  sound(7);
                  delay(10000);
                  nosound();
                  return 0;
               }

     spawnl, spawnle, spawnlp, spawnlpe,
     spawnv, spawnve, spawnvp и spawnvpe
──────────────────────────────────────────────────────────────
Функция        Создает и запускает дочерний процесс.

Синтаксис      #include <process.h>
               #include <stdio.h>
               int spawnl(int mode, char *path,
                          char *arg0, arg1, ... , argn, NULL);
               int spawnle(int mode, char *path,
                           char *arg0, arg1, ... , argn, NULL,
                           char *envp[]);
               int spawnlp(int mode, char *path,
                           char *arg0, arg1, ... , argn,NULL);
               int spawnlpe(int mode, char *path,
                            char *arg0, arg1, ... , argn,NULL,
                            char *envp[]);
               int spawnv(int mode, char *path, char *argv[]);
               int spawnve(int mode, char *path, char *argv[],
                           char *envp[]);
               int spawnvp(int mode,char *path, char *argv[]);
               int spawnvpe(int mode,char *path, char *argv[],
                            char *envp[]);

Прототип в     process.h

Примечания     Функции семейства spawn...  создают и запускают
               (выполняют) другие файлы,  именуемые  дочерними
               процессами. Для загрузки и выполнения этих про-
               цессов должно иметься достаточно основной памя-
               ти.
               Значение mode определяет,  какие действия будет
               выполнять вызывающая функция (родительский про-
               цесс) после вызова spawn...  Возможные значения
               mode:
               
                P_WAIT        Приостанавливает      выполнение
                              родительского процесса, пока до-
                              черний процесс не завершится.
                P_NOWAIT      Продолжает  выполнять  родитель-
                              ский процесс  одновременно с до-
                              черним.
                P_OVERLAY     Загружает дочерний процесс на то
                              же место в памяти, которое зани-
                              мал  родительский. То же  самое,
                              что  и вызов exec...
               
         !!!   Значение P_NOWAIT в настоящее время не допуска-
               ется  и его использование приводит к ошибочному
               завершению.
               path - имя файла  с  вызываемым  дочерним  про-
               цессом.  Функции spawn...  ищут этот файл с по-
               мощью стандартного алгоритма поиска DOS:
               - Если не задано ни расширения имени файла,  ни
                 точки в его имени,  ищется в точности то имя,
                 которое задано; в случае неудачи DOS добавля-
                 ет .COM к имени файла и повторяет поиск; если
                 опять неудача, добавляется .EXE и поиск снова
                 повторяется.
               - Если задано расширение, ищется только то имя,
                 которое задано.
               - Если  в  имени есть точка,  ищется только имя
                 файла без расширения.
               - Если  path  не содержит явно указанного спра-
                 вочника, функции spawn..., имя которых содер-
                 жит  суффикс  p,  будут искать файл сначала в
                 текущем справочнике,  а затем в справочниках,
                 указанных в переменной среды DOS PATH.

               Суффиксы l,  v,  p и e, добавляемые к имени се-
               мейства spawn..., определяют некоторые дополни-
               тельные возможности этих функций.
                 p   Функция будет  искать  файл во всех спра-
                     вочниках,  указанных в  переменной  среды
                     DOS PATH.  Без этого суффикса функция бу-
                     дет искать файл только в текущем справоч-
                     нике.
                 l   Указатели на аргументы arg0,  arg1,  ...,
                     argn  передаются как отдельные аргументы.
                     Обычно суффикс l используется,  когда за-
                     ранее точно известно количество передава-
                     емых аргументов.
                 v   Указатели на  аргументы  arg[0],  arg[1],
                     ...,  arg[n] передаются как массив указа-
                     телей.  Обычно  суффикс  v  используется,
                     когда может передаваться переменное число
                     аргументов.
                 e   Аргумент envp может быть передан дочерне-
                     му  процессу,  чтобы  изменить его среду.
                     Без суффикса e дочерний процесс наследует
                     среду родительского.

               Каждая функция семейства spawn...  ДОЛЖНА иметь
               один из двух суффиксов,  определяющих аргументы
               (либо l,  либо v). Суффиксы, определяющие объем
               поиска  файла и наследование среды (p и e) - не
               обязательны.
               Например,
               - spawnl передает отдельные аргументы, ищет до-
                 черний процесс только в текущем справочнике и
                 передает  дочернему  процессу   среду   роди-
                 тельского.
               - spawnvpe передает массив указателей, включает
                 в  круг  поиска дочернего процесса переменную
                 PATH и в качестве  среды  дочернего  процесса
                 передает аргумент envp.

               Функции spawn...  должны  передавать  дочернему
               процессу по крайней мере  один  аргумент  (arg0
               или  arg[0]):  этот аргумент,  по соглашениям о
               связях,  является копией  path.  (Использование
               иного  значения для "нулевого" аргумента не бу-
               дет приводить к ошибке).
               В DOS 3.x значение path доступно дочернему про-
               цессу;  в более ранних версиях дочерний процесс
               не  может  использовать  передаваемое  значение
               "нулевого" аргумента (arg0 или arg[0]).
               Когда используется суффикс l,  arg0 обычно ука-
               зывает на path, а arg1, ..., argn - на символь-
               ные строки,  составляющие новый список аргумен-
               тов.  После argn должен  обязательно  следовать
               нуль-символ, определяющий конец списка.
               Когда используется  суффикс  e,  Вы   передаете
               список  новых  установок переменных среды через
               аргумент envp.  Этот аргумент - массив указате-
               лей  на  строки символов.  Каждый указатель ад-
               ресует завершающуюся нуль-символом строку вида
                 envvar = value
               где envvar - имя переменной среды,  а  value  -
               строка-значение этой переменной. Последний эле-
               мент envp[] - нуль-символ.  Если envp пуст, до-
               черний процесс наследует среду родительского.
               Суммарная длина arg0+arg1+...+argn (или arg[0]+
               arg[1]+...+arg[n]),  включая пробелы, разделяю-
               щие аргументы,  но исключая хвостовые нуль-сим-
               волы, должна быть < 128 байтов.
               Когда происходит вызов spawn...,  все  открытые
               файлы остаются открытыми в дочернем процессе.

Значение       При успешном выполнении функции spawn...  возв-
               ращают  код  возврата дочернего процесса (0 при
               нормальном завершении).  Если дочерний  процесс
               явно  вызвал  exit с ненулевым аргументом,  его
               код возврата может быть установлен в  ненулевое
               значение.
               В случае ошибки функции spawn... возвращают -1,
               а глобальная переменная errno получает одно  из
               следующих значений:
               
                 E2BIG      Слишком длинный список аргументов
                 EINVAL     Недопустимый аргумент
                 ENOENT     Путь или файл не найден
                 ENOEXEC    Файл не имеет EXE-формата
                 ENOMEM     Недостаточно памяти

Переносимость  Функции spawn... доступны только в DOS.

См. также      abort, atexit,  _exit, exit, exec..., _fpreset,
               searchpath, system

Пример 1       /* пример функции spawnl() */

               #include <process.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  int result;
                  clrscr();
                  result = spawnl(P_WAIT, "bcc.exe", NULL);
                  if (result == -1) {
                     perror("Error from spawnl");
                     exit(1);
                  }
                  return 0;
               }

Пример 2       /* пример функции spawnle() */

               #include <process.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  int result;

                  clrscr();
                  result = spawnle(P_WAIT, "bcc.exe",
                                   NULL, NULL);
                  if (result == -1) {
                     perror("Error from spawnle");
                     exit(1);
                  }
                  return 0;
               }

     sprintf
──────────────────────────────────────────────────────────────
Функция        Форматный вывод в строку.

Синтаксис      #include <stdio.h>
               int sprintf(char *buffer, const
                           char *format [,argument,...]);

Прототип в     stdio.h

Примечания     sprintf принимает список аргументов,  применяет
               к каждому из них спецификатор формата, содержа-
               щийся  в  строке формата,  на которую указывает
               format,  и помещает сформатированные  данные  в
               строку.

См. детальное  sprintf применяет первый спецификатор формата к
описание       первому  аргументу,  второй - ко второму и т.д.
спецификаторов Число спецификаторов формата и аргументов долж-
формата        но быть одинаковым.
в printf

Значение       sprintf возвращает  число байтов,  помещенных в
               строку.  В это число  не  включается  хвостовой
               нуль-символ. В случае ошибки sprintf возвращает
               EOF.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie.

См. также      fprintf, printf

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  char buffer[80];
                  sprintf(buffer,
                          "An approximation of Pi is %f\n",
                                                       M_PI);
                  puts(buffer);
                  return 0;
               }

     sqrt
──────────────────────────────────────────────────────────────
Функция        Если аргумент вещественный, вычисляется положи-
               тельное значение квадратного корня из  передан-
               ного значения.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>      #include <complex.h>
               double sqrt(double x); complex sqrt(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                 complex.h

Примечания     sqrt вычисляет положительное значение  квадрат-
               ного корня входного параметра.
               Обработка ошибок  для sqrt может быть модифици-
               рована посредством функции matherr.
               Для комплексного  числа  x  sqrt(x)  дает комп-
               лексный корень с аргументом arg(x)/2.
               Комплексный квадратный  корень определяется как
               sqrt(z)=sqrt(abs(z))*(cos(arg(z)/2)+i*
                       sin(arg(z)/2))

Значение       В случае успешного выполнения  sqrt  возвращает
               вычисленное  значение  квадратного  корня из x.
               Если x вещественно  и  положительно,  результат
               положителен. Если x вещественно и отрицательно,
               глобальная переменная errno принимает значение
               
                  EDOM     Ошибка области определения

Переносимость  Вещественная версия доступна в системах UNIX  и
               определена  в  ANSI C.  Комплексная версия этой
               функции требует С++ и, вероятно, непереносима.

См. также      complex, exp, log, pow

Пример         #include <math.h>
               #include <stdio.h>

               int main(void)
               {
                  double x = 4.0, result;
                  result = sqrt(x);
                  printf("The square root of %lf is %lf\n", x,
                         result);
                  return 0;
               }

     srand
──────────────────────────────────────────────────────────────
Функция        Инициализирует генератор случайных чисел.

Синтаксис      #include <stdlib.h>
               void srand(unsigned seed);

Прототип в     stdlib.h

Примечания     Генератор случайных  чисел  вновь инициализиру-
               ется посредством вызова srand с  аргументом  1.
               Ему может быть установлена новая начальная точ-
               ка вызовом srand c другим значением seed.

Значение       Нет.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      rand, random, randomize

Пример         #include <stdlib.h>
               #include <stdio.h>
               #include <time.h>

               int main(void)
               {
                  int i;
                  time_t t;
                  srand((unsigned) time(&t));
                  printf("Ten random numbers from 0
                          to 99\n\n");
                  for(i = 0; i < 10; i++)
                      printf("%d\n", rand() % 100);
                  return 0;
               }

     sscanf
──────────────────────────────────────────────────────────────
Функция        Форматный ввод из строки.

Синтаксис      #include <stdio.h>
               int sscanf(const char *buffer,
                         const char *format [, address,...]);

Прототип в     stdio.h

Примечания     sscanf посимвольно   читает  последовательность
               входных полей из строки. Каждое поле форматиру-
Детальное      ется  в  соответствии со спецификацией формата,
описание       передаваемой sscanf в строке формата,  на кото-
спецификаторов рую указывает format. Наконец, sscanf записыва-
формата        ет форматированный ввод по адресам,  переданным
см. scanf      в качестве аргументов, следующих за format. Ко-
               личество спецификаций формата и адресов  должно
               совпадать с количеством входных полей.
               
               sscanf может прекратить обработку текущего поля
               до достижения обычного символа конца поля (сим-
               вола-разделителя),  или вообще  завершиться  по
               различным причинам. Обсуждение возможных случа-
               ев см. scanf.

Значение       sscanf возвращает  количество успешно прочитан-
               ных,  преобразованных  и  записанных  в  память
               входных полей; возвращаемое значение не включа-
               ет прочитанные поля, которые не были записаны в
               память.  Если ни одно поле не записано, возвра-
               щается 0.  Если sscanf  встретил  символ  конца
               строки, возвращается EOF.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.  Она совместима  с  Kernighan  &
               Ritchie.

См. также      fscanf, scanf

Пример         #include <stdio.h>

               char buffer[] = "a 3.14159 12 a-string\n";

               int main(void)
               {
                  char ch;
                  float f;
                  int i;
                  char string[20];
                  sscanf(buffer, "%c %f %d %s", &ch, &f, &i,
                         string);
                  printf("%c %f %d %s", ch, f, i, string);
                  return 0;
               }

     stat
──────────────────────────────────────────────────────────────
Функция        Получает информацию о файле.

Синтаксис      #include <sys\stat.h>
               int stat(char *path, struct stat *statbuf);

Прототип в     sys\stat.h

Примечания     stat записывает информацию о заданном файле или
               справочнике в структуру stat.
               statbuf указывает на структуру stat (определена
               в sys\stat.h). Эта структура содержит следующие
               поля:
                 st_mode    Битовая  маска,  содержащая  режим
                            файла
                 st_dev     Номер дисковода,  содержащего файл
                 st_rdev    То же, что и st_dev
                 st_nlink   Всегда установлено в 1
                 st_size    Размер файла в байтах
                 st_atime   Время последней модификации файла
                 st_mtime   То же, что и st_atime
                 st_ctime   То же, что и st_atime
               Структура stat  содержит три дополнительных по-
               ля,  которые здесь не упоминаются; они содержат
               значения, не имеющие смысла в DOS.

               Битовая маска,  содержащая  информацию о режиме
               файла, включает следующие биты.

               Ровно один из следующих битов должен быть уста-
               новлен:
                 S_IFREG    path определяет ровно один файл
                 S_IFDIR    path определяет справочник
               Один или оба из следующих бита могут быть уста-
               новлены:
                 S_IWRITE   Пользователю   разрешено  писать в
                            файл
                 S_IREAD    Пользователю  разрешено  читать из
                            файла
               Битовая маска содержит биты  исполнимости;  они
               устанавливаются  в  соответствии  с расширением
               имени открытого файла.  Она содержит также биты
               чтения/записи; эти биты устанавливаются в соот-
               ветствии с режимом разрешения доступа к файлу.

Значение       stat возвращает  0,  если  информация  о  файле
               успешно извлечена.  При ошибке (извлечение  ин-
               формации не осуществлено) stat возвращает -1, а
               глобальная переменная errno принимает значение
                 ENOENT      Путь или файл не найден

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      access, chmod, fstat

Пример         #include <sys\stat.h>
               #include <stdio.h>
               #include <time.h>

               #define FILENAME "TEST.$$$"

               int main(void)
               {
                  struct stat statbuf;
                  FILE *stream;
                  /* открыть файл */
                  if ((stream = fopen(FILENAME, "w+")) ==
                       NULL) {
                     fprintf(stderr, "Cannot open output
                                                  file.\n");
                     return(1);
                  }
                  /* получить информацию о файле */
                  stat(FILENAME, &statbuf);
                  fclose(stream);
                  /* вывести полученную информацию */
                  if (statbuf.st_mode & S_IFCHR)
                     printf("Handle refers to a device.\n");
                  if (statbuf.st_mode & S_IFREG)
                     printf("Handle refers to an ordinary
                                                    file.\n");
                  if (statbuf.st_mode & S_IREAD)
                     printf("User has read permission on
                                                 file.\n");
                  if (statbuf.st_mode & S_IWRITE)
                     printf("User has write permission on
                                                  file.\n");
                  printf("Drive letter of file: %c\n",
                         'A'+statbuf.st_dev);
                  printf("Size of file in bytes: %ld\n",
                         statbuf.st_size);
                  printf("Time file last opened: %s\n",
                         ctime(&statbuf.st_ctime));
                  return 0;
               }

     _status87
──────────────────────────────────────────────────────────────
Функция        Получение статуса процессора плавающей точки.

Синтаксис      #include <float.h>
               unsigned int _status87(void);

Прототип в     float.h

Примечания     _status87 получает слово  состояния  процессора
               плавающей  точки,  которое является комбинацией
               слова состояния  сопроцессора  80x87  и  других
               условий,  распознаваемых  обработчиком исключи-
               тельных ситуаций сопроцессора 80x87.

Значение       Биты возвращаемого значения  составляют  статус
               процессора плавающей точки.  Полное определение
               битов, возвращаемых _status87, см. float.h.

Переносимость  Эта функция доступна только в DOS.

См. также      _clear87, _control87, _fpreset

Пример         #include <stdio.h>
               #include <float.h>

               int main(void)
               {
                  float x;
                  double y = 1.5e-100;
                  printf("Status 87 before error: %x\n",
                         _status87());
                  x = y;  /* вызывает ошибку */
                  y = x;
                  printf("Status 87 after error : %x\n",
                         _status87());
                  return 0;
               }

     stime
──────────────────────────────────────────────────────────────
Функция        Устанавливает системную дату и время.

Синтаксис      #include <time.h>
               int stime(time_t *tp);

Прототип в     time.h

Примечания     stime устанавливает системную дату и время.  tp
               указывает на значение, определяющее время в се-
               кундах,  прошедшее  с  00.00.00  GMT,  1 января
               1970г.

Значение       stime возвращает 0.

Переносимость  Эта функция доступна в системах UNIX.

См. также      asctime, ftime,  gettime,  gmtime,   localtime,
               time, tzset

Пример         #include <stdio.h>
               #include <time.h>
               #include <dos.h>

               int main(void)
               {
                  time_t t;
                  struct tm *area;
                  t = time(NULL);
                  area = localtime(&t);
                  printf("Number of seconds since 1/1/1970 is:
                         %ld\n", t);
                  printf("Local time is: %s", asctime(area));
                  t++;
                  area = localtime(&t);
                  printf("Add a second:  %s", asctime(area));
                  t += 60;
                  area = localtime(&t);
                  printf("Add a minute:  %s", asctime(area));
                  t += 3600;
                  area = localtime(&t);
                  printf("Add an hour:   %s", asctime(area));
                  t += 86400L;
                  area = localtime(&t);
                  printf("Add a day:     %s", asctime(area));
                  t += 2592000L;
                  area = localtime(&t);
                  printf("Add a month:   %s", asctime(area));
                  t += 31536000L;
                  area = localtime(&t);
                  printf("Add a year:    %s", asctime(area));
                  return 0;
               }

     stpcpy
──────────────────────────────────────────────────────────────
Функция        Копирует одну строку в другую.

Синтаксис      #include <string.h>
               char *stpcpy(char *dest, const char *src);

Прототип в     string.h

Примечания     stpcpy копирует строку src в строку dest, прек-
               ращая копирование после достижения нуль-символа
               в src.

Значение       stpcpy возвращает dest + strlen(src).

Переносимость  Эта функция доступна в системах UNIX.

См. также      strcpy

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char string[10];
                  char *str1 = "abcdefghi";
                  stpcpy(string, str1);
                  printf("%s\n", string);
                  return 0;
               }

     strcat, _fstrcat
──────────────────────────────────────────────────────────────
Функция        Присоединяет одну строку к другой.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strcat(char *dest, const char *src);
               FAR-ВЕРСИЯ:
               char far *far _fstrcat(char far *dest,
                                      const char far *src);

Прототип в     string.h

Примечания     strcat присоединяет  копию  src  к  концу dest.
               Длина полученной строки  равна  strlen(dest)  +
               strlen(src).

Значение       strcat возвращает   указатель  на  объединенную
               строку.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie.

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char destination[25];
                  char *blank = " ", *c = "C++", *Borland =
                                                   "Borland";
                  strcpy(destination, Borland);
                  strcat(destination, blank);
                  strcat(destination, c);
                  printf("%s\n", destination);
                  return 0;
               }

     strchr, _fstrchr
──────────────────────────────────────────────────────────────
Функция        Просматривает строку  до  первого вхождения за-
               данного символа.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strchr(const char *s, int c);
               FAR-ВЕРСИЯ:
               char far *far _fstrchr(const char far *s,
                                                   int c);

Прототип в     string.h

Примечания     strchr просматривает  строку в прямом направле-
               нии в поисках заданного символа. Она отыскивает
               ПЕРВОЕ   вхождение   символа   c  в  строку  s.
               Нуль-символ считается частью  строки,  поэтому,
               например,
                  strchr(strs,0)
               возвращает указатель на терминальный  нуль-сим-
               вол строки strs.

Значение       strchr возвращает указатель на первое вхождение
               символа c в строку s; если c не входит в строку
               s, strchr возвратит нуль.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      strcspn, strrchr

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
                {
                   char string[15];
                   char *ptr, c = 'r';
                   strcpy(string, "This is a string");
                   ptr = strchr(string, c);
                   if (ptr)
                      printf("The character %c is at position:
                             %d\n", c, ptr - string);
                   else
                      printf("The character was not found\n");
                   return 0;
                }

     strcmp
──────────────────────────────────────────────────────────────
Функция        Сравнивает одну строку с другой.

Синтаксис      #include <string.h>
               int strcmp(const char *s1, const char *s2);

Прототип в     string.h

Примечания     strcmp производит  беззнаковое сравнение симво-
               лов строк s1 и s2,  начиная с  первого  символа
               каждой строки и продолжая то же с последующими,
               пока не встретятся два соответствующих не  сов-
               падающих символа,  или не будет достигнут конец
               данных строк.

Значение       strcmp возвращает следующее значение:
                  < 0, если s1 меньше s2
                  ==0, если s1 совпадает с s2
                  > 0, если s1 больше s2

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      strcmpi, strcoll,  stricmp,  strncmp, strncmpi,
               strnicmp

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                   char *buf1 = "aaa", *buf2 = "bbb",
                                       *buf3 = "ccc";
                   int ptr;
                   ptr = strcmp(buf2, buf1);
                   if (ptr > 0)
                      printf("buffer 2 is greater than
                                            buffer 1\n");
                   else
                      printf("buffer 2 is less than
                                            buffer 1\n");
                   ptr = strcmp(buf2, buf3);
                   if (ptr > 0)
                      printf("buffer 2 is greater than
                                            buffer 3\n");
                   else
                      printf("buffer 2 is less than
                                         buffer 3\n");
                   return 0;
               }

     strcmpi
──────────────────────────────────────────────────────────────
Функция        Сравнивает одну строку с другой без  учета  ре-
               гистра.

Синтаксис      #include <string.h>
               int strcmpi(const char *s1, const char *s2);

Прототип в     string.h

Примечания     strcmpi выполняет беззнаковое сравнение s1 и s2
               без учета регистра (то же самое, что и stricmp,
               но реализовано как макроопределение).
               Функция возвращает значение  (<0,  0  или  >0),
               исходя  из  результата  сравнения  s1  (или  ее
               части) и s2 (или ее части).
               Процедура strcmpi есть,  по сути,  то же самое,
               что и stricmp. strcmpi реализована через макро-
               определение  в  string.h  и  преобразует  вызов
               strcmpi в  вызов  stricmp.  Следовательно,  для
               использования strcmpi, необходимо включить файл
               string.h,  чтобы макроопределение стало доступ-
               ным. Это макроопределение введено для совмести-
               мости с другими компиляторами C.

Значение       strcmpi возвращает целое значение, которое:
                  < 0, если s1 меньше s2
                  ==0, если s1 совпадает с s2
                  > 0, если s1 больше s2

Переносимость  Эта функция доступна только в DOS.

См. также      strcmp, strcoll,  stricmp,  strncmp,  strncmpi,
               strnicmp

Пример         /* пример функции strncmpi */

               #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char *buf1 = "BBB", *buf2 = "bbb";
                  int ptr;
                  ptr = strcmpi(buf2, buf1);
                  if (ptr > 0)
                     printf("buffer 2 is greater than
                                           buffer 1\n");
                  if (ptr < 0)
                     printf("buffer 2 is less than buffer
                                                      1\n");
                  if (ptr == 0)
                     printf("buffer 2 equals buffer 1\n");
                  return 0;
               }

     strcoll
──────────────────────────────────────────────────────────────
Функция        Сравнивает две строки.

Синтаксис      #include <string.h>
               int strcoll(char *s1, char *s2);

Прототип в     string.h

Примечания     strcoll сравнивает строку,  адресуемую указате-
               лем s1, со строкой, адресуемой указателем s2, в
               соответствии с сортирующей последовательностью,
               установленной посредством setlocale.

Значение       strcoll возвращает значение, которое:
                  < 0, если s1 меньше s2
                  ==0, если s1 совпадает с s2
                  > 0, если s1 больше s2

Переносимость  Эта функция совместима с ANSI C.

См. также      strcmp, strcmpi,  stricmp,  strncmp,  strncmpi,
               strnicmp, strxfrm

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char *two = "International";
                  char *one = "Borland";
                  int check;

                  check = strcoll(one, two);
                  if (check == 0)
                     printf("The strings are equal\n");
                  if (check < 0)
                     printf("%s comes before %s\n", one, two);
                  if (check > 0)
                     printf("%s comes before %s\n", two, one);
                  return 0;
               }

     strcpy
──────────────────────────────────────────────────────────────
Функция        Копирует одну строку в другую.

Синтаксис      #include <string.h>
               char *strcpy(char *dest, const char *src);

Прототип в     string.h

Примечания     Копирует строку src в строку dest.  Копирование
               завершается   после   достижения  терминального
               нуль-символа.

Значение       strcpy возвращает dest.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      stpcpy

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
                {
                   char string[10];
                   char *str1 = "abcdefghi";
                   strcpy(string, str1);
                   printf("%s\n", string);
                   return 0;
                }

     strcspn, _fstrcspn
──────────────────────────────────────────────────────────────
Функция        Просматривает строку  в поисках начального сег-
               мента,  не содержащего никакого подмножества из
               заданного множества символов.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               size_t strcspn(const char *s1, const char *s2);
               FAR-ВЕРСИЯ:
               size_t far far _fstrcspn(const char far *s1,
                                        const char far *s2);

Прототип в     string.h

Значение       strcspn возвращает  длину  начального  сегмента
               строки s1,  который полностью состоит из симво-
               лов, НЕ встречающихся в s2.

Переносимость  Эта функция доступна в системах UNIX и определе-
               на в ANSI C.

См. также      strchr, strrchr

Пример         #include <stdio.h>
               #include <string.h>
               #include <alloc.h>

               int main(void)
                {
                   char *string1 = "1234567890";
                   char *string2 = "747DC8";
                   int length;
                   length = strcspn(string1, string2);
                   printf("Character where strings intersect
                           is at position %d\n", length);
                   return 0;
                }

     strdup, _fstrdup
──────────────────────────────────────────────────────────────
Функция        Копирует строку на вновь распределяемое место.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strdup(const char *s);
               FAR-ВЕРСИЯ:
               char far *far _fstrdup(const char far *s);

Прототип в     string.h

Примечания     strdup создает дубликат строки s,  получая  па-
               мять посредством malloc.  Размер получаемой об-
               ласти (strlen(s) + 1) байтов.  Пользователь от-
               вечает  за  освобождение  этой  области памяти,
               когда она более не требуется.

Значение       strdup возвращает указатель на созданный дубли-
               кат или нуль, если запрошенная память недоступ-
               на.

Переносимость  Эта функция доступна в системах UNIX.

См. также      free

Пример         #include <stdio.h>
               #include <string.h>
               #include <alloc.h>

               int main(void)
                {
                   char *dup_str, *string = "abcde";
                   dup_str = strdup(string);
                   printf("%s\n", dup_str);
                   free(dup_str);
                   return 0;
                }

     _strerror
──────────────────────────────────────────────────────────────
Функция        Строит пользовательское сообщение об ошибке.

Синтаксис      #include <string.h>
               char *_strerror(const char *s);

Прототип в     string.h, stdio.h

Примечания     _strerror позволяет   генерировать    пользова-
               тельские сообщения об ошибке; возвращает указа-
               тель на строку, содержащую сообщение и заканчи-
               вающуюся нуль-символом.
               - Если s - нуль, возвращаемое значение указыва-
               ет на последнее  сгенерированное  сообщение  об
               ошибке.
               - Если s - не нуль,  возвращаемое значение  со-
               держит s (Ваше сообщение),  двоеточие,  пробел,
               последнее из системных сообщений об  ошибках  и
               символ  новой строки.  s должна быть не длиннее
               94 символов.
               _strerror есть  то  же самое,  что и strerror в
               версии 1.0 Turbo C.

Значение       _strerror возвращает  указатель  на строку соз-
               данного сообщения.  Эта строка создается в ста-
               тическом  буфере  и перезаписывается при каждом
               новом обращении к _strerror.

Переносимость  Эта функция доступна только в DOS.

См. также      perror, strerror

Пример         #include <stdio.h>

               int main(void)
               {
                  FILE *fp;
                  /* открыть файл для записи */
                  fp = fopen("TEST.$$$", "w");
                  /* создать ошибочную ситуацию, пытаясь
                     читать файл */
                  if (!fp) fgetc(fp);
                  if ferror(fp)
                     /* вывести пользовательское сообщение
                        об ошибке */
                     printf("%s", _strerror("Custom"));
                  fclose(fp);
                  return 0;
               }

     strerror
──────────────────────────────────────────────────────────────
Функция        Возвращает указатель  на  строку  сообщения  об
               ошибке.

Синтаксис      #include <string.h>
               char *strerror(int errnum);

Прототип в     stdio.h, string.h

Примечания     strerror принимает целый параметр errnum -  но-
               мер  ошибки  - и возвращает указатель на строку
               сообщения, соответствующую этому номеру.

Значение       strerror возвращает  указатель  на  построенную
               строку сообщения. Эта строка создается в стати-
               ческом буфере,  который переписывается при каж-
               дом новом вызове strerror.

Переносимость  Эта функция совместима с ANSI C.

См. также      perror, _strerror

Пример         #include <stdio.h>
               #include <errno.h>

               int main(void)
               {
                  char *buffer;
                  buffer = strerror(errno);
                  printf("Error: %s\n", buffer);
                  return 0;
               }

     strftime
──────────────────────────────────────────────────────────────
Функция        Форматирует время для вывода.

Синтаксис      #include <time.h>
               size_t_cdecl strftime(char *s, size_t maxsize,
                        const char  *fmt, const struct tm *t);

Прототип в     time.h

Примечания     strftime форматирует время,  передаваемое в ар-
               гументе t, в массив, адресуемый аргументом s, в
               соответствии со спецификаторами формата. Строка
               формата  состоит  из  нуля или более директив и
               обычных символов. Как и в случае printf, дирек-
               тивы  состоят из символа %,  за которым следует
               символ, который определяет требуемую подстанов-
               ку.  Все обычные символы копируются без измене-
               ния.  В строку s помещается  не  более  maxsize
               символов.

Значение       strftime возвращает количество символов,  поме-
               щенное в строку s.  Если  требуемое  количество
               превышает   maxsize,   strftime  возвращает  0.
               ───────────────────────────────────────────────
                Спецификатор формата  Подстановка
               ───────────────────────────────────────────────
                      %%         Символ %
                      %a         Сокращенное    название   дня
                                 недели
                      %A         Полное название дня недели
                      %b         Сокращенное название месяца
                      %B         Полное название месяца
                      %c         Дата и время
                      %d         Двузначное    число    месяца
                                 (01-31)
                      %H         Двузначный час (00-23)
                      %I         Двузначный час (01-12)
                      %j         Трехзначный номер  дня в году
                                 (001-366)
                      %m         Двузначный номер месяца
                      %M         Двузначное     число    минут
                                 (00-59)
                      %p         AM или PM
                      %S         Двузначное    число    секунд
                                 (00-59)
                      %U         Двузначный    номер   недели,
                                 начиная с воскресенья (00-52)
                      %w         Номер дня недели
                                 (воскресенье - 0) (0-6)
                      %W         Двузначный    номер   недели,
                                 начиная     с    понедельника
                                 (00-52)
                      %x         Дата
                      %X         Время
                      %y         Двузначный номер года (00-99)
                      %Y         Год с  цифрами, обозначающими
                                 век
                      %Z         Название  часового  пояса или
                                 ничего
               ───────────────────────────────────────────────

Переносимость  Эта функция совместима с ANSI C.

См. также      localtime, mktime, time

Пример         #include <stdio.h>
               #include <time.h>
               #include <dos.h>

               int main(void)
               {
                   struct tm *time_now;
                   time_t secs_now;
                   char str[80];
                   tzset();
                   time(&secs_now);
                   time_now = localtime(&secs_now);
                   strftime(str, 80, "It is %M minutes after
                            %I o'clock (%Z)  %A, %B %d 19%y",
                            time_now);
                   printf("%s\n",str);
                   return 0;
               }

     stricmp, _fstricmp
──────────────────────────────────────────────────────────────
Функция        Сравнивает одну  строку  с другой без учета ре-
гистра.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               int stricmp(const char *s1, const char *s2);
               FAR-ВЕРСИЯ:
               int far _fstricmp(const char far *s1,
                                 const char far *s2);

Прототип в     string.h

Примечания     strcmp производит  беззнаковое сравнение симво-
               лов строк s1 и s2,  начиная с  первого  символа
               каждой строки и продолжая то же с последующими,
               пока не встретятся два соответствующих не  сов-
               падающих символа,  или не будет достигнут конец
               данных строк.  Регистр не принимается во внима-
               ние.
               Функция возвращает  значение  (<0,  0  или >0),
               исходя  из  результата  сравнения  s1  (или  ее
               части) и s2 (или ее части).

               Процедуры stricmp  и strcmpi - по сути,  одно и
               то же; strcmpi реализована через макроопределе-
               ние  в  string.h  и преобразует вызов strcmpi в
               вызов stricmp. Следовательно, для использования
               strcmpi,  необходимо  включить  файл  string.h,
               чтобы макроопределение стало доступным.

Значение       stricmp возвращает целое значение, которое:
                   < 0, если s1 меньше s2
                   ==0, если s1 совпадает с s2
                   > 0, если s1 больше s2

Переносимость  Эта функция доступна только в DOS.

См. также      strcmp, strcmpi,  strcoll,  strncmp,  strncmpi,
               strnicmp

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char *buf1 = "BBB", *buf2 = "bbb";
                  int ptr;
                  ptr = strcmpi(buf2, buf1);
                  if (ptr > 0)
                     printf("buffer 2 is greater than
                                           buffer 1\n");
                  if (ptr < 0)
                     printf("buffer 2 is less than
                                        buffer 1\n");
                  if (ptr == 0)
                     printf("buffer 2 equals buffer 1\n");
                  return 0;
               }

     strlen, _fstrlen
──────────────────────────────────────────────────────────────
Функция        Вычисляет длину строки.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               size_t strlen(const char *s);
               FAR-ВЕРСИЯ:
               size_t strlen(const char far *s);

Прототип в     string.h

Примечания     strlen вычисляет длину строки s.

Значение       strlen возвращает количество символов в  строке
               s, не считая терминального нуль-символа.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char *string = "Borland International";
                  printf("%d\n", strlen(string));
                  return 0;
               }

     strlwr, _fstrlwr
──────────────────────────────────────────────────────────────
Функция        Преобразует все  прописные  буквы  в  строке  в
               строчные.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strlwr(char *s);
               FAR-ВЕРСИЯ:
               char far *far _fstrlwr(char char far *s);

Прототип в     string.h

Примечания     strlwr преобразует  прописные буквы (от A до Z)
               в строчные (от a до z).  Никакие другие символы
               не изменяются.

Значение       strlwr возвращает указатель на строку s.

Переносимость  Эта функция доступна только в DOS.

См. также      strupr

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char *string = "Borland International";
                  printf("string prior to strlwr: %s\n",
                                                 string);
                  strlwr(string);
                  printf("string after strlwr:    %s\n",
                                                 string);
                  return 0;
               }

     strncat, _fstrncat
──────────────────────────────────────────────────────────────
Функция        Присоединяет порцию одной строки к другой.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strncat(char *dest, const char *src,
                             size_t maxlen);
               FAR-ВЕРСИЯ:
               char far *far _fstrncat(char far *dest,
                              const  char far *src, size_t
                                                    maxlen);

Прототип в     string.h

Примечания     strncat копирует не более  maxlen  символов  из
               src  в  конец  dest  и  добавляет  терминальный
               нуль-символ.  Максимальная   длина   полученной
               строки равна strlen(dest) + maxlen.

Значение       strncat возвращает dest.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char destination[25];
                  char *source = " States";
                  strcpy(destination, "United");
                  strncat(destination, source, 7);
                  printf("%s\n", destination);
                  return 0;
               }

     strncmp, _fstrncmp
──────────────────────────────────────────────────────────────
Функция        Сравнивает порцию  одной  строки с порцией дру-
               гой.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               int strncmp(const char *s1, const char *s2,
                           size_t maxlen);
               FAR-ВЕРСИЯ:
               int far _fstrncmp(const char far *s1,
                                 const char far *s2,
                                      size_t maxlen);

Прототип в     string.h

Примечания     strncmp выполняет  то же беззнаковое сравнение,
               что и strcmp,  однако проверяет не более maxlen
               символов. Она начинает с первого символа каждой
               строки и продолжает то же с последующими,  пока
               не  встретятся два соответствующих не совпадаю-
               щих символа, или не будет проверено maxlen сим-
               волов.

Значение       strncmp возвращает  целое  значение,  исходя из
               результата сравнения s1 (или  ее  части)  и  s2
               (или ее части).
               
                  < 0, если s1 меньше s2
                  ==0, если s1 совпадает с s2
                  > 0, если s1 больше s2

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      strcmp, strcoll, stricmp, strncmpi, strnicmp

Пример         #include <string.h>
               #include <stdio.h>

               int  main(void)

               {
                  char *buf1 = "aaabbb", *buf2 = "bbbccc",
                       *buf3 = "ccc";
                  int ptr;
                  ptr = strncmp(buf2,buf1,3);
                  if (ptr > 0)
                     printf("buffer 2 is greater than
                                           buffer 1\n");
                  else
                     printf("buffer 2 is less than
                                        buffer 1\n");
                  ptr = strncmp(buf2,buf3,3);
                  if (ptr > 0)
                     printf("buffer 2 is greater than
                                           buffer 3\n");
                  else
                     printf("buffer 2 is less than
                                        buffer 3\n");
                  return(0);
               }

     strncmpi
──────────────────────────────────────────────────────────────
Функция        Сравнивает порцию одной строки с порцией другой
               без учета регистров.

Синтаксис      #include <string.h>
               int strncmpi(const char *s1, const char *s2,
                            size_t n);

Прототип в     string.h

Примечания     strncmpi выполняет  сравнение  строк  s1 и s2 с
               учетом знаков,  проверяя не более  n  символов.
               Она  начинает с первого символа каждой строки и
               продолжает то же с последующими, пока не встре-
               тятся два соответствующих не совпадающих симво-
               ла,  или не будет проверено n символов. Регистр
               не  принимается во внимание.  (strncmpi есть то
               же самое,  что и strnicmp,  но реализовано  как
               макроопределение).  Функция возвращает значение
               (<0,  0 или >0), исходя из результата сравнения
               s1 (или ее части) и s2 (или ее части).
               Процедуры strnicmp и strncmpi - по сути, одно и
               то же;  strncmpi реализована через макроопреде-
               ление в string.h и преобразует вызов strncmpi в
               вызов strnicmp.  Следовательно, для использова-
               ния    strncmpi,   необходимо   включить   файл
               string.h,  чтобы макроопределение стало доступ-
               ным. Это макроопределение введено для совмести-
               мости с другими компиляторами C.

Значение       strncmpi возвращает целое значение, которое:
                  < 0, если s1 меньше s2
                  ==0, если s1 совпадает с s2
                  > 0, если s1 больше s2

Переносимость  Эта функция доступна только в DOS.

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char *buf1 = "BBBccc", *buf2 = "bbbccc";
                  int ptr;
                  ptr = strncmpi(buf2,buf1,3);
                  if (ptr > 0)
                     printf("buffer 2 is greater than
                                           buffer 1\n");
                  if (ptr < 0)
                     printf("buffer 2 is less than
                                        buffer 1\n");
                  if (ptr == 0)
                     printf("buffer 2 equals buffer 1\n");
                  return 0;
               }

     strncpy, _fstrncpy
──────────────────────────────────────────────────────────────
Функция        Копирует заданное  количество  байтов  из одной
               строки в другую,  усекая или дополняя при необ-
               ходимости.

Синтаксис      #include <stdio.h>
               NEAR-ВЕРСИЯ:
               char *strncpy(char *dest, const char *src,
                             size_t maxlen);
               FAR-ВЕРСИЯ:
               char far *far _fstrncpy(char far *dest,
                              const  char far *src,
                              size_t maxlen);

Прототип в     string.h

Примечания     strncpy копирует не более  maxlen  символов  из
               src в dest,  усекая dest или дополняя нуль-сим-
               волами.  Строка назначения,  dest, может не за-
               канчиваться нуль-символом, если длина src боль-
               ше или равна maxlen.

Значение       strncpy возвращает dest.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char string[10];
                  char *str1 = "abcdefghi";
                  strncpy(string, str1, 3);
                  string[3] = '\0';
                  printf("%s\n", string);
                  return 0;
               }

     strnicmp, _fstrnicmp
──────────────────────────────────────────────────────────────
Функция        Сравнивает порцию одной строки с порцией другой
               без учета регистров.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               int strnicmp(const char *s1, const char *s2,
                            size_t maxlen);
               FAR-ВЕРСИЯ:
               int far _fstrnicmp(const char far *s1,
                        const char far *s2, size_t maxlen);

Прототип в     string.h

Примечания     strnicmp выполняет  сравнение  строк  s1 и s2 с
               учетом знаков,  проверяя не более maxlen симво-
               лов.  Она  начинает  с  первого  символа каждой
               строки и продолжает то же с последующими,  пока
               не  встретятся два соответствующих не совпадаю-
               щих символа, или не будет проверено maxlen сим-
               волов. Регистр не принимается во внимание.
               Функция возвращает  значение  (<0,  0  или >0),
               исходя  из  результата  сравнения  s1  (или  ее
               части) и s2 (или ее части).

Значение       strnicmp возвращает целое значение, которое:
                  < 0, если s1 меньше s2
                  ==0, если s1 совпадает с s2
                  > 0, если s1 больше s2

Переносимость  Эта функция доступна только в DOS.

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char *buf1 = "BBBccc", *buf2 = "bbbccc";
                  int ptr;
                  ptr = strnicmp(buf2, buf1, 3);
                  if (ptr > 0)
                     printf("buffer 2 is greater than
                                           buffer 1\n");
                  if (ptr < 0)
                     printf("buffer 2 is less than
                                        buffer 1\n");
                  if (ptr == 0)
                     printf("buffer 2 equals buffer 1\n");
                  return 0;
               }

     strnset, _fstrnset
──────────────────────────────────────────────────────────────
Функция        Заполняет указанное количество символов  строки
               заданным символом.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strnset(char *s, int ch, size_t n);
               FAR-ВЕРСИЯ:
               char far *far _fstrnset(char far *s,
                                       int ch, size_t n);

Прототип в     string.h

Примечания     strnset помещает символ ch в  первые  n  байтов
               строки s.  Если n > strlen(s), вместо n берется
               значение strlen(s). Функция завершается, если n
               символов  уже  заполнены,  или обнаружен терми-
               нальный нуль-символ.

Значение       strnset возвращает s.

Переносимость  Эта функция доступна только в DOS.

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char *string = "abcdefghijklmnopqrstuvwxyz";
                  char letter = 'x';
                  printf("string before strnset: %s\n",
                                                 string);
                  strnset(string, letter, 13);
                  printf("string after  strnset: %s\n",
                                                 string);
                  return 0;
               }

     strpbrk, _fstrpbrk
──────────────────────────────────────────────────────────────
Функция        Просматривает строку с целью обнаружения перво-
               го вхождения любого символа из  заданного  мно-
               жества.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strpbrk(const char *s1, const char *s2);
               FAR-ВЕРСИЯ:
               char far *far _fstrpbrk(const char far *s1,
                                       const char far *s2);

Прототип в     string.h

Примечания     strpbrk просматривает строку s1, пока не встре-
               тит вхождение любого символа из s2.

Значение       strpbrk возвращает  указатель на первое вхожде-
               ние любого из символов, содержащихся в s2. Если
               ни  один  из  символов  s2  не содержится в s1,
               strpbrk возвращает нуль.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                 char *string1 = "abcdefghijklmnopqrstuvwxyz";
                 char *string2 = "onm";
                 char *ptr;
                 ptr = strpbrk(string1, string2);
                 if (ptr)
                    printf("strpbrk found first character:
                            %c\n", *ptr);
                 else
                    printf("strpbrk didn't find character in "
                           "set\n");
                 return 0;
               }

     strrchr, _fstrrchr
──────────────────────────────────────────────────────────────
Функция        Просматривает строку    с   целью   обнаружения
               последнего вхождения заданного символа.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strrchr(const char *s, int c);
               FAR-ВЕРСИЯ:
               char far *far _fstrrchr(const char far *s,
                                                    int c);

Прототип в     string.h

Примечания     В поисках указанного символа strrchr просматри-
               вает строку в обратном направлении. Эта функция
               отыскивает  ПОСЛЕДНЕЕ  вхождение  символа  c  в
               строку s.  Терминальный  нуль-символ  считается
               частью строки.

Значение       strrchr возвращает указатель на последнее вхож-
               дение символа c.  Если c  не  содержится  в  s,
               возвращается нуль.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      strcspn, strchr

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char string[15];
                  char *ptr, c = 'r';
                  strcpy(string, "This is a string");
                  ptr = strrchr(string, c);
                  if (ptr)
                    printf("The character %c is at position:
                            %d\n", c, ptr - string);
                  else
                    printf("The character was not found\n");
                  return 0;
               }

     strrev, _fstrrev
──────────────────────────────────────────────────────────────
Функция        Реверсирует строку,  т.е., переставляет ее сим-
               волы в обратном порядке.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strrev(char *s);
               FAR-ВЕРСИЯ:
               char far *far _fstrrev(char far *s);

Прототип в     string.h

Примечания     strrev изменяет порядок следования  символов  в
               строке на обратный, за исключением терминально-
               го нуль-символа. (Например, строка string\0 бу-
               дет изменена на gnirts\0.)

Значение       strrev возвращает  указатель на реверсированную
               строку.

Переносимость  Эта функция доступна только в DOS.

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char *forward = "string";
                  printf("Before strrev(): %s\n", forward);
                  strrev(forward);
                  printf("After strrev():  %s\n", forward);
                  return 0;
               }

     strset, _fstrset
──────────────────────────────────────────────────────────────
Функция        Заполняет всю строку заданным символом.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strset(char *s, int ch);
               FAR-ВЕРСИЯ:
               char far *far _fstrset(char far *s, int ch);

Прототип в     string.h

Примечания     strset заполняет всю строку s символом ch.  Она
               завершает  работу  при достижении терминального
               нуль-символа.

Значение       strset возвращает s.

Переносимость  Эта функция доступна только в DOS.

См. также      setmem

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char string[10] = "123456789";
                  char symbol = 'c';
                  printf("Before strset(): %s\n", string);
                  strset(string, symbol);
                  printf("After strset():  %s\n", string);
                  return 0;
               }

     strspn, _fstrspn
──────────────────────────────────────────────────────────────
Функция        Просматривает строку  с  целью  обнаружения на-
               чальной подстроки, содержащей только символы из
               заданного множества.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               size_t strspn(const char *s1, const char *s2);
               FAR-ВЕРСИЯ:
               size_t far _fstrspn(const char far *s1,
                                   const char far *s2);

Прототип в     string.h

Примечания     strspn ищет начальную подстроку строки s1,  це-
               ликом  состоящую  из  символов,  содержащихся в
               строке s2.

Значение       strspn возвращает  длину  начальной   подстроки
               строки s1, состоящей только из символов, содер-
               жащихся в строке s2.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

Пример         #include <stdio.h>
               #include <string.h>
               #include <alloc.h>

               int main(void)
               {
                  char *string1 = "1234567890";
                  char *string2 = "123DC8";
                  int length;
                  length = strspn(string1, string2);
                  printf("Character where strings differ is at
                          position %d\n", length);
                  return 0;
               }

     strstr, _fstrstr
──────────────────────────────────────────────────────────────
Функция        Просматривает строку с целью обнаружения задан-
               ной подстроки.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strstr(const char *s1, const char *s2);
               FAR-ВЕРСИЯ:
               char far *far _fstrstr(const char far *s1,
                                      const char far *s2);

Прототип в     string.h

Примечания     strstr просматривает строку s1 до первого обна-
               ружения вхождения подстроки s2.

Значение       strstr возвращает  указатель  на  первый символ
               первого вхождения s2 в s1.  Если подстроки s2 в
               s1 не содержится, strstr возвращает нуль.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char *str1 = "Borland International",
                       *str2 = "nation", *ptr;
                  ptr = strstr(str1, str2);
                  printf("The substring is: %s\n", ptr);
                  return 0;
               }

     strtod
──────────────────────────────────────────────────────────────
Функция        Преобразует строку в значение типа double .

Синтаксис      #include <stdlib.h>
               double strtod(const char *s, char **endptr);

Прототип в     stdlib.h

Примечания     strtod преобразует символьную строку s в значе-
               ние типа double. s есть последовательность сим-
               волов,  которая может быть интерпретирована как
               значение типа double;  она должна иметь следую-
               щий обобщенный формат:
                  [ws] [sn] [ddd] [.] [ddd] [fmt [sn] ddd]
               где
                  [ws]  = необязательные пробелы
                  [sn]  = необязательный знак (+ или -)
                  [ddd] = необязательные цифры
                  [fmt] = необязательный символ e или E
                  [.]   = необязательная десятичная точка
               strtod также распознает +INF и -INF как плюс- и
               минус-бесконечность и +NAN и -NAN как Не-Число.
               Например,  следующие строки strtod может преоб-
               разовать в double:
                   +1231.1981e-1
                   502.85E2
                   +2010.952
               strtod прекращает работу при обнаружении перво-
               го символа, который не может быть интерпретиро-
               ван  как  соответствующая  часть  значения типа
               double.
               Если endptr не есть нуль,  strtod устанавливает
               указатель *endptr на символ,  вызвавший прекра-
               щение работы strtod (*endptr = &stopper).  Этот
               параметр полезен для обработки ошибок.

Значение       strtod возвращает  значение типа double,  полу-
               ченное из строки s. В случае переполнения возв-
               ращается плюс или минус HUGE_VAL.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      atof

Пример         #include <stdio.h>
               #include <stdlib.h>

               int main(void)
               {
                  char input[80], *endptr;
                  double value;
                  printf("Enter a floating point number:");
                  gets(input);
                  value = strtod(input, &endptr);
                  printf("The string is %s the number
                          is %lf\n", input, value);
                  return 0;
               }

     strtok, _fstrtok
──────────────────────────────────────────────────────────────
Функция        Ищет в строке лексические единицы,  разделяемые
               заданными ограничителями.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strtok(char *s1, const char *s2);
               FAR-ВЕРСИЯ:
               char far *far _fstrtok(char far *s1,
                                      const char far *s2);

Прототип в     string.h

Примечания     strtok предполагает,  что  строка s1 состоит из
               последовательности из  нуля  или  более  лекси-
               ческих единиц, разделенных одним или нескольки-
               ми символами из строки разделителей s2.
               Первое обращение к strtok возвращает  указатель
               на  первый  символ первой лексической единицы в
               s1 и записывает нуль-символ в s1 непосредствен-
               но  за  этой лексической единицей.  Последующие
               обращения с первым аргументом,  установленным в
               нуль, будут продолжать просматривать строку s1,
               пока не  исчерпаются  все  содержащиеся  в  ней
               лексические единицы, .
               Строка разделителей s2  может  различаться  при
               каждом обращении к strtok.

Значение       strtok возвращает указатель на лексическую еди-
               ницу,  обнаруженную  в  s1.  Нулевой  указатель
               возвращается, если таковых больше нет.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char input[16] = "abc,d";
                  char *p;
                  /* strtok помещает нуль-символ  после
                     лексической единицы, если она найдена */
                  p = strtok(input, ",");
                  if (p)   printf("%s\n", p);
                  /* Второй вызов strtok, использующий NULL
                    в качестве первого параметра, возвращает
                    указатель на первый символ следующей
                    лексемы */
                  p = strtok(NULL, ",");
                  if (p)   printf("%s\n", p);
                  return 0;
               }

     strtol
──────────────────────────────────────────────────────────────
Функция        Преобразует строку в значение типа long.

Синтаксис      #include <stdlib.h>
               long strtol(const char *s, char **endptr,
                           int radix);

Прототип в     stdlib.h

Примечания     strtol преобразует символьную строку s в значе-
               ние типа long. s есть последовательность симво-
               лов,  которая  может  быть интерпретирована как
               значение типа long;  она должна иметь следующий
               обобщенный формат:
                  [ws] [sn] [0] [x] [ddd]
               где
                  [ws]  = необязательные пробелы
                  [sn]  = необязательный знак (+ или -)
                  [0]   = необязательный ноль (0)
                  [x]   = необязательный символ x или X
                  [ddd] = необязательные цифры
               strtod прекращает работу при обнаружении перво-
               го символа, который она не может распознать.
               Если radix лежит в диапазоне от 2 до 36,  длин-
               ное  целое  считается  представленным в системе
               счисления по основанию radix.  Если radix  есть
               0, первые несколько символов s определяют осно-
               вание системы счисления, в которой представлено
               преобразуемое                         значение.
               ───────────────────────────────────────────────
                Первый  Второй     Строка интерпретируется как
                символ  символ
               ───────────────────────────────────────────────
                  0       1-7         Восьмеричная
                  0     x или X       Шестнадцатеричная
                 1-9                  Десятичная
               ───────────────────────────────────────────────
               Если radix равен 1,  значение  считается  недо-
               пустимым. Если radix меньше нуля или больше 36,
               эти значения также считаются недопустимыми.
               Любое недопустимое  значение  radix  приводит к
               тому,  что результат выполнения функции полага-
               ется равным нулю, а указатель следующего симво-
               ла *endptr устанавливается на начало строки.
               Если значение s предполагается интерпретировать
               как восьмеричное  число,  любой  символ,  кроме
               цифр от 0 до 7, считается нераспознаваемым.
               Если значение s предполагается интерпретировать
               как десятичное число,  любой символ, кроме цифр
               от 0 до 9, считается нераспознаваемым.
               Если значение s предполагается интерпретировать
               как число по любому другому основанию,  распоз-
               наваемыми будут только цифры и буквы, использу-
               емым для представления чисел по  этому  основа-
               нию. (Например, если radix равен 5, распознава-
               емыми будут только цифры от 0 до 4;  если radix
               равен 20, распознаваемы будут цифры от 0 до 9 и
               буквы от A до J.)
               Если endptr не есть нуль,  strtol устанавливает
               указатель *endptr на символ,  вызвавший прекра-
               щение работы strtol (*endptr = &stopper).

Значение       strtol возвращает   значение    преобразованной
               строки или 0 в случае ошибки.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      atoi, atol, strtoul

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  char *string = "87654321", *endptr;
                  long lnumber;
                  /* strtol преобразует строку в
                     long integer  */
                  lnumber = strtol(string, &endptr, 10);
                  printf("string = %s  long = %ld\n", string,
                         lnumber);
                  return 0;
               }

     strtoul
──────────────────────────────────────────────────────────────
Функция        Преобразует строку  в  значение  типа  unsigned
               long по данному основанию.

Синтаксис      #include <stdlib.h>
               unsigned long strtoul(const char *s,
                                     char **endptr,
                                     int radix);

Прототип в     stdlib.h

Примечания     strtoul работает так же,  как и strtol, за иск-
               лючением того,  что строка  s  преобразуется  в
               значение  типа unsigned long,  в то время,  как
               strtol преобразует в значение типа long.  Даль-
               нейшую информацию см. в strtol.

Значение       strtoul возвращает преобразованное значение ти-
               па unsigned long или 0 в случае ошибки.

Переносимость  Эта функция совместима с ANSI C.

См. также      atol, strtol

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  char *string = "87654321", *endptr;
                  unsigned long lnumber;
                  lnumber = strtoul(string, &endptr, 10);
                  printf("string = %s  long = %lu\n", string,
                         lnumber);
                  return 0;
               }

     strupr, _fstrupr
──────────────────────────────────────────────────────────────
Функция        Преобразует  строчные  буквы в строке в пропис-
               ные.

Синтаксис      #include <string.h>
               NEAR-ВЕРСИЯ:
               char *strupr(char *s);
               FAR-ВЕРСИЯ:
               char far *far _fstrupr(char  4far  0*s);

Прототип в     string.h

Примечания     strupr преобразует строчные буквы (a-z), содер-
               жащиеся в строке s,  в прописные (A-Z). Никакие
               другие символы не изменяются.

Значение       strupr возвращает s.

Переносимость  Эта функция доступна только в DOS.

См. также      strlwr

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                 char *string = "abcdefghijklmnopqrstuvwxyz",
                                                         *ptr;
                 /* преобразует символы строки в прописные */
                 ptr = strupr(string);
                 printf("%s\n", ptr);
                 return 0;
               }

     strxfrm
──────────────────────────────────────────────────────────────
Функция        Пересылает порцию строки.

Синтаксис      #include <string.h>
               size_t strxfrm(char *s1, char *s2, size_t n);

Прототип в     string.h

Примечания     strxfrm пересылает не более n символов из стро-
               ки s2 в строку s1.

Значение       Количество скопированных символов.

Переносимость  Эта функция совместима с ANSI C.

См. также      strcoll, strncpy

Пример         #include <stdio.h>
               #include <string.h>
               #include <alloc.h>

               int main(void)
               {
                  char *target;
                  char *source = "Frank Borland";
                  int length;
                  /* распределяет пространство для строки
                     назначения */
                  target = calloc(80, sizeof(char));
                  /* копирует из исходной строки в строку
                     назначения и получает длину */
                  length = strxfrm(target, source, 80);
                  /* распечатать результаты */
                  printf("%s has the length %d\n", target,
                          length);
                  return 0;
               }

     swab
──────────────────────────────────────────────────────────────
Функция        Пересылает строку с обменом байтов.

Синтаксис      #include <stdlib.h>
               void swab(char *from, char *to, int nbytes);

Прототип в     stdlib.h

Примечания     swab копирует  nbytes  байтов  из строки from в
               строку to.  Смежные четные и нечетные байты ме-
               няются  местами.  Эта  функция  полезна для пе-
               ресылки данных с одной машины на  другую,  если
               они  различаются  порядком  следования  байтов.
               Значение nbytes должно быть четным.

Значение       Нет.

Переносимость  Эта функция доступна в системах UNIX.

Пример         #include <stdlib.h>
               #include <stdio.h>
               #include <string.h>

               char source[15] = "rFna koBlrna d";
               char target[15];

               int main(void)
               {
                  swab(source, target, strlen(source));
                  printf("This is target: %s\n", target);
                  return 0;
               }

     system
──────────────────────────────────────────────────────────────
Функция        Запуск команды DOS.

Синтаксис      #include <stdlib.h>
               int system(const char *command);

Прототип в     stdlib.h, process.h

Примечания     system вызывает  файл  COMMAND.COM системы DOS,
               чтобы выполнить команду DOS, командный файл или
               другую  программу,  имя  которой  содержится  в
               строке command,  из выполняющейся программы  на
               C.
               Чтобы быть  найденной и выполненной,  программа
               должна находиться в текущем справочнике  или  в
               одном из справочников, перечисленных в перемен-
               ной   среды   PATH.   Для   нахождения    файла
               COMMAND.COM   используется   переменная   среды
               COMSPEC,  поэтому не требуется, чтобы этот файл
               находился в текущем справочнике.

Значение       Если command - NULL-указатель, system возвраща-
               ет ненулевое значение, если командный процессор
               доступен.  Если command не есть NULL-указатель,
               system  возвращает 0,  если командный процессор
               успешно запущен.  В случае ошибки  возвращается
               -1,  и errno устанавливается в ENOENT,  ENOMEM,
               E2BIG или ENOEXEC.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie. Эта функция несовместима с Windows.

См. также      exec..., _fpreset, searchpath, spawn...

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  printf("About to spawn command.com and run
                          a DOS command\n");
                  system("dir");
                  return 0;
               }
