     lfind
──────────────────────────────────────────────────────────────
Функция        Осуществляет линейный поиск.

Синтаксис      #include <stdlib.h>
               void *lfind(const void *key, const void *base,
                      size_t *num, size_t width,
                      int(*fcmp)(const void *, const void *));

Прототип в     stdlib.h

Замечание      lfind осуществляет линейный поиск  по  значению
               ключа *key в массиве последовательных  записей.
               Использует  определенную  пользователем функцию
               сравнения (*fcmp).
               Массив описывается,  как  имеющий  *num записей
               длиной width байтов каждая, и размещается в па-
               мяти по адресу base.

Значение       lfind возвращает адрес первой записи в таблице,
               соответствующей ключу поиска. Если такая запись
               не найдена,  возвращается NULL. Функция сравне-
               ния должна возвращать 0, если *elem1 == *elem2,
               и ненулевое значение в других случаях (elem1  и
               elem2 - два параметра этой функции).

Переносимость  Эта функция доступна только в DOS.

См.также       bsearch, lsearch, qsort

Пример         #include <stdio.h>
               #include <stdlib.h>

               int compare(int *x, int *y)
               {
                  return( *x - *y );
               }

               int main(void)
               {
                  int array[5] = {35, 87, 46, 99, 12};
                  size_t nelem = 5;
                  int key;
                  int *result;

                  key = 99;
                  result = lfind(&key, array, &nelem,
                                 sizeof(int), (int(*)
                         (const void *,const void *))compare);
                  if (result)
                     printf("Number %d found\n",key);
                  else
                     printf("Number %d not found\n",key);

                  return 0;
               }

     line
──────────────────────────────────────────────────────────────
Функция        Рисует линию, соединяющую две заданные точки.

Синтаксис      #include <graphics.h>
               void far line(int x1, int y1, int x2, int y2);

Прототип в     graphics.h

Замечание      Используя текущие  цвет,  тип  и толщину линии,
               эта функция рисует линию,  соединяющую две  за-
               данные точки (x1,y1) и (x2,y2),  без обновления
               текущей позиции (СР).

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       getlinesetting, linerel,    lineto,   setcolor,
               setlinestyle, setwritemode

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int xmax, ymax;

                  /*инициализация графики и локальных
                    переменных */
                  initgraph(&gdriver, &gmode, "");

                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  /* обнаружена ошибка */
                  if (errorcode != grOk)
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1);
                  }

                  setcolor(getmaxcolor());
                  xmax = getmaxx();
                  ymax = getmaxy();

                  /* изобразить диагональную линию */
                  line(0, 0, xmax, ymax);

                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     linerel
──────────────────────────────────────────────────────────────
Функция        Рисует линию, заданную смещением из текущей по-
               зиции (СР).

Синтаксис      #include <graphics.h>
               void far linerel(int dx, int dy);

Прототип в     graphics.h

Замечание      linerel проводит линию из текущей позиции  (СР)
               в точку,  смещенную относительно CP на заданный
               вектор (dx,dy). СР перемещается на (dx,dy).

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       getlinesetting, line,     lineto,     setcolor,
               setlinestyle, setwritemode

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  char msg[80];

                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");

                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)
                  {
                     printf("Graphics error: %s\n",
                        grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1);
                  }

                  /* перемещение CP в позицию (20,30) */
                  moveto(20, 30);

             /* создать и вывести сообщение в точке (20,30) */
                  sprintf(msg, " (%d, %d)", getx(), gety());
                  outtextxy(20, 30, msg);

                  /* провести линию в точку, расположенную на
                  заданном расстоянии от текущего указателя */
                  linerel(100, 100);

                  /* создать и вывести сообщение в точке CP */
                  sprintf(msg, " (%d, %d)", getx(), gety());
                  outtext(msg);

                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     lineto
──────────────────────────────────────────────────────────────
Функция        Рисует линию из текущей позиции (СР) в заданную
               точку (x,y).

Синтаксис      #include <graphics.h>
               void far lineto(int x, int y);

Прототип в     graphics.h

Замечание      lineto рисует линию из СР в (x,y),  затем пере-
               мещает СР в (x,y).

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       getlinesetting, line,     linerel,    setcolor,
               setlinestyle, setvisualpage, setwritemode

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  char msg[80];

                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");

                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)
                  {
                     printf("Graphics error: %s\n",
                        grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1);
                  }

                  /* переместить СР в точку (20,30) */
                  moveto(20, 30);

             /* создать и вывести сообщение в точке (20,30) */
                  sprintf(msg, " (%d, %d)", getx(), gety());
                  outtextxy(20, 30, msg);

                  /* провести линию в точку (100, 100) */
                  lineto(100, 100);

                  /* создать и вывести сообщение в точке CP.*/
                  sprintf(msg, " (%d, %d)", getx(), gety());
                  outtext(msg);

                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     localeconv
──────────────────────────────────────────────────────────────
Функция        Возвращает указатель  на   текущую   структуру,
               описывающую местность.

Синтаксис      #include <locale.h>
               struct lconv *localeconv(void);

Прототип в     locale.h

Замечание      Эта функция устанавливает местность (т.е. наци-
               ональные атрибуты данной местности -  обозначе-
               ние валюты,  разделитель тысяч и т.п.).  Однако
               Borland  C++  поддерживает  в  настоящее  время
               только  код местности "C".

Значение       Возвращает указатель   на   текущую  структуру,
               описывающую местность. Подробнее см. locale.h.

Переносимость  Эта функция совместима с ANSI C.

См.также       setlocale

Пример         #include <locale.h>
               #include <stdio.h>

               int main(void)
               {
                  struct lconv ll;
                  struct lconv *conv = &ll;

               /* читать локальную структуру преобразования */
                  conv = localeconv();

               /* вывести структуру на экран */
                 printf("Decimal Point                : %s\n",
                        conv->decimal_point);
                 printf("Thousands Separator          : %s\n",
                        conv->thousands_sep);
                 printf("Grouping                     : %s\n",
                        conv->grouping);
                 printf("International Currency symbol: %s\n",
                        conv->int_curr_symbol);
                 printf("$ thousands separator        : %s\n",
                        conv->mon_thousands_sep);
                 printf("$ grouping                   : %s\n",
                        conv->mon_grouping);
                 printf("Positive sign                : %s\n",
                        conv->positive_sign);
                 printf("Negative sign                : %s\n",
                        conv->negative_sign);
                 printf("International fraction digits: %d\n",
                        conv->int_frac_digits);
                 printf("Fraction digits              : %d\n",
                        conv->frac_digits);
                 printf("Positive $ symbol precedes   : %d\n",
                        conv->p_cs_precedes);
                 printf("Positive sign space separation:%d\n",
                        conv->p_sep_by_space);
                 printf("Negative $ symbol precedes    :%d\n",
                        conv->n_cs_precedes);
                 printf("Negative sign space separation:%d\n",
                        conv->n_sep_by_space);
                 printf("Positive sign position       : %d\n",
                        conv->p_sign_posn);
                 printf("Negative sign position       : %d\n",
                        conv->n_sign_posn);
                 return 0;
               }

     localtime
──────────────────────────────────────────────────────────────
Функция        Преобразует значения даты и времени в структуру

Синтаксис      #include <tume.h>
               struct tm *localtime(const time_t *timer);

Прототип в     time.h

Замечание      localtime принимает адрес значения,  возвращае-
               мого функцией time,  и возвращает указатель  на
               структуру  типа  tm,  содержащую разнесенное по
               отдельным полям значение времени  и  даты.  Она
               корректирует эти значения с учетом часового по-
               яса и, возможно, режима летнего времени.
               Глобальная переменная  timezone   (типа   long)
               должна  быть  установлена в значение разности в
               секундах между временем  по  Гринвичу  (GMT)  и
               местным  временем (для Тихоокеанского Стандарт-
               ного Времени - PST -  значение  timezone  равно
               8x60x60). Глобальной переменной daylight должно
               быть присвоено ненулевое значение ТОЛЬКО в слу-
               чае,  если применяется стандарт США режима лет-
               него времени.
               Структура tm описана в time.h  следующим  обра-
               зом:
                 struct tm {
                    int tm_sec;
                    int tm_min;
                    int tm_hour;
                    int tm_mday;
                    int tm_mon;
                    int tm_year;
                    int tm_wday;
                    int tm_yday;
                    int tm_isdst;
                            };
               Эти величины   определяют  время  в  24-часовом
               исчислении, день месяца (от 1 до 31), месяц (от
               0 до 11), день недели (воскресенью соответству-
               ет 0),  (год - 1900), день года (от 0 до 365) и
               флаг,  который отличен от нуля,  если действует
               режим летнего времени.

Значение       localtime возвращает  указатель  на  структуру,
               содержащую разнесенное по отдельным полям  зна-
               чение  времени  и даты.  Эта структура является
               статическим объектом, т.е. перезаписывается при
               каждом вызове.

Переносимость  Эта функция  доступна  в  системах  UNIX и сов-
               местима с ANSI C.

См.также       asctime, ctime,  ftime,  gmtime,  stime,  time,
               tzset

Пример         #include <time.h>
               #include <stdio.h>
               #include <dos.h>

               int main(void)
               {
                  time_t timer;
                  struct tm *tblock;

                  /* получает время суток */
                  timer = time(NULL);

                  /* переводит дату и время в структуру */
                  tblock = localtime(&timer);

                  printf("Local time is: %s",asctime(tblock));

                  return 0;
               }

     lock
──────────────────────────────────────────────────────────────
Функция        Устанавливает блокировку   файлов   совместного
               использования.

Синтаксис      #include <io.h>
               int lock(int handle, long offset, long length);

Прототип в     io.h

Замечание      lock обеспечивает интерфейс с  механизмом  сов-
               местного  использования  файлов DOS версии 3.x.
               До  использования  lock  должен  быть  загружен
               SHARE.EXE.
               Заблокированы могут быть любые  неперекрывающи-
               еся области любого файла. Программа, пытающаяся
               читать или  записывать  в  заблокированную  об-
               ласть,  будет повторять попытку три раза.  Если
               все три попытки окажутся неудачными,  обращение
               к файлу завершится с ошибкой.

Значение       lock возвращает 0 при успешном завершении, и -1
               в случае ошибки.

Переносимость  Эта функция доступна только в  DOS  3.x.  Более
               ранние версии DOS ее не поддерживают.

См.также       open, sopen, unlock

Пример         #include <io.h>
               #include <fcntl.h>
               #include <sys\stat.h>
               #include <process.h>
               #include <share.h>
               #include <stdio.h>

               int main(void)
               {
                  int handle, status;
                  long length;

                  /* Должна быть загружена утилита DOS
                  SHARE.EXE, для правильного запирания файла*/
                  handle = sopen("c:\\autoexec.bat",
                  O_RDONLY,SH_DENYNO,S_IREAD);

                  if (!handle)
                  {
                     printf("sopen failed\n");
                     exit(1);
                  }

                  length = filelength(handle);
                  status = lock(handle,0L,length/2);

                  if (status == 0)
                     printf("lock succeeded\n");
                  else
                     printf("lock failed\n");

                  status = unlock(handle,0L,length/2);

                  if (status == 0)
                     printf("unlock succeeded\n");
                  else
                     printf("unlock failed\n");

                  close(handle);
                  return 0;
               }

     log
──────────────────────────────────────────────────────────────
Функция        Вычисляет натуральный логарифм числа х.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>       #include <complex.h>
               double log(double x);   complex log(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                  complex.h

Замечание      log вычисляет натуральный логарифм числа х.
               Комплексный натуральный  логарифм  определяется
               как
                  log(z) = log(abs(z)) + i * arg(z)

Значение       При успешном  завершении возвращается результат
               вычисления ln(x).
               Если аргумент х,  переданный log,  является ве-
               щественным  и  меньше 0,  глобальная переменная
               errno устанавливается в значение:
                  EDOM   Ошибка области определения
               log(0) возвращает  отрицательное   HUGE_VAL   и
               устанавливает errno в ERANGE.
               Обработка ошибок  для  этой  функции может быть
               модифицирована посредством функции matherr.

Переносимость  Вещественная версия доступна в системах UNIX  и
               определена  в  ANSI C.  Комплексная версия этой
               функции требует С++ и, вероятно, не переносима.

См.также       complex, exp, log10, sqrt

Пример         #include <math.h>
               #include <stdio.h>

               int main(void)
               {
                  double result;
                  double x = 8.6872;

                  result = log(x);
                  printf("The natural log of %lf is %lf\n", x,
                         result);

                  return 0;
               }

     log10
──────────────────────────────────────────────────────────────
Функция        Вычисляет логарифм числа х по основанию 10.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>       #include <complex.h>
               double                  complex
                  log10 (double x);          log10(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                  complex.h

Замечание      log10 вычисляет логарифм х по основанию 10.
               Общий комплексный логарифм определяется как
                  log10(z) = log10 / log(10)

Значение       При успешном  завершении  log10  возвращает вы-
               численное значение логарифма числа х по основа-
               нию 10.
               Если аргумент х, переданный log10, вещественный
               и  меньше 0,  глобальная переменная errno уста-
               навливатся в значение:
                  EDOM   Ошибка области определения
               log10(0) возвращает  отрицательное  HUGE_VAL  и
               устанавливает errno в ERANGE.
               Обработка ошибок  для  этой  функции может быть
               модифицирована посредством функции matherr.

Переносимость  Вещественная версия доступна в системах UNIX  и
               определена  в  ANSI C.  Комплексная версия этой
               функции требует С++ и, вероятно, не переносима.

См.также       complex, exp, log

Пример         #include <math.h>
               #include <stdio.h>

               int main(void)
               {
                  double result;
                  double x = 800.6872;

                  result = log10(x);
                  printf("The common log of %lf is %lf\n", x,
                         result);

                  return 0;
               }

     longjmp
──────────────────────────────────────────────────────────────
Функция        Выполняет нелокальный переход.

Синтаксис      #include <setjmp.h>
               void longjmp(jmp_buf jmpb, int retval);

Прототип в     setjmp.h

Замечание      Обращение к  longjmp  восстанавливает состояние
               задачи,  которое было  зафиксировано  последним
               вызовом setjmp с аргументом jmpb. Затем longjmp
               возвращает управление в точку  возврата  setjmp
               так,  как  будто  бы setjmp возвращает значение
               retval.
               Состояние задачи включает:
               - все регистры сегментов (CS, DS, ES, SS)
               - регистровые переменные (SI, DI)
               - указатель стека (SP)
               - указатель базы (BP)
               - флаги
               Информация, заключенная   в  состоянии  задачи,
               полностью достаточна для того,  чтобы использо-
               вать setjmp при реализации сопрограмм.
               setjmp должна  быть  вызвана до вызова longjmp.
               Процедура, которая вызывает setjmp и устанавли-
               вает jmpb,  должна оставаться активной и не мо-
               жет быть завершена  прежде,  чем  будет  вызван
               longjmp.  В  противном  случае  результаты неп-
               редсказуемы.
               longjmp не может возвратить значение 0;  если 0
               передан в retval, longjmp заменит его на 1.
         !!!   Нельзя использовать setjmp и longjmp для реали-
               зации  сопрограмм,  если Ваша программа - овер-
               лейная.  В обычной ситуации  setjmp  и  longjmp
               сохраняют и восстанавливают все регистры,  тре-
               буемые для реализации сопрограмм. Однако менед-
               жер  оверлеев  отслеживает  содержимое  стека и
               предполагает, что имеется только один стек. При
               реализации  сопрограмм обычно используются либо
               два стека,  либо две части одного стека,  и ме-
               неджер  оверлеев  не сможет правильно отследить
               их.
               У Вас могут быть фоновые задачи,  работающие со
               своим  собственным стеком или частью стека,  но
               Вы должны быть уверены,  что эти фоновые задачи
               не   будут  активизировать  никакие  оверлейные
               программы, и Вы не должны использовать оверлей-
               ные  версии  setjmp  и longjmp для переключения
               управления на фоновые задачи и обратно.

Значение       Нет.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C. Она не совместима с Windows.

См.также       ctrlbrk, setjmp, signal

Пример         #include <stdio.h>
               #include <setjmp.h>
               #include <stdlib.h>

               void subroutine(jmp_buf);

               int main(void)
               {

                  int value;
                  jmp_buf jumper;

                  value = setjmp(jumper);
                  if (value != 0)
                  {
                     printf("Longjmp with value %d\n", value);
                     exit(value);
                  }
                  printf("About to call subroutine ... \n");
                  subroutine(jumper);

                  return 0;
               }

               void subroutine(jmp_buf jumper)
               {
                  longjmp(jumper,1);
               }

     lowvideo
──────────────────────────────────────────────────────────────
Функция        Устанавливает пониженную яркость символов.

Синтаксис      #include <conio.h>
               void lowvideo(void);

Прототип в     conio.h

Примечания     lowvideo выбирает пониженную  яркость  символов
               путем очистки бита повышенной яркости для теку-
               щего цвета переднего плана.
               Эта функция не влияет на символы, уже находящи-
               еся  на  экране,  она влияет только на символы,
               изображаемые  с  помощью  функций  (таких,  как
               cprintf),  осуществляющих прямой вывод в видео-
               память в текстовом режиме, ПОСЛЕ того, как была
               вызвана функция lowvideo.

Значение       Нет.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Соответствующая функция имеется в
               Turbo Pascal. Она не совместима с Windows.

См.также       highvideo, normvideo, textattr, textcolor

Пример         #include <conio.h>

               int main(void)
               {
                  clrscr();

                  highvideo();
                  cprintf("High Intesity Text\r\n");
                  lowvideo();
                  gotoxy(1,2);
                  cprintf("Low Intensity Text\r\n");

                  return 0;
               }

     _lrotl
──────────────────────────────────────────────────────────────
Функция        Побитовый циклический сдвиг влево значения типа
               unsigned long.

Синтаксис      #include <stdlib.h>
               unsigned long _lrotl(unsigned long val,
                                    int count);

Прототип в     stdlib.h

Примечания     _lrotl циклически сдвигает значение value влево
               на заданное в count количество бит.  Сдвигаемое
               значение должно иметь тип unsigned long.

Значение       _lrotl возвращает результат циклического сдвига
               value влево на count бит.

Переносимость  _lrotl доступна только в DOS.

См.также       _lrotr, _rotl, _rotr

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  unsigned long result;
                  unsigned long value = 100;

                  result = _lrotl(value,1);
             printf("The value %lu rotated left one bit is: "
                         "%lu\n", value, result);

                  return 0;
               }

     _lrotr
──────────────────────────────────────────────────────────────
Функция
               Побитовый циклический сдвиг вправо значения ти-
               па unsigned long.

Синтаксис      #include <stdlib.h>
               unsigned long_lrotr(unsigned long val,
                                   int count);

Прототип в     stdlib.h

Примечания     _lrotr циклически сдвигает значение value впра-
               во на заданное в count количество бит. Сдвигае-
               мое значение должно иметь тип unsigned long.

Значение       _lrotr возвращает результат циклического сдвига
               value вправо на count бит.

Переносимость  _lrotr доступна только в DOS.

См.также       _lrotl, _rotl, _rotr

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  unsigned long result;
                  unsigned long value = 100;

                  result = _lrotr(value,1);
              printf("The value %lu rotated right one bit is:"
                         "%lu\n", value, result);

                  return 0;
               }

     lsearch
──────────────────────────────────────────────────────────────
Функция        Осуществляет линейный поиск.

Синтаксис      #include <stdlib.h>
               void *lsearch(const void *key, void *base,
                     size_t *num, size_t width,
                     int (*fcmp)(const void *, const void *));

Прототип в     stdlib.h

Замечание      lsearch осуществляет  поиск информации в табли-
               це.  Так как поиск линейный,  то нет  необходи-
               мости  сортировать записи таблицы перед вызовом
               lsearch. Если записи, на которую указывает key,
               нет  в таблице,  lsearch добавляет эту запись в
               таблицу.
                  base  - указатель на  начало  (0-й  элемент)
                          таблицы поиска.
                  num   - указатель на целое число, содержащее
                          количество записей в таблице.
                  width - содержит длину записей в байтах
                  key   - указывает на запись,  которую требу-
                          ется найти (ключ поиска).
               Аргумент fcmp - указатель на написанную пользо-
               вателем функцию  сравнения,  которая сравнивает
               две записи и возвращает результат сравнения.
               Во время поиска в таблице,  lsearch делает пов-
               торные обращения к функции,  адрес которой ука-
               зан в fcmp.
               При каждом вызове функции сравнения lsearch пе-
               редает  два  аргумента:  key - указатель на за-
               пись,  которую нужно найти,  и elem - указатель
               на элемент таблицы, который сравнивается.
               fcmp свободна  в  интерпретации  ключа поиска и
               записей таблицы.

Значение       lsearch возвращает адрес первой записи таблицы,
               соответствующей ключу поиска.
               Если ключ поиска не идентичен *elem, fcmp долж-
               на  возвращать целое число,  не равное 0.  Если
               ключ поиска идентичен *elem,  fcmp должна возв-
               ращать 0.

Переносимость  Эта функция доступна в системах UNIX.

См.также       bsearch, lfind, qsort

Пример         #include <stdio.h>
               #include <stdlib.h>
               #include <string.h>  /* для объявления strcmp*/

               /* установление количества цветов */
               char *colors[10] = {"Red", "Blue", "Green"};
               int ncolor = 3;
               int colorscmp(char **arg1, char **arg2)
               {
                  return( strcmp(*arg1,*arg2));
               }

               int addelem(char *key)
               {
                  int oldn = ncolors;
                  lsearch(key, colors, (size_t *) @ncolors,
                          sizeof(char *), clolorscmp);
                  return(ncolors == oldn);
               }
               int main(void)
               {
                  int i;
                  char *key = "Purple";
                  if (addelem(key))
                  printf(" %s already in colors table\n",key);
                  else
                  {
                    strcpy(colors[ncolors-1],key);
                    printf(" %s added to colors table\n",key);
                  }
                  printf("The colors:\n");
                  for (i=0, i < ncolors, i++)
                     printf(" %s \n",colors[i]);
                  return 0;
               }

                  Результат программы:

                  "Purple" добавлена в таблицу,
                  теперь 4 цвета

     lseek
──────────────────────────────────────────────────────────────
Функция        Перемещает указатель файла.

Синтаксис      #include <io.h>
               long lseek(int handle, long offset,
                          int fromwhere);

Прототип в     io.h

Замечание      lseek устанавливает указатель файла, связанного
               с обработчиком handle,  на новую позицию,  сме-
               щенную на offset байтов от позиции,  заданной в
               fromwhere.  Для  установки  fromwhere   полезно
               использовать   одну   из   трех   символических
               констант (определенных в io.h) вместо явно ука-
               занного  числа.  Эти  константы  представлены в
               таблице:
               ───────────────────────────────────────────────
                fromwhere        Позиция в файле
               ───────────────────────────────────────────────
                SEEK_SET   (0)   Начало файла
                SEEK_CUR   (1)   Текущая позиция в файле
                SEEK_END   (2)   Конец файла
               ───────────────────────────────────────────────

Значение       lseek возвращает  смещение в байтах новой пози-
               ции указателя от начала файла.  В случае ошибки
               lseek  возвращает -1L,  и глобальная переменная
               errno устанавливается в одно из следующих  зна-
               чений:
                 EBADF    Неверный номер (обработчика) файла
                 EINVAL   Неверный аргумент
               На устройствах,  не предназначеннных для поиска
               (таких, как терминалы и принтеры), возвращаемое
               значение не определено.

Переносимость  Эта функция доступна во всех системах UNIX.

См.также       filelength, fseek,  ftell,  getc,  open, sopen,
               ungetc, _write, write

Пример         #include <sys\stat.h>
               #include <string.h>
               #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
                  int handle;
                  char msg[] = "This is a test";
                  char ch;

                  /* создать файл */
                  handle = open("TEST.$$$", O_CREAT | O_RDWR,
                                S_IREAD | S_IWRITE);

                  /* записать некоторые данные в файл */
                  write(handle, msg, strlen(msg));

                  /* поместить указатель на начало файла */
                  lseek(handle, 0L, SEEK_SET);

               /* считать символы из файла, пока не достигнут
                  EOF */
               do {
                     read(handle, &ch, 1);
                     printf("%c", ch);
                  }  while (!eof(handle));

                  close(handle);
                  return 0;
               }

     ltoa
──────────────────────────────────────────────────────────────
Функция        Преобразует целое типа long в строку.

Синтаксис      #include <stdlib.h>
               char *ltoa(long value, char *string,
                          int radix);

Прототип в     stdlib.h

Замечание      ltoa преобразует value  в  строку,  завершаемую
               нуль-символом,   и   записывает   результат   в
               *string. value - целое типа long.
               radix определяет  основание  системы  счисления
               для преобразования value; значение radix должно
               быть в диапазоне от 2 до 36 включительно.  Если
               value отрицательно и radix = 10, то первым сим-
               волом строки будет знак минус (-).
               Область, зарезервированная для  string,  должна
               быть достаточно большой, чтобы разместить полу-
               ченную  строку,  включая  символ  конца  строки
               (\0). ltoa может возвращать до 33-х байтов.

Значение       ltoa возвращает указатель на *string.

Переносимость  Эта функция доступна только в DOS.

См.также       itoa, ultoa

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  char string[25];
                  long value = 123456789L;

                  ltoa(value,string,10);
                  printf("number = %ld string = %s\n", value,
                         string);

                  return 0;
               }

     malloc
──────────────────────────────────────────────────────────────
Функция        Распределяет основную память.

Синтаксис      #include <stdlib.h> или #include <alloc.h>
               void *malloc(size_t size);

Прототип в     alloc.h,stdlib.h

Замечание      malloc распределяет в куче блок памяти размером
               size байт.  Функция позволяет программе распре-
               делять  память  в  таком порядке и в таких объ-
               емах, как это ей необходимо.
               Куча используется для динамического распределе-
               ния  блоков  памяти  переменной  длины.  Многие
               структуры данных,  например,  деревья и списки,
               обычно используют память из кучи.
               Все пространство между концом сегмента данных и
               началом программного стека доступно для исполь-
               зования в малых моделях памяти,  за исключением
               небольшого пространства перед  вершиной  стека.
               Это  пространство предназначено для возможности
               расширения стека,  а также небольшое количество
               памяти требуется для DOS.
               В больших моделях памяти все пространство между
               програмным стеком  и  концом  имеющейся  памяти
               доступно для кучи.

Значение       При успешном завершении malloc возвращает  ука-
               затель  на  вновь  распределенный  блок памяти.
               Если для нового блока недостаточно места, возв-
               ращается  NULL.  Содержимое  блока остается без
               изменений.  Если аргумент  size  ==  0,  malloc
               возвращает NULL.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См.также       allocmem,    calloc,    coreleft,    farcalloc,
               farmalloc, free, realloc

Пример         #include <stdio.h>
               #include <string.h>
               #include <alloc.h>
               #include <process.h>

               int main(void)
               {
                  char *str;

                  /* выделение памяти для строки */
                  if ((str = malloc(10)) == NULL)
                  {
                     printf("Not enough memory to allocate "
                            "buffer\n");
                     exit(1);
             /* завершение прогаммы, если не хватает памяти */
                  }

                  /* поместить "Hello" в строку */
                  strcpy(str, "Hello");

                  /* вывод строки на экран */
                  printf("String is %s\n", str);

                  /* освобождение памяти */
                  free(str);

                  return 0;
               }

     matherr
──────────────────────────────────────────────────────────────
Функция        Модифицируемый пользователем обработчик матема-
               тических ошибок.

Синтаксис      #include <math.h>
               int matherr(struct exception *e);

Прототип в     math.h

Замечание      matherr вызывается,  когда  ошибки генерируются
               математической библиотекой.
               matherr работает как точка пользователя  (функ-
               ция, которая может быть указана пользователем),
               которую вы можете заменить собственной програм-
               мой  обработки  математических  ошибок - смотри
               ниже пример  реализации  matherr,  определенной
               пользователем.
               matherr полезна  для обнаружения ошибок области
               определения и  диапазона,  вызванных  математи-
               ческими  функциями.  Она не обнаруживает ошибок
               плавающей точки, таких, как деление на ноль. По
               вопросу поиска таких ошибок см. signal.
               Вы можете определить собственную версию функции
               matherr  в  качестве  стандартного  обработчика
               ошибок (например, функция, которая обнаруживает
               и исправляет  определенные  типы  ошибок);  эта
               функция заменит версию, встроенную в библиотеку
               C.  Модифицированная  функция  matherr   должна
               возвращать 0, если она не может исправить ошиб-
               ку,  и не ноль,  если ошибка исправлена.  Когда
               matherr возвращает ненулевое значение,  сообще-
               ние об ошибках не выводится, и глобальная пере-
               менная errno не изменяется.
               Ниже приведена  структура типа exception (опре-
               деленная в math.h) :
                  struct exception {
                     int    type;
                     char   *Function;
                     double arg1, arg2, retval;
                  };
               Элементы этой структуры показаны в таблице:
               ───────────────────────────────────────────────
               Элемент      Что представляет или означает
               ───────────────────────────────────────────────
                type        Тип обнаруженной    математической
                            ошибки;  перечислимый тип, опреде-
                            ленный в typedef _mexcep (см.опре-
                            деление ниже).
                name        Указатель на  строку,  завершаемую
                            нуль-символом,    содержащую   имя
                            функции математической библиотеки,
                            которая завершилась ошибкой.
                arg1,       Аргументы (переданные в эту  функ-
                arg2        цию), которые вызвали ошибку; если
                            передан только один  аргумент,  он
                            хранится в arg1.
                retval      Стандартное значение, возвращаемое
                            matherr;  вы  можете  изменить это
                            значение.
               ───────────────────────────────────────────────
               typedef _mexcep,  также определенный в  math.h,
               перечисляет  следующие символичкские константы,
               представляющие возможные математические ошибки:
               ───────────────────────────────────────────────
                Символич.            Математическая
                константа                ошибка
               ───────────────────────────────────────────────
                DOMAIN       Аргумент не  принадлежит  области
                             определения    функции,     напр.
                             log(-1).
                SING         Аргумент приводит   к  необычному
                             результату, напр. pow(0,-2).
                OVERFLOW     Результат функции   больше,   чем
                             MAXDOUBLE, напр. exp(1000).
                UNDERFLOW    Результат функции   меньше,   чем
                             MINDOUBLE, напр. exp(-1000).
                TLOSS        Полная потеря   значащих    цифр,
                             напр. sin(10e70).
               ───────────────────────────────────────────────
               Символические константы  MAXDOUBLE  и MINDOUBLE
               определены в values.h.
               Исходный код стандартной функции matherr  нахо-
               дится на дистрибутивных дисках Borland C++.
               Стандартное поведение    UNIX-версии    функции
               matherr (печать сообщения и завершение  работы)
               не совместимо с ANSI.  Если вы хотите использо-
               вать UNIX-версию функции  matherr,  используйте
               MATHERR.С, находящуюся на дистрибутивных дисках
               Borland C++.

Значение       Стандартное возвращаемое  значение  matherr  1,
               если ошибка UNDERFLOW или TLOSS, и 0 - в других
               случаях. matherr может также модифицировать по-
               ле е -> retval, которое возвращает в вызывающую
               программу.
               Когда matherr  возвращает 0 (показывая,  что не
               может исправить ошибку),  глобальная переменная
               errno устанавливается в значение 0 и печатается
               сообщение об ошибке.
               Когда matherr  возвращает  ненулевое   значение
               (показывая,  что ошибка исправлена), глобальная
               переменная errno не устанавливается и сообщение
               об ошибке не печатается.

Переносимость  matherr доступна для многих компиляторов  языка
               C,   однако   она   несовместима   с   ANSI  C.
               UNIX-версия matherr, которая печатает сообщения
               и  завершает работу,  имеется в файле MATHERR.C
               на дистрибутивных дисках Borland  C++.  matherr
               может  не  поддерживаться  в  следующих версиях
               Borland C++.

Пример         #include <math.h>
               #include <string.h>
               #include <stdio.h>

               int matherr(struct exception *a)
               {
                 if (a -> type == DOMAIN)
                 {
                   if (!strcmp(a -> name,"sqrt"))
                   {
                      a -> retval = sqrt(-(a -> arg1));
                      return 1;
                   }
                 }
                 return 0;
               }
               int main(void)
               {
                  double x, y;
                  x = -2.0;
                  y = sqrt(x);
                  printf("Matherr corrected value: %if\n",y);
                  return 0;
               }
     max
──────────────────────────────────────────────────────────────
Функция        Возвращает большее из двух чисел.

Синтаксис      #include <stdlib.h>
               (type) max(a,b);

Прототип в     stdlib.h

Замечание      Этот макрос  сравнивает  два числа и возвращает
               большее из них.  Оба аргумента и функция должны
               быть одного типа.

Значение       max возвращает большее из двух чисел.

Переносимость  Эта функция доступна только в DOS.

См.также       min

Пример         #include <stdio.h>
               #include <stdlib.h>

               int main(void)
               {
                 int x = 5;
                 int y = 6;
                 int z;

                 z = max(x,y);
                 printf("The larger number is %d\n",z);
                 return 0;
               }
                 Результат программы:

                 Наибольшее число 6

     memccpy, _fmemcpy
──────────────────────────────────────────────────────────────
Функция        Копирует блок из n байтов.

Синтаксис      #include <mem.h>
               NEAR-ВЕРСИЯ:
               void *memccpy(void *dest, const void *src,
                             int c, size_t n);
               FAR-ВЕРСИЯ:
               void far *far _memccpy(void  far  *dest,  const
                              void far *src, int c, size_t n);

Прототип в     string.h, mem.h

Замечание      memccpy копирует блок размером n байтов из *src
               в  *dest.  Копирование  завершается  в любом из
               следующих случаев:
               - символ с впервые скопиро-
               ванным в dest
               - n байтов уже скопированы в dest

Значение       memccpy возвращает указатель на байт  в  *dest,
               непосредственно следующий за символом с, если с
               был скопирован;  в остальных случаях  возвраща-
               ется NULL.

Переносимость  memccpy доступна в системах UNIX System V.

См.также       memcpy, memmove, memset

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char *src = "This is the source string";
                  char dest[50];
                  char *ptr;

                  ptr = memccpy(dest, src, 'c', strlen(src));

                  if (ptr)
                  {
                    *ptr = '\0';
              printf("The character was found:  %s\n", dest);
                  }
                  else
                    printf("The character wasn't found\n");
                  return 0;
               }

      memchr,_fmemchr
──────────────────────────────────────────────────────────────
Функция        Ищет символ с в n байтах.

Синтаксис      #include <mem.h>
               NEAR-ВЕРСИЯ:
               void *memchr(const void *s, int c, size_t n);
               FAR-ВЕРСИЯ:
               void far*far_fmemchr(const void far*s,
               int c, size_t n);

Прототип в     string.h, mem.h

Замечание      memchr ищет символ с в первых n  байтах  блока,
               на который указывает s.

Значение
               В случае успеха, memchr возвращает указатель на
               первый обнаруженный символ (с)  в  s,  иначе  -
               ноль.

Переносимость  memchr   доступна  на  UNIX  и
               совместима с ANSI C.

Пример         #include <string.h>
               #include <stdio.h>

               int main(void)
               {
                  char str[17];
                  char *ptr;

                  strcpy(str, "This is a string");
                  ptr = memchr(str, 'r', strlen(str));
                  if (ptr)
                    printf("The character 'r' is at position:"
                            "%d\n", ptr - str);
                  else
                     printf("The character was not found\n");
                  return 0;
               }


     memcmp,_fmemcmp
──────────────────────────────────────────────────────────────
Функция        Сравнивает два блока длинной ровно в n байт.

Синтаксис      #include <mem.h>
               NEAR-ВЕРСИЯ:
               int memcmp(const void *s1, const void *s2,
               size_t n);
               FAR-ВЕРСИЯ:
               int far_fmemcmp(const  void far*s1,  const void
               far*s2,size_t n);

Прототип в     string.h, mem.h

Замечание      memcmp сравнивает первые n байтов из блоков  s1
               и s2 как unsigned char.

Значение       Поскольку байты   сравниваются   как   unsigned
               char,то memcmp возвращает значение :
                  < 0   если s1 меньше s2
                  = 0   если s1 равен s2
                  > 0   если s1 больше s2
               Например,
                  memcmp("\xFF", "\x7F", 1)
               возвращает значение больше чем 0.

Переносимость  memcmp доступна на UNIX системах и совместима с
               ANSI C.

См.также        memicmp

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char *buf1 = "aaa";
                  char *buf2 = "bbb";
                  char *buf3 = "ccc";

                  int stat;

              stat = memcmp(buf2, buf1, strlen(buf2));
              if (stat > 0)
                printf("buffer 2 is greater than buffer 1\n");
              else
                 printf("buffer 2 is less than buffer 1\n");

              stat = memcmp(buf2, buf3, strlen(buf2));
              if (stat > 0)
                printf("buffer 2 is greater than buffer 3\n");
              else
                 printf("buffer 2 is less than buffer 3\n");

                  return 0;
               }


     memcpy,_fmemcpy
──────────────────────────────────────────────────────────────
Функция        Копирует блок из n байтов.

Синтаксис      #include <mem.h>
               NEAR-ВЕРСИЯ:
               void *memcpy(void *dest, const void *src,
               size_t n);
               FAR-ВЕРСИЯ:
               void far*far_fmemcpy(void far*dest,  const void
               far*src, size_t n);

Прототип в     string.h, mem.h

Замечание      memcmp копирует блок из n байтов из src в dest.
               Если src и dest перекрываются, поведение memcpy
               неопределено.

Значение       memcpy возвращает dest.

Переносимость  memcpy доступна на UNIX системах и совместима с
               ANSI C.

См.также       memccpy, memmove, memset, movedata, movmem

Пример         #include <stdio.h>
               #include <string.h>

          int main(void)
          {
             char src[] = "******************************";
             char dest[] = "abcdfghijlmnpqstvwxyz0123456709";
             char *ptr;

             printf("destination before memcpy: %s\n", dest);
             ptr = memcpy(dest, src, strlen(src));
             if (ptr)
                printf("destination after memcpy:  %s\n",
                       dest);
             else
                printf("memcpy failed\n");
             return 0;
          }


     memicmp,_fmemicmp
──────────────────────────────────────────────────────────────
Функция        Сравнивает n байтов в двух символьных массивах,
               игнорируя регистр.

Синтаксис      #include <mem.h>
               NEAR-ВЕРСИЯ:
               int memicmp(const void *s1, const void *s2,
               size_t n);
               FAR-ВЕРСИЯ:
               int far_fmemicmp(const void far*s1,  const void
               far*s2,size_t n);

Прототип в     string.h, mem.h

Замечание      memicmp сравнивает первые n байтов блоков s1  и
               s2, игнорируя символ регистра (верхний или ниж-
               ний).

Значение       memicmp возвращает значение :
                < 0   если s1 меньше s2
                = 0   если s1 равен s2
                > 0   если s1 больше s2

Переносимость  memicmp доступна на UNIX  системах.

См.также       memcmp

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char *buf1 = "ABCDE123";
                  char *buf2 = "abcde456";
                  int stat;

                  stat = memicmp(buf1, buf2, 5);
                  printf("The strings to position 5 are ");
                  if (stat)
                     printf("not ");
                  printf("the same\n");

                  return 0;
               }


     memmove
──────────────────────────────────────────────────────────────
Функция        Копирует блок из n байтов.

Синтаксис      #include <mem.h>
               void *memmove(void *dest, const void *src,
               size_t n);

Прототип в     string.h, mem.h

Замечание      memmove копирует блок размером в  n  байтов  из
               src в dest. Даже если исходный блок и блок наз-
               начения перекрываются,  байты в перекрывающихся
               областях будут скопированы правильно.

Значение       memmove возвращает dest.

Переносимость  memmove доступна  на UNIX системах и совместима
               с ANSI C.

См.также       memccpy, memcpy, movmem

Пример         #include <stdio.h>
               #include <string.h>

               int main(void)
               {
              char *dest = "abcdfghijlmnpqstvwxyz0123456709";
              char *src = "******************************";

           printf("destination prior to memmove: %s\n", dest);
           memmove(dest, src, 26);
           printf("destination after memmove:  %s\n",dest);
           return 0;
               }


     memset,_fmemset
──────────────────────────────────────────────────────────────
Функция        Заполняет n байтов в блоке памяти указанным в с
               символом.

Синтаксис      #include <mem.h>
               NEAR-ВЕРСИЯ:
               void *memset(void *s, int c, size_t n);
               FAR-ВЕРСИЯ:
               void far*far_fmemset(void far*s, int c,
               size_t n);

Прототип в     string.h, mem.h

Замечание      memset выделяет первые n байтов в массиве s для
               символа с.

Значение       memset возвращает s.

Переносимость  memset доступна на UNIX системах и совместима с
               ANSI C.

См.также       memccpy, memcpy, setmem

Пример         #include <string.h>
               #include <stdio.h>
               #include <mem.h>

               int main(void)
               {
                 char buffer[] = "Hello world\n";

                 printf("Buffer before memset: %s\n", buffer);
                 memset(buffer, '*', strlen(buffer) - 1);
                 printf("Buffer after memset:  %s\n", buffer);
                 return 0;
               }


     min
──────────────────────────────────────────────────────────────
Функция        Возвращает меньшее из двух чисел.

Синтаксис      #include <stdlib.h>
               (type) min(a,b);

Прототип в     stdlib.h

Замечание
               min сравнивает  два числа и возвращает меньшее.
               Оба аргумента и функция должны быть одного  ти-
               па.

Значение       min возвращает меньшее из двух чисел.

Переносимость  min уникальна в DOS.

См.также       max

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main()
               {
                 int x = 5;
                 int y = 6;
                 printf("The smaller number is %d\n",min(x,y));
                 return 0;
               }
                 Результат программы:

                 Наименьшее число 5


     mkdir
──────────────────────────────────────────────────────────────
Функция        Создает справочник.

Синтаксис      #include <dir.h>
               int mkdir(const char *path);

Прототип в     dir.h

Замечание      mkdir создает новый справочник на заданном пути
               path

Значение       mkdir возвращает  значение 0,  если новый спра-
               вочник создан.

               Возврат значения -1 означает ошибку, и глобаль-
               ной переменной errno присваивается одно из сле-
               дующих значений :
                  EACCES  Нарушение прав доступа
                  ENOENT  Нет такого файла или справочника

См.также       chdir, getcurdir, getcwd, rmdir

Пример         #include <stdio.h>
               #include <conio.h>
               #include <process.h>
               #include <dir.h>

               int main(void)
               {
                 int status;

                  clrscr();
                  status = mkdir("asdfjklm");
                  (!status) ? (printf("Directory created\n")) :
                      (printf("Unable to create directory\n"));

                  getch();
                  system("dir");
                  getch();

                  status = rmdir("asdfjklm");
                  (!status) ? (printf("Directory deleted\n")):
                       (perror("Unable to delete directory"));

                  return 0;
               }


     MK_FP
──────────────────────────────────────────────────────────────
Функция        Формирует дальний указатель.

Синтаксис      #include <dos.h>
               void far *MK_FP(unsigned seg, unsigned ofs);

Прототип в     dos.h

Замечание
               MK_FP - макрос,  который формирует дальний ука-
               затель из компонент сегмента (seg)  и  смещения
               (ofs).

Значение       MK_FP возвращает дальний указатель.

Переносимость  MK_FP уникальна в Borland C++.

См.также       FP_OFF, FP_SEG, movedata, segread

Пример         #include <dos.h>
               #include <graphics.h>

               int main(void)
               {
                  int gd, gm, i;
                  unsigned int far *screen;

                  detectgraph(&gd, &gm);
                  if (gd == HERCMONO)
                      screen = MK_FP(0xB000, 0);
                  else
                      screen = MK_FP(0xB800, 0);
                  for (i=0; i<26; i++)
                     screen[i] = 0x0700 + ('a' + i);
                  return 0;
               }


     mktemp
──────────────────────────────────────────────────────────────
Функция        Создает уникальное имя файла.

Синтаксис      #include <dir.h>
               char *mktemp(char *template);

Прототип в     dir.h

Замечание      mktemp заменяет строку, указанную в template на
               уникальное имя файла и возвращает template.

               template должна  быть строкой,  заканчивающейся
               (\0) с шестью помеченными полями Xs. Эти Xs за-
               меняются  на уникальную последовательность букв
               и точки,  так,  что в новом имени файла сначала
               будут две буквы, затем точка и три заключитель-
               ные буквы.

               Начиная с АА.ААА, новое имя файла будет ассоци-
               ировано с именем на диске, а ранее существовав-
               шие имена с таким же форматом будут  анулирова-
               ны.

Значение
               Если template  правильно  сформирована,  mktemp
               возвращает адрес template строки.  Иначе mktemp
               возвращает ноль.

Переносимость  mktemp доступна в UNIX системах.

Пример         #include <dir.h>
               #include <stdio.h>

               int main(void)
               {
                  /* fname определяет template для временного
                    файла. */

                  char *fname = "TXXXXXX", *ptr;

                  ptr = mktemp(fname);
                  printf("%s\n",ptr);
                  return 0;
               }


     mktime
──────────────────────────────────────────────────────────────
Функция        Преобразует время в календарный формат.

Синтаксис      #include <time.h>
               time_t mktime(stuct tm *t);

Прототип в     time.h

Замечание      Преобразует время в структуре, указанной в t, в
               календарное время такого формата, какой исполь-
               зует функция time.  Первоначальные значения по-
               лей tm_sec,  tm_min,tm_hour,tm_mday и tm_mon не
               ограничиваются порядком,  описанным в tm струк-
               туре.  Если поля находятся не на  своем  месте,
               они  упорядочиваются.  Значение полей tm_wday и
               tm_yday определяются после того, как упорядоче-
               ны другие.

Значение       Смотрите Замечание.

Переносимость  mktime совместима с ANSI C.

См.также       localtime,strftime,time

Пример         #include <stdio.h>
               #include <time.h>

               char *wday[] = {"Sunday", "Monday", "Tuesday",
                            "Wednesday", "Thursday", "Friday",
                            "Saturday", "Unknown"};

               int main(void)
               {
                  struct tm time_check;
                  int year, month, day;

               /*  Ввести год, месяц и день для определения
                   дня недели */
                  printf("Year:  ");
                  scanf("%d", &year);
                  printf("Month: ");
                  scanf("%d", &month);
                  printf("Day:   ");
                  scanf("%d", &day);

               /*  загрузить time_check структуру с данными */
                  time_check.tm_year = year - 1900;
                  time_check.tm_mon  = month - 1;
                  time_check.tm_mday = day;
                  time_check.tm_hour = 0;
                  time_check.tm_min  = 0;
                  time_check.tm_sec  = 1;
                  time_check.tm_isdst = -1;

              /* вызвать mktime для заполнения поля дня недели
                   в структуре */
                  if (mktime(&time_check) == -1)
                     time_check.tm_wday = 7;

               /*  напечатать день недели */
                  printf("That day is a %s\n",
                         wday[time_check.tm_wday]);
                  return 0;
               }


     modf
──────────────────────────────────────────────────────────────
Функция        Разделяет double на целую и дробную части.

Синтаксис      #include <math.h>
               double modf(double x, double *ipart);

Прототип в     math.h

Замечание
               modf разделяет x на две части:  целое и  дробь.
               Целая часть сохраняется в ipart,  а дробь возв-
               ращается .

Значение       modf возвращает дробную часть х.

Переносимость  modf уникальна в DOS.

См.также       fmod, ldexp

Пример         #include <math.h>
               #include <stdio.h>

               int main(void)
               {
                  double fraction, integer;
                  double number = 100000.567;

                  fraction = modf(number, &integer);
                  printf("The whole and fractional parts "
                         "of %lf are %lf and %lf\n",
                         number, integer, fraction);
                  return 0;
               }


     movedata
──────────────────────────────────────────────────────────────
Функция        Копирует n байтов.

Синтаксис      #include <mem.h>
               void movedata(unsigned srcseg, unsigned srcoff,
                             unsigned dstseg,unsigned dstoff,
                             size_t n);

Прототип в     mem.h, string.h

Замечание      movedata копирует n байтов из исходного  адреса
               (srcseg:srcoff)      в      указанный     адрес
               (dstseg:dstoff).

               movedata -  средство перемещения блоков данных,
               которые не зависят от модели памяти.

Значение       Нет.

Переносимость  movedata уникальна в DOS.

См.также       FP_OFF, memcpy, MK_FP, movmem, segread

Пример         #include <mem.h>

               #define MONO_BASE 0xB000

               /* сохранить содержимое монохромного экрана в
                  буфере */
               void save_mono_screen(char near *buffer)
               {
                  movedata(MONO_BASE, 0, _DS, (unsigned)buffer,
                           80*25*2);
               }

               int main(void)
               {
                  char buf[80*25*2];
                  save_mono_screen(buf);
               }


     moverel
──────────────────────────────────────────────────────────────
Функция        Перемещает текущую позицию курсора (СР) на  от-
               носительное расстояние.

Синтаксис      #include <graphics.h>
               void far moverel(int dx, int dy);

Прототип в     graphics.h

Замечание
               moverel перемещает  текущий  указатель  на   dx
               пикселов  относительно  х  - координаты и на dy
               пикселов относительно y - координаты.

Значение       Нет.

Переносимость
               Эта функция уникальна в Turbo C++. Она работает
               только на IBM PC и совместимых с ней,  оснащен-
               ных адаптерами графических устройств.

См.также       moveto

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  char msg[80];

                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");

                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) /*обнаружена ошибка*/
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }

                  /* поместить CP в точку (20, 30) */
                  moveto(20, 30);

                  /* изобразить пиксел */
                  putpixel(getx(), gety(), getmaxcolor());

                  /* вывести сообщение в точке (20, 30) */
                  sprintf(msg, " (%d, %d)", getx(), gety());
                  outtextxy(20, 30, msg);

                 /*переместить указатель в точку,находящуюся*/
                 /* на расстоянии от текущего значения CP */
                  moverel(100, 100);

                  /* изобразить пиксел в этой точке */
                  putpixel(getx(), gety(), getmaxcolor());

                  /* вывести сообщение в этой точке */
                  sprintf(msg, " (%d, %d)", getx(), gety());
                  outtext(msg);

                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }


     movetext
──────────────────────────────────────────────────────────────
Функция        Копирует текст на экране из одного окна в  дру-
               гое.

Синтаксис      #include <conio.h>
               int movetext(int left, int right, int bottom,
                            int destleft, int desttop);

Прототип в     conio.h

Замечание      movetext копирует содержимое окна определенного
               left,top,right и bottom в  новое  окно  тех  же
               размеров.  destleft  и desttop - позиция левого
               верхнего угла нового окна.

               Все координаты  - это абсолютные экранные коор-
               динаты.  Если прямоугольные области  перекрыва-
               ются, копирование будет происходить корректно.

               movetext - текстовая функция выполняющая прямой
               визуальный вывод.

Значение       movetext возвращает   не  ноль,  если  операция
               успешна. Если неудача ( например, если заданные
               координаты  выходят  за пределы текущего режима
               экрана), movetext возвращает 0.

Переносимость
               Она работает только на IBM PC и  совместимых  с
               ней. Не совместима с Windows.

См.также       gettext, puttext

Пример         #include <conio.h>
               #include <string.h>

               int main(void)
               {
                  char *str = "This is a test string";

                  clrscr();
                  cputs(str);
                  getch();

                  movetext(1, 1, strlen(str), 2, 10, 10);
                  getch();

                  return 0;
               }


     moveto
──────────────────────────────────────────────────────────────
Функция        Переносит текущую позицию курсора (CP) в (х,у).

Синтаксис      #include <graphics.h>
               void far moveto(int x, int y);

Прототип в     graphics.h

Замечание      moveto переносит текущую позицию курсора (CP) в
               точку (x,y) текущего окна.

Значение       Нет.

Переносимость  Эта функция уникальна в Turbo C++. Она работает
               только на IBM PC и совместимых с ней,  оснащен-
               ных адаптерами  графических устройств.  Не сов-
               местима с Windows.

См.также       moverel

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  char msg[80];

                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");

                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)/*обнаружена ошибка*/
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }

                  /* переместить C.P. в позицию (20, 30) */
                  moveto(20, 30);

                  /* изобразить пиксел в точке C.P. */
                  putpixel(getx(), gety(), getmaxcolor());

                  /* вывести сообщение в точке (20, 30) */
                  sprintf(msg, " (%d, %d)", getx(), gety());
                  outtextxy(20, 30, msg);

                  /* переместить в точку (100, 100) */
                  moveto(100, 100);

                  /* изобразить пиксел в точке C.P. */
                  putpixel(getx(), gety(), getmaxcolor());

                  /* вывести сообщение в точке C.P. */
                  sprintf(msg, " (%d, %d)", getx(), gety());
                  outtext(msg);

                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }


     movmem
──────────────────────────────────────────────────────────────
Функция        Переносит блок длиной length байтов.

Синтаксис      #include <mem.h>
               void movmem(void *src, void *dest,
               unsigned length);

Прототип в     mem.h

Замечание      movmem копирует блок размером в  length  байтов
               из  src в dest.  Даже если исходный блок и блок
               назначения перекрываются,то данные всегда копи-
               руются правильно.

Значение       Нет.

Переносимость  movmem уникальна в Borland C++.

См. также      memcpy, memmove, movedata

Пример         #include <mem.h>
               #include <alloc.h>
               #include <stdio.h>
               #include <string.h>

               int main(void)
               {
                  char *source = "Borland International";
                  char *destination;
                  int length;

                  length = strlen(source);
                  destination = malloc(length + 1);
                  movmem(source,destination,length);
                  printf("%s\n",destination);

                  return 0;
               }


     norm
──────────────────────────────────────────────────────────────
Функция        Возвращает квадрат абсолютного значения числа.

Синтаксис      #include <complex.h>
               double norm(complex x);

Прототип в     complex.h

Замечание      norm может  привести   к   переполнению,   если
               действительная или мнимая часть числа достаточ-
               но большая.

Значение       norm(x) возвращает величину real(x) * real(x) +
               imag (x) * imag(x).

Переносимость  Комплексная функция требует С++ и непереносима.

См.также       arg, complex, polar

Пример         #include <iostream.h>
               #include <complex.h>

               int main(void)
               {
            double x = 3.1, y = 4.2;
            complex z = complex(x,y);
            cout << "z = " << z << "\n";
            cout << "  has real part = " << real(z) << "\n";
            cout << "  and imaginary real part = " << imag(z)
                 << "\n";
            cout << "z has complex conjugate = " << conj(z)
                 << "\n";

            double mag = sqrt(norm(z));
            double ang = arg(z);
            cout << "The polar form of z is:\n";
            cout << "   magnitude = " << mag << "\n";
            cout << "   angle (in radians) = " << ang
                 << "\n";
            cout << "Reconstructing z from its polar form "
                    "gives:\n";
            cout << "   z = " << polar(mag,ang) << "\n";
            return 0;
               }


     normvideo
──────────────────────────────────────────────────────────────
Функция        Выбирает нормальную интенсивность для символов.

Синтаксис      #include <conio.h>
               void normvideo(void);

Прототип в     conio.h

Замечание      normvideo выбирает  нормальную яркость для сим-
               волов,  возвращая текстовым атрибутам (основной
               и фоновый) значения, которые они имели, при за-
               пуске программы.

               Эта функция не влияет на текущие символы на эк-
               ране.  Она влияет только на те символы, которые
               будут   изображаться  функциями  (как  например
               cprintf), выполняющими прямой консольный вывод,
               после вызова normvideo.

Значение       Нет.

Переносимость  normvideo работает с IBM PC  и  совместимыми  с
               ней;  подобная функция есть в Turbo Pascal.  Не
               совместима с Windows.

См.также       highvideo, lowvideo, textattr, textcolor

Пример         #include <conio.h>

               int main(void)
               {
                  clrscr();
                  lowvideo();
                  cprintf("LOW Intensity Text\r\n");

                  highvideo();
                  cprintf("HIGH Intensity Text\r\n");

                  normvideo();
                  cprintf("NORMAL Intensity Text\r\n");
                  return 0;
               }


     nosound
──────────────────────────────────────────────────────────────
Функция        Выключает внутренний динамик.

Синтаксис      #include <dos.h>
               void nosound(void);

Прототип в     dos.h

Замечание      Выключает внутренний динамик после того, как он
               был включен функцией sound.

Значение       Нет.
Переносимость  normvideo работает с IBM PC  и  совместимыми  с
               ней; подобная  функция есть в Turbo Pascal.  Не
               совместима с Windows.

См.также       delay, sound

Пример         /* Издает  тон 7-Hz за 10 секунд. */

               /*
             True story: 7 Hz is the resonant frequency of a
             chicken's skull cavity. This was determined
             empirically in Australia, where a new factory
             generating 7-Hz tones was located too close to a
             chicken ranch: When the factory started up,
             all the chickens died.
               */

            /* Ваш PC может быть не может издать тон в 7-Hz. */

               int main(void)
               {
                  sound(7);
                  delay(10000);
                  nosound();
               }


     _open
──────────────────────────────────────────────────────────────
Функция        Открывает файл для чтения или записи.

Синтаксис      #include <fcntl.h>
               int_open(const char *filename, int oflags);

Прототип в     io.h

Замечание
               _open открывает файл,  указанный в filename,  и
               подготавливает его для чтения или записи, в за-
               висимости от значения oflags.  Файл всегда отк-
               рывается в двоичном режиме.

               Для _open,  значение oflags в DOS 2.x определе-
               но:  O_RDONLY,O_WRONLY и O_RDWR.  Для  DOS  3.x
               используются  следующие дополнительные значения
               :

 Эти символ.  - O_NOINHERIT включается, если  файл  не переда-
 константы                  ется порожденным программам.
 определены   - O_DENYALL   позволяет только текущему дескрип-
 в fcntl.h                  тору иметь доступ к файлу.
               - O_DENYWRITE допускает только чтение из любого
                             другого открытого файла в файл
               - O_DENYREAD  допускает только запись из любого
                             другого открытого файла в файл
               - O_DENYNONE  допускает другие одновременные
                             операции открытия файла

               Только одно  из  значений  O_DENYxxx может быть
               включено в _open в DOS 3.x. Эти атрибуты файлов
               коллективного использования существуют в допол-
               нение к другим,  выполняющим запирание для фай-
               лов.

               Максимальное количество  одновременно  открытых
               файлов определено величиной HANDLE_MAX.

Значение       При успешном завершении, _open возвращает неот-
               рицательное число (дескриптор файла).  Файловый
               указатель, который определяет текущую позицию в
               файле,  устанавливается на начало файла. В слу-
               чае  ошибки,  _open  возвращает -1 и глобальной
               переменной errno устанавливается одно из следу-
               ющих значений :

                ENOENT  - Путь или файл не найден
                EMFILE  - Слишком много открытых файлов
                EACCES  - Доступ не разрешается
                EINVACC - Неправильный код доступа

Переносимость  _open уникальна в DOS.

См.также       open, _read, sopen

Пример         #include <string.h>
               #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
                  int handle;
                  char msg[] = "Hello world";

                  if ((handle = _open("TEST.$$$",O_RDWR))==-1)
                  {
                     perror("Error:");
                     return 1;
                  }
                  _write(handle, msg, strlen(msg));
                  _close(handle);
                  return 0;
               }


     open
──────────────────────────────────────────────────────────────
Функция        Открывает файл для чтения или записи.

Синтаксис      #include <fcntl.h>
               #include<sys\stat.h>
               int open(const char *path,
                        int access [, unsigned mode]);

Прототип в     io.h

Замечание
               open открывает  файл,  указанный в path,  затем
               подготавливает его для чтения и /  или  записи,
               как указано в access.

               Чтобы создать файл конкретного типа,  вы можете
               или определить глобальную переменную _fmode или
               вызвать open с опциями O_CREAT и O_TRUNC, или с
               помощью требуемого режима трансляции. Например,
               вызов
                  open("xmp",O_CREAT|O_TRUNC|O_BINARY,S_IREAD)

               создает файл двоичного типа,  только для чтения
               с  именем XMP,  установив его длину в 0 байтов,
               если он уже существовал.

               Для функции open,  access формируется с помощью
               флагов, полученных при выполнении побитовой ло-
               гической  операции  ИЛИ   из   следующих   двух
               списков. Только один флаг из первого списка мо-
               жет и должен быть использован, оставшиеся флаги
               могут быть использованы в любой логической ком-
               бинации.

               Список 1 : флаги чтения / записи

 Эти симв.      O_RDONLY   Открыт только для чтения
 константы      O_WRONLY   Открыт только для записи
 определены     O_RDWR     Открыт для чтения и записи
 в fcntl.h

               Список 2 : другие флаги доступа

          O_NDELAY - не   используется;  для  UNIX  систем.
          O_APPEND - если  установлен,  то  указатель   файла
                     устанавливается   в  конец  файла  перед
                     каждой  записью.  O_CREAT  -  если  файл
                     существует,  этот  флаг  не  эффективен.
                     Если  файл  не   существует,   то   файл
                     создается  и  биты mode используются для
                     установки атрибутов файла как в chmod.
          O_TRUNC -  Если   файл   существует,   его    длина
                     заменяется на 0. Атрибуты файла остаются
                     неизменными.
          O_EXCL -   Используется только с O_CREATE.     Если
                     файл уже существует,возвращается ошибка.
          O_BINARY - Этот флаг может быть передан для точного
                     открытия файла двоичного типа.
          O_TEXT -   Этот флаг может быть передан для точного
                     открытия файла текстового типа.

               Если ни O_BINARY ни O_TEXT не заданы, файл отк-
               рывается глобальной переменной _fmode в  режиме
               трансляции.

               Если флаг  O_CREATE  использован в формировании
               access, вам необходимо определить аргумент mode
               в open из следующих символьных констант,  опре-
               деленных в sys\stat.h.

               ───────────────────────────────────────────────
                Значение режима     Разрешение доступа
               ───────────────────────────────────────────────
                S_IWRITE            Разрешение записи
                S_IREAD             Разрешение чтения
                S_IREAD|S_IWRITE    Разрешение записи и чтения
               ───────────────────────────────────────────────

Значение       При успешном завершении, _open возвращает неот-
               рицательное число (дескриптор файла). Указатель
               файла,  который  определяет  текущую  позицию в
               файле,  устанавливается на начало файла. В слу-
               чае  ошибки,  _open  возвращает -1 и глобальной
               переменной errno устанавливается одно из следу-
               ющих значений :
                ENOENT  - Нет такого файла или справочника
                EMFILE  - Слишком много открытых файлов
                EACCES  - Доступ не разрешается
                EINVACC - Неправильный код доступа

Переносимость  open доступна  для  UNIX  систем.  В  UNIX  7-й
               версии О_type мнемоника не определена.  В  UNIX
               System  III  используется вся мнемоника O_type,
               кроме O_BINARY и O _TEXT.

См.также
               chmod, chsize,  close, _creat, creat, creatnew,
               creattemp,   dup,   dup2,  fdopen,  filelength,
               fopen,  freopen,  getftime, lseek, lock, _open,
               read, sopen, _write, write

Пример         #include <string.h>
               #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
                  int handle;
                  char msg[] = "Hello world";

                  if ((handle=open("TEST.$$$",O_CREAT|O_TEXT))
                       == -1)
                  {
                     perror("Error:");
                     return 1;
                  }
                  write(handle, msg, strlen(msg));
                  close(handle);
                  return 0;
               }


     outport
──────────────────────────────────────────────────────────────
Функция        Выводит слово на аппаратный порт.

Синтаксис      #include <dos.h>
               void outport(int portid, int value);

Прототип в     dos.h

Замечание
               outport работает  только  как  инструкция 80x86
               out. Она записывает младший байт слова,заданно-
               го  в  value,  в  выходной  порт,  указанный  в
               portid, старший байт слова - в portid+1.

Значение       Нет.

Переносимость  output уникальна   для   процессоров  семейства
               8086.

См.также       inport, inportb, outportb

Пример         #include <stdio.h>
               #include <dos.h>

               int main(void)
               {
                  int value = 64;
                  int port = 0;

                  outportb(port, value);
                  printf("Value %d sent to port number %d\n",
                         value, port);
                  return 0;
               }


     outportb
──────────────────────────────────────────────────────────────
Функция        Выводит байт в аппаратный порт.

Синтаксис      #include <dos.h>
               void outportb(int portid, unsigned char value);

Прототип в     dos.h

Замечание      outportb - макроc, который записывает байт, за-
               данный в value,  в  порт  вывода,  указанный  в
               portid.

               Если outportb вызывается,  когда dos.h включен,
               она  трактуется как макроc,  расширяющий inline
               код.  Если Вы не включаете dos.h,  или, если Вы
               включаете  dos.h и отменяете (#undef) определе-
               ние  макроса  outportb,  Вы  получаете  функцию
               outportb.

Значение       Нет.

Переносимость  outputb уникальна  для  процессоров   семейства
               8086.

См.также       inport, inportb, outport

Пример         #include <stdio.h>
               #include <dos.h>

               int main(void)
               {
                  int port = 0;
                  char value = 'C';

                  outportb(port, value);
                  printf("Value %c sent to port number %d\n",
                         value, port);
                  return 0;
               }


     outtext
──────────────────────────────────────────────────────────────
Функция        Выводит строку в текущем окне.

Синтаксис      #include <graphics.h>
               void far outtext(char far *textstring);

Прототип в     graphics.h

Замечание      outtext выводит текстовую строку в текущем  ок-
               не,  используя  текущие установки выравнивания,
               шрифта, направления и размера.

               outtext выводит  textstring  в  текущей позиции
               указателя (СР).  Если горизонтальное  текстовое
               выравнивание - LEFT_TEXT и направление текста -
               HORIZ_DIR,  то текущая х - координата указателя
               продвигается            на           расстояние
               textwidth(textstring). Иначе, СР остается неиз-
               менной.

               Чтобы сохранить   совместимость   кодов,  когда
               используются  несколько  шрифтов,   используйте
               textwidth  и texthigth для определения размеров
               строки.

               Если строка  печатается   стандартным   шрифтом
               используя outtext, то любая часть строки, кото-
               рая выходит за пределы  текущего  окна,  усека-
               ется.

               outtext используется в графическом режиме;  она
               не работает в текстовом режиме.

Значение       Нет.

Переносимость
               Эта функция уникальна в Borland C++.  Она рабо-
               тает только на IBM  PC  и  совместимых  с  ней,
               оснащенных адаптерами графических устройств.

См.также       gettextsetting,    outtexty,    settextjustify,
               textheigth, textwidth

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy;

                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");

                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) /*обнаружена ошибка*/
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }

                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;

                /*поместить текущий указатель в центр экрана*/
                moveto(midx, midy);

                  /* вывести текстовую строку в точке СР */
                  outtext("This ");
                  outtext("is ");
                  outtext("a ");
                  outtext("test.");

                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }


     outtextxy
──────────────────────────────────────────────────────────────
Функция        Выводит строку в указанной позиции.

Синтаксис      #include <graphics.h>
               void far outtextxy(int x, int y, char far
                                  *textstring);

Прототип в     graphics.h

Замечание      outtextxy выводит текстовую строку на  экран  в
               заданной  позиции (x,y),  используя текущие вы-
               равнивание, шрифт, направление и размер.

               Чтобы сохранить совместимость кодов при исполь-
               зовании    нескольких    шрифтов,   используйте
               textwidth и textheigth для определения размеров
               строки.

Примечание     Если строка   напечатана   стандартным  шрифтом
               используя outtext или outtextxy,  часть строки,
               выходящая за пределы текущего поля вывода, усе-
               кается.

               оuttextxy используется  в  графическом режиме и
               не работает в текстовом.

Значение       Нет.

Переносимость  Эта функция уникальна в Borland C++.  Она рабо-
               тает только на IBM  PC  и  совместимых  с  ней,
               оснащенных адаптерами графических устройств.

См.также       gettextsettings, outtext, textheigth, textwidth

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* Запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy;

                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");

                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) /*обнаружена ошибка*/
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }

                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;

              /* вывести текст в центре экрана */
              /* Замечание:текущий указатель не был изменен.*/
              outtextxy(midx, midy, "This is a test.");

                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }


     _OvrInitEms
──────────────────────────────────────────────────────────────
Функция        Инициализирует обмен   расширенной  памяти  для
               программы управления оверлеями.

Синтаксис      #include <dos.h>
               int cdecl far _OvrInitEms(unsigned emsHandle,
                                         unsigned firstPage,
                                         unsigned pages);

Прототип в     dos.h

Замечание      _OvrInitEms проверяет наличие расширенной памя-
               ти,  для чего осуществляет поиск EMS-драйвера и
               распределяет  память из него.  Если emsHandle -
               ноль,  программа управления оверлеями распреде-
               ляет  EMS  станицы  и использует их для обмена.
               Если emsHandle не ноль,то это должно быть  пра-
               вильно  обработано  EMS;  программа  управления
               оверлеями использует это значение для обмена. В
               этом    случае,   Вы   можете   специфицировать
               firstPage внутри этой области, откуда может на-
               чинаться обмен.

               В обоих случаях,  ненулевое значение  параметра
               pages   дает  предельное  количество  свободных
               страниц для программы управления оверлеями.

Значение      _OvrInitEms возвращает 0, если программа управ-
               ления оверлеями может использовать  расширенную
               память для обмена.

Переносимость  _OvrInitEms уникальна в Borland С++.

См.также       _OvrInitExt

Пример         #include <dos.h>

               int main(void)
               {
               /*
                  запросить программу управления оверлеями
                  проверить расширенную память и разрешить
                  использовать 16 страниц (256K);
                  доступно только в средних, больших и очень
                  больших моделях памяти
               */
                  _OvrInitEms (0, 0, 16);

                  return 0;

               }


     _OvrInitExt
──────────────────────────────────────────────────────────────
Функция        Инициализирует обмен   расширенной  памяти  для
               программы управления оверлеями.

Синтаксис      #include <dos.h>
               int cdecl far _OvrInitExt(unsigned long
               startAddress, unsigned long length);

Прототип в     dos.h

Замечание     _OvrInitExt проверяет наличие расширенной памя-
               ти, используя известные методы других программ,
               использующих расширенную память, и распределяет
               память из них.  Если startAddress - ноль, прог-
               рамма управления оверлеями определяет стартовый
               адрес и использует,  самое большое,  это размер
               перекрытий.  Если startAddress -  не  ноль,  то
               программа   управления   оверлеями   использует
               расширенную память, выше этого адреса.

               В обоих  случаях,  ненулевое значение параметра
               length определяет размер доступной  расширенной
               памяти,   используемой   программой  управления
               оверлеями.

Значение       _OvrInitExt возвращает 0, если менеджер оверле-
               ев готов использовать  расширенную  память  для
               перекачки.

Переносимость  _OvrInitExt уникальна в Borland С++.

Пример         #include <dos.h>

               int main(void)
               {
               /*
                  Доступно только в средних, больших и очень
                  больших моделях памяти
               */

               /*
                  Используйте расширенную память из линейного
                  адреса 0x200000L (2MB), если это необходимо
               */
                  _OvrInitExt (0x200000L, 0);

                  return 0;
               }

