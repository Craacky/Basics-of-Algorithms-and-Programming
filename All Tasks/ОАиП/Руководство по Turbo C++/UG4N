                           ГЛАВА 4.

            УПРАВЛЕНИЕ МУЛЬТИФАЙЛОВЫМИ ПРОЕКТАМИ.

     Так как многие программы состоят из более чем одного фай-
ла, было бы идеальным иметь способ для автоматического опреде-
ления файлов, которые необходимо заново откомпилировать и сде-
лать редакцию связей. В Borland C++ встроенный менеджер проек-
та делает не только это, но даже более того.
     Менеджер проекта позволяет задавать файлы,  принадлежащие
проекту.  Когда бы ни было сделано заново построение  проекта,
менеджер проекта автоматически обновляет информацию,  хранящу-
юся в проектном файле. Этот проектный файл включает:
     - все файлы в проекте;
     - где искать их на диске;
     - какие  файлы зависят от других файлов,  компилирующихся
раньше (автозависимости);
     - какие  опции  компилятора  и командной строки нужны при
создании каждой части программы;
     - куда поместить программу-результат;
     - размер кода, размер данных и число строк последней ком-
пиляции.
     Использовать менеджер  проекта  достаточно  просто.   Для
построения проекта:
     - выберите  имя   проектного   файла   (из   Project/Open
Project);
     - добавьте  исходные  файлы,  используя  диалоговое  окно
Project/Add Item;
     - отдайте Borland C++ команду Compile/Make EXE File.
     Затем с помощью команд управления проектом,  доступными в
меню Project, можно:
     - добавить или удалить файлы из своего проекта;
     - установить опции для файла в проекте;
     - посмотреть  включенные  файлы  для  конкретного файла в
проекте.
     Давайте рассмотрим  пример  того,  как  работает менеджер
проекта.
     Примечание. Все файлы в этой главе находятся в справочни-
ке Examples.

               Использование менеджера проекта.

     Предположим, что имеется программа, состоящая из главного
исходного файла,  MYMAIN.C, файл поддержки MYFUNCS.C, содержа-
щий функции и данные,  на которые ссылается основной  файл,  и
MYFUNCS.H. MYMAIN.C выглядит следующим образом:
       #include <stdio.h>
       #include "myfuncs.h"

       main (int argc, char *argv[])
       {
          char *s;

          if (argc > 1)
             s = argv[1];
          else
             s = "the universe";

          printf("%s %s.\n",GetString(),s);
       }
     MYFUNCS.C выглядит следующим образом:
       char ss[] = "The restaurant at the end of";

       char *GetString(void)
       {
           return ss;
       }
     MYFUNCS.H выглядит следующим образом:
       extern char *GetString(void);
     Примечание. Если  Вы  взяли  проектные файлы из Турбо Си,
используйте утилиту PRJCNVT.EXE для их преобразования;  детали
посмотрите в UTIL.DOC на диске.
     Эти файлы  составляют  программу,   которую   мы   сейчас
рассмотрим с точки зрения менеджера проекта.
     Первый шаг - сообщить Borland C++ имя  проектного  файла;
назовем его MYPROG.PRJ.  Заметим,  что имя проектного файла не
совпадает с именем основного файла (MYMAIN.C).  В этом  случае
выполнимый файл будет называться MYPROG.EXE (и если Вы выбере-
те  его  для  генерации,  то  файл   .MAP   будет   называться
MYPROG.MAP).
     Примечание. Эти имена могут совпадать (кроме расширений),
но необязательно. Имя выполнимого файла (и имя любого файла
.MAP, созданного  редактором связей),  основывается на имени
проектного файла.
     Нажмите Alt-P, чтобы войти в Project меню, и выберите ко-
манду  Open Project.  Это вызовет диалоговое окно Load Project
File,  содержащее список всех файлов в текущем  справочнике  с
расширением .PRJ, а также информацию о дате, времени и размере
первого проектного файла.  Так как мы начинаем новый файл, на-
берем MYPROG в диалоговом окне Load Project File.
     Заметим, что как только проект открыт,  опции  Add  Item,
Delete  Item,  Local  Options  и  Include Files становятся не-
доступными в меню Project.
     Можно хранить  проектный файл в любом справочнике;  чтобы
поместить его в справочник,  отличный от текущего,  просто за-
дайте путь как часть имени файла. (Можно также задать путь для
исходных файлов, если они находятся в различных справочниках).
Заметим,  что  все  файлы  и  соответствующие пути относятся к
справочнику,  из которого загружен проектный файл. После того,
как Вы наберете имя проектного файла, Вы увидите окно Project.
     Примечание. Если проектный файл,  который  Вы  загрузили,
находится в другом справочнике, то текущим справочником станет
справочник, из которого загружен проектный файл.
     Окно Project   содержит  имя  текущего  проектного  файла
(MYPROG) и информацию о файлах,  выбранных для этого  текущего
проекта.  Для  каждого файла показаны имя и путь (местоположе-
ние).  Как только файл откомпилируется,  оно также  показывает
число строк в файле и размер кода и данных (в байтах),  сгене-
рированных компилятором.
     Строка статуса  внизу  экрана показывает,  какие действия
могут быть выполнены в этой точке: F1 дает справочную информа-
цию,  Ins добавляет файлы к проекту, Del удаляет файлы из про-
екта,  Ctrl-O позволяет выбрать опции для файла, ПРОБЕЛ позво-
ляет посмотреть информацию об include файлах, требуемых файлом
в проекте, Enter открывает окно редактора для текущего выбран-
ного файла,  а F10 возвращает в основное меню. Нажмите Ins для
добавления файла к проектному списку.
     Появляется диалоговое окно Add Item to Project List;  это
окно позволяет выбирать и добавлять исходные  файлы  к  своему
проекту. Окно Files List показывает все файлы с расширением .С
в  текущем  справочнике.  (В  этом  списке  есть  MYMAIN.C   и
MYFUNCS.C). Доступны три кнопки: Add, Cancel и Help.
     Примечание. Можно изменить спецификацию  имени  файла  на
требуемую  с помощью окна ввода Name;  *.С задается по умолча-
нию.
     Так как  кнопка  Add установлена по умолчанию,  можно по-
местить файл в окно Project,  набрав его имя в окне ввода Name
и нажав Enter, или выбрав его в окне списка Files. Можно также
осуществить поиск файла в окне  списка  Files,  набрав  первые
несколько букв из имени требуемого файла.  В этом случае, наб-
рав my,  Вы должны сразу попасть на MYFUNCS.C;  нажмите Enter.
Вы увидите, что MYFUNCS добавилось в окно Project, а Вы верну-
лись в диалоговое окно Add Item для добавления другого  файла.
Двигайтесь далее и добавьте MYMAIN.C. Borland C++ откомпилиру-
ет файлы в том порядке, в каком они появились в проекте.
     Примечание. Если  Вы скопировали неправильный файл в окно
Project,  нажмите Esc для возврата в окно Project, а затем Del
для удаления текущего файла из списка.
     Нажмите Esc для закрытия диалогового окна  и  возврата  в
окно  Project.  Отметим,  что  поля Lines,  Code и Data в окне
Project помечены n/a.  Это означает, что информация недоступна
до тех пор, пока модули не будут откомпилированы.
     Примечание. Заметим,  что кнопка Add совершает изменения;
нажатие  Esc,  когда  Вы находитесь в диалоговом окне,  просто
приводит к его исчезновению.
┌─────────────────────────────────────────────────────────────────┐
│█ ЁFile Edit Search Run Compile Debug Project Options Window Help│
│                                                                 │
│┌──────────────────────── MYFUNCS.C ────────────────────────1───┐│
││┌──────────────────────── MYMAIN.C ────────────────────────2──┐││
│││#include ╔═[█]═════ Add Item to Project List ═══════╗        │││
│││#include ║ ┌──────┐                                 ║        │││
│││         ║ │ Name └──────────────────────┐          ║        │││
│││main (int║ │ *.*                         ││∙│       ║        │││
│││{        ║ └─────────────────────────────┘          ║        │││
│││         ║ ┌────────────────────────────┐           ║        │││
│││  char *s║ │Files        │              │   [ Add ] ║        │││
│││  if (arg║ │ INTR01.C    │ MYMAIN.OBJ   │           ║        │││
│││     s = ║ │ INTR02.C    │              │           ║        │││
│││  else   ║ │ INTR03.C    │              │           ║        │││
│││     s = ║ │ LIST.CPP    │              │           ║        │││
│││  print("║ │ LIST.H      │              │           ║        │││
│││         ║ │ LMMG.PRJ    │              │           ║        │││
│││}        ║ │ LONIG.PRG   │              │           ║        │││
│││         ║ │ MYFUNCS.C   │              │ [ Cancel ]║        │││
│││         ║ │ MYFUNCS.H   │              │           ║        │││
│││         ║ │ MYFUNCS.OBJ │              │           ║        │││
│││         ║ │ MYMAIN.C    │              │   [ Help ]║        │││
│└┴───13:1──╢ │<ЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁ█>│           ╟────────┴┘│
│╔═[█]══════╣ └────────────────────────────┘           ║═══4═[°]═╗│
│║ File name║ C:\BORLAND\EXAMPLES\*.*                  ║ode Data ^│
│║ MYFUNCS.C║ MYMAIN.C        207  Feb 4,1991   2:45pm ║n/a  n/a █│
│║ MYFUNCS.H╚══════════════════════════════════════════╝n/a  n/a Ё│
│║ MYMAIN.C                                             n/a  n/a Ё│
│║                                                               Ё│
│║                                                               v│
│╚═<█ ЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁ>──┘│
│File Load status line help message!                              │
└─────────────────────────────────────────────────────────────────┘
     После установки  всех  опций  компилятора  и справочников
Borland C++ знает все, что ему необходимо для построения прог-
раммы,  названной  MYPROG.EXE,  использующей  исходные  коды в
MYMAIN.C, MYFUNCS.C и MYFUNCS.H. Теперь Вы действительно начи-
наете строить проект.
     Нажмите F10 для перехода в основное меню. Теперь сделайте
make для MYPROG.EXE посредством нажатия клавиши F9 (или выбора
команды Compile/Make EXE File). Затем запустите свою программу
путем  нажатия Ctrl-F9 (или выбора Run/Run).  Чтобы посмотреть
вывод,  выберите  команду  Window/User  Screen  (или   нажмите
Alt-F5), затем нажмите любую клавишу для возврата в интегриро-
ванную среду.
     Примечание. Можно также посмотреть свой вывод, выбрав ко-
манду Window/Output.
     При выходе  из  интегрированной усовершенствованной среды
проектный файл,  с которым Вы работали, автоматически сохраня-
ется на диске;  Вы можете отказаться от этого путем отключения
кнопки    Project    в     диалоговом     окне     Preferences
(Options/Environment).
     Сохраненный проект состоит  из  двух  файлов;  проектного
файла (.PRJ) и файла конфигурации окон (.DSK).  Проектный файл
содержит информацию, необходимую для создания соответствующего
выполнимого кода проекта (.EXE). Эта информация включает опции
компилятора,  пути INCLUDE/LIB/OUTPUT, опции редактора связей,
опции для MAKE и элементы перехода. Файл конфигурации окон со-
держит состояние всех окон  времени  последнего  использования
проекта.
     Примечание. Более подробную информацию о  файлах  .PRJ  и
.DSK  можно найти в разделе " Проектные файлы и файлы конфигу-
рации" в главе 2.
     В следующий  раз,  когда  Вы  будете использовать Borland
C++,  Вы можете попасть прямо в проект путем перезагрузки про-
ектного  файла.  Borland C++ автоматически загружает проектный
файл, если это единственный файл .PRJ в текущем справочнике; в
противном   случае  загружаются  проект  и  конфигурация  окна
(TCDEF.*), заданные по умолчанию. Так как файлы Вашей програм-
мы  и соответствующие пути относятся к справочнику файлов про-
екта, можно работать над любым проектом посредством перехода в
справочник файлов проекта и вызова Borland C++.  Для Вас авто-
матически будет загружен правильный файл. Если в текущем спра-
вочнике  нет ни одного проектного файла,  загрузится проектный
файл по умолчанию.
     Примечание. Можно  задать проект для загрузки в командной
строке DOS следующим образом: ВC myprog.prj.

                     Отслеживание ошибок.

     Как и синтаксические ошибки в  программах,  состоящих  из
единственного файла, так и сообщения об ошибках и предупрежде-
ния,  генерируемые компилятором в  мультифайловых  программах,
можно выбрать и посмотреть в окне Message.
     Чтобы посмотреть это,  давайте введем несколько синтакси-
ческих  ошибок  в  два файла MYMAIN.C и MYFUNCS.C.  В MYMAIN.C
удалите первую угловую скобку в первой строке и  удалите  с  в
char пятой строки. Эти изменения сгенерируют пять ошибок и два
предупреждения в MYMAIN.
     В MYFUNCS.C  удалите  первую  r из return в пятой строке.
Это изменение породит две ошибки и одно предупреждение.
     Так как Вы хотите посмотреть эффект трассировки в сложных
файлах,  Вам нужно изменить критерий Borland C++,  когда оста-
навливать процесс Make.  Это можно сделать с помощью установки
зависимой кнопки в диалоговом окне Make (Options/Make).
     Примечание. Изменение  этих  файлов  приводит  к  несоот-
ветствию их дат и дат объектных  файлов,  так  что  выполнение
Make приведет к их перекомпиляции.

                       Остановка Make.

     Можно выбрать  тип  сообщения,  требуемого для остановки,
посредством установки одной из опций Break Make On в  диалого-
вом окне Make (Options/Make).  По умолчанию задана Errors, ко-
торая используется чаще всего.  Однако, Вы можете делать оста-
новку  после  компиляции файла с предупреждениями,  с ошибками
или с фатальными ошибками, или делать остановку перед попыткой
редакции связей.
     Полезность каждого из этих режимов на самом деле  опреде-
ляется  способом,  который  Вы  предпочитаете для фиксирования
ошибок и предупреждений.  Если Вы хотите фиксировать ошибки  и
предупреждения сразу, как только их увидели, Вы должны устано-
вить Break Make On в Warnings или в Errors.  Если Вы предпочи-
таете  получить сразу весь список ошибок во всех исходных фай-
лах перед их фиксацией, Вы должны установить независимую кноп-
ку в Fatal Errors или Link. Для того чтобы посмотреть ошибки в
составных файлах,  выберите Fatal  Errors  в  диалоговом  окне
Make.

      Синтаксические ошибки в составных исходных файлах.

     Так как  Вы  только  что  ввели  синтаксические  ошибки в
MYMAIN.C и MYFUNCS.C, идите дальше и нажмите F9 (Make) для то-
го,  чтобы "сделать проект".  Окно Compiling показывает файлы,
которые компилируются,  и число ошибок  и  предупреждений  для
каждого файла и общее их число для Make.  Нажмите любую клави-
шу, когда вспыхивает сообщение "Errors: Press any key".
     Сейчас курсор установился на первой ошибке или предупреж-
дении в окне Message.  Если файл, на который ссылается сообще-
ние, находится в редакторе, высвеченная полоса в окне редакто-
ра покажет Вам,  где компилятор обнаружил проблему.  Можно пе-
редвигаться  вверх и вниз в окне Message для просмотра различ-
ных сообщений.
     Заметим, что для каждого исходного файла, который был от-
компилирован,  имеется сообщение  "Compiling".  Эти  сообщения
служат "границей" для файла, разделяя различные сообщения, ге-
нерируемые каждым модулем и его включенными файлами.  Когда Вы
переходите к сообщению,  сгенерированному другим исходным фай-
лом, окно редактора будет отслеживать ошибки только в тех фай-
лах, которые загружены.
     Таким образом, перемещение к сообщению, которое ссылается
на незагруженный файл, приводит к тому, что высвеченная полоса
в окне редактора гаснет.  Нажмите ПРОБЕЛ  для  загрузки  этого
файла и продолжайте отслеживание;  высвеченная полоса появится
снова.  Если Вы выберете одно из этих сообщений (нажав  Enter,
находясь под одним из них),  Borland C++ загрузит файл, на ко-
торый оно ссылается,  в окно редактора и поместит  курсор  под
ошибкой.  Если  затем вы вернетесь в окно Message (нажав Alt-W
M), отслеживание возобновится в этом файле.
     Опции Source   Tracking  в  диалоговом  окне  Preferences
(Options/Environment) помогают определить,  в какое окно  файл
будет загружаться.  Можно использовать эти установки, когда Вы
отслеживаете сообщения и делаете пошаговую отладку.
     Заметим, что  на  сообщения  Previos  и  Next  (Alt-F7  и
Alt-F8) действует установка Source Tracking. Эти команды всег-
да  будут  находить  предыдущую и следующую ошибку и загружать
файл, используя методы, заданные установкой Source Tracking.

               Сохранение и удаление сообщений.

     Обычно, как только Вы начинаете делать Make проекта, окно
Message очищает место для новых сообщений. Однако иногда быва-
ет желательно хранить сообщения поблизости  между  выполнением
Make.
     Рассмотрим следующий пример.  Ваш проект состоит из боль-
шого  количества  исходных файлов,  а установкой для остановки
Вашей программы является Errors.  В этом случае после компиля-
ции  многих  файлов  с предупреждениями одна ошибка в каком-то
файле вызовет остановку Make.  Вы зафиксировали эту  ошибку  и
хотите выяснить ее причины,  если компилятор примет эту фикса-
цию. Но если Вы сделаете Make или повторную компиляцию, Вы по-
теряете более ранние сообщения-предупреждения.  Чтобы избежать
этого,  включите  Save  Old   Messages   в   диалоговом   окне
Preferences  (Options/Environment).  При этом удаляются только
те сообщения,  которые были выданы для перекомпилируемых  фай-
лов. Таким образом, старые сообщения для заданного файла заме-
няются какими-то новыми сообщениями,  которые может сгенериро-
вать компилятор.
     Можно всегда избавиться от всех  сообщений  путем  выбора
команды  Compile/Remove  Message.  Выключение  опции  Save Old
Messages и другое выполнение Make также приведет к  избавлению
от всех старых сообщений.

                 Мощность менеджера проекта.

     Когда Вы делали предыдущий проект, Вы имели дело с основ-
ной ситуацией:  со списком имен исходных файлов  Си.  Менеджер
проекта  предоставит  Вам большие возможности для того,  чтобы
пойти дальше этой простой ситуации.

            Включение автоматических зависимостей.

     Менеджер проекта собирает информацию о автозависимости во
время  компиляции  и прячет ее так,  что нуждаются в обработке
только файлы,  откомпилированные вне  интегрированной  усовер-
шенствованной среды. Менеджер проекта может автоматически про-
верять зависимости между исходными файлами в проектном  списке
(и файлами, которые они включают) и их соответствующими объек-
тными файлами.  Это полезно  в  том  случае,  если  конкретный
исходный  файл  Си  зависит от других файлов.  Обычно исходный
файл Си включает несколько файлов заголовков (.h файлов),  оп-
ределяющих интерфейс с внешними программами.  Если интерфейс с
этими программами был изменен,  то Вы захотите  перекомпилиро-
вать файл, использующий эти программы.
     Если Вы включите опцию  Auto-Dependencies  (Option/Make),
Make  получает  время/дату всех файлов .C и их включенных фай-
лов.  Затем Make сравнивает информацию  дата/время  всех  этих
файлов  со  временем/ датой их последней компиляции.  Если ка-
кие-либо время/дата отличаются,  исходный файл  перекомпилиру-
ется.
     Если опция Auto-Dependencies отключена,  файлы .С сравни-
ваются с файлами .OBJ.  Если существуют более ранние файлы .С,
исходный файл перекомпилируется.
     Когда компилируется исходный файл,  компилятор интегриро-
ванной усовершенствованной среды и компилятор в режиме команд-
ной  строки  помещает  информацию о зависимостях в файлы .OBJ.
Менеджер проекта использует ее для сравнения  времени  и  даты
каждого файла, используемого для построения файла .OBJ, с вре-
менем и датой файла .OBJ.  Исходный файл .С перекомпилируется,
если даты отличаются.
     Это все о зависимостях. Вы получили мощность традиционных
Make и избежали длинных списков зависимостей.

         Использование различных трансляторов файлов.

     До сих  пор  Вы  строили  проекты,  используя  в качестве
транслятора языка только Borland C++.  Многие проекты  состоят
как из кода Си, так и ассемблерного кода, и возможно кода, на-
писанного на других языках.  Было бы  хорошо  иметь  несколько
способов  сказать  Borland  C++,  как  строить  такие  модули,
используя те же проверки зависимостей,  описанных выше.  С ме-
неджером проекта Вам не нужно беспокоиться о том, что Вы забу-
дете заново построить файлы при изменении исходного кода,  или
о том, в правильном ли справочнике Вы поместили их, и т.д.
     Для каждого исходного файла, который Вы включили в список
в окне Project, можно задать:
     - какая программа (Borland C++, TASM и т.д.) используется
для файла назначений;
     - Какие опции командной строки дать этой программе;
     - будет ли модуль оверлейным;
     - какой результирующий модуль вызывается и где  он  будет
размещен  (эта  информация используется менеджером проекта для
размещения файлов, необходимых для редактирования связей);
     - должен ли содержать модуль отладочную информацию;
     - должен ли модуль быть включен в редактирование связей.
     По умолчанию компилятор интегрированной усовершенствован-
ной среды выбирается в качестве транслятора для каждого  моду-
ля,  не используя опции перекрытия командной строки, используя
справочник Output для вывода,  в предположении,  что модуль не
оверлейный, а отладочная информация не должна быть исключена.
     Давайте рассмотрим простой пример.  Войдем в окно Project
и передвинем курсор к MYFUNCS.C. Теперь нажмите CTRL-O для вы-
зова диалогового окна Override Options:
┌─────────────────────────────────────────────────────────────────┐
│█ ЁFile Edit Search Run Compile Debug Project Options Window Help│
│        ╔═[█]══════════ Override Options ═══════════════╗        │
│┌───────╢                                               ╟───1───┐│
││┌──────╢ Project Item: MYFUNCS.C                       ╟───2──┐││
│││#inclu║                                               ║      │││
│││#inclu║ ┌──────────────────────────────────┐          ║      │││
│││      ║ │Command Line Options              │          ║      │││
│││main (║ │                               │∙││ [ OK ]   ║      │││
│││{     ║ └──────────────────────────────── ─┘          ║      │││
│││      ║ ┌──────────────────────────────────┐          ║      │││
│││  char║ │Output Path                       │          ║      │││
│││      ║ │ MYFUNCS.OBJ                      │          ║      │││
│││  if (║ └──────────────────────────────────┘          ║      │││
│││     s║                                     [ Cancel ]║      │││
│││  else║ ┌──────────────────────────────────┐          ║      │││
│││     s║ │Project File Translators         ^│          ║      │││
│││  prin║ │ЎBorland C++ Integrated Compilerў█│          ║      │││
│││      ║ │ ~Turbo Assembler                Ё│          ║      │││
│││}     ║ │Borland C++ command-line compilerЁ│          ║      │││
│││      ║ │                                 Ё│          ║      │││
│││      ║ │                                 Ё│          ║      │││
│││      ║ │                                 Ё│          ║      │││
│││      ║ │                                 Ё│          ║      │││
│└┴───13:║ │                                 Ё│          ╟──────┴┘│
│╔═[█]═══╣ │                                 v│ [ Help ] ╠═4═[°]═╗│
│║ File n║ └──────────────────────────────────┘          ║  Data ^│
│║ MYMAIN║                                               ║    21 █│
│║ MYFUNC║ [ ] Overlay this module                       ║    29 Ё│
│║       ║ [ ] Exclude debug information                 ║       Ё│
│║       ║ [ ] Exclude from link                         ║       Ё│
│║       ║                                               ║       v│
│╚═<█ ЁЁЁ╚═══════════════════════════════════════════════╝ЁЁЁЁ>──┘│
│F1 Help│Commamd line parameters to pass to the Item's translator │
└─────────────────────────────────────────────────────────────────┘
     В предположении Borland C++, каждое из имен в окне списка
Project File Translation является ссылкой на программу, задан-
ную в диалоговом окне Transfer (Options/Transfer).
     Нажмите Esc,  а  затем  F10 для возврата в основное меню,
затем выберите Options/Transfer.  Появившееся диалоговое  окно
Transfer  содержит список всех текущих заданных программ пере-
хода.  Используйте  клавиши  со  стрелками  для  выбора  Турбо
Ассемблера  и  нажмите  Enter.  (Так как кнопка Edit задана по
умолчанию,  нажатие Enter вызовет диалоговое  окно  Modify/New
Transfer  Item).  Здесь Вы увидите,  что Турбо Ассемблер задан
как программа TASM по текущему пути.  Заметим, что независимая
кнопка  Translator помечена X;  этот элемент транслятора затем
показывается в диалоговом окне Override Options.  Нажмите  Esc
для возврата в диалоговое окно Transfer.
     Предположим, Вы  хотите  компилировать  модуль   MYFUNCS,
используя  компилятор  в  режиме  командной строки Borland C++
вместо компилятора интегрированной усовершенствованной  среды.
Для этого нужно выполнить следующие шаги:
     1. Во-первых,  нужно определить BCC как один  из  Project
File  Translator в диалоговом окне Transfer.  Курсор находится
за последней записью в списке Program  Titles;  затем  нажмите
Enter для вызова диалогового окна Modify/New Transfer Item.  В
окне ввода Program Title  наберите  Borland  C++  Command-Line
Compiler;  в окне ввода Program Path наберите BCC; в командной
строке наберите $EDNAME.
     2. Включите Translator посредством нажатия клавиши ПРОБЕЛ
и нажмите Enter (New - это кнопка действия по умолчанию). Вер-
нувшись  обратно в диалоговое окно Transfer,  Вы увидите,  что
командная строка Borland C++ (compiler не  показан)  находится
сейчас в окне списка Program Titles. С помощью Tab перейдите к
ОК и нажмите Enter.
     3. Вернувшись  в  окно Project,  нажмите Ctrl-O для того,
чтобы войти в диалоговое окно Override Options снова. Заметим,
что  теперь Borland C++ Command-Line Compiler является выбором
в списке Project File Translator для MYFUNCS.C (так же  как  и
для всех остальных Ваших файлов).
     С помощью  Tab  перейдите  к  окну  списка  Project  File
Translator  и  высветите  Borland C++ Command-Line Compiler (в
этой точке нажатие Enter или переход  с  помощью  табуляции  к
другой  группе  выберет  эту  запись).  Используйте окно ввода
Command-Line Options для добавления  опций  командной  строки,
требуемых BСС при компиляции MYFUNCS.
     MYFUNCS.C теперь компилируется с использованием  BCC.EXE,
в  то время как остальные Ваши исходные модули компилируются с
BC.EXE.  Менеджер проекта применит тот же критерий к MYFUNCS.C
при решении вопроса, перекомпилировать ли модуль во время Make
так, как остальные модули, которые компилируются с BC.EXE.

                    Библиотеки перекрытий.

     В некоторых случаях необходимо перекрывать файлы  началь-
ного кода или библиотеки. Перекройте файл начального кода, по-
местив файл,  названный C0x.OBJ,  как первое имя  в  проектном
файле,  где  х означает любое имя DOS (например,  C0MINE.OBJ).
Необходимо,  чтобы имя начиналось с С0,  чтобы оно было первым
файлом в проекте и имело точное расширение .OBJ.
     Чтобы перекрыть стандартную  библиотеку,  необходимо  по-
местить  имя  специальной  библиотеки где-нибудь в списке имен
окна Project.  Имя библиотеки должно начинаться с С, сопровож-
даемого буквой,  представляющую модель (например, S для модели
Small),  остальные символы (до шести) могут быть любыми, кото-
рые  Вам  хочется  для  файлового  имени.  Нужно набрать явное
расширение .LIB (например, CSMYFILE.LIB или CSNEW.LIB).
     При перекрытии  стандартной  библиотеки  MAKE не пытается
редактировать  в  математических  библиотеках  (основанных  на
установке  Floating  Point  в  диалоговом  окне  Advanced Code
Generation меню Options/Compiler).  Если Вы  хотите,  чтобы  в
этих библиотеках происходило редактирование, когда Вы перекры-
ли стандартную библиотеку,  Вы должны явно включить их в  про-
ект.

           Остальные возможности менеджера проекта.

     Рассмотрим некоторые предлагаемые менеджером проекта воз-
можности.  При работе над проектом,  включающим много исходных
файлов,  Вы  хотите  иметь  возможность легкого просмотра этих
файлов и записи заметок, что Вы делаете во время работы. Также
Вы захотите иметь возможность быстрого доступа к файлам, вклю-
чаемым в другие.  Менеджер проекта предлагает  не  только  эти
возможности, но и многие другие.
     Например, расширим MYMAIN.C до включения вызова  функции,
названной GetMyTime:
   #include <stdio.h>
   #include "myfuncs.h"
   #include "mytime.h"

   main (int argc, char *argv[])
   {
      char *s

      if (argc > 1)
         s = argv[1];
      else
         s = "the universe";

 printf("%s %s opens at %d.\n",GetString(),s,GetMyTime(HOUR));
     Этот код  добавляет  два  включенных  файла   к   MYMAIN:
myfuncs.h  и mytime.h.  Эти файлы содержат прототипы,  которые
определяют  функции  GetString  и  GetMyTime,  вызываемые   из
MYMAIN. myfuncs.h содержит
       extern char *GetString(void);
     mytime.h содержит
     #define HOUR 1
     #define MINUTE 2
     #define SECOND 3
     extern int GetMyTime(int)
     Идем дальше и поместим действительный код для GetMyTime в
новый исходный модуль, названный MYTIME.C:
     #include <time.h>
     #include "mytime.h"

     int GetMyTime(int which)
     {
       struct tm       *timeptr;
       time_t          secsnow;

       time(&secsnow);
       timeptr = localtime(&secsnow);
       switch (which)  {
          case HOUR:
             return (timeptr -> tm_hour);
          case MINUTE:
             return (timeptr -> tm_min);
          case SECOND:
             return (timeptr -> tm_sec);
      }
     }
     MYTIME.C включает стандартный файл заголовка time.h,  со-
держащий прототипы функций time и localtime и определения tm и
time_t среди прочего. Также он включает mytime.h для определе-
ния HOUR, MINUTE и SECOND.
     Создайте эти новые файлы,  затем используйте Project/Open
Project для открытия MYPROG.PRJ.  Файлы MYMAIN.C  и  MYFUNCS.C
все еще находятся в окне Project. Теперь для построения расши-
ренного проекта добавьте имя файла MYTIME.C  в  окно  Project.
Нажмите Ins (или выберите Project/Add Item) для появления диа-
логового окна Add Item.  Если Вы поместили MYTIME.C в  текущий
справочник, используйте окно списка Files для его выбора. Если
MYTIME.C находится в другом справочнике,  с помощью Tab перей-
дите  к  окну  ввода Name и наберите MYTIME.C и его путь.  Как
только Вы используете один из этих методов,  нажмите Enter для
действительного  добавления файла.  Зависимая кнопка Add явля-
ется кнопкой действия по умолчанию.
     Теперь нажмите F9,  чтобы сделать Make проекта.  MYMAIN.C
перекомпилируется,  потому что Вы сделали в нем  изменения  со
времени последней компиляции.  MYFUNCS.C не будет перекомпили-
роваться,  потому что Вы не делали в нем изменений со  времени
Make  предыдущего  примера.  MYTIME.C откомпилируется в первый
раз.
     В проектном  окне  MYPROG передвиньте курсор к MYMAIN.C и
нажмите ПРОБЕЛ (или Project/Include File) для показа  диалого-
вого  окна  Include Files.  Это диалоговое окно содержит имена
выбранных файлов,  несколько кнопок и список включенных файлов
и  их  пути.  В окне списка Include Files высвечивается первый
файл;  окно списка перечисляет все  файлы,  включенные  файлом
MYMAIN.C. Если какой-то включенный файл находится вне текущего
справочника,  то путь этого файла отражен в поле Location окна
списка.
     Как только каждый исходный файл откомпилируется, информа-
ция о том, какие файлы в какие включаются, сохраняется в файле
.OBJ исходных файлов.  Если  Вы  попадете  в  диалоговое  окно
Include  Files перед выполнением Make,  то оно может не содер-
жать файлов или содержать файлы, оставшиеся от предыдущей ком-
пиляции  (которые  имеют  неправильную дату).  Чтобы загрузить
один из включенных файлов в окно редактора,  высветите требуе-
мый файл и нажмите Enter (или отметьте View).

                  Просмотр файлов в проекте.

     Давайте посмотрим один из файлов в проекте, MYMAIN.C. Вы-
берем файл, используя клавиши со стрелками или мышку, и нажмем
Enter. Это приведет к появлению окна редактора с загруженным в
нем файлом MYMAIN.C.  Теперь Вы можете делать изменения в фай-
ле,  скроллинг, поиск по тексту и все, что Вам нужно. Когда Вы
закончите работу с файлом,  сохраните изменения, если они были
(F2), затем нажмите Alt-F3 для закрытия окна редактора.
     Предположим, что после просмотра MYMAIN.C, Вы поняли, что
на самом деле Вы хотите посмотреть mytime.h,  один из включен-
ных файлов MYMAIN.C.  Высветите MYMAIN.C в окне Project, затем
нажмите  ПРОБЕЛ  для  появления диалогового окна Include Files
для MYMAIN.  (Альтернативно,  когда MYMAIN.C находится в  окне
редактора, выберите Project/Include Items или Alt-P I). Теперь
выберите mytime.h в диалоговом окне Include Files  и  отметьте
кнопку View.  Это приведет к появлению окна редактора с загру-
женным в нем файлом MYTIME.H.  Когда Вы сделаете это,  нажмите
Alt-F3, закрывающее окно редактора mytime.h.

                Замечания для Вашего проекта.

     Теперь, когда   Вы   имели   возможность  посмотреть  код
MYMAIN.C и mytime.h,  то Вы решили, что оптимизируете его, как
только у Вас будет время.  Выберите Window/Project Notes.  Это
приведет к появлению нового окна редактора,  которое  хранится
как часть Вашего проектного файла. Наберите следующее:
     Сделать изменения:
     Джон Г.
       Добавить проверку переполнения памяти в DBADDFIELD.
     Гарри Б.
       Зафиксировать ошибку 0183.
     Каждый проект поддерживает свой файл заметок,  так что Вы
можете хранить заметки,  которые возникают во время работы над
проектом;  они  заключаются  в  прикосновениях к кнопкам,  как
только Вы выбрали проектный файл.  Теперь нажмите  Alt-F3  для
закрытия окна редактора Project Notes.
