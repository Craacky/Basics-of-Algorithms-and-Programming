                           ГЛАВА 4.
                        ПРЕПРОЦЕССОР.

     Хотя Borland  C++ использует однопроходный компилятор для
интегрированной среды и компилятора командной  строки,  удобно
использовать терминологию, связанную с более ранними многопро-
ходными компиляторами.
     В дальнейшем  первый проход исходного текста будет связан
с включаемыми файлами, проверкой директив условной компиляции,
расширением макро и созданием промежуточного файла для следую-
щих проходов  компилятора.  Поскольку  версии  интегрированной
среды  и  компилятора  командной  строки Borland C++ выполняют
первый проход без  промежуточного  вывода,  Borland  C++  пре-
доставляет отдельный препроцессор CPP.EXE, который создает та-
кой выходной файл.  CPP  полезен  при  отладке,  позволяя  Вам
просмотреть результат выполнения директив включения,  условной
компиляции и сложные макрорасширения.
     Последующее обсуждение  директив  препроцессора,  их син-
таксис и семантика применимы к препроцессору CPP и  к  препро-
цессору, встроенному в компиляторы Borland C++.
     Примечание. Препроцессор обнаруживает  директивы  препро-
цессора (известные так же как управляющие строки) и анализиру-
ет лексемы, заключенные в них.
     Препроцессор Borland  C++ включает в себя макропроцессор,
который сканирует Ваш исходный код до начала работы компилято-
ра. Препроцессор предоставляет Вам большую мощность и гибкость
в следующих случаях:
     - При  определении  макро,  которые  сокращают  усилия по
программированию и улучшают понятность исходного кода. Некото-
рые макро могут так же сократить число вызовов функций.
     - При включении текста из других файлов,  таких как файлы
заголовков, содержащихся в стандартной библиотеке и прототипов
пользовательских функций и константы.
     - Для  установления условной компиляции для улучшения пе-
реносимости и отладки.
     Любая строка,  начинающаяся с #,  рассматривается как ди-
ректива препроцессора,  за исключением  #  внутри  литеральных
строк,  символьных констант или в комментариях. Вокруг # могут
стоять разделители (за исключением новой строки).
     Примечание: Директивы  препроцессора обычно размещаются в
начале Вашего исходного кода,  но они могут помещаться в любой
точке программы.
     Полный синтаксис директив препроцессора Borland C++  при-
веден в следующей таблице:

  Таблица 4.1. Синтаксис директив препроцессора Borland C++.
──────────────────────────────────────────────────────────────
     препроцессорный-файл:
       группа

     группа:
       часть-группы
       группа часть-группы

     часть-группы:
       <pp-лексемы>новая-строка
       if-выбор
       строка-управления

     if-выбор:
       if-группа<еlif-группы><else-группа>endif-строка

     if-группа:
       #if константное-выражение новая-строка<группа>
       #ifdef идентификатор новая-строка<группа>
       #ifndef идентификатор новая-строка<группа>

     elif-группы:
       elif-группа
       elif-группы elif-группа

     elif-группа:
       #elif константное-выражение новая-строка<группа>

     else-группа:
       #else новая-строка<группа>

     endif-строка:
       #endif новая-строка

     строка-управления:
       #include pp-лексемы новая-строка
       #define идентификатор список-замещений новая-строка
       #define идентификатор lparen<список-идентификаторов>)
         список-замещений новая-строка
       #undef идентификатор новая-строка
       #line рр-лексемы новая-срока
       #error <рр-лексемы> новая-строка
       #pragma <рр-лексемы> новая-строка
       #pragma varn действие аббревиатура новая-строка
       #pragma inline новая-строка
       # новая-строка

     действие: одно из
       +  -  .

     аббревиатура:
       amb     amp     apt     aus     big     cln     cpt
       def     dup     eff     mod     par     pia     pro
       rch     ret     rng     rpt     rvl     sig     str
       stu     stv     sus     ucp     use     voi     zst

     lpаrеn:
       символ "(" без предшествующего разделителя

     список-замещений:
       <рр-лексемы>

     рр-лексемы:
       лексема-препроцессора
       рр-лексемы лексема-препроцессора

     лексема-препроцессора:
       имя-заголовка (только внутри директивы #include)
       идентификатор (включая ключевые слова)
       константа
       литеральная-строка
       оператор
       знак-пунктуации
       любой неразделительный символ, который не может быть
         одним из предыдущих

     имя-заголовка:
       <hchar-последовательность>

     hchar-последовательность:
       hchar
       hchar-последовательность hchar

     hchar:
      любой символ из набора исходных символов, за исключением
         новой строки (\n) и ">"

     новая-строка:
       символ новой строки
──────────────────────────────────────────────────────────────

                      Пустая директива.

     Пустая директива содержит строку с одним символом #.  Эта
директива всегда игнорируется.

                    Директивы #define и #undef.

     Директива #define определяет  макро.  Макро  обеспечивает
механизм  для  замены лексем с или без набора формальных пара-
метров, подобным параметрам функции.

                    Простой макро #define.

     В случае без параметров он имеет синтаксис:
     #define идентификатор-макро<последовательность-лексем>
     Каждое появление идентификатора макро  в  исходном  коде,
следующее за этой строкой управления,  будет замещаться после-
довательностью  лексем  (возможно  пустой)(возможны  некоторые
исключения,  приведенные  ниже).  Такое замещение известно как
макрорасширение.  Последовательность лексем иногда  называется
телом макро. Любое появление идентификатора макро внутри лите-
ральных строк, символьных констант или комментариев в исходном
коде не расширяется.
     Пустая последовательность  лексем  приводит  к   удалению
идентификатора макро из исходного кода:
     #define HI "Хороший день!"
     #define empty
     #define NIL **
     ...
     puts(HI);
     puts(NIL);
     puts("пустой");
     После каждого  макрорасширения  производится сканирование
для следующих расширений макро. Это реализует вложенные макро:
расширяемый текст может содержать идентификаторы макро,  кото-
рые так же замещаются.  Однако,  если макрорасширение выглядит
как  директива препроцессора,  такая директива не распознается
препроцессором:
     #define GETSTR #include <stdio.h>
     ...
     GETSTR
     GETSTD расширяется в #include <stdio.h>.  Однако  препро-
цессор не распознает ее как директиву и будет литерально пере-
давать в компилятор.  Компилятор отвергает #include  <stdio.h>
как неверный вход.  Макро не расширяется во время его расшире-
ния. Так #define A A не расширяется бесконечно.

                      Директива #undef.

     Вы можете отключить макро, используя директиву #undef.
     #undef идентификатор-макро
     Эта строка отключает предыдущую последовательность лексем
от идентификатора макро; макроопределение забывается и иденти-
фикатор макро неопределен.
     Внутри строки #undef не происходит макрорасширения.
     Состояние определен  или  неопределен   является   важным
свойством идентификатора. Директивы #ifdef и #ifndef использу-
ются для проверки определен идентификатор в данный момент  или
нет  и  обеспечивают  гибкий  механизм  для управления многими
аспектами компиляции.
     После того,  как идентификатор макро отключен,  его можно
переопределить с помощью #define,  используя ту же  или  новую
последовательность лексем.
     #define BLOCK_SIZE 512
     ...
     buff = BLOCK_SIZE*blks;
     ...
     #undef BLOCK_SIZE
     ...
     #define BLOCK_SIZE 128
     ...
     buf = BLOCK_SIZE*blks;
     ...
     Попытка переопределить  уже  определенный   идентификатор
макро  будет вызывать предупреждение,  если только определение
не точно такое же, как предыдущее. В этом случае можно исполь-
зовать:
     #ifndef BLOCK_SIZE
       #define BLOCK_SIZE 512
     #endif
     Средняя строка  пропускается,  если BLOCK_SIZE определен;
если BLOCK_SIZE неопределен, то для его определения вызывается
средняя строка.  Заметим, что для завершения директивы препро-
цессора не требуется ";".  Любой символ из  последовательности
лексем,  включая  ";"  будет  появляться  в  расширении макро.
Последовательность лексем завершается первым встреченным  сим-
волом новой строки без "\".  Любая последовательность раздели-
телей,  включая комментарии, из последовательности лексем, за-
меняется одним символом пробела.
     Программисты языка Ассемблер должны не  поддаваться  соб-
лазну написать следующее:
     #define BLOCK_SIZE = 512
        /* ?? последовательность символов включает = */

                        Опции -D и -U.

     Идентификаторы могут   быть   определены  или  отключены,
используя опции командной строки компилятора -D и -U (См. гла-
ву  6  в руководстве пользователя).  Идентификаторы могут быть
определены, но не отключены из меню Options/Compiler/Defines в
интегрированной  среде (См.  главу 2 в руководстве пользовате-
ля).
     Командная строка
     bcc -Ddebug=1; paradox=0; X -Umysym myprog.c
эквивалентна
     #define debug 1
     #define paradox 0
     #define X
     #undef mysym
в программе.

                 Ключевые и защищенные слова.

     Разрешено, но нежелательно  использовать  ключевые  слова
Borland C++ как идентификаторы макро:
     #define int long    // разрешено, но вероятны ошибки
     #define INT long    // разрешено, и, возможно, полезно
     Следующие предопределенные глобальные  идентификаторы  не
могут  появляться  непосредственно  после  директив  #define и
#undef:
     __STDC__              __DATE__
     __FILE__              __TIME__
     __LINE__
     Примечание. Отметим лидирующие и заключающие двойные под-
черкивания.

                     Макро с параметрами.

     Для определения  макро  с  параметрами  используется син-
таксис:
     #define идентификатор-макро(<список-аргументов>)
        последовательность-лексем
     Заметим, что нельзя использовать разделители между  иден-
тификатором  макро  и "(".  Необязательный список аргументов -
это последовательность идентификаторов,  разделенных запятыми.
Каждый  идентификатор  играет  роль  формального аргумента или
"хранителя места".
     Примечание: Любая запятая внутри () в  списке  аргументов
интерпретируется как часть аргумента, а не как разделитель ар-
гументов.
     Макро может быть вызвано:
     идентификатор-макро<разделитель>(<список-действительных-
       аргументов>)
в последующем исходном коде.  Синтаксис идентичен вызову функ-
ции; и в действительности многие "функции" стандартной библио-
теки С реализованы как макро. Однако существует некоторые важ-
ные семантические различия и возможны потенциальные ошибки.
     Необязательный список  действительных  аргументов  должен
содержать то же число последовательностей лексем,  разделенных
запятыми,  известных как действительные аргументы, сколько за-
дано в списке формальных аргументов в #define, т.е. для каждо-
го формального аргумента должен быть действительный  аргумент.
Если  число  аргументов  в двух списках различается,  выдается
ошибка.
     Вызов макро приводит к двум замещениям.  Во-первых, иден-
тификатор макро и аргументы в  скобках  замещаются  последова-
тельностью лексем. Затем все формальные аргументы, встретивши-
еся в последовательности лексем,  заменяются  соответствующими
аргументами из списка действительных аргументов. Например
     #define CUBE(x)  { (x)*(x)*(x) }
     ...
     int n, y;
     n = CUBE(y);
приводит к следующей подстановке:
     n = ((y)*(y)*(y));
Аналогично, последняя строка
     #define SUM ((a) + (b))
     ...
     int i, j, sum;
     sum = SUM(i,j);
расширяется в sum = ((i)+(j)).  Причина такого изобилия скобок
станет ясна, если Вы рассмотрите вызов
     n = CUBE(y+1);
     Без внутренних () в определении  это  будет  расширяться,
как n = y + 1 * y + 1 * y + 1, что будет анализироваться как
     n = y + (1*y) + (1*y) + 1
     // != (y+1) в кубе, если не y=0 или y=-3!
     Как и для простого макроопределения,  производится после-
дующее сканирование для определения любых идентификаторов мак-
ро для последующего расширения.
     Опишем тонкости, когда используется макро со списками ар-
гументов:
     1. Вложенные () и запятые: список действительных аргумен-
тов может содержать вложенные (),  которые  должны  быть  сба-
лансированы;  запятые,  появляющиеся внутри кавычек или (), не
рассматриваются как разделители аргументов:
     #define ERRMSG(x, str) showerr("Error", x, str)
     #define SUM(x, y)  ((x) + (y))
     ...
     ERRMSG(2, "Нажмите Enter или Esc");
   /* расширяется в showerr("Error",2,"Нажмите Enter или Esc"); */
     return SUM(f(i,j), g(k,l));
     /* расширяется для возврата (f(i,j) + g(k,l)); */
     2. Лексемы,  соединенные с помощью ##:  Вы можете склеить
(или объединить) две лексемы,  разделив их ## (могут быть раз-
делители с обоих сторон).  Препроцессор удаляет разделители  и
##, объединяя разделенные лексемы в одну новую лексему. Вы мо-
жете таким образом создавать идентификаторы;  например с опре-
делением
     #define VAR(i,j) (j##j)
     вызов VAR(x,6)  будет  расширяться  в (x6).  Это заменяет
старый (не переносимый) метод использования (i/**/j).
     3. Преобразование в строку с #:  В начале формального ар-
гумента макро может быть помещен символ # для того, чтобы пре-
образовать  действительный  аргумент в строку после замещения.
Так макроопределение:
     #define TRACE(flag) printf(#flag "=%d\n", flag)
и фрагмент кода
     int highval = 1024;
     TRACE(highval);
становится
     int highval = 1024;
     printf("highval" "= %d\n", highval);
который интерпретируется как
     int highval = 1024;
     printf("highval=%d\n", highval);
     4. \  для конкатенации строк:  Длинная последовательность
лексем может быть разбита на строки с  использованием  \.  При
расширении \ и символ новой строки удаляются:
     #define WARN "Это очень-\
     длинная строка"
     ...
     puts(WARN);
     /* экран покажет: "Это очень-длинная строка" */
     5. Сторонние  эффекты  и другие опасности:  Подобие между
вызовами функций и макро часто приводят к недоразумениям.  Вы-
зов  макро не имеет встроенной проверки типов и несоответствие
между типами данных формальных и действительных аргументов мо-
гут привести к ошибочному,  трудноотлаживаемому результату без
выдачи сообщений.  Вызовы макро могут так же приводить к неже-
лательным  сторонним  эффектам,  особенно когда действительный
аргумент вычисляется более одного раза. Сравните CUBE и cube в
следующем примере
     int cube(int x)  {
       return x*x*x;
     }
     #define CUBE(x)  ((x)*(x)*(x))
     ...
     int b = 0, a = 3;
     b = cube(a++);
       // в cube() передается arg = 3; так, что b = 27, now = 4
     a = 3;
     b = CUBE(a++);
       // расширяется как ((a++)*(a++)*(a++)); now = 6
     Примечание. Конечное значение b зависит от того,  что де-
лает компилятор для расширения выражения.

             Включение файла с помощью #include.

     Директива #include включает файлы, известные как включае-
мые  файлы,  файлы  заголовков или заголовки,  в исходный код.
Синтаксис
     #include <имя-заголовка>
     #include "имя-заголовка"
     #include идентификатор-макро
     Примечание: <> - это действительная  лексема,  а  не  ме-
тасимволы, указывающие, что имя-заголовка необязательно.
     В третьем варианте не появляется ни <,  ни ",  как первый
неразделительный  символ  после #include;  макро должно расши-
ряться в имя-заголовка в формате <имя-заголовка> или  "имя-за-
головка".
     В первом и втором варианте макро  расширяться  не  будут;
другими  словами,  имя-заголовка  никогда  не  сканируется для
идентификаторов макро.  Имя_ заголовка рассматривается как имя
файла  DOS с расширением (обычно .h для заголовка) и возможным
указанием пути файла.
     Препроцессор удаляет   строку   #include  и  заменяет  ее
текстом файла заголовка.  Сам исходный код не  изменяется,  но
компилятор "видит" вставляемый текст.  Следовательно помещение
#include может влиять на сферу и время действия любого иденти-
фикатора во включаемом файле.
     Если Вы задаете явный путь имени заголовка,  только  этот
справочник будет просматриваться.
     Различие между форматами <имя-заголовка> и  "имя-заголов-
ка" в алгоритмах поиска включаемого файла.

            Поиск файла заголовка <имя-заголовка>.

     Вариант <имя-заголовка>   задает  стандартный  включаемый
файл.  Поиск проводится в каждом  из  справочников  включаемых
файлов в порядке их определения.  Если файл не найден ни в од-
ном из этих справочников по умолчанию,  выдается сообщение  об
ошибке.

            Поиск файла заголовка "имя-заголовка".

     Вариант "имя-заголовка"  задает включаемый файл пользова-
теля;  вначале файл ищется в текущем справочнике (обычно спра-
вочник,  содержащий компилируемый файл). Если файл не найден в
этом справочнике, поиск продолжается в справочниках включения,
как в случае <имя-заголовка>. Рассмотрим пример
     #include (stdio.h>
     /* заголовок в стандартном справочнике включения */
     #define myinclude  "c:\borlandc\include\mystuff.h"
     /* заметим: одиночный обратный слеш здесь употреблен пра-
вильно; внутри утверждения С Вы должны написать:
     "C:\\BORLANDC\\INCLUDE\\mystuff.h"    */
     #include myinclude         // макрорасширение
     #include "myinclude.h"     // нет расширения макро
     После расширения, второй оператор #include задает поиск в
C:\BORLANDC\INCLUDE\mstuff.h  и  нигде более.  Третий #include
приводит к поиску myinclude.h в текущем справочнике, а затем в
справочниках по умолчанию.

                     Условная компиляция.

     Borland C++  поддерживает  условную  компиляцию,  заменяя
соответствующие строки исходного кода пустой строкой.  Строки,
которые  начинаются  с  #,  игнорируются  (кроме директив #if,
#ifdef, #ifndef, #else, #elif и #endif), также как все строки,
которые не должны компилироваться как результат директив.  Все
директивы условной компиляции должны  полностью  находиться  в
исходном или во включаемом файле, в котором они начинаются.

     Директивы условной компиляции #if, #elif, #else, #endif.

     Директивы условной компиляции #if,  #elif,  #else, #endif
работают как обычные условные операторы С. Они используются:
     #if константное-выражение1
     <секция1>
     <#elif константное-выражение2 новая-строка секция2>
        ...
     <#elif константное-выражениеn новая-строка секцияn>
        ...
     <#else последняя-секция>
     #endif
     Если константное-выражение1  вычисляется  не  в 0 (true),
строки кода (возможно пустые),  представленные секцией1,  либо
это строки с командами препроцессора, либо это строки исходно-
го кода обрабатываются препроцессором и передаются в  компиля-
тор Borland C++.  Иначе,  если константное-выражение1 вычисля-
ется в 0 (false),  секция1 игнорируется (не макрорасширяется и
не компилируется).
     В случае true после препроцессорной обработки секции1 уп-
равление  передается на соответствующую #endif (которая закан-
чивает условный эпизод),  и продолжается со следующей секцией.
В  случае false управление передается на следующую #elif (если
она есть) и вычисляется  константное-выражение2  и  т.д.  Если
true, то секция2 обрабатывается, после чего управление перехо-
дит  на  соответствующий  #endif.  В  противном  случае,  если
константное-выражение2 false,  то управление переходит на сле-
дующую #elif,  и т.д.,  до тех пор,  пока не  исчерпаются  все
#else  или #endif.  Необязательная #else используется как аль-
тернативный вариант в случае,  если все предыдущие  тесты  вы-
числялись в false.  #endif заканчивает условную последователь-
ность.
     Секции могут  содержать  директиву  условной  компиляции,
вложенную на любую глубину; каждая #if должна быть сбалансиро-
вана закрывающей #endif.
     В результате действия директив условной компиляции только
одна  секция (возможно пустая) передается для дальнейшей обра-
ботки.  Пропущенные секции годятся только для  хранения  следа
вложенных условий, так что каждая директива #if получает соот-
ветствующую верную директиву #endif.
     Константные выражения    должны   вычисляться   в   целое
константное значение.

                      Оператор defined.

     Оператор defined обеспечивает альтернативный,  более гиб-
кий способ проверки, была ли определена комбинация идентифика-
торов или нет. Он допустим только в выражениях #if и #elif.
     Выражение defined(идентификатор)  или defined идентифика-
тор (круглые скобки необязательны)  вычисляется  в  1  (true),
если символ был предварительно определен (используя #define) и
не был отключен (используя #undef);  в противном случае он вы-
числяется в 0 (false). Так директива
     #if defined (mysym)
аналогична
     #ifdef mysym
     Преимущество defined  в  том,  что Вы можете использовать
его в сложных выражениях в #if, таких как
     #if defined(mysym) && !defined(yoursym)

       Директивы условной компиляции #ifdef и #ifndef.

     Директивы условной  компиляции #ifdef и #ifndef позволяют
Вам проверять определен идентификатор или нет, то есть была ли
обработана предыдущая команда #define для этого идентификатора
и находится ли она еще в силе. Строка
     #ifdef идентификатор
действует как
     #if 1
если идентификатор определен, и действует как
     #if 0
если идентификатор неопределен.
     #ifndef
возвращает true для "неопределенного" условия, и строка
     #ifndef идентификатор
действует как
     #if 0
если идентификатор определен, и действует как
     #if 1
если идентификатор неопределен.
     Синтаксис использования  такой  же,  как для #if,  #elif,
#else, #endif.
     Идентификатор, определенный как NULL считается определен-
ным.

                 Управляющая директива #line.

     Вы можете использовать команду #line для передачи номеров
строк  в  программу  для  перекрестных ссылок и выдачи ошибок.
Если программа состоит из частей, включенных из другого файла,
бывает  полезно пометить такие части номерами строк оригиналь-
ного файла, а не номерами строк результирующей программы. Син-
таксис
     #line целая-константа <"имя-файла">
     указывает, что  следующая  исходная  строка  получена  из
строки номер "целая-константа" файла "имя-файла".  После того,
как имя-файла было однажды указано, последующие команды #line,
относящиеся к этому файлу,  могут  использоваться  без  явного
имени файла. Например
     #include <stdio.h>
     #line 4 "junk.c"
     void main()
     {
       printf("in line %d of %s", __LINE__, __FILE__);
     #line 12 "temp.c"
       printf("\n");
       printf(" in line %d of %s", __LINE__, __FILE__);
     #line 8
       printf("\n");
       printf("in line %d of %s", __LINE__, __FILE__);
     }
     Примечание. Включение stdio.h означает, что вывод препро-
цессора будет большим.
     Если Вы обработаете TEMP.C с помощью CPP (cpp  temp),  Вы
получите файл TEMP.I; в виде:
     temp.c 1:
     c:\borland\tc\cpp\include\stdio.h 1:
     c:\borland\tc\cpp\include\stdio.h 2:
     c:\borland\tc\cpp\include\stdio.h 3:
     ...
     c:\borland\tc\cpp\include\stdio.h 212:
     c:\borland\tc\cpp\include\stdio.h 213:
     temp.c 2:
     temp.c 3:
     junk.c 4: void main()
     junk.c 5: {
     junk.c 6: printf(" in line %d of %s", 6, "junk.c");
     junk.c 7:
     temp.c 12: printf("\n");
     temp.c 13: printf(" in line %d of %s",13, "temp.c");
     temp.c 14:
     temp.c 8: printf("\n");
     temp.c 9: printf("in line %d of %s", 9, "temp.c");
     temp.c 10: }
     temp.c 11:
Если Вы откомпилируете TEMP.C Вы получите вывод:
     in line 6 of junk.c
     in line 13 of temp.c
     in line 9 of temp.c
     Макросы расширяются в аргументах #line как будто  бы  они
находятся в директиве #include.
     Директива #line обычно используется утилитами, генерирую-
щими код С как выходной, а не как написанный человеком код.

                      Директива #error.

     Директива #error имеет синтаксис:
     #error сообщение
Она выдает сообщение
     Error: имя-файла строка# : error directive: сообщение
     Эта директива  обычно используется с условными директива-
ми,  чтобы отловить некоторые  нежелательные  условия  времени
компиляции. Обычно это условие будет false. Если условие true,
Вы хотите,  чтобы компилятор вывел сообщение об ошибке и оста-
новил  компиляцию.  Вы делаете это,  поместив директиву #error
внутри условия, которое будет true для нежелательного случая.
     Например, предположим Вы определили #define MYVAL,  кото-
рое должно быть 0 или 1.  Вы можете включить следующее выраже-
ние  в  исходный  код  для  проверки  на некорректное значение
MYVAL:
     #if (MYVAL != 0 && MYVAL != 1)
     #error MYVAL должен быть определен от 0 до 1
     #endif

                      Директива #pragma.

     Директива #pragma применяется для директив,  зависимых от
реализации:
     #pragma имя-директивы
     С помощью #pragma Borland C++ может определить директивы,
которые не конфликтуют с другими компиляторами, поддерживающи-
ми #pragma.  Если компилятор не распознает имя  директивы,  он
игнорирует  директиву #pragma без выдачи ошибок или предупреж-
дений.
     Borland C++ поддерживает следующие директивы #pragma:
     - #pragma argsused
     - #pragma exit
     - #pragma hdrfile
     - #pragma hdrstop
     - #pragma inline
     - #pragma option
     - #pragma saveregs
     - #pragma startup
     - #pragma warn

                      #pragma argsused.

     argsused разрешенa только между определениями  функций  и
воздействует  только на следующую функцию.  Она запрещает пре-
дупреждающие сообщения:
     "Parameter name is never used in function func-name"
     (Параметр имя никогда не используется в функции имя)

               #pragma exit и #pragma startup.

     Эти директивы позволяют задать  функции,  которые  должны
вызываться  либо  перед  началом  работы  программы (до вызова
main),  либо при выходе из  программы  (непосредственно  перед
тем, как программа завершится через _exit).
     Синтаксис:
     #pragma exit имя-функции<приоритет>
     #pragma startup имя-функции<приоритет>
     Имя-функции должно  быть предварительно объявленной функ-
цией без аргументов и возвращающей void; т.е.
     void func(void);
     Необязательный параметр приоритет должен быть целым в ди-
апазоне от 64 до 255.  Наивысший приоритет 0. (Приоритеты от 0
до 63 используются библиотеками С и не  должны  использоваться
пользователем).  Функции с большим приоритетом вызываются пер-
выми при запуске программы и последними при  завершении.  Если
Вы не задали приоритет,  используется 100 по умолчанию. Напри-
мер
     #include <stdio.h>

     void startFunc(void)
     {
       printf("Startup function.\n");
     }
     #pragma startup startFunc 64

     void exitFunc(void)
     {
       printf("Wrapping up execution.\n");
     }

     #pragma exit exitFunc

     void main(void)
     {
       printf("This is main.\n");
     }
     Заметим, что имя-функции,  используемое в #pragma startup
или  exit,  должно быть определено (или объявлено) до строки с
директивой #pragma.

                       #pragma hrdfile.

     Эта директива устанавливает имя файла, в котором хранятся
откомпилированные заголовки.  По умолчанию это TCDEF.SYM. Син-
таксис:
     #pragmd hrdfile "filename.SYM"
     Если Вы не используете  откомпилированные  заголовки,  то
эта директива ни на что не влияет.
     Можно использовать  опцию  компилятора  командной  строки
-H=filename для изменения имени файла,  используемого для хра-
нения заголовков. См. главу 6 в Руководстве пользователя.

                       #pragma hrdstop.

     Эта директива завершает список файлов,  которые  подходят
для  перекомпиляции.  Можно  использовать  ее  для  уменьшения
пространства на диске, используемого для откомпилированных за-
головков.  (Про откомпилированные заголовки см. в Приложении А
Руководства пользователя).

                       #pragma inline.

     Эта директива эквивалентна  опции  компилятора  командной
строки  -В.  Она указывает компилятору на то,  что где-то есть
встроенный код ассемблера в Вашей программе (См.  главу 9 "Ин-
терфейс с языком Ассемблера"). Синтаксис:
     #pragma inline
     Ее лучше поместить в самом начале файла, поскольку компи-
лятор перезапускает себя с опцией -В,  когда встречает #pragma
inline.  В действительности Вы можете не использовать ни опцию
-В,  ни директиву #pragma inline и  компилятор  будет  переза-
пускать  себя,  как  только встретит оператор asm.  Назначение
этой опции и директивы в некотором сокращении времени компиля-
ции.

                       #pragma option.

     Используйте #pragma  option для включения опции командной
строки в код программы. Синтаксис
     #pragma option[опции...]
     Опции могут быть любой опцией командной строки, за исклю-
чением перечисленных в следующем параграфе.  В одной директиве
можно задать любое число опций.
     Любые переключаемые  опции  (такие  как  -а или -К) могут
быть включены и выключены как в командной  строке.  Они  могут
появляться после "." для переключения этой опции в их первона-
чальное состояние из командной строки,  файла  конфигурации  и
установок меню опций. Это позволяет Вам постоянно изменять оп-
ции, а затем возвращать их к значениям по умолчанию, без запо-
минания (и даже не зная их значений) точных установок по умол-
чанию.
     Опции, которые нельзя использовать в #pragma option:
     -B               -efilename          -lfilename
     -c               -E                  -Lfilename
     -dname           -Fx                 -lxset
     -Dname=string    -H                  -M
     -o               -S                  -V
     -P               -T                  -X
     -Q               -Uname              -Y
     Можно использовать #pragma, #include, #define и некоторые
#if перед:
     1. использованием любого имени макро,  которое начинается
двумя подчеркиваниями (и более того,  возможно является встро-
енным макро) в директивах #if, #ifdef, #ifndef и #elif.
     2. появлением первой действительной лексемы (первым  объ-
явлением С или С++).
     Определенные опции  могут  появляться  только  в  #pragma
option перед этими событиями. Этими опциями являются:
     -Efilename     -m*            -u
     -f*            -npath         -W
     -i#            -ofilename     -z*
     Другие опции могут изменяться везде.  Следующие опции бу-
дут иметь действие только если они были изменены между  объяв-
лениями функций или объектов:
     -1          -h          -r
     -2          -k          -rd
     -a          -N          -v
     -ff         -O          -y
     -G          -p          -Z
     Следующие опции  могут  быть  изменены  в  любое  время и
действуют немедленно:
     -A          -gn         -zE
     -b          -jn         -zF
     -C          -K          -zH
     -d          -wxxxx
     Они могут сопровождаться точкой (.) для установки опций в
первоначальное состояние командной строки.

                      #pragma saveregs.

     saveregs гарантирует,  что huge функция не будет изменять
значение любого регистра при вызове. Эта директива иногда тре-
буется для связи с ассемблерным кодом.  Эта  директива  должна
быть помещена непосредственно перед определением функции.  Она
применима именно к этой функции.

                        #pragma warn.

     Директива warn позволяет Вам  перекрыть  опцию  командной
строки  -wxxx  (или  кнопку  Display  Warnings в окне Options/
Compiler/ Messages).
     Например, если исходный код содержит директивы:
     #pragma warn +xxx
     #pragma warn -yyy
     #pragma warn .zzz
     ххх будет      включено     (даже     если     в     меню
Options/Compiler/Messages оно было включено), yyy выключено, а
zzz будет восстановлено в значение,  которое было, когда начал
компилироваться этот файл.
     Полный список предупреждений и их трехсимвольных аббреви-
атур дан в главе 6 "Компилятор командной  строки"  Руководства
Пользователя.

                   Предопределенные макро.

     Borland C++ предопределяет следующие глобальные идентифи-
каторы.  За исключением __cplusplus и _WINDOWS,  каждый из них
начинается и заканчивается двойным подчеркиванием ("__").

                        __BCPLUSPLUS__

     Это макро  специфично  для семейства компиляторов Borland
C++ и С.  Оно задает компиляцию только С++.  Если  Вы  выбрали
компиляцию С++,  то она задается как 0х0200, шестнадцатиричная
константа.  Это числовое значение будет увеличиваться в после-
дующих реализациях.

                         __BORLANDC__

     Это макро  специфичен  для семейства компиляторов Borland
C++ и С.  Оно задается как 0х0200,  16-ричная  константа.  Это
числовое значение будет увеличиваться в последующих реализаци-
ях.

                          __CDECL__

     Это макро специфично для семейства  компиляторов  Borland
C++ и С.  Оно указывает,  что флаг -р не используется (Calling
Convention...  C): установлено в целую константу 1, если -р не
используется; иначе неопределено.
     Следующие 6 символов определены для  указания  на  модель
памяти, выбранную во время компиляции.
     __COMPACT__                __MEDIUM__
     __HUGE__                   __SMALL__
     __LARGE__                  __TINY__
     Во время компиляции определен только один из них;  другие
неопределены.  Например, если Вы компилируете с моделью small,
__SMALL__ определено, а остальные нет, так что директива
     #if defined(__SMALL__)
будет true, а
     #if defined(__HUGE__)
     (или любая другая) будет false.  Определенное макро имеет
значение 1.

                         __cplusplus

     Это макро специфично для семейства  компиляторов  Borland
C++ и С. Это позволяет Вам писать модуль, который будет иногда
компилироваться как С,  а иногда как C++.  Используя  условную
компиляцию, Вы можете управлять включением частей С и C++.

                           __DATE__

     Это макро выдает дату, когда препроцессор начал обработку
текущего исходного файла (как литеральную строку).
     Каждое включение __DATA__ в данном файле содержит опреде-
ленное значение вне зависимости от длительности обработки. Да-
та  появляется  в формате mmm dd yyyy ,  где mmm - месяц (Jan,
Feb, ...), dd - день (первый символ dd - пробел, если значение
меньше 10) и yyyy - год.

                           __DLL__

     Это макро  специфично  для семейства компиляторов Borland
C++ и С.  Оно задано в 1, если Вы компилируете модуль с опцией
компилятора командной строки -WD (генерируется код для Windows
DLL); иначе оно остается неопределенным.

                           __FILE__

     Это макро выдает имя текущего исходного файла (как  лите-
ральную строку).  Это макро изменяется, когда компилятор обра-
батывает директиву #include или #line или когда включение фай-
ла завершено.

                           __LINE__

     Это макро  выдает  номер  обрабатываемой  строки текущего
исходного файла  (как  десятичную  константу).  Обычно  первая
строка  исходного  файла определена как 1,  но директива #line
может изменить это.

                          __MSDOS__

     Это макро специфично для семейства  компиляторов  Borland
C++ и С. Оно выдает целую константу 1 для всех компиляций.

                         __OVERLAY__

     Это макро  специфично  для семейства компиляторов Borland
C++ и С. Оно выдает 1, если Вы компилируете модуль с опцией -Y
(поддержка оверлеев включена); иначе неопределено.

                          __PASCAL__

     Это макро  специфично  для семейства компиляторов Borland
C++ и С.  Оно указывает, что используется флаг -p. В этом слу-
чае оно установлено в целую константу 1; иначе неопределено.

                           __STDC__

     Это макро определено как константа 1, если Вы компилируе-
те с флагом совместимости с ANSI (-А или ANSI Keywords Only...
On); иначе неопределено.

                           __TIME__

     Это макро содержит время,  когда препроцессор начал обра-
ботку текущего исходного файла (как литеральную строку).
     Как и  с __DATA__ каждое включение __TIME__ содержит одно
значение, вне зависимости от длительности обработки. Оно имеет
формат hh:mm:ss,  где hh - часы (от 00 до 23), mm - минуты (от
00 до 59), ss - секунды (от 00 до 59).

                        __TCPLUSPLUS__

     Это макро специфично для семейства  компиляторов  Borland
C++ и С.  Оно определяется только для компиляций С++.  Если Вы
выбрали компиляцию С++,  то оно  определено  как  0х0200.  Это
числовое значение будет увеличено при последующих реализациях.

                          __TURBOC__
     
     Это макро  специфично  для семейства компиляторов Borland
C++ и С.  Оно определено как 0х0297,  16-ричная константа. Это
числовое значение будет увеличено при последующих реализациях.

                           _WINDOWS

     Это макро определено, если Вы компилируете модуль с любы-
ми включенными опциями компилятора командной строки -W  (гене-
рация  приложений  Windows).  Если  Вы не включаете ни одну из
этих опций, это макро не определено.
