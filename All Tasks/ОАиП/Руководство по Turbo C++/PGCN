                        ПРИЛОЖЕНИЕ С.
                 БИБЛИОТЕКА КЛАССОВ ХРАНЕНИЯ.

     Это приложение   содержит   вводное   описание  библиотек
классов хранения Borland C++.  Здесь  предполагается,  что  Вы
знакомы с синтаксисом и семантикой С++ и с основными концепци-
ями объектно-ориентированного программирования.  Глава делится
на четыре части:  Первая часть дает обзор библиотечных классов
и некоторые важные  концепции,  касающиеся  библиотек;  вторая
часть рассматривает  соглашения,  используемые  в  библиотеках
класса. Третья  часть  описывает  справочник  CLASSLIB  и  его
использование. Четвертая часть - это справочное руководство по
каждому классу в библиотеке.
     Примечание. Более подробную информацию по С++ см.  в гла-
вах 4 и 5 в руководстве "Начало работы" и в главах с 1 по 3  и
в 5 главе Руководства программиста.

                 Обзор и основные концепции.

     Библиотека класса   хранения   предоставляет  классы  для
структур данных общего использования (списков,  стеков, очере-
дей и т.д.). Классы организуют иерархию классов, что допускает
высшую степень модулярности через наследование и  полиморфизм.
Можно использовать  эти классы в таком виде,  как они есть,  а
можно расширить их для создания объектно-ориентированного  па-
кета соответственно своим потребностям.
     Вверху иерархии класса стоит класс  Object  (см.  рисунок
С.1). Object является абстрактным классом, то есть он не пред-
назначен для того, чтобы иметь какие-либо переменные объявлен-
ных им типов.  Абстрактный класс главным образом служит как бы
"зонтиком" для родственных классов.  Он имеет  мало  элементов
данных  (если они вообще есть),  а его элементы-функции обычно
бывают чистыми виртуальными функциями (функции, которые никог-
да не вызываются прямо,  а только "держат" место для функций с
таким же именем,  определенных  в  порожденных  классах).  Не-
абстрактные классы,   предназначенные   для  непосредственного
использования, называются классами образцов.
     При чтении  этой  главы  помните,  что порожденные классы
наследуют все элементы данных и  элементы-функции  всех  своих
базовых родительских классов.  Например, классу Array не нужно
явно определять функцию для печати массива, потому что это бу-
дет делать    его    непосредственный    родительский    класс
AbstractArray. Класс Container,  наследник всего стоящего  над
ним дерева,  определяет  другую функцию печати,  которая также
может использоваться для массива,  поскольку  массив  является
хранителем. Чтобы  определить все элементы-функции,  доступные
объекту, надо подняться  вверх  по  дереву  иерархии  классов.
Поскольку общий  интерфейс  предназначается для удовлетворения
потребностей всех приложений, то объектно-ориентированное про-
граммирование делает  необязательным знание закрытых элементов
данных; поэтому элементы данных не приведены в этой главе.
     Примечание. Чтобы  лучше понять классы,  можно посмотреть
их полные определения в файлах исходных  кодов  в  справочнике
CLASSLIB.

                         Рисунок С.1.
                 Иерархия классов в CLASSLIB.

Object─┬─Error
       ├─Sortable─┬─String
       │          ├─BaseDate──Date
       │          └─BaseTime──Time
       ├─Association
       └Container─┬─Collection─┬─AbstractArray─┬─Array
                  │            │               └─SortedArray
                  │            ├─HashTable──Bag──Dictionary
                  │            ├─List
                  │            └─DoubleList
                  ├─Stack
                  ├─Queue
                  └─Deque

ContainerIterator──┬──HashTableIterator
                   ├──ListIterator
                   ├──DoubleListIterator
                   └──ArrayIterator
DoubleListElement

ListElement

           Абстрактные классы в объектной иерархии.

     Иерархия, основанная на объектах,  включает элементы дан-
ных, порожденные от одного  абстрактного  базового  класса.  В
библиотеке класса хранителей класс Object служит корнем иерар-
хии. Object предоставляет минимальный набор определений, какие
должны сделать порожденные классы.

                      Классы хранителей.

     Классы в иерархии класса Object делятся на два логических
множества: классы,  содержащие  объекты  других   классов,   и
классы, их не содержащие.  Первое множество называется классом
Container. Класс Array, например, поддерживает порядок коллек-
ции объектов.  Таким образом, класс Array является порождением
класса Container.

                 Право собственности объекта.

     Перед использованием класса Container или других  классов
этого семейства  нужно  понять  концепцию  права собственности
объектов. В реальной жизни хранитель С++ появляется  пустым  и
должен заполняться объектами до того,  как будет сказано,  что
объект должен находиться в хранителе. Однако как только объек-
ты помещаются в хранитель,  они становятся его собственностью.
Это истина для хранителей библиотек классов. Если не было под-
ходящего случая,  добавьте объект в хранитель, затем разрушьте
сам объект,  чтобы хранитель не знал, что объект разрушен. Это
оставит хранитель в очень запутанном состоянии.
     Когда хранитель присваивает объект,  Вы не должны  разру-
шать объект, вначале не удалив его из хранителя. Или Вы можете
попросить, чтобы хранитель разрушил этот объект для  Вас.  Это
ограничение основано  на правилах сферы действия и распределе-
нии памяти в С++.
     ВАЖНО! Если  Вы  объявили  автоматический объект (то есть
объект, локальный для Вашей подпрограммы),  и  поместили  этот
объект в  глобальный хранитель,  то Ваш локальный объект будет
разрушен, когда подпрограмма оставит сферу действия, в которой
он был объявлен.  Чтобы предотвратить это, ВЫ ДОЛЖНЫ ДОБАВЛЯТЬ
ТОЛЬКО ОБЪЕКТЫ КУЧИ (объекты, не являющиеся локальными для те-
кущей сферы действия) В ГЛОБАЛЬНЫЙ ХРАНИТЕЛЬ. Аналогично, ког-
да Вы удаляете объект из глобального хранителя, Вы присваивае-
те этот  объект  и  отвечаете за его разрушение и освобождение
места, в котором он находился.

               Группировка последовательности.

     Классы Stack,  Queue и Deque известны как  последователь-
ности. Последовательность определяет группу объектов, соблюда-
ющую следующие правила:
     1. Объекты можно вставлять и удалять.
     2. Порядок вставки и удаления имеет важное значение.
     3. Вставка  и удаление в соответствующей точке происходит
так, как определено конкретным классом.
     Последовательность предоставляет механизм для определения
того, имеются ли какие-либо элементы группы.  Это  выполняется
функцией isEmpty.
     Группировка последовательностей сама по себе  классом  не
является, поскольку классы,  составляющие группировку, не раз-
деляют  много  общего,  что  подтверждают  различные   базовые
классы. Однако Вы можете найти это полезным при рассматривании
классов вместе во время обзора иерархии объектов.

                     Иерархия коллекции.

     Классы, порожденные от абстрактного класса  Collection  -
это классы,  которые Вы будете использовать больше всего. Нап-
ример, поскольку коллекции предоставляют метод  для  собирания
объектов вместе и оперирования ими,  Вы можете начать с созда-
ния конкретного  раздела  проекта,  используя  свойства,  пре-
доставленные классом Collection. Позднее, когда Вы изучите ха-
рактеристики проекта,  Вы  можете  сделать  особую  реализацию
класса Collection, нужную для себя.
     Класс Collection обеспечивает свойство использовать  объ-
екты различных  порожденных  классов,  таких как Array,  Set и
Bag, меняя  их  по  мере  того,  как  ограничиваются  функции,
доступные для  Collection.  Collection  отличается от класса в
группировке последовательности свойством определять,  является
ли объект элементом Collection.

                  Неупорядоченные коллекции.

     Неупорядоченная коллекция  -  это  класс,  порожденный от
Collection, в котором порядок объектов в  классе  не  различа-
ется. Классы, попадающие в эту категорию:
     - Hash Table и порожденные от  него  классы  Bag,  Set  и
       Dictionary;
     - List и DoubleList.
     Поскольку класс неупорядоченной коллекции требует только,
чтобы объект можно было проверить на принадлежность этой  кол-
лекции, то в неупорядоченную коллекцию можно поместить объекты
любого класса,  порожденного от абстрактного  базового  класса
Object.

                   Упорядоченные коллекции.

     Класс, являющийся    упорядоченной   коллекцией,   должен
составляться из объектов,  для которых  определяются  операции
порядка; то  есть  они  должны порождаться от класса Sortable.
Классы, являющиеся    упорядоченной    коллекцией    -     это
AbstractArray, а их порожденные классы  Array и SortedArray.

                 Иерархия ContainerIterator.

     Каждый класс  в  иерархии,  основанной  на классе Object,
должен иметь средства для итерации через любые подобъекты, со-
держащиеся в нем.  Иерархия,  основанная на ContainerIterator,
осуществляет это требование.  Абстрактный базовый  класс  этой
иерархии, ContainerIterator,    объявлен   как   дружественный
абстрактному базовому классу Object.  Эта связь означает,  что
можно применить  итераторы  к каждому объекту иерархии классов
Object без необходимости знать происхождение объекта,  который
Вы повторяете.
     Итераторы часто встречаются в программах С. Чтобы иллюст-
рировать эту ситуацию,  приведем пример использования итерато-
ров в С и транслируем этот пример в  С++.  Следующий  фрагмент
кода С  использует итератор для пошагового прохождения по эле-
ментам массива строк.
     char *text[] = {"this", "is", "some", "text", 0 };
     char **cur = text;

     while (*cur != 0)
     {
       . . .
       cur++;
     }
     Шагами итерации являются:
     1. Инициализировать итератор. Это происходит в объявлении
и операторе инициализации,  который начинается cur  *text[]  =
{... .
     2. Проверять итератор на  завершение  процесса  итерации.
Это происходит в операторе: while (*cur != 0).
     3. Увеличивать итератор. Это выполняется оператором cur++.
     Расширим эту  форму в С++.  Приведенный выше пример можно
написать следующим образом:
     Array myArray(. . .);
     ContainerIterator myIterator = myArray.initIterator();
     while (myIterator != 0)
     {
       . . .
       myIterator++;
     }
     Следовательно, чтобы класс был итератором, он должен:
     1. Перегрузить  оператор  увеличения  operator++().  Этот
оператор должен возвращать ссылку на следующий объект в после-
довательности итерации.
     2. Предоставить оператор,  который будет  преобразовывать
итератор в предопределенный тип int.  Это преобразование необ-
ходимо для того,  чтобы сообщить пользователям итератора,  что
слева в итерационной последовательности нет больше объектов.
     3. Предоставить функцию для повторного  запуска  процесса
итерации в любой момент времени после того, как программа соз-
даст итератор.
     Допустимыми итераторами в библиотеке классов являются:
     - HashTableIterator;
     - ListIterator;
     - DoubleListIterator;
     - ArrayIterator.
     Заметим, что   DoubleListIterator   определяет   оператор
уменьшения, operator--(),  вдобавок к другим требуемым функци-
ям. Этот  оператор  появляется  в  классе  DoubleListIterator,
поскольку  DoubleList можно пройти в любом направлении.

       Соглашения, используемые в библиотеках классов.

     Чтобы обеспечить последовательный интерфейс к коду в биб-
лиотеках классов С++,  принимаются следующие соглашения. Пред-
полагается, что Вы будете выполнять эти соглашения;  это помо-
жет уменьшить возможность конфликтов имен и другие проблемы.

                       Название файлов.

     Файлы, содержащие  определения  классов,  называются   по
классу, с некоторыми изменениями, необходимыми из-за ограниче-
ния имени файла DOS в 8 символов.
     Следовательно, файл set.h содержит определение для класса
Set. Дополнительно,  файл SET.CPP содержит реализацию для эле-
ментов-функций для класса Set. Если элементы-функции не требу-
ются, то файл .CPP для класса можно пропустить.
     Файлы заголовков  содержат  директивы  препроцессора  для
предотвращения многочисленных включений.  Каждый файл заголов-
ков тестируется на определение __<filename>_H. Если это имя не
определено, то файл заголовков определяет его.

                      Исходные названия.

     Имена классов в библиотеке начинаются с  прописных  букв.
Аналогично каждое  слово в имени класса начинается с прописной
буквы (например,  класс DoubleList).  Элементы-функции  класса
должны начинаться  со  строчной  буквы,  но каждое последующее
слово должно начинаться с прописной буквы (например, printOn).
     Имена личной  части  класса  состоят  только  из строчных
букв. Имена элементов-функций класса и  параметров  выбираются
на основе  их  способности  отразить эффективно и правильно их
значение. Например,  если не нужно скрыть  факт,  что  элемент
данных является указателем, то все имена указателей заканчива-
ются на Ptr, как aPtr.
     Имена типов  в библиотеке класса также выполняют эти сог-
лашения. Все имена типов выполняют правила  для  имен  элемен-
тов-функций и    заканчиваются    словом    Type;    например,
hashValueType. Типы указателей заканчиваются на PtrType.

                    Стиль комментирования.

     Если Вы посмотрели исходный код для библиотек классов, то
Вы могли заметить, что используемый для комментариев стиль от-
личается от того,  к которому Вы привыкли.  Хотя вначале  этот
стиль может приводить в замешательство,  но в его основе лежат
структура и организация,  которые делают проще работу с  доку-
ментацией и поддержкой больших программ.  Вдобавок комментарии
помогают читателю,  не знающему способности библиотеки, разоб-
раться в несметном количестве доступного кода.
     Следующие параграфы набрасывают в общих чертах  структуру
каждого из больших разделов, составляющих исходный файл. Реко-
мендуем Вам исследовать исходный код,  чтобы  посмотреть,  как
располагаются отдельные части в исходном коде.

                      Заголовок модуля.

     Каждый файл,  или  модуль,  в библиотеке классов содержит
исходный заголовок,  который появляется сразу после отметки  о
правах копирования. Формат этого заголовка модуля такой:
     // Модуль //
     // Содержание ------------------------------------------
     //
     // Функции, переменные, классы, типы и т.д., составляющие
     // модуль, перечисляются здесь.
     //
     // Описание
     //
     // Здесь приводится точное описание содержимого модуля и
     // как оно относится к другим классам в библиотеке.
     //
     // Конец ------------------------------------------------

                         Зависимости.

     Важная часть любого исходного  файла  С  или  С++  -  это
список файлов,  которые  включаются  как часть этого исходного
файла. Говорится,  что исходный файл зависит от  этих  файлов.
Эта зависимость возникает в двух случаях.  Во-первых,  функция
или класс внутри файла могут включать в своем  прототипе  тип,
определенный в другом файле. Эта зависимость называется интер-
фейсной зависимостью,  так как она влияет на информацию о про-
тотипе, или интерфейсе, исходного файла. Зависимости этого ти-
па помещаются в раздел интерфейсной зависимости,  который выг-
лядит так:
     // Интерфейсные зависимости ----------------------------
     здесь идут #include, или // Нет ничего, если нет интер-
                              // фейсных зависимостей
     // Конец интерфейсных зависимостей---------------------
     Во-вторых, зависимость может возникнуть,  когда операторы
функции требуют определение, которое находится в другом файле,
как объявление  локальной  переменной  типа,  определенного  в
stdib.h. Эти зависимости помещаются в область  реализации  за-
висимостей, имеющую следующий формат:
     // Зависимости реализации ------------------------------
     #include здесь идут, или // Нет ничего, если нет зависи-
                              // мостей реализации
     // Конец зависимостей реализации------------------------

                       Заголовок типа.

     Каждое определение типа,  класса и структуры имеет  соот-
ветствующий заголовок,  который идет за определением. Этот за-
головок описывает элемент, его использование и определяет эле-
менты структуры  или класса.  Заголовок класса имеет следующий
формат:
     // Класс // (или тип, структура)
     Здесь идет определение класса
     // Описание --------------------------------------------
     //
     //        Точное описание элемента и как его использовать.
     //
     // Здесь перечисляются элементы класса или структуры.
     //
     // Конец ------------------------------------------------

                      Заголовок функции.

     Каждая функция,  констрактор, дестрактор, элемент-функция
или дружественная функция имеет заголовок, который стоит после
прототипа функции,  но перед телом реализации. Заголовок пере-
числяет и описывает параметры функции,  возвращаемое значение,
внутреннюю  работу  функции и перечисляет замечания о побочных
эффектах, предположения и общие предупреждения и предостереже-
ния. Формат заголовка функции приведен ниже.
     // Функция // (или элемент функции, констрактор и т.д.)
     function prototype
     // Изложение функции ------------------------------------
     //
     //                 Точное изложение функции
     //
     // Параметры
     //
     //                 Описание каждого из параметров функции
     //                 и как их использовать.
     //
     // Возвращаемое значение
     //
     //                 Описание значения, возвращаемое
     //                 подпрограмме, вызвавшей функцию.
     //
     // Функциональное описание
     //
     //                 Описание всего хода и операций функции
     //
     // Замечания
     //
     //                 Список побочных эффектов,
     //                 предположений, предупреждений и
     //                 предостережений.
     //
     // Конец ------------------------------------------------

                      Комментарии тела.

     Комментарии, стоящие внутри тела функции, называются ком-
ментариями тела. Они вводят читателя в курс дела по реализации
функции. Комментарий тела имеет следующую форму:
     // Комментарии тела
     //
     //                    Здесь идут комментарии.
     //
     // Конец

                Справочник библиотеки классов.

     Файлы в библиотеке классов устанавливают следующую струк-
туру справочника:
                     ╔═══════════╗
                     ║ CLASSLIB\ ║
                     ╚══════╤════╝
     ┌───────────┬──────────┼────────────────┬──────────┐
╔════╧═══╗  ╔════╧═══╗  ┌───┴─────────┐   ╔══╧══╗  ╔════╧════╗
║INCLUDE\║  ║ SOURCE\║  │ CLASSLIB.DOC│   ║ LIB\║  ║ EXAMPLES║
╚════════╝  ╚════════╝  └─────────────┘   ╚═════╝  ╚═════════╝
     Справочник CLASSLIB является  справочником  Borland  C++.
Содержание справочников в библиотеке классов обсуждается более
детально в следующих разделах.


                     Справочник INCLUDE.

     Справочник INCLUDE содержит файлы заголовков, необходимые
для компиляции  программы,  использующей  библиотеку  классов.
Нужно поместить  этот  справочник на пути поиска включений при
компиляции своей программы.

                      Справочник SOURCE.

     Справочник SOURCE содержит исходные файлы, которые реали-
зуют многие элементы-функции классов в библиотеке.  Эти исход-
ные файлы предоставляются как руководство для реализации новых
классов.
     Эти файлы также могут понадобиться,  если Вы хотите пост-
роить библиотеку с моделью памяти,  отличающейся от той, кото-
рая предоставлена на диске реализации. Пакетный файл BUILD.BAT
строит библиотеку  классов  заданной  модели памяти и помещает
эту библиотеку в справочник LIB.  Чтобы построить  библиотеку,
использующую модель памяти large,  наберите BUILD L в справоч-
нике SOURCE. Когда Вы сделаете это, пакетный файл вызовет ком-
пилятор для  построения  всех  файлов  в  библиотеке  классов,
используя large модель.  Затем архиватор библиотечных  файлов,
TLIB, создаст библиотеку TCLASS.LIB в подсправочнике LIB спра-
вочника CLASSLIB.
     ВАЖНО! Когда Вы используете библиотеку, которую построили
в одном из проектов образцов,  Вы должны изменить  библиотеку,
которая включается  в  Ваш проект,  на ту,  которую построили.
Также Вы должны проследить,  чтобы компиляция  Вашего  проекта
шла точно  с  теми  переключателями  и опциями,  с которыми Вы
строили библиотеку.  Если они будут отличаться, то Вы получите
предупреждения от редактора при построении файла .ЕХЕ.

                       Справочник LIB.

     Справочник LIB  содержит компилированные исходные модули,
архивированные в библиотеку.  Нужно поместить этот  справочник
на пути поиска библиотек при редактировании программы. если Вы
строите другие модели памяти библиотек  класса,  то  поместите
результирующие библиотеки в этот справочник.

                     Справочник EXAMPLES.

     Справочник EXAMPLES  содержит  примерные  программы  и их
проектные файлы. Вы можете откомпилировать эти программы, что-
бы посмотреть,  как помещаются вместе части библиотеки классов
для формирования приложения.  Большинство примеров  используют
один или  более  классов  в иерархии.  Другие примеры сложнее.
Примерные программы и классы,  которые они  используют,  пере-
числены ниже:
     1. STRNGMAX:  Очень простой  пример,  использующий  класс
String.
     2. REVERSE:  Средний пример,  использующий классы Stack и
String.
     3. LOOKUP: Средний пример, использующий классы Dictionary
и Association.
     4. QUEUETST:  Средний пример,  использующий класс Queue и
вводящий неиерархический класс Time.
     5. DIRECTRY:  Сложный пример, который иллюстрирует порож-
денные пользователем классы и использует класс SortedArray.

                     Справочник классов.

     Остаток этой главы будет посвящен описанию каждого класса
в библиотеке классов.  Используемые соглашения аналогичны сог-
лашениям, принятым  в  справочном  руководстве по библиотекам.
Для каждого класса  сообщается,  какого  он  типа,  от  какого
класса (классов) он порожден, какие классы можно от него поро-
дить (другими словами, какие классы для каких являются базой);
какие дружественные отношения существуют, некоторые замечания,
элементы-функции и пример использования класса.


     AbstractArray
_______________________________________________________________
Тип класса                   Абстрактный
Порожден от                  Collection
База для                     Array, SortedArray
Дружественен к               Нет
Имеет дружественные классы   ArrayIterator

Замечания  Класс AbstractArray имеет случайный доступ  к  эле-
           ментам коллекции. То, что объект должен быть масси-
           вом,  подразумевает, что можно применить индекс для
           доступа  к  элементам этого объекта.  AbstractArray
           существует   потому,   что    порожденные    классы
           SortedArray  и Array имеют достаточно много для то-
           го, чтобы скомбинировать общие свойства в абстракт-
           ный  базовый класс для этих классов.  Поскольку по-
           рожденные классы отличаются только реализацией эле-
           ментов-функций add,  detach и индексным оператором,
           то оставшиеся функции могут быть инкапсулированы  в
           AbstractArray.

Элементы-  AbstractArray(int upper,  int  lower = 0,  sizeType
функции    aDelta = 0) Конструирует массив с данными верхней и
           нижней границами. Если aDelta не 0, то массив пере-
           распределяется во время  выполнения  для  включения
           других элементов aDelta при переполнении.

           virtual void add(Object&) Чистая виртуальная  функ-
           ция для порожденных классов для добавления элемента
           в массив.

           sizeType arraySize() Возвращает текущее число расп-
           ределенных ячеек (upperBound - lowerBound + 1).

           void detach(int, int = 0) Удаляет объект в i-ой по-
           зиции массива (если второй аргумент не 0,  то также
           удаляет объект).

           void destroy(int  i)  Удаляет объект с i-ой позиции
           массива и удаляет этот объект.

           int lowerBound() Возвращает нижнюю границу массива.

           int upperBound() Возвращает верхнюю границу.

           virtual void detach(const Object&, int = 0) Удаляет
           объект  из  массива (если второй аргумент не 0,  то
           также удаляет объект).

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение объекта массива.

           virtual classType  isA() Чистая виртуальная функция
           для порожденных классов для возврата ID их объекта.

           virtual int isEqual (const Object&)  Возвращает  не
           0,  если  массивы  равны (равны размерности и равны
           компоненты, расположенные в том же порядке).

           virtual char *nameOf() Чистая  виртуальная  функция
           для  порожденных  классов,  возвращающая  строку ID
           объекта.

           virtual void   printContentsOn(ostream&)   Печатает
           массив в предложенную строку.

     Array
_______________________________________________________________
Тип класса                  Образец
Порожден от                 AbstractArray
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Образец класса    Array    порожден    от    класса
           AbstractArray.  Объект Array определяет  массив,  в
           котором  порядок  элементов  неопределен.  То есть,
           элемент с индексом i массива не имеет связей с эле-
           ментом  индекса  i+1.  Класс  Array  добавляет эле-
           мент-функцию addAt() и индексный оператор для свое-
           го  родительского класса AbstractArray.  В то время
           как наследуемая элемент-функция add()  (наследуемая
           от   Collection)  хранит  данный  объект  в  первом
           доступном месте  массива,  элемент-функция  addAt()
           хранит  данный объект по заданному индексу.  Анало-
           гично,  индексный оператор возвращает lvalue, кото-
           рому можно присвоить ссылку объекта.

Элементы-  Array(int upper,  int lower = 0,  sizeType aDelta =
функции    0) Конструирует массив с данными верхней  и  нижней
           границами.  Если aDelta не 0, то массив перераспре-
           деляется во время выполнения для  включения  других
           элементов aDelta при переполнении.

           virtual void add(Object&) Добавляет объект в следу-
           ющую доступную ячейку в конце массива.

           virtual classType isA() Возвращает ID типа Array.

           virtual char  *nameOf()  Возвращает  строку ID типа
           Array.

           Object& operator [](int) Возвращает ссылку на  объ-
           ект в заданном месте массива.

 Пример    Исходный код

           #include <array.h>
           #include <string.h>
           #include <assoc.h>

           main()
           {
               Array a(2);

               String *s1 = new String("a string");
               String *s2 = new String("another string");
               Association *a1 = new Association(*s1,*s2);

               // Поместим некоторые объекты в массив
               a.add(*s1);
               a.add(*s2);
               a.add(*a1);

               // Напечатаем как хранитель
               cout <<"As a container:\n";
               a.printOn(cout);
               cout << '\n';

               // Напечатаем как массив
               cout <<"As an array:\n";
               a.printContentsOn(cout);

               // Напечатаем как элементы
               cout <<"\nAs elements:\n";
               for (int i = 0; i < a.array.Size(); ++i)
               {
                    a[i].printOn(cout);
                    cout <<'\n';
                }
           }

           Вывод

           As a container:
           Array { a string,
               another string,
                Association { a string, another string }
            }

           As an array:
           Array { a string,
               another string,
                Association { a string, another string }
            }

           As elements:
           a string,
           another string,
            Association { a string, another string }

     ArrayIterator
_______________________________________________________________
Тип класса                   Образец
Порожден от                  ContainerIterator
База для                     Нет
Дружественен к               AbstractArray
Имеет дружественные классы   Нет

Замечания  Предоставляет функции для прохождения объектов  ие-
           рархии   классов  AbstractArray.  (Главным  образом
           предназначается для прямого  использования  классом
           AbstractArray и порожденными от него классами).

Элементы-  virtual operator int() Оператор преобразования  для
функции    проверки позиции конца итерации.

           virtual operator Object&() Возвращает ссылку на те-
           кущий объект в Array, указанный итератором.

           virtual Object& opreator ++() Продвигает итератор к
           следующему  объекту  в Array и возвращает ссылку на
           него.

           virtual void restart() Приводит к тому,  что итера-
           тор указывает на первый объект в Array.


     Association
_______________________________________________________________
Тип класса                  Образец
Порожден от                 Object
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Как и абстрактный класс Sortable, класс Association
           - это  другой  пример  класса   объектов,   которые
           используются как элементы другого объекта (в данном
           случае, класс    объектов    Dictionary).     Класс
           Association предоставляет   логическую  группировку
           для ключей и значений.

Элементы-  Association(Object& Object&) Конструирует  ассоциа-
функции    цию от ключевого значения и объекта значения.

           Association(const Association)  Копирует  констрак-
           тор.

           Object& key() Возвращает ключевой  объект  ассоциа-
           ции.

           Object& value() Возвращает объект значения ассоциа-
           ции.

           virtual classType    isA()   Возвращает   ID   типа
           Association.

           virtual char *nameOf() Возвращает  строку  ID  типа
           Association.

           virtual hashValueType  hashValue()  Возвращает слу-
           чайное значение ассоциации.

           virtual int isEqual(const Object&) Возвращает не 0,
           если две ассоциации равны (то есть,  имеют одинако-
           вые ключ и значение, соответственно).

           virtual int isAssociation() Возвращает не 0  (исти-
           на).

           virtual void  printOn(ostream&) Печатает ассоциацию
           в предложенный поток.

 Пример    Исходный код

           // Файл TASSOC.CPP: иллюстрирует класс Association

           #include <string.h>   // Для strlen()
           #include <strng.h>
           #include <assoc.h>

           void identify(Object&)

           main()
           {
                char s1[21], s2[81];
                // Читаем ключ
                cout << "Enter a key:";
                cin >> s1;
                cin.get();      // Ест новую строку
                String str1(s1);
                identify(str1);

                // Читаем значение
                cout << "Enter a value: ";
                cin.getline(s2, 81);
                s2[strlen(s2) - 1] = '\0';
                String str2(s2);
                identify(str2);

                Association a1(str1,str2);
                identify(a1);
                Association a2 = a1;
                identify(a2);

                cout << "Edual: " << a1.isEqual(a2) << '\n\;
           }

           void identify(Object& o)
           {
               // Отображает объект и его тип
               cout << "Value: ";
               o.printOn(cout);
               cout << ", Object type: " << o.nameOf();
               cout << "\n\n";
           }

           Вывод

    Enter a key: class
    Value: class, Object Type: String

    Enter a value: A group of related objects
    Value: A group of related objects, Object Type: String

    Value: Association {  class, A group of related objects }
    , Object Type: Association

    Value: Association {  class, A group of related objects }
    , Object Type: Association

    Equal: 1
     
     
     Bag
_______________________________________________________________
Тип класса                  Абстрактный
Порожден от                 HashTable
База для                    Set
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Класс Bag определяет коллекцию объектов, идентичную
           HashTable. Bag - коллекция, которая может содержать
           более одного и того же объекта.

Элементы-  См. класс HashTable.
функции


     BaseDate
_______________________________________________________________
Тип класса                  Абстрактный
Порожден от                 Sortable
База для                    Date
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  BaseDate - абстрактный класс,  обеспечивающий функ-
           ции манипуляции основными данными.

Элементы-  unsigned Month()  Возвращает  месяц  объекта данных
функции    (как целое от 1 до 12).

           unsigned Day()  Возвращает день месяца объекта дан-
           ных (как целое 1-31).

           unsigned Year() Возвращает год объекта данных  (це-
           лое 1-12).

           void SetMonth(unsigned char)

           void SetDay(unsigned char)

           void SetYear(unsigned)

           virtual operator String() Чистая виртуальная  функ-
           ция для преобразования данных в строку (должна  пе-
           рекрываться в порожденных классах).

           virtual classType  isA() Чистая виртуальная функция
           для возврата ID типа класса (должна перекрываться в
           порожденных классах).

           virtual char *nameOf() Чистая виртуальная функция
           для возврата строки ID типа класса (должна перекры-
           ваться в порожденных классах).

           virtual hashValueType  hashValue()  Возвращает слу-
           чайное значение для объекта данных.

           virtual int isEqual(const Object&) Возвращает не 0,
           если объект представляет те же данные,  что и аргу-
           мент функции.

           virtual int isLessThan(const Object&) Возвращает не
           0, если объект предшествует первому аргументу в ка-
           лендаре.

           virtual void printOn(ostream&) Печатает объект дан-
           ных в данный поток.

     BaseTime
_______________________________________________________________
Тип класса                  Абстрактный
Порожден от                 Sortable
База для                    Time
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  BaseTime является абстрактным классом, предоставля-
           ющим основные функции манипуляции временем.

Элементы-  BaseTime() Нулевой констрактор.
функции
           BaseTime(const BaseTime&) Констрактор копии.

           BaseTime(unsigned char,unsigned     char=0,unsigned
           char=0,unsigned char=0) Инициализатор.

           unsigned hour()  Возвращает элемент данных час объ-
           екта BaseTime.

           unsigned minute() Возвращает элемент данных минуту.

           unsigned second() Возвращает элемент данных  секун-
           ду.

           unsigned hundredths()  Возвращает сотые доли секун-
           ды.

           void setHour(unsigned char)  Устанавливает  элемент
           данных час в данное значение.

           void setMinute(unsigned char) Устанавливает минуту.

           void setSecond(unsigned  char) Устанавливает секун-
           ду.

           void setHundredths(unsigned   char)   Устанавливает
           сотые доли секунды.

           virtual operator  String() Чистая виртуальная функ-
           ция для порожденного класса для возврата  представ-
           ления String объекта  BaseTime.

           virtual classType  isA() Чистая виртуальная функция
           для порожденного класса, возвращающая ID класса.

           virtual char *nameOf() Чистая  виртуальная  функция
           для  порожденного  класса,  возвращающая  строку ID
           класса.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для объекта BaseTime.

           virtual int  isEqual(const  Object&) Сравнивает  с
           другим совместимым  с  BaseTime  объектом  на   ра-
           венство.

           virtual int  isLessThan(const Object&) Сравнивает с
           другим совместимым с  BaseTime  объектом  на  мень-
           ше-чем.

           virtual void  printOn(ostream&)  Печатает  читаемое
           представление объекта BaseTime в поток.

     Collection
_______________________________________________________________
Тип класса                  Абстрактный
Порожден от                 Container
База для                    AbstractArray, HashTable,
                            List, DoubleList
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Классы, порожденные    от    абстрактного    класса
           Collection - это классы,  которые Вы будете исполь-
           зовать больше всего.  Например, поскольку коллекции
           предоставляют способ  для собирания объектов вместе
           и оперирования с ними, то Вы можете начать построе-
           ние конкретного раздела проекта, используя свойства
           класса Collection. Позднее, когда Вы изучите харак-
           теристики построения  достаточно хорошо,  Вы можете
           сделать требуемую реализацию класса  Collection.
           Класс Collection предоставляет свойства для исполь-
           зования объектов различных порожденных классов, та-
           ких как Array,  Set и Bag, заменяя их по мере огра-
           ничения функций,  доступных Collection.  Collection
           отличается от  класса  в группировке последователь-
           ностей свойством  определять,  является  ли  объект
           элементом Collection.

Элементы-  virtual void  add(Object&) Чистая виртуальная функ-
функции    ция для добавления объектов в Collection.

           virtual void detach(const Object&,  int = 0) Чистая
           виртуальная функция   для   удаления   объекта   из
           Collection.

           virtual int  hasMember(const Object&) Возвращает не
           0, если Collection содержит данный объект.

           virtual Object& findMember(const Object&) Возвраща-
           ет позицию объекта в Collection, или NOOBJECT, если
           он не найден.

           virtual ContainerIterator&  initIterator()   Чистая
           виртуальная функция для инициализации итератора для
           Collection.

           virtual destroy(const  Object&)  Чисто  виртуальная
           функция для удаления объекта из Collection и разру-
           шения этого объекта.

           virtual classType  isA() Чистая виртуальная функция
           для порожденного класса, возвращающая ID класса.

           virtual char *nameOf() Чистая  виртуальная  функция
           для  порожденного  класса,  возвращающая  строку ID
           класса.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для объекта Collection.


     Container
_______________________________________________________________
Тип класса                  Абстрактный
Порожден от                 Object
База для                    Collection, Deque, Queue, Stack
Дружественен к              Нет
Имеет дружественные классы  ContainerIterator

Замечания  Класс Container выполняет следующее:
           1. Включает все классы,  которые содержат 0 или бо-
           лее образцов других объектов.
           2. Обеспечивает метод определения того, присутству-
           ют ли объекты в хранителе, и если да, то предостав-
           ляет метод итерации наличествующих объектов.
           3. Определяет  метод  для показа объектов,  находя-
           щихся в хранителе, в форматированном виде.

Элементы-  Container() Инициализирует Container.
функции
           Container(const Container&) Констрактор копии.

           virtual ContainerIterator&  initIterator()   Чистая
           виртуальная функция для инициализации итератора для
           хранителя.

           void forEach(iterFuncType, void *) Выполняет данную
           функцию для каждого элемента в хранителе.

           virtual Object&   firstThat(condFuncType,  void  *)
           Возвращает ссылку на  первый  объект  в  хранителе,
           удовлетворяющий данному условию.

           virtual Object&   lastThat(condFuncType,   void  *)
           Возвращает ссылку на последний объект в  хранителе,
           удовлетворяющий данному условию.

           virtual classType  isA() Чистая виртуальная функция
           для порожденного класса, возвращающая ID класса.

           virtual char *nameOf() Чистая  виртуальная  функция
           для  порожденного  класса,  возвращающая  строку ID
           класса.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для хранителя.

           virtual int isEqual(const Object&) Возвращает не 0,
           если данный хранитель имеет те же объекты в том  же
           порядке, что и этот.

           virtual void printOn(ostream&) Посылает читабельное
           представление хранителя в данный поток вывода.

           virtual void printHeader(ostream&)  Печатает  стан-
           дартный заголовок   для  хранителя  (вызывается  из
           printOn()).

           virtual void printSeparator(ostream&) Печатает раз-
           делитель (запятую)  для объектов в хранителе (вызы-
           вается из printOn()).

           virtual void printTrailer(ostream&) Печатает  стан-
           дартный трейлер  (закрывающую  фигурную скобку) для
           хранителя (вызывается из printOn()).

           int isEmpty() Возвращает не 0,  если  хранитель  не
           имеет элементов.

           countType getItemsInContainer()   Возвращает  число
           элементов в хранителе.


     ContainerIterator
_______________________________________________________________
Тип класса                  Абстрактный
Порожден от                 Нет
База для                    ArrayIterator, DoubleListIterator,
                            HashTableIterator, ListIterator
Дружественен к              Container
Имеет дружественные классы  Нет

Замечания  ContainerIterator - абстрактный класс,  объявленный
           как дружественный  абстрактному   базовому   классу
           Object. Это отношение означает, что можно применить
           итераторы к  каждому  объекту  в  иерархии   класса
           Object, ничего не зная об извлечении объекта, кото-
           рый Вы повторяете.

Элементы-  virtual operator int() Оператор преобразования  для
функции    проверки условия конца итерации.

           virtual void restart(); Приводит к тому, что итера-
           тор хранителя указывает на первый объект в итераци-
           онной последовательности.

     Date
_______________________________________________________________
Тип класса                  Образец
Порожден от                 BaseDate
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Класс Date  добавляет  функции  для  преобразования
           данных в и из ASCII к классу BaseDate.

Элементы-  Date() Нулевой констрактор.
функции
           Date(unsigned char, undigned char, unsigned) Иници-
           ализатор.

           Date(const Date&) Констрактор копии.

           virtual operator String() Возвращает  представление
           строки данных.

           vurtual classType isA() Возвращает ID класса Date.

           virtual char  *nameOf() Возвращает строку ID класса
           Date.

     Dictionary
_______________________________________________________________
Тип класса                 Образец
Порожден от                Set
База для                   Нет
Дружественен к             Нет
Имеет дружественные классы Нет

Замечания  Dictionary -  это  неупорядоченная коллекция объек-
           тов, порожденных  от  класса   Association.   Класс
           Dictionary наследует   все  свойства  своего  роди-
           тельского класса Set и добавляет функцию просмотра.
           Эта функция  позволяет  Вам взять часть ассоциации,
           хранящейся в справочнике, если Вы предложите ключ.

Элементы-  Dictionary() Нулевой констрактор.
функции
           Dictionary(Dictionary&) Констрактор копии.

           virtual void  add(Object&)  Добавляет  ассоциацию в
           справочник.

           Association& lookup(const Object&) Возвращает  дан-
           ную ассоциацию,  если  она находится в справочнике,
           иначе возвращается NOOBJECT.

           virtual classType  isA()   Возвращает   ID   класса
           Dictionary.

           virtual char  *nameOf() Возвращает строку ID класса
           Dictionary.

     Deque
_______________________________________________________________
Тип класса                  Образец
Порожден от                 Container
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Класс Deque реализует двухконечную очередь. Объекты
           могут вставляться и удаляться и с левого,  и с пра-
           вого конца.   Можно  использовать  элементы-функции
           peekLeft и  prrkRight  для  исследования  объектов,
           стоящих с левого и с правого концов. К ссылкам объ-
           ектов, возвращаемым этими функциями, применяются те
           же предостережения,  что  и  возврату peek в классе
           Queue и top в классе Stack. То есть нужно быть вни-
           мательным и не разрушить объект,  на который ссыла-
           ется возвращенное значение. Deque - это особая реа-
           лизация DoubleList.

Элементы-  Object& peekLeft()Возвращает объект с левого конца
функции    (головы) очереди.

           Object& peekRight()  Возвращает  объект  с  правого
           конца (хвоста) очереди.

           Object& getLeft() Возвращает объект с левого  конца
           очереди и удаляет его из очереди.

           Object& getRight() Возвращает объект с правого кон-
           ца очереди и удаляет его из очереди.

           void putLeft(Object&) Добавляет объект в левый  ко-
           нец очереди.

           void putRight(Object&)  Добавляет  объект  в правый
           конец очереди.

           virtual ContainerIterator& initIterator() Инициали-
           зирует итератор  слева  очереди (в направлении впе-
           ред).

           virtual ContainerIterator&    initReverseIterator()
           Инициализирует  итератор справа очереди (в обратном
           направлении).

           virtual classType isA() Возвращает ID класса Deque.

           virtual char *nameOf() Возвращает строку ID  класса
           Deque.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для очереди.

           int isEmpty() Возвращает не 0, если очередь не име-
           ет элементов.

Пример     Исходный код:
     
           #include <deque.h>
           #include <strng.h>
     
           main()
           {
     
              Deque d;
              String *s1 = new String("one");
              String *s2 = new String("two");
              String *s3 = new String("three");
              String *s4 = new String("four");
     
              // Заполним deque
              d.putLeft(*s1);
              d.putRight(*s2);
              d.putLeft(*s3);
              d.putRight(*s4);
     
              // Печать на cout
              cout << "As a container:\n";
              d.printOn(cout);
              cout << '\n';
     
              cout << "As a Deque:\n";
              while (!d.isEmpty())
              {
                  d.getLeft().printOn(cout);
                  cout << '\n';
               }
     
              // Должен быть пустым
              cout << "\nShould be empty:\n";
              d.printOn(cout);
           }
     
           Вывод
     
           As a container:
           Deque { three,
               one,
               two,
               four }
     
           As a Deque:
           three
           one
           two
           four
     
           Should be empty:
           Deque { }
     
     
     DoubleList
_______________________________________________________________
Тип класса                  Образец
Порожден от                 Collection
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  DoubleListIterator

Замечания  Класс DoubleList  предоставляет метод для помещения
           объекта в два списка, в то время как поддерживается
           только один объект.  Можно добавлять и удалять объ-
           екты с любого конца каждого  списка.  Можно  пройти
           список в любом направлении,  начиная с головы или с
           хвоста, и сменить направление в  середине  процесса
           итерации. Элемент-функция initReverseIterator начи-
           нает процесс итерации с хвоста очереди.  Чтобы раз-
           решить обратное направление,  задается operator--()
           для класса DoubleListIterator.

Элементы-  DoubleList() Инициализирует новый, пустой список.
функции
           Object& peekAtHead()  Возвращает  объект  в  начале
           списка.

           Object& peekAtTail()   Возвращает  объект  в  конце
           списка.

           virtual void add(Object&) Подобен addAtHead().

           virtual void detach(const Object&, int = 0) Удаляет
           первое вхождение данного объекта,  встреченного при
           поиске от начала списка. Если второй параметр не 0,
           то удаленный  объект  также разрушается (вызывается
           его дестрактор).

           void addAtHead(Object&) Добавляет  новый  объект  в
           начало списка.

           void addAtTail(Object&) Добавляет объект в список.

           void destroyFromHead(const  Object&)  То  же самое,
           что и detachFromHead(object, 1).

           void destroyFromTail(const Object&)  То  же  самое,
           что и detachFromTail(object, 1).

           void detachFromHead(const Object&, int = 0) Удаляет
           объект в голове списка.  Если второй параметр не 0,
           то удаленный объект также разрушается.

           void detachFromTail(const Object&, int = 0) Удаляет
           объект в хвосте списка.  Если второй параметр не 0,
           то удаленный объект также разрушается.

           virtual ContainerIterator& initIterator() Инициали-
           зирует итерацию очереди вперед (слева).

           virtual ContainerIterator&    initReverseIterator()
           Инициализирует итерацию очереди назад (справа).

           virtual classType   isA()   Возвращает   ID  класса
           DoubleList.

           virtual char *nameOf() Возвращает строку ID  класса
           DoubleList.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для DoubleList.

     DoubleListElement
_______________________________________________________________
Тип класса                  Образец
Порожден от                 Нет
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  DoubleList, DoubleListIterator

Замечания  DoubleList (список  с  двойными связями) - это кол-
           лекция объектов этого типа. Здесь нет активных эле-
           ментов-функций, поскольку  дружественные классы де-
           лают всю работу.

Элементы-  DoubleListElement(Object *) Инициализатор.
функции

     DoubleListIterator
_______________________________________________________________
Тип класса                  Образец
Порожден от                 ContainerIterator
База для                    Нет
Дружественен к              DoubleList, DoubleListElement
Имеет дружественные классы  Нет

Замечания  Определяет класс, который реализует прямой и обрат-
           ный проход по  списку  с  двойными  связями  (класс
           DoubleList).

Элементы-  DoubleListIterator(const DoubleList&, int = 1) Ини-
функции    циализирует итератор в начало головы  списка,  если
           второй параметр равен 1, иначе в конец списка.

           virtual operator int() Оператор преобразования  для
           проверки условия конца итерации.

           virtual operator  Object&() Возвращает текущий объ-
           ект, на который указывает итератор.

           virtual operator& operator ++() Передвигает  итера-
           тор вперед на одну позицию в списке.

           Object& operator --() Передвигает итератор назад на
           одну позицию в списке.

           virtual void restart() Передвигает  итератор  назад
           на его исходную позицию (голову или хвост списка).

     Error
_______________________________________________________________
Тип класса                  Особый образец (см. Remarks).
Порожден от                 Object
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Класс Error -  это  особый  класс  образцов  класса
           Object. Есть   точно   один  пример  класса  Error,
           theErrorObject. Указание на этот глобальный  объект
           - указатель статического объекта Object::ZERO. Мак-
           ро NOOBJECT   определяет   Object::ZERO.   Оператор
           Object::operator new    возвращает   указатель   на
           theErrorObject, если  попытка  распределить  объект
           завершилась неудачей.   Можно   проверить  значение
           возврата оператора new на NOOBJECT,  чтобы  посмот-
           реть, как завершилось распределение.

Элементы-  virtual classtype isA() Возвращает ID класса Error.
функции
           virtual char *nameOf() Возвращает строку ID  класса
           Error.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для объекта Error.

           virtual int isEqual(const Object&) Возвращает не 0,
           если тестируемый  объект  является особым ошибочным
           объектом.

           virtual void  printOn(ostream&)   Печатает   строку
           "Error\n" в данный поток.

           void operator delete(void *) Нулевая функция.


     HashTable
_______________________________________________________________
Тип класса                  Образец
Порожден от                 Collection
База для                    Bag, Dictionary, Set
Дружественен к              Нет
Имеет дружественные классы  HashTableIterator

Замечания  Класс HashTable  обеспечивает реализацию коллекции,
           в которой объекты  неупорядочены.  Класс  HashTable
           служит базовым  классом  для  классов  Bag,  Set  и
           Dictionary, являющихся неупорядоченными коллекциями
           объектов. Класс HashTable является базовым классом,
           потому что каждый из порожденных  от  него  классов
           реализуется с    использованием   методов   доступа
           HashTable. Можно  заметить,  что  порождение  этого
           сорта отличается  от  концептуального  порождения в
           других областях иерархии.  Это отличие  существует,
           потому что оно легче для понимания отношения,  если
           это отношение основано на реализации классов.

Элементы-  HashTable(sizeType = DEFAULT_HASH_TABLE_SIZE)  Ини-
функции    циализирует новую   таблицу  (в  111  записей,  см.
           RESOURCE.H).

           virtual void add(Object&) Добавляет объект  в  слу-
           чайную таблицу.

           virtual void detach(const Object&, int = 0) Удаляет
           объект из случайной таблицы; разрушает объект, если
           второй параметр не 0.

           virtual ContainerIterator& initIterator() Инициали-
           зирует итератор для случайной таблицы.

           virtual Object& findMember(const Object&) Возвраща-
           ет ссылку  на  объект,  связанный с данным ключевым
           объектом.

           virtual classType  isA()   Возвращает   ID   класса
           HashTable.

           virtual char  *nameOf() Возвращает строку ID класса
           HashTable.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для объекта HashTable.


     HashTableIterator
_______________________________________________________________
Тип класса                  Образец
Порожден от                 ContainerIterator
База для                    Нет
Дружественен к              HashTable
Имеет дружественные классы  Нет

Замечания  Класс, реализующий  функции  для  последовательного
           прохождения по случайной таблице.

Элементы-  HashTableIterator(const Array&) Инициализирует ите-
функции    ратор (примечание:   случайная   таблица   является
           массивом).

           virtual operator int() Оператор преобразования  для
           проверки конца условия итерации.

           virtual Object&  operator ++() Передвигает итератор
           вперед на следующий элемент в случайной таблице.

           virtual operator Object&() Возвращает ссылку на те-
           кущий объект, на который указывает итератор.

           virtual void restart() Приводит к тому,  что итера-
           тор указывает на начало случайной таблицы.

     List
_______________________________________________________________
Тип класса                  Образец
Порожден от                 Collection
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  ListIterator

Замечания  Класс List обеспечивает реализацию коллекции, в ко-
           торой объекты образуют цепочку. Можно удалять и до-
           бавлять объекты  только  в  голове цепочки;  однако
           можно пройти список для исследования объектов. Про-
           хождение начинается  с головы и продолжается до тех
           пор, пока в списке есть объекты.

Элементы-  List() Инициализирует пустой список.
функции
           Object& peekHead()  Возвращает  ссылку  на объект в
           начале списка.

           void add(Object&) Добавляет объект в список (стано-
           вится новым началом).

           void detach(const Object&,  int = 0) Удаляет объект
           из списка.  Если второй параметр не 0, то удаленный
           объект также разрушается.

           void destroy(const   Object&)   То  же  самое,  что
           detach(&object, 1).

           virtual classType isA() Возвращает ID класса List.

           virtual char  *nameOf() Возвращает строку ID класса
           List.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для объекта List.

           virtual ContainerIterator& initIterator() Инициали-
           зирует итератор для списка (начинается с головы).

     ListElement
_______________________________________________________________
Тип класса                  Образец
Порожден от                 Нет
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  List, ListIterator

Замечания  ListElement - это то,  из чего делается List.  Этот
           класс содержит  указатель  на  объект,  но не имеет
           активных элементов-функций,  поскольку  всю  работу
           выполняют дружественные классы.

Элементы-  ListElement(Object *) Инициализатор.
функции

     ListIterator
_______________________________________________________________
Тип класса                  Образец
Порожден от                 ContainerIterator
База для                    Нет
Дружественен к              List, ListElement
Имеет дружественные классы  Нет

Замечания  Реализует функции для прохождения связанного списка
           (класс List).

Элементы-  ListIterator(const List&)  Инициализирует  итератор
функции    для указания на начало списка.

           virtual operator  int() Оператор преобразования для
           проверки условия конца итерации.

           virtual operator  Object&()  Возвращает  ссылку  на
           объект, на который указывает итератор.

           virtual Object&  operator  ++() Продвигает итератор
           на следующий элемент в списке.

           virtual void restart() Приводит к тому,  что итера-
           тор указывает на голову списка.

     Object
_______________________________________________________________
Тип класса                  Абстрактный
Порожден от                 Нет
База для                    Assosiation, Container, Error,
                            Sortable
Дружественен к              Нет
Имеет дружественные классы  operator<<(), operator==(),
                            operator !=()

Замечания  Поскольку Object - абстрактный класс,  то нет  эле-
           ментов данных  этого  типа.  Однако  так  как боль-
           шинство  элементов  данных  порождаются  от   этого
           абстрактного класса,  то класс предоставляет основ-
           ной механизм и структуру для проверки  типа  и  ин-
           капсуляции. Класс  Object  обеспечивает минимальный
           набор определений,  что должен  делать  порожденный
           класс. Объект должен:
           1. возвращать класс,  которому принадлежит  объект.
              Это делает элемент-функция isA.
           2. возвращать   символьное   представление    имени
              класса. Это делает элемент-функция nameOf.
           3. показывать содержимое объекта в формате,  подхо-
              дящем для объекта.  Это  делает  элемент-функция
              printOn.
           4. возвращать уникальный ключ, основанный на объек-
              те. Это делает элемент-функция hashValue.
           5. делать  итерацию  по каждой части,  составляющей
              объект. Это делает элемент-функция forEach.
           6. находить первую или последнюю часть всего объек-
              та, удовлетворяющую данному условию. Это  делают
              элементы-функции firstThat и lastThat.
           7. определять, равен ли объект другому объекту. Это
              свойство обеспечивает элемент-функция isEqual.
           8. определять,  можно  ли  сортировать  объект;  то
              есть, порожден   ли   он   от  класса  Sortable.
              Это выполняет элемент-функция isSortable.
           9. определять,  является  ли объект частью ассоциа-
              ции; то  есть,  порождается  ли  он  от   класса
              Association. Это      делает     элемент-функция
              isAssociation.
           10. конструировать, разрушать и копировать в другой
               объект.
           11. распределять новый объект.
           Реализация этих функций обеспечивается  каждым  по-
           рожденным классом;  эти  реализации  идентифицируют
           этот класс.

Элементы-  Object() Констрактор.
функции
           Object(Object&) Констрактор копии.

           virtual classType isA() Чистая виртуальная  функция
           для порожденных классов для возврата ID класса.

           virtual char  *nameOf() Чистая виртуальная  функция
           для порожденных  классов  для  возврата  строки  ID
           класса.

           virtual hashValueType  hashValue() Чистая виртуаль-
           ная функция для порожденных  классов  для  возврата
           случайного значения.

           virtual int isEqual(const Object&) Чистая виртуаль-
           ная функция для порожденных классов для проверки на
           равенство.

           virtual int isSortable() Возвращает ноль.

           virtual int isAssociation() Возвращает ноль.

           void *operator   new(size_t)   Распределяет  данное
           число байт для объекта.

           virtual void forEach(iterFuncType, void *) Вызывает
           данный итератор для объекта вместе со списком пара-
           метров.

           virtual Object& firstThat(condFuncType, void *) Вы-
           зывает данную  функцию  тестирования для объекта со
           списком параметров.  Возвращает объект,  если  тест
           успешен, иначе NOOBJECT.

           virtual Object& lastThat(condFuncType, void *) Ана-
           логично firstThat для объектов не-хранителей.

           virtual void printOn(ostream&)  Чистая  виртуальная
           функция  для порожденных классов для выполнения вы-
           вода.

     Queue
_______________________________________________________________
Тип класса                  Образец
Порожден от                 Container
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Класс Queue реализует хранитель FIFO и соответству-
           ющие методы очереди.  Объекты вставляются слева,  а
           удаляются справа.  Можно использовать элемент-функ-
           цию peek для проверки того, какой объект будет уда-
           лен следующим.  Поскольку peek возвращает ссылку на
           объект, который все  еще  принадлежит  очереди,  то
           нельзя разрушать ссылаемый объект.  Обсуждение воп-
           роса о хранителе-владельце см. в разделе "Владельцы
           объекта".

Элементы-  Object& peekLeft() Возвращает  объект в голове (сле-
функции    ва) очереди.

           Object& peekRight()   Возвращает  объект  в  хвосте
           (справа) очереди.

           Object& get() Удаляет и возвращает  следующий  эле-
           мент (голову) из очереди.

           void put(Object&  o)  Добавляет объект к очереди (в
           хвост).

           virtual classType isA() Возвращает ID типа Queue.

           virtual char *nameOf() Возвращает  строку  ID  типа
           Queue.

           virtual hashValueType  HashValue()  Возвращает слу-
           чайное значение для очереди.

Пример     Исходный код
      
           #include <queue.h>
           #include <strng.h>
           #include <assoc.h>
     
           main()
           {
               String *s1 = new String("a string");
               String *s2 = new String("another string");
               Association *a1 = new Association(*s1,*s2);

               // Заполним очередь
               q.put(*s1);
               q.put(*s2);
               q.put(*a1);

               // Напечатаем на cout как хранитель
               cout <<"As a container:\n";
               q.printOn(cout);
               cout << '\n';
     
              cout << "As a queue:\n";
              while (!q.isEmpty())
              {
                  q.get().printOn(cout);
                  cout << '\n';
               }
              cout << '\n';
     
              // Очередь должна быть пустой
              cout << "Should be empty:\n";
              q.printOn(cout);
           }
     
           Вывод
     
           As a container:
           Queue { Association { a string, another string }
           ,
               another string,
               a string }

           As a queue:
           a string,
           another string,
             Association { a string, another string }

           Should be empty:
           Queue { }

     Set
_______________________________________________________________
Тип класса                  Абстрактный
Порожден от                 Bag
База для                    Dictionary
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Класс Set порожден от класса Bag.  Set ограничивает
           членство объектов  в  коллекции по одному на каждый
           объект. Различаясь в методах по добавлению  элемен-
           тов, в остальном Set и Bag идентичны.

Элементы-  Set(sizeType = DEFAULT_SET_SIZE) Инициализирует Set
функции    как Bag (см. размер по умолчанию в RESOURCE.H).

           virtual void add(Object&) Добавляет объект  в  мно-
           жество, только если его там еще нет.

           virtual classType isA() Возвращает ID класса Set.

           virtual char  *nameOf() Возвращает строку ID класса
           Set.

     Sortable
_______________________________________________________________
Тип класса                  Абстрактный
Порожден от                 Object
База для                    BaseDate, BaseTime, String
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Этот абстрактный класс состоит из классов объектов,
           которые можно  сортировать.  Членство в этом классе
           ограничено теми объектами,  которые можно  тестиро-
           вать на порядок.  Можно порождать от него объекты и
           помещать эти объекты в упорядоченные коллекции, та-
           кие как  деревья.  Объект,  порожденный  от  класса
           Sortable,  должен  определять isLessThan вдобавок к
           функциям,  требуемым классом Object.  (Помните, что
           класс   Sortable   наследует  все  свойства  класса
           Object).

Элементы-  virtual int isEqual(const Object&) Чистая виртуаль-
функции    ная функция для порожденных классов для  тестирова-
           ния на равенство.

           virtual int isLessThan(const Object&) Чистая вирту-
           альная функция  для  порожденных классов для тести-
           рования на порядок.

           virtual int idSortable() Возвращает единицу.

           virtual classType isA() Чистая виртуальная  функция
           для порожденных классов для возврата ID класса.

           virtual char  *nameOf() Чистая виртуальная  функция
           для порожденных  классов  для  возврата  строки  ID
           класса.

           virtual hashValueType  hashValue() Чистая виртуаль-
           ная функция для порожденных  классов  для  возврата
           случайного значения.


     SortedArray
_______________________________________________________________
Тип класса                  Образец
Порожден от                 AbstractArray
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Класс SortedArray определяет массив, в котором объ-
           екты, составляющие его,  сортируются  в  восходящем
           порядке. То  есть,  объект  с индексом n меньше или
           равен объекта с индексом n + 1. Заметим, что должен
           быть определен  оператор < для сравнения объектов в
           массиве.
           Между классами Array и SortedArray есть различия:
           1. Метод  для  добавления  объекта по заданному ин-
              дексу, addAt,  предоставленный в  классе  Array,
              отсутствует в классе SortedArray.
           2. В отличие от  индексного  оператора  для  класса
              Array, индексный  оператор в классе SortedArray,
              operator[], не возвращает lvalue.  Это ограниче-
              ние предотвращает любые добавления в массив, ко-
              торые могут нарушить порядок объектов в массиве.

Элементы-  SortedArray(int upper,  int  lower  =  0,  sizeType
функции    aDelta = 0) Инициализатор.

           const Sortable&  operator [](int) Оператор индекси-
           рования (не возвращает lvalue).

           virtual void  add(Object&)  Добавляет   сортируемый
           объект на его соответствующую,  упорядоченную пози-
           цию в массиве.

           virtual void detach(const Object&, int = 0) Удаляет
           объект из  массива  и перемещает оставшиеся объекты
           для заполнения дыры.  Если второй  параметр  не  0,
           удаляемый объект разрушается.

           virtual classTypa   isA()   Возвращает   ID  класса
           SortedArray.

           virtual char *nameOf() Возвращает строку ID  класса
           SortedArray.


     Stack
_______________________________________________________________
Тип класса                    Образец
Порожден от                   Container
База для                      Нет
Дружественен к                Нет
Имеет дружественные классы    Нет

Замечания  Класс Stack  -  это член группировки последователь-
           ности классов, порожденных от Соntainer. Класс пре-
           доставляет обычные  стековые  операции,  такие  как
           isEmpty, push и pop.  Вдобавок  Stack  обеспечивает
           метод для  ссылки  и  изменения верхнего элемента в
           стеке без выталкивания данных из стека. Этот метод,
           top, является исключением правил собственности хра-
           нителей в том,  что он возвращает ссылку на объект,
           которая все еще присваивается хранителем стека.  Вы
           должны быть внимательны, чтобы не разрушить ссылае-
           мый объект,  поскольку это нарушит внутренний меха-
           низм хранения стека.

Элементы-  void push(Object&) Добавляет объект в стек.
функции
           Object& pop() Удаляет и возвращает верх стека.

           Object& top()  Возвращает (но не удаляет) верх сте-
           ка.

           virtual int isEmpty() Возвращает не  0,  если  стек
           пуст.

           virtual classType isA() Возвращает ID типа Stack.

           virtual char  *nameOf()  Возвращает  строку ID типа
           Stack.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для стека.

Пример     Исходный код
         
           #include <stack.h>
           #include <strng.h>
           #include <assoc.h>
     
           main()
           {
               Stack s;
               String *s1 = new String("a string");
               String *s2 = new String("another string");
               Association *a1 = new Association(*s1,*s2);

               s.push(*s1);
               s.push(*s2);
               s.push(*a1);

               // Напечатаем Stack
               cout <<"As a container:\n";
               s.printOn(cout);
               cout << '\n';
     
              cout << "As a Stack:\n";
              while (!s.isEmpty())
              {
                  s.pop().printOn(cout);
                  cout << '\n';
               }
     
            }
     
           Вывод
     
           As a container:
           Stack { Association { a string, another string }
           ,
               another string,
               a string }

           As a Stack:
             Association { a string, another string }
     
           another string
           a string

     String
_______________________________________________________________
Тип класса                  Образец
Порожден от                 Sortable
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Определяет класс    оперирования   строкой.   Можно
           использовать объекты String везде,  где  вызывается
           объект образца. Строковый объект всегда завершается
           нулем.

Элементы-  String(const char *) Конструирует объект String  из
функции    строки С.

           String(const String&) Констрактор копии.

           virtual int isEqual(const Object&) Возвращает не 0,
           если две String равны.

           virtual int isLessThan(const Object&) Возвращает не
           0, если строка лексически предшествует другой.

           virtual void printOn(ostream&)  Печатает  строку  в
           предложенный поток.

           String& operator = (const String&) Оператор присва-
           ивания для String (перераспределяет в случае  необ-
           ходимости).

           operator const  char *() Возвращает символьный ука-
           затель на строку объекта String.

           virtual classType isA() Возвращает ID типа String.

           virtual char  *nameOf()  Возвращает  строку ID типа
           String.

           virtual hashValueType hashValue()  Возвращает  слу-
           чайное значение для строки.

Пример     Исходный код:
     
     // Файл TSTRNG.CPP: Тест класса String

     #include <strng.h>

     void identify(String&);

     main()
     {
        char s1[21],s2[21];
        cout << "Enter a string: "; // Читаем строку
        cin >> s1;
        String str1(s1);
        identify(str1);

        cout << "Enter another string: "; // Читаем дру-
                                          // гую
        cin >> s2;
        String str2(s2);
        identify(str2);

        // Проведем некоторые тесты:
        cout << "Equal: " << str1.isEqual(str2) << '\n';
        cout << "Less than: " << str1.isLessThan(str2) << '\n';
     
        // Присвоение строк:
        str2 = str1;
        cout << "After assignment:\n" << "Equal: "
             << str1.IsEqual(str2);
     }
     void identify(String& str)
     {
        // Отражение значения и типа String
        cout << "Value: ";
        str.printOn(cout);
        cout << ", Object type: " << strnameOf();
        cout << "\n\n";
     }
     
           Вывод
     
     Enter a string: hello
     Value: hello, Object type: String
     
     Enter another string: goodbye
     Value: goodbye, Object type: String
     
     Equal: 0
     Less than: 0
     After assignment:
     Equal: 1

     Time
_______________________________________________________________
Тип класса                  Образец
Порожден от                 BaseTime
База для                    Нет
Дружественен к              Нет
Имеет дружественные классы  Нет

Замечания  Используемый временем класс.

Элементы-  Time() Констрактор.
функции
           Time(const Time&) Констрактор копии.

           Time(unsigned char,  unsigned char  =  0,  unsigned
           char = 0, unsigned char = 0) Инициализатор.

           virtual operator  String()   Возвращает   строковое
           представление времени.

           virtual classType isA() Возвращает ID класса Time.

           virtual char  *nameOf() Возвращает строку ID класса
           Time.
