                           ГЛАВА 5

                       РАБОТА  НА  С++

     Примечание. Эта глава является  кратким  руководством  по
работе на С++
     Для лучшего понимания того, как выглядит С++ и как выпол-
няются  задачи на С++,  в этой главе будет быстро  просмотрено
большое количество понятий с минимумом многословия.  Предпола-
гается, что Вы будете работать на компьютере; Вы можете загру-
зить и прогнать каждую  из  программ  (которые  есть  в  Вашем
подсправочнике EXAMPLES, наряду с файлами заголовков и другими
файлами,  которые Вам потребуются).  Если Вы хотите более под-
робно  познакомиться с С++,  особенно с понятиями,  лежащими в
основе объектно-ориентированного программирования,  то читайте
Главу 4 "Учебник для начинающих программистов на С++".  Вы мо-
жете также обратиться к Главе 3 " C++" в Руководстве  програм-
миста  для  получения точных деталей,  касающихся синтаксиса и
использования С++.
     Важно! В  этой главе,  мы предполагаем,  что Вы знакомы с
языком С и, что Вы знаете как компилировать, компоновать и вы-
полнять исходную программу с помощью Borland C++.  Мы начнем с
простых примеров, которые будут усложняться таким образом, что
будут выделяться новые понятия.  Разумно, что такие примеры не
будут непробиваемыми пулями (другими  словами,  они  не  будут
проверять ошибки, связанные с памятью и т.д.). Данная глава не
является трактатом по структурам данных и  технике  профессио-
нального  программирования,  вместо этого,  она является руко-
водством по постепенному введению в сложный язык.
     Эта глава  подразделяется  на два раздела.  Первый раздел
предоставляет альтернативы С++ знанию и привычкам,  которые Вы
можете иметь в программировании на С.  Второй раздел обеспечи-
вает быстрое ознакомление с ядром С++:  объектно-ориентирован-
ное программирование, использующее классы и наследование.

         Более лучший С : осуществление перехода из С

     Примечание. При  ссылке  на  номера строк мы подсчитываем
пустые строки.
     Хотя знание С помогает в изучении С++,  иногда это знание
может увести в сторону, особенно в областях , которые не явля-
ются специфично областями объектно-ориентированного программи-
рования и где С++ проводит операции,  которые отличаются от С.
По  этой причине в этом разделе будет показано как выполнять в
С++ многие из тех же самых видов действий, которые Вы могли бы
выполнять в С: написание текста на экране, комментирование ко-
да,  создание и использование констант,  работа с потоком вво-
да/вывода, встроенные функции и т.д.

                         Программа 1

     Исходный код
// ex1.cpp:   Первый взгляд
// из Главы 5 Начального руководства
#include <iostream.h>

main()
{
   cout << "Frankly, my dear...\n";
   cout << "C++ is a better C.\n";
}
     Выходные данные
     Frankly, my dear...
     С++ is a better С.
     Обратите внимание на новый синтаксис комментария в первой
строке этой программы. Все символы от первого экземпляра двой-
ных наклонных черточек до конца сроки считаются  комментарием,
хотя   Вы  можете  также  использовать  и  традиционный  стиль
/*...*/.  Имена файлов, имеющих расширение .CPP, как предпола-
гается, являются файлами С++ (или Вы можете использовать опцию
компилятора командной строки - Р).
     Третья строка   включает   стандартный   файл   заголовка
Iostream.h,  который заменяет большую  часть  функциональности
stdio.h.  cout  -  это  выходной  поток  и он используется для
посылки символов на стандартное выходное устройство (как дела-
ет stdout.h в С). Оператор << означающий "помещать в" посылает
данные находящиеся справа от него в поток,  определенный слева
от него.  В данном случае,  контекст оператора << отличает его
от арифметического оператора сдвиг влево,  который  использует
тот же самый символ.  (Такое многократное использование опера-
торов и функций вполне обычно в С++ и называется перекрытием).

                         Программа 2

     Исходный код
// ex2.cpp:   Интерактивный пример
// из Главы 5 Начального руководства
#include <iostream.h>

main()
{
   char name[16];
   int age;

   cout << "Enter your name: ";
   cin >> name;
   cout << "Enter your age: ";
   cin >> age;

   if (age < 21)
      cout << "You young whippersnapper, " << name << "!\n";
   else if (age < 40)
      cout << name << ", you're still in your prime!\n";
   else if (age < 60)
      cout << "You're over the hill, " << name << "!\n";
   else if (age < 80)
      cout << "I bow to your wisdom, " << name << "!\n";
   else
      cout << "Are you really " << age << ", " << name
      << "?\n";
}
     Примерное выполнение:
     Enter your name: Don
     Enter your age: 40
     You're over the hill, Don!
     Сin является входным потоком,  связанным  со  стандартным
вводом.  Он может точно обрабатывать все стандартные типы дан-
ных.  Вы могли заметить, что в С распечатка подсказки без сим-
вола  новой  строки в stdout требует вызова fflush(stdout) для
появления подсказки.  В С++,  где бы не использовался cin,  он
подавляет  cout автоматически (Вы можете выключить это автома-
тическое подавление, если оно включается по умолчанию).

                         Программа 3

     Исходный код

// ex3.cpp:   Встроенные функции
// из Главы 5 Начального руководства
#include <iostream.h>

const float Pi = 3.1415926;

inline float area(const float r) {return Pi * r * r;}

main()
{
   float radius;

   cout << "Введите радиус окружности: ";
   cin >> radius;
   cout << "Площадь равна " << area(radius) << "\n";
}
     Примерное выполнение:
     Введите радиус окружности: 3
     Площадь равна 28,274334
     Идентификатор константы  ведет себя подобно обычной пере-
менной (то есть,  его область действия - это блок, который оп-
ределяет его, и он подлежит проверке типов) за исключением то-
го, что он не может появляться в левой части оператора присва-
ивания (или там где требуется именующее выражение).  Использо-
вание #define в С++ является почти устаревшим.
     Ключевое слово  inline  сообщает  компилятору о необходи-
мости вставить код непосредственно там,  где это возможно, для
того,  чтобы избежать непроизводительных затрат на вызов функ-
ции.  Во всем остальном (область действия и  т.д.)  встроенная
функция  ведет себя подобно обычной функции.  Ее использование
рекомендуется вместо макросов #defined (конечно, за исключени-
ем тех случаев,  где Вы зависите от "хитрых" приемов замещений
макросов препроцессора).  Эта особенность предназначается  для
простых, однострочных функций.

                         Программа 4

     Исходный код
// ex4.cpp:   Аргументы по умолчанию и передача по ссылке
// из Главы 5  Начального руководства
#include <iostream.h>
#include <ctype.h>

int get_word(char *, int &, int start = 0);

main()
{
   int word_len;
   char *s = "Эти слова будут печататься по одному слову в
              строке";
   int word_idx = get_word(s,word_len);          // строка 13
   while (word_len > 0)
   {
      cout.write(s+word_idx, word_len);
                cout << "\n";
      //cout << form("%.*s\n",word_len,s+word_idx);
      word_idx = get_word(s,word_len,word_idx+word_len);
   }
}
     Примечание. Хорошим  стилем программирования является вы-
деление тела нулевого цикла.

int get_word(char *s, int& size, int start)
{
   // пропуск начальных пробелов
   for (int i = start; isspace(s[i]); ++i);
   int start_of_word = i;
     Примечание. Важным отличием от С является то,  что объяв-
ления могут появляться в любом  месте,  где  могут  появляться
предложения.
   // Проследить слово
   while (s[i] != '\0' && !isspace(s[i]))
      ++i;
   size = i - start_of_word;
   return start_of_word;
}
     Выход программы:
     Эти
     слова
     будут
     печататься
     по
     одному
     слову
     в
     строке
     Прототип для функции get_word в шестой строке  имеет  две
специальных особенности. Второй аргумент объявляется как пара-
метр ссылки. Это означает, что значение такого аргумента будет
видоизменяться  в вызывающей программе (это эквивалентно пара-
метру var в Паскале,  и  выполняется  благодаря  указателям  в
С).Посредством этого переменная word_len модифицируется в main
и мы можем еще вернуть другое пригодное  значение  с  функцией
get_word.
     Примечание.Одной из вызывающих интерес  особенностей  С++
является определенный по умолчанию аргумент.
     Третьим аргументом является определенный по умолчанию ар-
гумент.  Это  означает,  что он может опускаться (как в строке
13) и в этом случае значение 0 передается автоматически. Обра-
тите внимание на то,  что значение,  определенное по умолчанию
должно определяться  только  при  первом  упоминании  функции.
Только  для  конечных аргументов функции можно задавать значе-
ния, определенные по умолчанию.

                      Поддержка объектов

     Мир состоит из вещей,  которые обладают атрибутами и  де-
монстрируют  поведение.  С++  предоставляет  модель для этого,
посредством расширения понятия структуры,  чтобы она содержала
функции  так же как и элементы данных.  Этот путь полного тож-
дества объекта  выражается  благодаря  конструкции  отдельного
языка.  Понятие  объектно-ориентированной  поддержки  означает
несколько больше,  чем удобное обозначение  -  это  инструмент
мысли.

                         Программа 5

     Предположим, что  мы  желаем иметь интерактивный словарь.
Словарь составляется из определений для слов. Мы сначала будем
моделировать понятие определения.
     Примечание.Вам необходимо откомпилировать DEF.CPP  в  OBJ
файл,  а затем скомпоновать его с EX6.CPP или EX7.CPP(или заг-
рузить EX5.PRJ).  Вы можете также откомпилировать его с  Debug
info  (отладочной  информацией),  что  позволит  Вам проверить
программу путем пошагового просмотра.
// def.h: Класс определения слова
// из Главы 5 Начального руководства

#include <string.h>

const int Maxmeans = 5;

class Definition
{
   char *word;                 // Слово, которое определяется
   char *meanings[Maxmeans]; // Различные значения этого слова
   int nmeanings;

public:
   void put_word(char *);
   char *get_word(char *s) {return strcpy(s,word);}; // строка
                                                      // 15
   void add_meaning(char *);
   char *get_meaning(int, char *);
};
     В традиционном стиле С, мы помещаем определения в include
файл. Ключевое слово class вводит описание объекта. По умолча-
нию, элементы класса являются типа private (хотя Вы можете яв-
но использовать ключевое слово private),  поэтому в этом  слу-
чае,  поля в строках 9 - 11 могут быть доступными только функ-
циям данного класса.  (В С++, функции классов называются функ-
циями элементов.)Для того, чтобы сделать эти функции доступны-
ми в качестве интерфейса пользователя,  перед ними должно ста-
виться  ключевое  слово public.  Обратите внимание на то,  что
ключевое слово inline не требуется внутри определений  классов
(строка 15).
     Примечание.В других    объектно-ориентированных   языках,
классы часто называются объектами, а функции элементов - мето-
дами.
     Реализация обычно содержится в отдельном файле :
// def.cpp:   Реализация класса Definition
// из Главы 5 Начального руководства
#include <string.h>
#include "def.h"

void Definition::put_word(char *s)
{
   word = new char[strlen(s)+1];
   strcpy(word,s);
   nmeanings = 0;
}

void Definition::add_meaning(char *s)
{
   if (nmeanings < Maxmeans)
   {
      meanings[nmeanings] = new char[strlen(s)+1];
      strcpy(meanings[nmeanings++],s);
   }
}

char * Definition::get_meaning(int level, char *s)
{
   if (0 <= level && level < nmeanings)
      return strcpy(s,meanings[level]);
   else
      return 0;                                // строка 27
}
     Оператор разрешения  области  действия  (::)  информирует
компилятор о том,  что мы  определяем  функции  элементов  для
класса   Definition  (хорошей  практикой  является  присвоение
классу имени,  у которого первая буква - заглавная,  для  того
чтобы  избежать  конфликтов  с  именами библиотечных функций).
Ключевое слово new в строке 8 является заменой функции распре-
деления динамической памяти malloc.  В С++,  по соглашению для
указателя используется ноль вместо NULL (строка 27). Хотя мы в
данном  случае  так не делали,  разумно проверить то,  что new
возвращает значение, которое не равно нулю.
     Исходный текст
// ex5.cpp:   Использование класса Definition
// из Главы 5 Начального руководства
#include <iostream.h>
#include "def.h"

main()
{
   Definition d;          // Объявление объекта Definition
   char s[81];

   // Присваивание значений
   d.put_word("класс");
   d.add_meaning("группа студентов, встречающихся вместе для
                  изучения одного и того же предмета");
   d.add_meaning("группа,  совместно  использующая одинаковый
                  экономический статус");
   d.add_meaning("группа, множество или вид объектов, имеющих
                  одинаковые атрибуты");

   // Печатать их
   cout << d.get_word(s) << ":\n\n";
   for (int i = 0; d.get_meaning(i,s) != 0; ++i)
      cout << (i+1) << ": " << s << "\n";
}
     Выходные данные
     класс:
     1 : группа студентов, встречающихся вместе для изучения
         одного и того же предмета
     2 : группа,  совместно  использующая одинаковый
         экономический статус
     3 : группа, множество или вид объектов, имеющих
         одинаковые атрибуты

                         Программа 6

     Теперь мы определили словарь как собрание определений.
     Из командной строки постройте  DICTION.OBJ  и  DEF.OBJ  с
EX6.CPP.  Из  Programmers  Platform  используйте  файл проекта
EX6.PRJ.
// diction.h:   Класс Dictionary
// из Главы 5 Начального руководства
#include "def.h"

const int Maxwords = 100;

class Dictionary
{
   Definition *words;       // Массив определений; строка 9
   int nwords;

   int find_word(char *);   // строка 12

public:
   // Констрактор находится на следующей строке
   Dictionary(int n = Maxwords)  {nwords = 0;
   words = new Definition[n];};
   ~Dictionary() {delete words;};        // Это дестрактор
   void add_def(char *s, char **def);
        int get_def(char *, char **);
};
     Функция find_word на строке 12 предназначена  только  для
внутреннего  использования  классом Dictionary,  и поэтому она
относится к типу private. Функция с одним и тем же именем, что
и  класс называется констрактором (строка 16).  Она вызывается
один раз тогда, когда объявляется объект. Она используется для
выполнения  инициализаций;  здесь мы динамически размещаем па-
мять для массива определений.  Дестрактор (строка 17)  вызыва-
ется там,  где объект выходит из области действия (в этом слу-
чае,  оператор delete будет освобождать память ранее распреде-
ленную констрактором). Для того, чтобы иметь массив,элементами
которого являются объекты (строка 9), - используемый в качест-
ве  элемента  массива  класс должен иметь либо констрактор без
аргументов,  либо  вообще   не   иметь   констрактора   (класс
Definition не имеет ни того, ни другого).
// diction.cpp:   Реализация класса Dictionary
// из Главы 5 Начального руководства
#include "diction.h"

int Dictionary::find_word(char *s)
{
   char word[81];
   for (int i = 0; i < nwords; ++i)
      if (stricmp(words[i].get_word(word),s) == 0)
         return i;

   return -1;
}

void Dictionary::add_def(char *word, char **def)
{
   if (nwords < Maxwords)
   {
      words[nwords].put_word(word);
      while (*def != 0)
         words[nwords].add_meaning(*def++);
      ++nwords;
   }
}

int Dictionary::get_def(char *word, char **def)
{
   char meaning[81];
   int nw = 0;
   int word_idx = find_word(word);
   if (word_idx >= 0)
   {
      while (words[word_idx].get_meaning(nw,meaning) != 0)
      {
         def[nw] = new char[strlen(meaning)+1];
         strcpy(def[nw++],meaning);
      }
      def[nw] = 0;
   }

   return nw;
}
     Теперь мы  можем  использовать  класс  Dictionary без ка-
кой-либо ссылки на класс Definition (выходные данные те же са-
мые, как и в предыдущем примере).
     Исходный текст
// ex6.cpp:  Использование класса Dictionary
// из Главы 5 Начального руководства
#include <iostream.h>
#include "diction.h"

main()
{
   Dictionary d(5);
   char *word = "class";
   char *indef[4] =
     {"a body of students meeting together to study the same",
      "subject a group sharing the same economic status",
      "a group, set or kind sharing the same attributes",
      0};
   char *outdef[4];

   d.add_def(word,indef);
   cout << word << ":\n\n";
   int ndef = d.get_def(word,outdef);
   for (int i = 0; i < ndef; ++i)
      cout << (i+1) << ": " << outdef[i] << "\n";
}
     В реализации Dictionary  мы  специально  вызвали  функцию
элементов Definition.  Иногда это желательно,  чтобы позволить
определенным функциям или даже всему  классу  иметь  доступ  к
элементам типа private, относящимся к другому классу. Мы можем
объявить класс Dictionary как  friend  для  класса  Definition
(строка 18):
      Примечание.Скомпонуйте LIST.OBJ с EX7.CPP.
// def2.h:   Класс определения слова
// из Главы 5 Начального руководства
#include <string.h>

const int Maxmeans = 5;

class Definition
{
   char *word;                  // Слово, которое определяется
   char *meanings[Maxmeans]; // Различные значения этого слова
   int nmeanings;

public:
   void put_word(char *);
   char *get_word(char *s) {return strcpy(s,word);};
   void add_meaning(char *);
   char *get_meaning(int, char *);
   friend class Dictionary;         // строка 18
};
     Реализация find_word  может  затем   иметь   доступ   не-
посредственно к элементам Definition (строка 5 в следующем ко-
де):
     int Dictionary::find_word(char *s)
     {
        char word[81];
        for (int i = 0; i < nwords; ++i)
           if ((strcmp(words[i].word),s) == 0)
              return i;

        return -1;
     }

                         Программа 7

     Одной из ключевых особенностей программирования, ориенти-
рованного на объект,  является наследование. Новый класс может
наследовать данные и функции элементов из существующего  ("ба-
зового")  класса (новый класс,  как говорится,  порождается из
базового класса). В этой программе мы определили List, базовый
класс для обработки списка целых чисел, который затем порожда-
ет Stack, класс для управления стеком (который является специ-
альным  видом  списка).  Во-первых,  мы  создадим  файл  заго-
ловков:
     Примечание.Для пробы скомпонуйте LIST.OBJ и  EX7.CPP  или
используйте EX7.PRJ.
// list.h:   Класс целых чисел List
// из Главы 5 Начального руководства
const int Max_elem = 10;

class List
{
   int *list;        // Массив целых чисел
   int nmax;         // Размер массива
   int nelem;        // Количество элементов

public:
   List(int n = Max_elem) {list = new int[n]; nmax = n;
                           nelem = 0;};
   ~List() {delete list;};
   int put_elem(int, int);
   int get_elem(int&, int);
   void setn(int n) {nelem = n;};
   int getn() {return nelem;};
   void incn() {if (nelem < nmax) ++nelem;};
   int getmax() {return nmax;};
   void print();
};
     Затем мы создаем исходный код:
// list.cpp:   Реализация класса List
// из Главы 5 Начального руководства
#include <iostream.h>
#include "list.h"

int List::put_elem(int elem, int pos)
{
   if (0 <= pos && pos < nmax)
   {
      list[pos] = elem;    // Поместить элемент в список
      return 0;
   }
   else
      return -1;           // Не ноль означает ошибку
}

int List::get_elem(int& elem, int pos)
{
   if (0 <= pos && pos < nmax)
   {
      elem = list[pos];    // Найти элемент списка
      return 0;
   }
   else
      return -1;           // не ноль означает ошибку
}

void List::print()
{
   for (int i = 0; i < nelem; ++i)
      cout << list[i] << "\n";
}


     И, наконец, мы используем новый класс:

// ex7.cpp:   использование класса List
// из Главы 5 Начального руководства
#include "list.h"

main()
{
   List l(5);
   int i = 0;

   // Вставлять числа от 1 до 5
   while (l.put_elem(i+1,i) == 0)
      ++i;
   l.setn(i);

   l.print();
}
     Выходные данные

                  1
                  2
                  3
                  4
                  5

                         Программа 8

     Примечание.Скомпонуйте STACK.OBJ и  LIST.OBJ  с  EX8.CPP,
или используйте EX8.PRJ.
// stack2.h:   Класс Stack порожден из класса List
// из Главы 5 Начального руководства
#include "list.h"

class Stack : public List
{
   int top;

public:
   Stack() {top = 0;};
   Stack(int n) : List(n) {top = 0;};
   int push(int elem);
   int pop(int& elem);
   void print();
};
     Для того, чтобы определить порожденный класс, должно быть
доступным определение базового класса, поэтому мы включили его
файл заголовков(строка 3).  Строка 5 информирует компилятор  о
том, что класс Stack порождается из класса List. Ключевое сло-
во public выражает, что public элементы List должны рассматри-
ваться как public в Stack (это то,  что обычно требуется). Так
как класс List имеет констрактор,  который принимает аргумент,
констрактор  Stack  активизирует  непосредственно  констрактор
List (строка 11).  Констракторы базовых классов выполняются до
констракторов порожденного класса.
// stack.cpp:   Реализация класса Stack
// из главы 5 Начального руководства
#include <iostream.h>
#include "stack.h"

int Stack::push(int elem)
{
   int m = getmax();
   if (top < m)
   {
     put_elem(elem,top++);
     return 0;
   }
   else
     return -1;
   }
int Stack::pop(int& elem)
{
   if (top > 0)
   {
      elem = list[--top];
      return 0;
   }
   else
      return -1;
}

void Stack::print()
{
   for (int i = top-1; i >= 0; --i)
      cout << list[i] << "\n";
}
     Обратите внимание  на  то,  что  public функции элементов
класса List могут использоваться непосредственно,  потому  что
Stack - это List.  Однако, на private элементы части List объ-
екта Stack нельзя ссылаться непосредственно.
// ex8.cpp:   Использование класса Stack
// из Главы 5 Начального руководства
#include "stack.h"

main()
{
   Stack s(5);
   int i = 0;

   // Вставлять числа от 1 до 5
   while (s.push(i+1) == 0)
      ++i;

   s.print();
}
     Выходные данные
                5
                4
                3
                2
                1

                         Программа 9

     Иногда полезно позволить порожденному классу иметь прямой
доступ  к  некоторым  из  private  элементов  данных  базового
класса. Такие элементы данных называются protected (защищенны-
ми).
     Примечание.Скомпонуйте EX9.CPP, LIST2.OBJ, STACK2.OBJ или
используйте EX9.PRJ.
// list2.h:  Класс списка целых чисел
// из Главы 5 Начального руководства
const int Max_elem = 10;

class List
{
protected:     // Ключевое слово protected дает подклассам
               // прямой доступ к порожденным элементам
   int *list;        // Массив целых чисел
   int nmax;         // Размер массива
   int nelem;        // Количество элементов

public:
   List(int n = Max_elem) {list = new int[n]; nmax = n;
                           nelem = 0;};
   ~List() {delete list;};
   int put_elem(int, int);
   int get_elem(int&, int);
   void setn(int n) {nelem = n;};
   int getn() {return nelem;};
   void incn() {if (nelem < nmax) ++nelem;};
   int getmax() {return nmax;};
   virtual void print();                   // строка 22
};
     Теперь мы  можем  заменить вызовы функций элементов List,
на прямую ссылку на данные List в реализации Stack.
// stack.cpp:   Реализация класса Stack
#include <iostream.h>
#include "stack2.h"

int Stack::push(int elem)
{
   if (top < nmax)
   {
      list[top++] = elem;
      return 0;
    }
    else
       return -1;
}

int Stack::pop(int& elem)
{
   if (top > 0)
   {
      elem = list[--top];
      return 0;
   }
   else
      return -1;
}

void Stack::print()
{
   for (int i = top-1; i >= 0; --i)
      cout << list[i] << "\n";
   }
}
     А затем мы можем их опробовать:
// ex9.cpp:   Использование виртуальной функции print()
// из Главы 5 Начального руководства
#include <iostream.h>
#include "stack2.h"

main()
{
   Stack s(5);
   List l, *lp;
   int i = 0;

   // Вставлять числа от 1 до 5 в стек
   while (s.push(i+1) == 0)
      ++i;

   // Поместить пару чисел в список
   l.put_elem(1,0);
   l.put_elem(2,1);
   l.setn(2);

   cout << "Stack:\n";
   lp = &s;           // строка 22
   lp->print();   // Вызвать метод print() класса Stack;
                  // строка 23
   cout << "\nList:\n";
   lp = &l;
   lp->print();   // Вызвать метод print() класса List;
                  // строка 27
}
     Выходные данные
     Стек
     5
     4
     3
     2
     1
     Список
     1
     2
     Приведенный выше  пример  иллюстрирует полиморфизм (также
известный как "позднее связывание" или "динамическое  связыва-
ние",  которое  в С++ выполняется с использованием виртуальных
функций). Это означает, что тип объекта не идентифицируется до
начала выполнения программы. Посредством определения виртуаль-
ной функции элементов print (смотрите строку  22,  "list2.h"),
мы  можем активизировать различные функции элементов print че-
рез указатель на базовый класс. Выше, в строке 22, lp указыва-
ет  на  объект  Stack (вспомните:  Stack - это List),  поэтому
способ распечатки Stack активизируется в строке 23.  Аналогич-
но,  функция  элементов print класса List выполняется в строке
27.

                      Подведение итогов

     С++ выполняет гораздо больше функций,  чем описывается  в
данной  главе.  Как констатировалось в начале,  эта глава дает
возможность понять,  что из себя представляет С++,  для  того,
чтобы  показать как он отличается от С и чтобы продемонстриро-
вать как использовать большую часть основных особенностей С++.
Для получения большей информации по основным понятиям С++, об-
ратитесь к главе 4 " Учебник для начинающих изучать С++"; Гла-
ва  3 "C++" в Руководстве программиста" дает более расширенный
материал по С++.


