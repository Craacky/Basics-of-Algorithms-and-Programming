                             ГЛАВА 2.

                  БИБЛИОТЕКА ВРЕМЕНИ ВЫПОЛНЕНИЯ.

     Эта глава содержит детальное описание каждой функции биб-
лиотеки  Borland  C++.  Некоторые  функции сгруппированы в се-
мейства (как,  например,  exec...  и spawn... функции, которые
создают,  загружают и выполняют программы),  поскольку они вы-
полняют сходные или тесно связанные действия.
     В остальных  случаях для каждой функции имеется индивиду-
альная статья.  Например, если Вы хотите посмотреть информацию
по  функции free,  Вы можете открыть справочник на имени free,
где найдете следующую информацию:
     - что делает free;
     - синтаксис вызова free;
     - какой(ие)  файл(ы)  заголовка содержит(ат) прототип для
free;
     - детальное описание реализации free и ее связь с другими
функциями распределения памяти;
     - список  других компиляторов,  имеющих аналогичную функ-
цию;
     - список  связанных  с  ней  функций  Borland  C++;
     - пример  использования  функции  или  ссылку  на  другую
статью, содержащую такой пример.
     Все примеры программ из этой главы содержатся во встроен-
ной системе помощи. Это означает, что Вы можете легко скопиро-
вать их оттуда и вставить в свои файлы.
     Следующий макет показывает,  как пользоваться информацией
по функциям библиотеки Borland C++.

             Как пользоваться справочной библиотекой.

     Имя функции
──────────────────────────────────────────────────────────────
Функция        Что делает

Синтаксис      #include<header.h>

               Файл(ы) заголовка, содержащий(е) прототип функ-
               ции или определения констант,  перечислимых ти-
               пов и др. объектов, используемые функцией.

               функция(модификатор параметр[,...]);

               Определение синтаксиса функции.  [,...] показы-
               вает, что здесь могут следовать другие парамет-
               ры и их модификаторы.

Прототип в     header.h

               Файл(ы) заголовка, содержащий(е) прототип функ-
               ции.  Прототип  некоторых  функций содержится в
               более чем одном файле заголовка;  в этом случае
               приводится   весь   список  файлов.  Вы  можете
               использовать любой файл заголовка, который луч-
               ше подходит для ваших нужд.

Примечания     Описание действий функции,  ее параметров и де-
               талей использования.

Значение       Значение, возвращаемое  функцией.  Если функция
               устанавливает  значение  глобальной  переменной
               errno,  то  это  значение также приводится (См.
               документацию по DOS для интерпретации errno).

Переносимость  Приводятся системы и языки, в которых эта функ-
               ция  доступна.  Это  может быть UNIX,  IBM PC и
               совместимые с ней,  Си++,  Windows или стандарт
               ANSI C.

См. также      Функции, связанные  с рассматриваемой функцией.
               Если имя функции содержит многоточие (...), это
               указывает, что Вы ссылаетесь к целому семейству
               функций  (например,  exec...  ссылается  к  се-
               мейству   exe  функций:  excl,  execl,  execlp,
               execlpe, execv, execve, execvp и execvpe).

Пример         /* Здесь Вы найдете  небольшую  программу,  ил-
               люстрирующую  использование  этой  функции  (и,
               быть может, других связанных функций) */

     abort
──────────────────────────────────────────────────────────────
Функция        Аварийно завершает программу.

Синтаксис      #include<stdlib.h>
               void abort(void);

Прототип в     stdlib.h, process.h

Примечания     Пишет сообщение  "Abnormal program termination"
               (Аварийное завершение программы) в stderr,  за-
               тем завершает программу,  вызывая _exit с кодом
               выхода 3.

Значение       Возвращает код выхода 3 родительскому  процессу
               или DOS.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      assert, atexit,  exit,  _exit,  ralse,  signal,
               spawn...

Пример         #include <stdio.h>
               #include <stdlib.h>

               int main(void)
               {
                  printf("Calling abort()\n");
                  abort();
                  return 0; /* Оператор никогда */
               }            /*  не выполняется  */

     abs
──────────────────────────────────────────────────────────────
Функция        Возвращает абсолютное значение целого.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:     КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>        #include <complex.h>
               int abs(int x);          double abs(complex x);
Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:     КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                     complex.h

Примечания     Возвращает абсолютное значение целого аргумента
               x.  Если abs вызывается, когда stdlib.h включе-
               на,  она  интерпретируется  как макро,  которое
               расширяется  в  inline  код.  Если  Вы   хотите
               использовать функцию abs вместо макро, включите
               #undef   abs    в    Вашу    программу    после
               #include<stdlib.h>.

Значение       Вещественная версия возвращает целое в диапазо-
               не от 0 до 32,767, за исключением случая, когда
               аргумент   равен  -32,768:  тогда  возвращается
               -32,768. Комплексная версия возвращает double.

Переносимость  Вещественная версия доступна в системах UNIX  и
               определена  в  ANSI C.  Комплексная версия этой
               функции требует С++ и, вероятно, не переносима.

См. также      cabs, complex, fabs, labs

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  int number = -1234;
                  printf("number: %d  absolute value: %d\n",
                         number, abs(number));
                  return 0;
               }

     absread
──────────────────────────────────────────────────────────────
Функция        Читает абсолютный сектор диска.

Синтаксис      #include<dos.h>
               int absread(int drive, int nsects, int lsect,
                           void *buffer);

Прототип в     dos.h

Примечания     Читает указанные  секторы  с диска.  Игнорирует
               логическую структуру диска:  файлы, FAT и спра-
               вочники.
               absread использует прерывание DOS 0x25 для чте-
               ния абсолютных секторов диска.
               drive = номер устройства для чтения (0=A, 1=B и
               т.д.)
               nsects = число секторов для чтения
               lsect = начальный логический номер сектора
               buffer = адрес памяти, куда читаются данные
               Число секторов для  чтения  ограничено  объемом
               64К или размером буфера.

Значение       Если операция успешна, возвращается 0. В случае
               ошибки возвращается -1, и глобальная переменная
               errno устанавливается в значение,  возвращенное
               системой в регистре AX.

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      abswrite, biosdisk

Пример         #include <stdio.h>
               #include <stdlib.h>
               #include <conio.h>
               #include <dos.h>
               #include <ctype.h>

               #define SECSIZE 512
               unsigned char buf[SECSIZE];

               int main(void)
               {
                  int i, j, sector, drive;
                  char str[10];

                  printf("Enter drive letter: ");
                  gets(str);
                  drive = toupper(str[0]) - 'A';
                  printf("Enter sector number to read: ");
                  gets(str);
                  sector = atoi(str);
                  if absread(drive, 1, sector, &buf) != 0) {
                      perror("Disk error");
                      exit(1);
                  }
                  printf("\nDrive: %c   Sector: %d\n",
                         'A' + drive, sector);
                  for (i = 0; i < SECSIZE; i += 16)
                  {
                      if ((i / 16) == 20) {
                      printf("Press any key to continue...");
                          getch();
                          printf("\n");
                      }
                      printf("%03d: ", i);
                      for (j = 0; j < 16; j++)
                          printf("%02X ", buf[i + j]);
                      printf("\t");
                      for (j = 0; j > 16; j++)
                          if (isprint(buf[i + j]))
                              printf("%c", buf[i + j]));
                          else
                              printf(".");
                      printf("\n");
                  }
                  return 0;
               }

     abswrite
──────────────────────────────────────────────────────────────
Функция        #include<io.h>
               Пишет в абсолютный сектор на диске.

Синтаксис      #include<dos.h>
               int abswritee(int drive, int nsects, int lsect,
                             void *buffer);

Прототип в     dos.h

Примечания     Пишет в указанные секторы на диске.  Игнорирует
               логическую структуру диска:  файлы, FAT и спра-
               вочники.
         !!!   Если Вы  используете  abswrite некорректно,  то
               можете перекрыть файлы, FAT, или справочники.
               abswrite использует  прерывание  DOS  0x26  для
               чтения абсолютных секторов диска.
               drive = номер устройства для записи (0=A, 1=B и
               т.д.)
               nsects = число секторов для записи
               lsect = начальный логический номер сектора
               buffer = адрес памяти, откуда пишутся данные
               Число секторов  для  чтения  ограничено объемом
               64К или размером буфера.

Значение       Если операция успешна, возвращается 0. В случае
               ошибки возвращается -1, и глобальная переменная
               errno устанавливается в значение,  возвращенное
               системой в регистре AX.

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      absread, biosdisk

     access
──────────────────────────────────────────────────────────────
Функция        Определяет доступность файла.

Синтаксис      #include<io.h>
               int access(const char *filename, int amode);

Прототип в     io.h

Примечания
               Проверяет, существует ли файл filename, и может
               ли он быть считан, записан или выполнен.
               Список значений amode:
                  06 Проверить на возможность чтения и записи
                  04 Проверить на возможность чтения
                  02 Проверить на возможность записи
                  01 Выполнить (игнорируется)
                  00 Проверить на существование
         !!!   В DOS  все  существующие файлы доступны по чте-
               нию, поэтому 00 и 04 дают одинаковый результат.
               Аналогично  06  и 02 эквивалентны,  поскольку в
               DOS доступ по  записи  предполагает  доступ  по
               чтению.

Значение       Если запрашиваемый   доступ   разрешен,  access
               возвращает 0;  в противном случае  возвращается
               -1,  и и глобальная переменная errno устанавли-
               вается в одно из следующих значений:
                  ENOENT   Путь или файл не найден
                  EACCES   Доступ запрещен

Переносимость  Эта функция доступна в системах UNIX.

См. также      chmod, fstat, stat

Пример         #include <stdio.h>
               #include <io.h>

               int file_exists(char *filename);
               int main(void)
               {
                  printf("Does NOTEXIST.FIL exist: %s\n",
                    file_exists("NOTEXISTS.FIL")?"YES":"NO");
                  return 0;
               }
               int file_exists(char *filename)
               {
                  return (access(filename, 0) == 0);
               }

               Вывод программы

               Does NOTEXIST.FIL exist?  NO

     acos
──────────────────────────────────────────────────────────────
Функция        Вычисляет арккосинус.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>      #include <complex.h>
               double acos(double x); complex acos(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                 complex.h

Примечания     Вычисляет арккосинус заданного  аргумента.  Ве-
               щественный  аргумент  acos должен быть от -1 до
               1,  в противном случае acos  возвращает  NAN  и
               устанавливает  глобальную  переменную  errno  в
               значение
                  EDOM  Ошибка области определения
               Комплексное обращение косинуса определено как
                  acos(z) = - i * log(z + i * sqrt(1 - z * z))

Значение       Для вещественного  аргумента от -1 до 1 возвра-
               щает значение от 0 до pi.  Обработка ошибок для
               этой  функции  может  быть модифицирована с по-
               мощью функции matherr.

Переносимость  Вещественная версия доступна в системах UNIX  и
               определена  в  ANSI C.  Комплексная версия этой
               функции требует С++ и, вероятно, не переносима.

См. также      asin, atan,  atan2, complex, cos, matherr, sin,
               tan

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  double result;
                  double x = 0.5;
                  result = acos(x);
                  printf("The arc cosine of %lf is %lf\n", x,
                  result);
                  return 0;
               }

     allocmem
──────────────────────────────────────────────────────────────
Функция        Распределяет сегмент памяти DOS.

Синтаксис      #include<dos.h>
               int allocmem(unsigned size, unsigned *segp);

Прототип в     dos.h

Примечания     Использует системный вызов DOS 0x48 для распре-
               деления блока свободной памяти и возвращает ад-
               рес сегмента распределенного блока.
               size - требуемый размер в параграфах (16 байт).
               segp -  указатель  на  слово,  которому   будет
               присвоено  значение  адреса для вновь распреде-
               ленного блока. Присвоение не производится, если
               памяти  недостаточно.  Все распределенные блоки
               выравниваются на параграф.
         !!!   allocmem и malloc не могут использоваться  сов-
               местно.

Значение       Возвращает -1 в случае успеха.  В случае ошибки
               возвращается число, равное размеру в параграфах
               наибольшего  свободного блока.  В случае ошибки
               глобальные переменные _doserrno и  errno  уста-
               навливаются в значение
                  ENOMEM  Недостаточно памяти

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      coreleft, freemem, malloc, setblock

Пример         #include <dos.h>
               #include <alloc.h>
               #include <stdio.h>

               int main(void)
               {
                  unsigned int size, segp;
                  int stat;
                  size = 64; /* (64 x 16) = 1024 байта */
                  stat = allocmem(size, &segp);
                  if (stat == -1)
                     printf("Allocated memory at
                     segment: %x\n", segp);
                  else
                     printf("Failed: maximum number of
                     paragraphs аvailable is %u\n", stat);
                  return 0;
               }

     arc
──────────────────────────────────────────────────────────────
Функция        Рисует дугу.

Синтаксис      #include<graphics.h>
               void far arc(int x, int y, int stangle,
                            int endangle, int radius);

Прототип в     graphics.h

Примечания     Рисует дугу окружности с центром в точке  (x,y)
               и радиусом radius.  Дуга рисуется от начального
               угла  stangle  до  конечного  угла  endangle  с
               использованием  текущего  цвета.  При начальном
               угле 0 и конечном 360 будет  нарисована  полная
               окружность.  Углы  для arc отсчитываются против
               часовой стрелки,  например,  0  градусов  соот-
               ветствует  3  часам,  90  градусов - 12 часам и
               т.д. Параметр linestyle не оказывает влияния на
               дуги,  окружности, эллипсы и сектора. Использу-
               ется только параметр thickness.
         !!!   Если Вы  используете CGA в режиме высокого раз-
               решения или  монохромный  графический  адаптер,
               примеры этой книги могут не приводить к ожидае-
               мым результатам.  Если Ваша система выполняется
               на CGA или монохромном адаптере, передайте зна-
               чение 1 функциям, устанавливающим цвета (напри-
               мер,  setcolor,  setfillstyle  и setlinestyle),
               вместо символической константы  цвета  (опреде-
               ленной в graphics.h).

Значение       Нет

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      circle, ellipse, fillellipse, getarccoords,
               getaspectratio, graphresult, pieslice, sector

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                   /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy;
                  int stangle = 45, endangle = 135;
                  int radius = 100;
             /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  setcolor(getmaxcolor());
                  /* рисование дуги */
                  arc(midx, midy, stangle, endangle, radius);
                  /* очистка */
                  getch();
                  closegraph();
                  return 0;
               }

     arg
──────────────────────────────────────────────────────────────
Функция        Вычисляет аргумент комплексного числа.

Синтаксис      #include<complex.h>
               double arg(complex x);

Прототип в     complex.h

Примечания     Вычисляет аргумент  комплексного числа в радиа-
               нах. Положительная действительная ось имеет ар-
               гумент 0, а положительная мнимая pi/2. Если ар-
               гумент, передаваемый в arg, есть комплексный 0,
               arg возвращает 0.

Значение       arg(x) возвращает atan2(imag(x), real(x))

Переносимость  Комплексные функции  требуют C++ и не переноси-
               мы.

См. также      complex, norm, polar

Пример         #include <iostream.h>
               #include <complex.h>

               int main(void)
               {
              double x = 3.1, y = 4.2;
              complex z = complex(x,y);
              cout << "z = " << z << "\n";
              cout << "  has real part = " << real(z) << "\n";
              cout << "  and imaginary part = " << imag(z)
                   << "\n";
              cout << "z has complex conjugate = " << conj(z)
                   << "\n";
              double mag = sqrt(norm(z));
              double ang = arg(z);
              cout << "The polar form of z is:\n";
              cout << "   magnitude = " << mag << "\n";
              cout << "   angle (in radians) = " << ang
                   << "\n";
              cout << "Reconstructing z from its polar form
                      gives:\n";
              cout << "   z = " << polar(mag,ang) << "\n";
              return 0;
               }

     asctime
──────────────────────────────────────────────────────────────
Функция        Преобразует дату и время в ASCII.

Синтаксис      #include<time.h>
               char *asctime(const struct tm *tblock);

Прототип в     time.h

Примечания     Преобразует значение даты и времени, содержаще-
               еся в структуре  в  *tblock,  в  26  символьную
               строку в такой же форме, как и ctime:
                  Sun Sep 16 01:03:52 1973\n\0

Значение       Возвращает указатель на символьную строку,  со-
               держащую  дату и время.  Строка является стати-
               ческой переменной, которая перезаписывается при
               каждом вызове asctime.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      ctime, difftime,  ftime,   gmtime,   localtime,
               mktime strtime, stime, time, tzset

Пример         #include <stdio.h>
               #include <string.h>
               #include <time.h>

               int main(void)
               {
                  struct tm t;
                  char str[80];
                  /* пример загрузки структуры tm */
               t.tm_sec    = 1;  /* Секунды */
               t.tm_min    = 30; /* Минуты */
               t.tm_hour   = 9;  /* Час */
               t.tm_mday   = 22; /* День месяца */
               t.tm_mon    = 11; /* Месяц */
               t.tm_year   = 56; /* Год - не включая век */
               t.tm_wday   = 4;  /* День недели */
               t.tm_yday   = 0;  /* Не показывать в asctime */
               t.tm_isdst  = 0;  /* Летнее время;
                                    не показывать в asctime */
                  /* преобразование структуры к строке,
                  завершаемой нуль-символом */
                  strcpy(str, asctime(&t));
                  printf("%s\n", str);
                  return 0;
               }

     asin
──────────────────────────────────────────────────────────────
Функция        Вычисляет арксинус.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>      #include <complex.h>
               double asin(double x); complex asin(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                 complex.h

Примечания     Вычисляет арксинус заданного аргумента. Вещест-
               венный аргумент asin должен быть от -1 до 1,  в
               противном случае asin возвращает NAN и устанав-
               ливает errno в
                  EDOM  Ошибка области определения
               Комплексное обращение синуса определено как
                  asin(z) = -i * log(i * z + sqrt(1 - z * z))

Значение       Для вещественного аргумента от -1 до 1  возвра-
               щает значение от -pi/2 до pi/2.  Обработка оши-
               бок для этой функции может быть  модифицирована
               с помощью функции matherr.

Переносимость  Вещественная версия  доступна в системах UNIX и
               определена в ANSI C.  Комплексная  версия  этой
               функции требует С++ и, вероятно, не переносима.

См. также      acos, atan, atan2, complex, matherr, sin, tan

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  double result;
                  double x = 0.5;
                  result = asin(x);
                  printf("The arc sin of %lf is %lf\n",
                   x,result);
                  return(0);
               }

     assert
──────────────────────────────────────────────────────────────
Функция        Проверяет условие и, возможно, завершает работу
               программы.

Синтаксис      #include<assert.h>
               void assert(int test);

Прототип в     assert.h

Примечания     assert -  это  макро,  которое  расширяется   в
               if-оператор; если значение test равно 0, assert
               печатает сообщение в stderr и  завершает  прог-
               рамму, вызывая abort. assert печатает следующее
               сообщение:

               Assertion failed: test, file filename,
               line linename

               filename и linename - это имя исходного файла и
               номер  строки,  где  появилось  макрорасширение
               assert. Если Вы поместите директиву
                  #define  NDEBUG
               ("не-отладка") в исходном коде перед директивой
               #include<assert.h>,  то  оператор  assert будет
               закомментирован.

Значение       Нет.

Переносимость  Эта функция доступна в некоторых системах UNIX,
               включая Systems III и V, и совместима с ANSI C.

См. также      abort

Пример         #include <assert.h>
               #include <stdio.h>
               #include <stdlib.h>

               struct ITEM {
                  int key;
                  int value;
               };
               /* добавить элемент в список,
                  если элемент существует     */
               void additem(struct ITEM *itemptr) {
                  assert(itemptr != NULL);
                  /* добавление элемента в список */
               }
               int main(void)
               {
                  additem(NULL);
                  return 0;
               }

               Вывод программы

               Assertion failed: itemptr !=NULL,
               file C:\TC\ASSERT.C, line 12

     atan
──────────────────────────────────────────────────────────────
Функция        Вычисляет арктангенс.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>      #include <complex.h>
               double atan(double x); complex atan(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                 complex.h

Примечания     Вычисляет арктангенс заданного аргумента.
               Комплексное обращение тангенса определено как:
               atan(z)=- 0.5*i* log((1 + i * z)/(1 - i * z))

Значение       Для вещественного аргумента возвращает значение
               от  -pi/2  до  pi/2.  Обработка ошибок для этой
               функции может  быть  модифицирована  с  помощью
               функции matherr.

Переносимость  Вещественная версия  доступна в системах UNIX и
               определена в ANSI C.  Комплексная  версия  этой
               функции требует С++ и, вероятно, не переносима.

См. также      acos, asin,  atan2, complex, cos, matherr, sin,
               tan

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  double result;
                  double x = 0.5;
                  result = atan(x);
                  printf("The arc tangent of %lf is %lf\n", x,
                         result);
                  return(0);
               }

     atan2
──────────────────────────────────────────────────────────────
Функция        Вычисляет арктангенс от y/x.

Синтаксис      #include<math.h>
               double atan2(double y, double x);

Прототип в     math.h

Примечания     Вычисляет арктангенс от  y/x;  дает  правильный
               результат,  даже  когда  угол близок к pi/2 или
               -pi/2 (x близок к 0).  Если и x и  y  равны  0,
               errno устанавливается в EDOM.

Значение       Возвращает значение  от  -pi  до pi.  Обработка
               ошибок для этой функции может быть  модифициро-
               вана функцией matherr.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      acos, asin, atan, cos, matherr, sin, tan

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  double result;
                  double x = 90.0, y = 15.0;

                  result = atan2(y, x);
              printf("The arc tangent ratio of %lf is %lf\n",
                         (y / x), result);
                  return 0;
               }

     atexit
──────────────────────────────────────────────────────────────
Функция        Регистрирует функцию выхода.

Синтаксис      #include<stdlib.h>
               int atexit(atexit_t func);

Прототип в     stdlib.h

Примечания     Регистрирует функцию,  указываемую func,  в ка-
               честве функции выхода.  При нормальном заверше-
               нии   программы   exit   вызывает  (*func)  не-
               посредственно перед  возвратом  в  операционную
               систему.  Каждый  вызов atexit регистрирует еще
               одну завершающую функцию.  Может быть зарегист-
               рировано  до  32  функций.  Они  выполняются на
               основе "последним пришел  -  первым  обслужен",
               т.е.,  функция,  зарегистрированная  последней,
               будет выполнена первой.

Значение       atexit возвращает 0 в случае успеха и ненулевой
               результат  при неудаче (нет места для регистра-
               ции).

Переносимость  Эта функция совместима с ANSI C.

См. также      abort, _exit, exit, spawn...

Пример         #include <stdio.h>
               #include <stdlib.h>

               void exit_fn1(void)
               {
                  printf("Exit function #1 called\n");
               }
               void exit_fn2(void)
               {
                  printf("Exit function #2 called\n");
               }
               int main(void)
               {
                  /* регистрация функции #1 */
                  atexit(exit_fn1);
                  /* регистрация функции #2 */
                  atexit(exit_fn2);
                  printf("Done in main\n");
                  return 0;
               }

     atof
──────────────────────────────────────────────────────────────
Функция        Преобразует строку в число с плавающей точкой.

Синтаксис      #include<math.h>
               double atof(const char *s);

Прототип в     math.h, stdlib.h

Примечания     Преобразует строку,  указываемую s,  в  double;
               данная  функция распознает символьное представ-
               ление числа с плавающей точкой,  которое  может
               включать:
               - необязательную  строку  из табуляций и пробе-
               лов;
               - необязательный знак;
               - строку цифр и необязательную десятичную точку
               (цифры  могут быть с обеих сторон от десятичной
               точки);
               - необязательный  символ  e или E с последующим
               за ним необязательным знаковым целым;
               Строка должна соответствовать формату:

               [пробелы/табуляции][знак][ddd][.][ddd][e/E
               [знак]ddd]

               atof также распознает +INF и -INF для  плюс(ми-
               нус) бесконечности и +NAN и -NAN для не-числа.
               При первом нераспознанном символе  эта  функция
               завершает преобразование.
               strtod подобна atof;  она  обеспечивает  лучшее
               обнаружение ошибок и, следовательно, предпочти-
               тельнее в некоторых приложениях.

Значение       Возвращает преобразованное   значение   входной
               строки.  При переполнении atof возвращает  плюс
               или минус HUGE_VAL, глобальная переменная errno
               устанавливается в значение ERANGE, и matherr не
               вызывается.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      atoi, atol, ecvt, fcvt, gcvt, scanf, strtod

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  float f;
                  char *str = "12345.678";
                  f = atof(str);
                  printf("string = %s float = %f\n", str, f);
                  return 0;
               }

     atoi
──────────────────────────────────────────────────────────────
Функция        Преобразует строку в целое.

Синтаксис      #include<stdlib.h>
               int atoi(const char *s);

Прототип в     stdlib.h

Примечания     Преобразует строку,  указываемую s, в int; дан-
               ная функция распознает (в указанном порядке):
               - необязательную  строку  из табуляций и пробе-
               лов;
               - необязательный знак;
               - строку  цифр.
               Строка должна соответствовать формату:
                  [пробелы/табуляции][знак][ddd]
               При первом нераспознанном символе  эта  функция
               завершает преобразование.
               В atoi нет проверки на переполнение  (результат
               в этом случае неопределен).

Значение       atoi возвращает преобразованное значение  вход-
               ной строки.  Если строка не может быть преобра-
               зована к типу int, возвращается 0.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      atof, atol, ecvt, fcvt, gcvt, scanf, strtod

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  int n;
                  char *str = "12345";
                  n = atoi(str);
                  printf("string = %s integer = %d\n",str,n);
                  return 0;
               }

     atol
──────────────────────────────────────────────────────────────
Функция        Преобразует строку в длинное целое (long).

Синтаксис      #include<stdlib.h>
               long atol(const char *s);

Прототип в     stdlib.h

Примечания     Преобразует строку, указываемую s, в long; дан-
               ная функция распознает (в указанном порядке):
               - необязательную  строку  из табуляций и пробе-
               лов;
               - необязательный знак;
               - строку  цифр.
               Строка должна соответствовать формату:
                  [пробелы/табуляции][знак][ddd]
               При первом  нераспознанном  символе эта функция
               завершает преобразование.
               В atol  нет проверки на переполнение (результат
               в этом случае неопределен).

Значение       atol возвращает  преобразованное значение вход-
               ной строки.  Если строка не может быть преобра-
               зована к типу long, возвращается 0.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      atof, atoi,  ecvt,  fcvt,  gcvt, scanf, strtod,
               strtol, strtoul

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  long l;
                  char *lstr = "98765432";
                  l = atol(lstr);
                  printf("string = %s integer=%ld\n",lstr,l);
                  return(0);
               }

     bar
──────────────────────────────────────────────────────────────
Функция        Рисует (плоский) прямоугольник.

Синтаксис      #include<graphics.h>
               #include<conio.h>
               void far bar(int left, int top,
                            int right, int bottom);

Прототип в     graphics.h

Примечания     Рисует закрашенный    плоский    прямоугольник.
               Используются  текущие шаблон и цвет заполнения.
               Контур не изображается.  Нарисовать контур пря-
               моугольника можно,  вызывая bar3d с нулевым па-
               раметром depth.  Верхний правый и нижний  левый
               углы  задаются,  соответственно,  парами (left,
               top) и (right, bottom). Координаты в пикселах.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См. также      bar3d, rectangle,    setcolor,    setfillstyle,
               setlinestyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                   /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy, i;
              /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)  /* ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  /* цикл по шаблонам заполнения */
                  for (i=SOLID_FILL; i<USER_FILL; i++)
                  {
                     /* установка шаблона и цвета заполнения*/
                     setfillstyle(i, getmaxcolor());
                     /* рисование прямоугольника */
                     bar(midx-50, midy-50, midx+50,
                        midy+50);
                     getch();
                  }
                  /* очистка */
                  closegraph();
                  return 0;
               }

     bar3d
──────────────────────────────────────────────────────────────
Функция        Рисует прямоугольный параллелепипед.

Синтаксис      #include<graphics.h>
               void far bar3d(int left, int top, int right,
                       int bottom, int depth, int topflag);

Прототип в     graphics.h

Примечания     Рисуется закрашенный параллелепипед.  Использу-
               ются текущие шаблон и цвет заполнения. Трехмер-
               ный  контур рисуется текущим типом линии и цве-
               том. Параметр depth задает глубину параллелепи-
               педа  в  пикселах.  Если topflag ненулевой,  то
               верхняя грань параллелепипеда рисуется,  в про-
               тивном  случае  -  нет  (это позволяет рисовать
               несколько  параллелепипедов  один  на  другом).
               Верхний  правый  и  нижний левый углы задаются,
               соответственно,  парами (left,  top) и  (right,
               bottom).  Обычно глубина принимается равной 25%
               от ширины параллелепипеда, например:
               bar3d(left,top,right,bottom,(right-left)/4,1);

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      bar, rectangle,     setcolor,     setfillstyle,
               setlinestyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                   /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy, i;
             /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)  /* ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  /* цикл по шаблонам заполнения */
                  for (i=EMPTY_FILL; i<USER_FILL; i++)
                  {
                   /* установка шаблона и цвета заполнения */
                     setfillstyle(i, getmaxcolor());
                     /* рисование параллелепипеда */
                     bar3d(midx-50, midy-50, midx+50, midy+50,
                           10, 1);
                     getch();
                  }
                  /* очистка */
                  closegraph();
                  return 0;
               }

     bcd
──────────────────────────────────────────────────────────────
Функция        Преобразует число  к  двоично-десятичному  виду
               (BCD).

Синтаксис      #include<bcd.h>
               bcd bcd (int x);
               bcd bcd (double x);
               bcd bcd (double x, int decimals);

Прототип в     bcd.h

Примечания     Все обычные  арифметические  операторы   должны
               быть перезагружены для работы с BCD числами.
               BCD числа  имеют  точность  около 17 десятичных
               цифр в диапазоне примерно от 1 * 10 **(-125) до
               - 1 * 10 ** 125.
               Используйте функцию real для преобразования BCD
               чисел обратно во float, double или long double.
               Аргумент decimals необязателен. Он задает число
               десятичных цифр после десятичной точки.
               Число округляется в  соответствии  с  правилами
               банковского округления, которое означает округ-
               ление до ближайшего целого, причем половина ок-
               ругляется до четной цифры.

Значение       BCD эквивалент данного числа.

Переносимость  Эта  функция  доступна  только в  Borland C++ и
               работает только с С++.

См. также      real

Пример         #include <iostream.h>
               #include <bcd.h>

               double x = 10000.0;    // десять тысяч долларов
               bcd a = bcd(x/3,2);    // треть,  округленная
                                         до ближайшего цента
               int main(void)
               {
                  cout << "share of fortune = $" << a << "\n";
                  return 0;
               }

     bdos
──────────────────────────────────────────────────────────────
Функция        Обеспечивает доступ к системным вызовам DOS.

Синтаксис      #include<dos.h>
               int bdos(int dosfun, unsigned dosdx,
                        unsigned dosal);

Прототип в     dos.h

Примечания     Обеспечивает прямой  доступ ко многим системным
               вызовам DOS. См. Ваше руководство по DOS по по-
               воду дальнейших деталей по каждому вызову.
               Для каждого системного вызова, требующего цело-
               го аргумента,  используйте bdos; если требуется
               аргумент-указатель, используйте bdosptr.
               В больших  моделях  данных  (compact,  large  и
               huge)  важно  использовать  bdosptr вместо bdos
               для системных вызовов,  требующих  указатель  в
               качестве аргумента.
               dosfun - номер функции; определен в Вашем руко-
               водстве по DOS.
               dosdx - значение регистра DX.
               dosal - значение регистра AL.

Значение       Значение регистра AX, устанавливаемое системным
               вызовом.

Переносимость  Эта функция доступна только в DOS.

См. также      bdosptr, geninterrupt,  int86,  int86x, intdos,
               intdosx

Пример         #include <stdio.h>
               #include <dos.h>

              /* Получить текущее устройство как 'A','B',...*/
               char current_drive(void)
               {
                  char curdrive;
                  /* Получить текущий диск как 0, 1, ... */
                  curdrive = bdos(0x19, 0, 0);
                  return('A' + curdrive);
               }
               int main(void)
               {
                  printf("The current drive is %c:\n",
                         current_drive());
                  return 0;
               }

               Вывод программы

               The current drive is C:

     bdosptr
──────────────────────────────────────────────────────────────
Функция        Обеспечивает доступ к системным вызовам DOS.

Синтаксис      #include<dos.h>
               int bdosptr(int dosfun, void *argument,
                           unsigned dosal);

Прототип в     dos.h

Примечания     Обеспечивает прямой доступ ко многим  системным
               вызовам DOS. См. Ваше руководство по DOS по по-
               воду дальнейших деталей по каждому вызову.
               Для каждого системного вызова, требующего цело-
               го аргумента,  используйте bdos; если требуется
               аргумент-указатель, используйте bdosptr.
               В больших  моделях  данных  (compact,  large  и
               huge) важно использовать  bdosptr  вместо  bdos
               для  системных  вызовов,  требующих указатель в
               качестве аргумента.
               В малых моделях данных argument определяет зна-
               чение DX,  в больших моделях  -значение  DS:DX,
               используемые системным вызовом.
               dosfun - номер функции; определен в Вашем руко-
               водстве по DOS.
               dosal - значение регистра AL.

Значение       Значение AX в случае успеха и -1 при ошибке.  В
               последнем случае устанавливаются глобальные пе-
               ременные errno и _doserrno.

Переносимость  Эта функция доступна только в DOS.

См. также      bdos, geninterrupt,   int86,   int86x,  intdos,
               intdosx

Пример         #include <string.h>
               #include <stdio.h>
               #include <dir.h>
               #include <dos.h>
               #include <errno.h>
               #include <stdlib.h>

               #define  BUFLEN  80

               int main(void)
               {
                  char  buffer[BUFLEN];
                  int   test;
               printf("Enter full pathname of a directory\n");
                  gets(buffer);
                  test = bdosptr(0x3B,buffer,0);
                     if(test)
                     {
                     printf("DOS error message: %d\n", errno);
                        /* See errno.h for error listings */
                        exit (1);
                     }
                  getcwd(buffer, BUFLEN);
              printf("The current directory is: %s\n",buffer);
                  return 0;
               }

     bioscom
──────────────────────────────────────────────────────────────
Функция        Работает с последовательным портом В/В.

Синтаксис      #include<bios.h>
               int bioscom(int cmd, char abyte, int port);

Прототип в     bios.h

Примечания     Выполняет различные операции обмена с  последо-
               вательным портом В/В port.
               Значение port = 0 соответствует COM1;  port = 1
               - COM2 и т.д.
               Значение cmd может быть:
               0 -  Установить  параметры  обмена  в  значение
               abyte.
               1 - Переслать значение abyte в порт.
               2 - Считать символ из порта.
               3 - Получить текущий статус порта.
               abyte есть  комбинация следующих бит (одно зна-
               чение выбирается из каждой группы):
               0x02    7 бит данных
               0x03    8 бит данных         0x00    110 бод
                                            0x20    150 бод
               0x00    1 стоп-бит           0x40    300 бод
               0x04    2 стоп-бита          0x60    600 бод
                                            0x80    1200 бод
               0x00    Без паритета         0xA0    2400 бод
               0x08    Нечетный паритет     0xC0    4800 бод
               0x18    Четный паритет       0xE0    9600 бод
               Например, значение 0xEB (0xE0 | 0x08 |  0x00  |
               0x03) устанавливает параметры порта в 9600 бод,
               нечетный паритет, 1 стоп-бит, 8 бит данных.
               bioscom использует прерывание BIOS 0x14.

Значение       Для всех  значений   cmd   bioscom   возвращает
               16-битное целое,  где старшие 8 бит - биты ста-
               туса, а смысл младших 8 бит зависит от значения
               cmd.  Значения  старших битов для возвращаемого
               значения:
                 15  Тайм-аут
                 14  Регистр сдвига пуст
                 13  Регистр хранения пуст
                 12  Разрыв связи
                 11  Ошибка синхронизации
                 10  Ошибка четности
                  9  Ошибка переполнения
                  8  Готовность данных
               Если значение abyte послать не удалось,  бит 15
               устанавливается в 1. В противном случае осталь-
               ные  старшие  и  младшие  биты  устанавливаются
               соответствующим образом.  Например, если возни-
               кает ошибка синхронизации, то бит 11 устанавли-
               вается  в  1.  При cmd = 2 считанный байт нахо-
               дится в младших битах  возвращаемого  значения,
               если не было ошибок.  Если возникла ошибка , то
               по крайней мере один старший  бит  устанавлива-
               ется  в  1.  Если  ни  один из старших битов не
               установлен в 1, байт считан без ошибок. При cmd
               =  3  или 0 старшие биты возвращаемого значения
               установлены,  как определено ранее,  а  младшие
               биты определяются так:
                 7  Сигнал обнаружения линии приема
                 6  Кольцевой индикатор
                 5  Готовность набора данных
                 4  Свободный для передачи
                 3  Индикатор изменения в бите 7
                 2  Задний фронт кольцевого индикатора
                 1  Индикатор изменения бита 5
                 0  Индикатор изменения бита 4

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми.

Пример         #include <bios.h>
               #include <conio.h>

               #define COM1       0
               #define DATA_READY 0x100
               #define TRUE       1
               #define FALSE      0
               #define SETTINGS ( 0x80 | 0x02 | 0x00 | 0x00)

               int main(void)
               {
                  int in, out, status, DONE = FALSE;
                  bioscom(0, SETTINGS, COM1);
                  cprintf("... BIOSCOM [ESC] to exit ...\n");
                  while (!DONE) {
                     status = bioscom(3, 0, COM1);
                     if (status & DATA_READY)
                        if ((out = bioscom(2, 0, COM1) &
                           0x7F) != 0) putch(out);
                        if (kbhit()) {
                           if ((in = getch()) == '\x1B')
                              DONE = TRUE;
                           bioscom(1, in, COM1);
                        }
                  }
                  return 0;
               }

     biosdisk
──────────────────────────────────────────────────────────────

Функция        Работает с дисковым сервисом BIOS.

Синтаксис      #include<bios.h>
               int biosdisk(int cmd, int drive, int head,
               int track,int sector,int nsects,void *buffer);

Прототип в     bios.h

Примечания     Использует прерывание 0x13 для работы  напрямую
               с дисковыми операциями BIOS.
               drive -  это число,  задающее используемое уст-
               ройство:  0 для первого  флоппи-диска,  1-  для
               второго и т.д.  Для жестких дисков: 0x80 задает
               первый жесткий диск,  0x81 - второй и т.д.  Для
               жестких  дисков  указывается  физический  номер
               устройства, а не разделы на диске. Если необхо-
               димо,  прикладные программы должны сами интерп-
               ретировать  информацию  из   таблицы   разделов
               диска.
               cmd задает операцию,  которую необходимо выпол-
               нить.  В зависимости от значения cmd могут пот-
               ребоваться другие параметры. Возможные значения
               cmd для IBM PC,  XT, AT, PS/2 или совместимых с
               ними систем:
               0 Сброс устройства.  Все другие параметры игно-
               рируются.
               1 Возвращает  статус  последней дисковой опера-
               ции. Все другие параметры игнорируются.
               2 Читает  один или несколько секторов в память.
               Начальный сектор чтения  задается  через  head,
               track,  sector. Число секторов - nsects. Данные
               читаются по 512 байт на сектор в buffer.
               3 Пишет  один или несколько секторов из памяти.
               Начальный сектор записи  задается  через  head,
               track,  sector. Число секторов - nsects. Данные
               пишутся по 512 байт на сектор из buffer.
               4 Проверяет  один  или  несколько  секторов  на
               сбой.  Начальный сектор  задается  через  head,
               track, sector. Число секторов - nsects.
               5 Форматирует дорожку.  Дорожка задается  через
               head и track. buffer указывает на таблицу заго-
               ловков секторов для записи на указанную  дорож-
               ку. Описание этой таблицы и операции форматиро-
               вания см.  "Техническое Справочное  Руководство
               по IBM PC".
               Следующие значения cmd действительны только для
               XT, AT, PS/2 и совместимых с ними:
               6 Форматирует дорожку и устанавливает флаги  на
               дефектных секторах.
               7 Форматирует диск,  начиная с указанной дорож-
               ки.
               8 Возвращает текущие параметры устройства.  Ин-
               формация возвращается в buffer,  в первых четы-
               рех байтах.
               9 Инициализирует характеристики пары формирова-
               телей.
               10 Длинное чтение.  Читает 512 плюс 4 байта  на
               сектор.
               11 Длинная запись.  Пишет 512 плюс 4  байта  на
               сектор.
               12 Позиционирование на диске.
               13 Альтернативный сброс устройства.
               14 Читает буфер сектора.
               15 Пишет буфер сектора.
               16 Проверяет готовность указанного устройства.
               17 Перекалибрует устройство.
               18 Диагностика контроллера RAM.
               19 Диагностика устройства.
               20 Внутренняя диагностика контроллера.
         !!!   biosdisk выполняется на физическом уровне  сек-
               торов. Это может привести к разрушению содержи-
               мого файлов и справочников на жестком диске.

Значение       Возвращает байт статуса, скомпонованный из сле-
               дующих битов:
               0x00 Операция успешна.
               0x01 Неверная команда.
               0x02 Адресный маркер не найден.
               0x03 Попытка записи на защищенный диск.
               0x04 Сектор не найден.
               0x05 Неуспешный сброс.
               0x06 Диск изменился после последней операции.
               0x07 Ошибочный параметр устройства.
               0x08 Прямой доступ к памяти (DMA) перекрыт.
               0x09 Попытка получить доступ через  DMA  более,
               чем к 64К памяти.
               0x0A Обнаружен дефектный сектор.
               0x0B Обнаружена дефектная дорожка.
               0x0C Неподдерживаемая дорожка.
               0x10 Неверный CRC/ECC при чтении.
               0x11 CRC/ECC скорректированная ошибка данных.
               0x20 Контроллер неисправен.
               0x40 Неудачная операция поиска.
               0x80 Нет ответа.
               0xAA Устройство не готово (только для  жесткого
               диска).
               0xBB Неопределенная ошибка ( только для жестко-
               го диска).
               0xCC Ошибка при записи.
               0xE0 Ошибка статуса.
               0xFF Недопустимая операция.

               0x11 не является ошибкой т.к. данные корректны.
               Это значение возвращается, чтобы программа мог-
               ла принять решение самостоятельно.

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми.

См. также      absread, abswrite

Пример         #include <bios.h>
               #include <stdio.h>

               int main(void)
               {
                  #define CMD   2/* команда чтения сектора */
                  #define DRIVE 0/* номер устройства для A:*/
                  #define HEAD  0/* номер головки диска    */
                  #define TRACK 1/* номер дорожки          */
                  #define SECT  1/* номер сектора          */
                  #define NSECT 1/* количество секторов    */
                  int result;
                  char buffer[512];
                  printf("ttemoting to read from drive A:\n");
                  result = biosdisk(CMD, DRIVE, HEAD, TRACK,
                                    SECT, NSECT, buffer);
                  if (result == 0)
                  printf("Disk read from A: successful.\n");
                  else
          printf("Attempt to read from drive A: failed.\n");
                  return 0;
               }

     biosequip
──────────────────────────────────────────────────────────────
Функция        Проверяет наличие подключенного оборудования.

Синтаксис      #include<bios.h>
               int biosequip(void);

Прототип в     bios.h

Примечания     Использует прерывание BIOS  0x11  и  возвращает
               целое   значение,   описывающее   оборудование,
               подсоединенное к компьютеру.

Значение
               Возвращаемое значение интерпретируется как  на-
               бор битовых полей. Значения битов для IBM PC:
               14-15 Число подключенных параллельных принтеров
                       00 = 0
                       01 = 1
                       10 = 2
                       11 = 3
               13     Подключен последовательный принтер
               12     Есть игровой порт В/В
               9-11   Число COM портов
                       000 = 0
                       001 = 1
                       010 = 2
                       011 = 3
                       100 = 4
                       101 = 5
                       110 = 6
                       111 = 7
               8      Прямой доступ к памяти (DMA)
                       0 = есть
                       1 = нет
               6-7    Число дисковых драйверов
                       00 = 1
                       01 = 2
                       10 = 3
                       11 = 4 (только если бит 0 - 1)
               4-5    Видеорежим по умолчанию
                       00 = не используется
                       01 = 40x25 BW с цветным адаптером
                       10 = 80x25 BW с цветным адаптером
                       11 = 80x25 BW с монохромным адаптером
               2-3    Размер памяти на материнской плате
                       00 = 16К
                       01 = 32К
                       10 = 48К
                       11 = 64К
               1      Математический сопроцессор
               0      Загрузка с диска

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми.

Пример         #include <bios.h>
               #include <stdio.h>

               #define CO_PROCESSOR_MASK  0x0002

               int main(void)
               {
                   int equip_check;
                   /* получить конфигурацию оборудования */
                   equip_check = biosequip();
                   /* проверить наличие сопроцессора */
                   if (equip_check & CO_PROCESSOR_MASK)
           printf("There is a math coprocessor installed.\n");
                   else
           prontf("No math coprocessor installed.\n");
                   return 0;
               }

     bioskey
──────────────────────────────────────────────────────────────
Функция        Интерфейс с клавиатурой через сервис BIOS.

Синтаксис      #include<bios.h>
               int bioskey(int cmd);

Прототип в     bios.h

Примечания     Производит различные  операции  с  клавиатурой,
               используя  прерывание  0x16 BIOS.  Параметр cmd
               определяет конкретную операцию.

Значение       Возвращаемое значение зависит от операции,  оп-
               ределяемой значением cmd:
               0 Если младшие 8 бит ненулевые, bioskey возвра-
               щает ASCII символ очередной нажатой клавиши  из
               буфера  клавиатуры  или (если буфер пуст) ASCII
               символ следующей нажатой на клавиатуре клавиши.
               Если  младшие  8 бит нулевые,  то старшие 8 бит
               содержат расширенные коды  клавиатуры,  опреде-
               ленные в "Техническом справочном руководстве по
               IBM PC".
               1 Проверяет, имеется ли нажатая клавиша в буфе-
               ре клавиатуры. Если буфер пуст, возвращается 0.
               Если  нажато Ctrl-Brk,  возвращается 0xFFFFF (-
               1).  В противном случае  возвращается  значение
               очередной нажатой клавиши из буфера. Информация
               об этой клавише сохраняется и будет  возвращена
               при следующем вызове bioskey с cmd = 0.
               2 Запрашивает  текущее  состояние   регистровых
               клавиш. Возвращаемое значение является дизъюнк-
               цией следующих битовых значений:
                  Бит
                  7     0x80    Insert включена
                  6     0x40    Caps включена
                  5     0x20    Num Lock включена
                  4     0x10    Scroll Lock включена
                  3     0x08    Alt нажата
                  2     0x04    Ctrl нажата
                  1     0x02    левый Shift нажат
                  0     0x01    правый Shift нажат

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми.

Пример         #include <stdio.h>
               #include <bios.h>
               #include <ctype.h>

               #define RIGHT  0x01
               #define LEFT   0x02
               #define CTRL   0x04
               #define ALT    0x08

               int main(void)
               {
                  int key, modifiers;
                  /* функция 1 возвращает 0,
                     пока клавиша не нажата */
                  while (bioskey(1) == 0);
                  /* функция 0 возвращает ожидаемую клавишу */
                  key = bioskey(0);
                  /* использование функции 2 для определения
                     нажатых регистровых клавиш */
                  modifiers = bioskey(2);
                  if (modifiers) {
                     printf("[");
                     if (modifiers & RIGHT) printf("RIGHT");
                     if (modifiers & LEFT)  printf("LEFT");
                     if (modifiers & CTRL)  printf("CTRL");
                     if (modifiers & ALT)   printf("ALT");
                     printf("]");
                  }
                  /* печать введенного символа */
                  if (isalnum(key & 0xFF))
                     printf("'%c'\n", key);
                  else
                     printf("%#02x\n", key);
                  return 0;
               }

     biosmemory
──────────────────────────────────────────────────────────────
Функция        Возвращает размер памяти.

Синтаксис      #include<bios.h>
               int biosmemory(void);

Прототип в     bios.h

Примечания     Возвращает размер памяти RAM,  используя преры-
               вание 0x12 BIOS. Этот размер не включает память
               дисплейного адаптера и расширенную память.

Значение       Возвращает размер памяти в килобайтах.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми.

Пример         #include <stdio.h>
               #include <bios.h>

               int main(void)
               {
                  int memory_size;
                  memory_size = biosmemory();
                            /* возвращает значение до 640K */
                  printf("RAM size = %dK\n",memory_size);
                  return 0;
               }

     biosprint
──────────────────────────────────────────────────────────────
Функция        Использует напрямую  сервис  BIOS  для работы с
               портом В/В принтера.

Синтаксис      #include<bios.h>
               int biosprint(int cmd, int abyte, int port);

Прототип в     bios.h

Примечания     Выполняет различные   операции  с  параллельным
               портом принтера,  определяемым значением  port,
               используя прерывание 0x17 BIOS.
               Значение port = 0 соответствует LPT1;  port = 1
               - LPT2 и т.д.
               Возможные значения cmd:
                  0  Печатает символ из abyte.
                  1  Инициализирует порт принтера.
                  2  Читает статус принтера.
               Значение abyte может быть от 0 до 255.

Значение       Значение, возвращаемое любой из этих операций -
               это текущий статус принтера, получающийся дизъ-
               юнкцией следующих битовых значений:
                  Бит
                  0    0x01    Тайм-аут
                  3    0x08    Ошибка В/В
                  4    0x10    Выбрано
                  5    0x20    Конец бумаги
                  6    0x40    Подтверждение приема
                  7    0x80    Не занято

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми.

Пример         #include <stdio.h>
               #include <conio.h>
               #include <bios.h>

               int main(void)
               {
                  #define STATUS  2    /* статус принтера */
                  #define PORTNUM 0 /* номер порта для LPT1 */
                  int status, abyte=0;
                  printf("Please turn off your printer.
                          Press any key to continue\n");
                  getch();
                  status = biosprint(STATUS, abyte, PORTNUM);
                  if (status & 0x01)
                     printf("Device time out.\n");
                  if (status & 0x08)
                     printf("I/O error.\n");
                  if (status & 0x10)
                     printf("Selected.\n");
                  if (status & 0x20)
                     printf("Out of paper.\n");
                  if (status & 0x40)
                     printf("Acknowledge.\n");
                  if (status & 0x80)
                     printf("Not busy.\n");
                  return 0;
               }

     biostime
──────────────────────────────────────────────────────────────
Функция        Читает или устанавливает таймер BIOS.

Синтаксис      #include<bios.h>
               long biostime(int cmd, long newtime);

Прототип в     bios.h

Примечания     Использует прерывание  0x1A  BIOS.  Читает  или
               устанавливает таймер BIOS,  который отсчитывает
               прошедшее с полуночи время в единицах,  прибли-
               зительно равных 1/18.2 сек.
               Если cmd = 0,  biostime возвращает текущее зна-
               чение таймера;  если 1 - то таймер устанавлива-
               ется в значение newtime.

Значение       Когда biostime читает таймер(cmd = 0), он возв-
               ращает его текущее значение.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми.

Пример         #include <stdio.h>
               #include <bios.h>
               #include <time.h>
               #include <conio.h>

               int main(void)
               {
                  long bios_time;
                  clrscr();
                  cprintf("The number of clock ticks since
                          midnight is:\r\n");
                  cprintf("The number of seconds since
                          midnight is:\r\n");
                  cprintf("The number of minutes since
                           midnight is:\r\n");
                  cprintf("The number of hours since midnight
                          is:\r\n");
                  cprintf("\r\nPress any key to quit:");
                  while(!kbhit()) {
                     bios_time = biostime(0, 0L);
                     gotoxy(50, 1);
                     cprintf("%lu", bios_time);
                     gotoxy(50, 2);
                     cprintf("%.4f", bios_time / CLK_TCK);
                     gotoxy(50, 3);
                     cprintf("%.4f", bios_time/CLK_TCK/60);
                     gotoxy(50, 4);
                     cprintf("%.4f", bios_time/CLK_TCK/3600);
                  }
                  return 0;
               }

     brk
──────────────────────────────────────────────────────────────
Функция        Изменяет пространство сегмента данных.

Синтаксис      #include<alloc.h>
               int brk(void *addr);

Прототип в     alloc.h

Примечания     Динамически изменяет  объем   кучи   вызывающей
               программы.  Изменение производится переустанов-
               кой значения break value программы, которое яв-
               ляется  адресом  первой ячейки после конца сег-
               мента данных.  Объем распределенной памяти уве-
               личивается с увеличением break value. brk уста-
               навливает break value  в  addr,  соответственно
               изменяя распределенное пространство. Функция не
               выполняет действий, если количество запрашивае-
               мой памяти превышает доступное.

Значение       При успешном завершении возвращается 0;  в про-
               тивном случае возвращается -1, и глобальная пе-
               ременная errno устанавливается в значение
                  ENOMEM  Нет свободной памяти

Переносимость  Эта функция доступна в системах  UNIX.  Она  не
               совместима с Windows.

См. также      coreleft, sbrk

Пример         #include <stdio.h>
               #include <alloc.h>

               int main(void)
               {
                  char *ptr;
                  printf("Changing allocation with brk()\n");
                  ptr = malloc(1);
                  printf("Before brk() call:%lu bytes free\n",
                         coreleft());
                  brk(ptr+1000);
                  printf(" After brk() call:%lu bytes free\n",
                         coreleft());
                  return 0;
               }

     bsearch
──────────────────────────────────────────────────────────────
Функция        Двоичный поиск в массиве.

Синтаксис      #include<stdlib.h>
               void *bsearch(const void *key,const void *base,
               size_t nelem, size_t width, int (*fcmp)
               (const void *, const void *);

Прототип в     stdlib.h

Примечания     Производит поиск в массиве из nelem элементов в
               основной памяти и возвращает адрес первого най-
               денного  элемента,  соответствующего  заданному
               ключу. Массив должен быть упорядоченным по клю-
               чу.  Если элемент не  найден,  возвращается  0.
               Поскольку поиск двоичный, первый найденный эле-
               мент не обязан совпадать с первым по порядку  в
               массиве.
               Тип size_t определен как беззнаковое целое.
               nelem - число элементов массива.
               width - число байт в элементе.
               Функция сравнения *fcmp вызывается с двумя  ар-
               гументами: elem1 и elem2. Она сравнивает каждый
               из указанных  элементов  (*elem1  и  *elem2)  и
               возвращает   целое,  основанное  на  результате
               сравнения. Для bsearch *fcmp должна возвращать:
                  < 0, если *elem1 < elem2
                  == 0, если *elem1 == elem2
                  > 0, если *elem1 > elem2

Значение       Возвращает адрес первого  элемента  в  массиве,
               соответствующего заданному ключу.  Если элемент
               не найден, возвращается 0.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      lfind, lsearch, qsort

Пример         #include <stdlib.h>
               #include <stdio.h>

               #define NELEMS(arr)(sizeof(arr)/sizeof(arr[0]))

               int numarray[] = {123, 145, 512, 627, 800,933};
               int numeric (const int *p1, const int *p2)
               {
                  return(*p1 - *p2);
               }
               int lookup(int key)
               {
                  int *itemptr;
                  /* Требуется приведение типа для
                     (int(*)(const void *,const void*)),
                     чтобы избежать ошибки компиляции */
                  itemptr = bsearch (&key, numarray,
                            NELEMS(numarray), sizeof(int),
                  (int(*)(const void *,const void *))numeric);
                  return (itemptr != NULL);
               }
               int main(void)
               {
                  if (lookup(512))
                     printf("512 is in the table.\n");
                  else
                     printf("512 isn't in the table.\n");
                  return 0;
               }

     cabs
──────────────────────────────────────────────────────────────
Функция        Вычисляет абсолютное    значение   комплексного
               числа.

Синтаксис      #include<math.h>
               double cabs(struct complex z);

Прототип в     math.h

Примечания     cabs - это макро,  которое вычисляет абсолютное
               значение комплексного числа z. z - это структу-
               ра типа complex;  структура определена в math.h
               как:
                  struct complex {
                     double x, y;
                  };
               где x - вещественная часть, а y - мнимая.
               Вызов cabs эквивалентен вызову sqrt  с  вещест-
               венной  и  мнимой  компонентами,  как  показано
               здесь:
                  sqrt(z.x * z.x + z.y * z.y)
               В C++ используйте тип complex,  определенный  в
               complex.h, и функцию abs.

Значение       Возвращает абсолютное значение z  типа  double.
               При  переполнении  возвращается HUGE_VAL и гло-
               бальная переменная errno устанавливается в зна-
               чение
                  ERANGE  Результат вне границ
               Обработка ошибок для cabs может быть  модифици-
               рована функцией matherr.

Переносимость  Эта функция доступна в системах UNIX.

См. также      abs, complex, fabs, labs, matherr

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  struct complex z;
                  double val;
                  z.x = 2.0;
                  z.y = 1.0;
                  val = cabs(z);
                  printf("The absolute value of %.2lfi %.2lfj
                         is %.2lf", z.x, z.y, val);
                  return 0;
               }

     calloc
──────────────────────────────────────────────────────────────
Функция        Распределяет основную память.

Синтаксис      #include<stdlib.h>
               void *calloc(size_t nitems, size_t size);

Прототип в     stdlib.h, alloc.h

Примечания     Обеспечивает доступ к куче  Си.  Куча  доступна
               для  динамического  распределения блоков памяти
               переменной длины.  Многие структуры данных, по-
               добные  деревьям и спискам,  обычно распределя-
               ются в куче.
               Все пространство между концом сегмента данных и
               вершиной стека программы доступно для использо-
               вания в  малых  моделях  данных  (tiny,  small,
               medium),  кроме  небольшого участка прямо перед
               вершиной стека.  Этот участок предназначен  для
               увеличения стека в некоторых приложениях,  плюс
               небольшое количество, необходимое DOS.
               В больших моделях данных (compact, large, huge)
               все пространство выше стека и  до  конца  физи-
               ческой памяти доступно для кучи.
               calloc распределяет блок размером  nitems*size.
               Блок инициализируется в 0. Если Вы хотите расп-
               ределить  блок  длиной  более  64К,  Вы  должны
               использовать farcalloc.

Значение       calloc возвращает указатель на вновь  распреде-
               ленный  блок.  Если места для распределения нет
               либо nitems или size  =  0,  calloc  возвращает
               нуль.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.  Она совместима  с  Kernighan  &
               Ritchie.

См. также      farcalloc, free, malloc, realloc

Пример         #include <stdio.h>
               #include <alloc.h>
               #include <string.h>

               int main(void)
               {
                  char *str = NULL;
                  /* распределяет память для строки */
                  str = calloc(10, sizeof(char));
                  if (str) {
                     /* копирует "Hello" в строку */
                     strcpy(str, "Hello");
                     /* отображает строку */
                     printf("String is %s\n", str);
                     /* освобождает память */
                     free(str);
                  }
                  else
                  {
                     printf("Not enough memory!\n");
                  }
                  return 0;
               }

     ceil
──────────────────────────────────────────────────────────────
Функция        Округление.

Синтаксис      #include<math.h>
               double ceil(double x);

Прототип в     math.h

Примечания     Находит наименьшее целое, не меньшее, чем x.

Значение       Возвращает найденное целое (как double).

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      floor, fmod

Пример         #include <math.h>
               #include <stdio.h>

               int main(void)
               {
                  double number = 123.54;
                  double down, up;
                  down = floor(number);
                  up = ceil(number);
                  printf("original number %5.2lf\n", number);
                  printf("number rounded down %5.2lf\n",down);
                  printf("number rounded up   %5.2lf\n", up);
                  return 0;
               }

     cgets
──────────────────────────────────────────────────────────────
Функция        Читает строку с консоли.

Синтаксис      #include<conio.h>
               char *cgets(char *str);

Прототип в     conio.h

Примечания     Читает строку  с  консоли и запоминает ее (и ее
               длину) в буфере, указываемом str.
               Читает строку,  пока не  встретится  комбинация
               CR/LF  или  пока  не будет считано максимальное
               допустимое число символов.  Если  cgets  читает
               комбинацию  CR/LF,  она  замещается на \0 перед
               запоминанием строки в буфер.
               Перед вызовом  cgets установите в str[0] макси-
               мальную длину считываемой строки.  При возврате
               в str[1] будет помещено число реально считанных
               символов. Символы читаются, начиная с str[2], и
               кончаются   нуль-терминатором.  Таким  образом,
               длина str должна быть,  по меньшей мере, str[0]
               + 2 .

Значение       В случае успеха cgets возвращает  указатель  на
               str[2].

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми. Она не совместима с Windows.

См. также      cputs, fgets, getch, getche, gets

Пример         #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  char buffer[83];
                  char *p;
                  /* Пространство для 80 символов + NULL */
                  buffer[0] = 81;
                  printf("Input some chars:");
                  p = cgets(buffer);
                  printf("\ncgets read %d characters:
                          \"%s\"\n", buffer[1], p);
                  printf("The returned pointer is %p,
                         buffer[0] is at %p\n", p, &buffer);
                /*Оставим пространство только для 5 символов*/
                  buffer[0] = 6;
                  printf("Input some chars:");
                  p = cgets(buffer);
                  printf("\ncgets read %d characters:
                          \"%s\"\n", buffer[1], p);
                  printf("The returned pointer is %p,buffer[0]
                         is at %p\n", p, &buffer);
                  return 0;
               }

     chdir
──────────────────────────────────────────────────────────────
Функция        Изменяет текущий справочник.

Синтаксис      #include<dir.h>
               int chdir(const char *path);

Прототип в     dir.h

Примечания     Делает справочник  path  текущим.  path  должен
               указывать  на  существующий  справочник.   Уст-
               ройство также может быть указано в path:
                  chdir("a:\\BC"),
               но функция изменяет только  текущий  справочник
               на устройстве, не изменяя активного устройства.

Значение       В случае успеха chdir возвращает 0. В противном
               случае возвращается -1, и глобальная переменная
               errno устанавливается в значение
                  ENOENT  Путь или имя файла не найдено

Переносимость  Эта функция   доступна   в   системах   UNIX.

См. также      getcurdir, getcwd,   getdisk,   mkdir,   rmdir,
               setdisk, system

Пример         #include <stdio.h>
               #include <stdlib.h>
               #include <dir.h>

               char old_dir[MAXDIR];
               char new_dir[MAXDIR];
               int main(void)
               {
                  if (getcurdir(0, old_dir)) {
                     perror("getcurdir()");
                     exit(1);
                  }
                  printf("Current directory is: \\%s\n",
                          old_dir);
                  if (chdir("\\")) {
                     perror("chdir()");
                     exit(1);
                  }
                  if (getcurdir(0, new_dir)) {
                     perror("getcurdir()");
                     exit(1);
                  }
                  printf("Current directory is now: \\%s\n",
                         new_dir);
                 printf("\nChanging back to orignal directory:
                         \\%s\n", old_dir);
                  if (chdir(old_dir)) {
                     perror("chdir()");
                     exit(1);
                  }
                  return 0;
               }

     _chmod
──────────────────────────────────────────────────────────────
Функция        Изменяет режим доступа к файлам.

Синтаксис      #include<dos.h>
               #include<io.h>
               int _chmod(const char *path,
                    int func[,int attrib]);

Прототип в     io.h

Примечания     _chmod может возвращать или устанавливать атри-
               буты файла. Если func = 0, то функция возвраща-
               ет текущие атрибуты файла.  Если func =  1,  то
               атрибут устанавливается в attrib.
               attrib может  быть  одной из следующих символи-
               ческих констант (определенных в dos.h):
                  FA_RDONLY   Только для чтения
                  FA_HIDDEN   Скрытый
                  FA_SYSTEM   Системный
                  FA_LABEL    Метка тома
                  FA_DIREC    Справочник
                  FA_ARCH     Архив

Значение       При успехе  возвращает слово атрибута файла;  в
               противном случае возвращается -1,  и глобальная
               переменная errno устанавливается в одно из сле-
               дующих значений:
                  ENOENT  Путь или файл не найден
                  EACCES  Доступ запрещен

Переносимость  Эта функция доступна только в DOS.

См. также      chmod, _creat

Пример         #include <errno.h>
               #include <stdio.h>
               #include <dos.h>
               #include <io.h>

               int get_file_attrib(char *filename);
               int main(void)
               {
                  char filename[128];
                  int attrib;
                  printf("Enter a filename:");
                  scanf("%s", filename);
                  attrib = get_file_attrib(filename);
                  if (attrib == -1)
                     switch(errno) {
                        case ENOENT : printf("Path or file
                                             not found.\n");
                                      break;
                        case EACCES:printf("Permission denied.
                                             \n");
                                      break;
                        default:    printf("Error number: %d",
                                             errno);
                                      break;
                     }
                  else {
                    if (attrib & FA_RDONLY)
                       printf("%s is read-only.\n", filename);
                    if (attrib & FA_HIDDEN)
                       printf("%s is hidden.\n", filename);
                    if (attrib & FA_SYSTEM)
                       printf("%s is a system file.\n",
                              filename);
                    if (attrib & FA_LABEL)
                       printf("%s is a volume label.\n",
                              filename);
                    if (attrib & FA_DIREC)
                       printf("%s is a directory.\n",
                              filename);
                    if (attrib & FA_ARCH)
                       printf("%s is an archive file.\n",
                              filename);
                     }
                  return 0;
               }
               /* возвращает атрибуты файла DOS */
               int get_file_attrib(char *filename) {
                  return(_chmod(filename, 0));
               }

     chmod
──────────────────────────────────────────────────────────────
Функция        Изменяет режим доступа к файлам.

Синтаксис      #include<sys\stat.h>
               int chmod(const char *path, int amode);

Прототип в     io.h

Примечания     Устанавливает режим доступа к файлу,  заданному
               в path,  в соответствии с маской в amode.  path
               указывает  на  строку;  *path  -  первый символ
               строки. amode может содержать одну или обе сим-
               волические константы S_IWRITE и S_IREAD  (опре-
               деленные в sys\stat.h):
               ───────────────────────────────────────────────
               amode               Режим               доступа
               ───────────────────────────────────────────────
               S_IWRITE  Разрешена  запись  S_IREAD  Разрешено
               чтение  S_IREAD|S_IWRITE Разрешено чтение и за-
               пись
               ───────────────────────────────────────────────

Значение       При успехе  возвращает  0;  в  противном случае
               возвращается  -1,  и  и  глобальная  переменная
               errno  устанавливается в одно из следующих зна-
               чений:
                  ENOENT  Путь или файл не найден
                  EACCES  Доступ запрещен

Переносимость  Эта функция доступна в системах UNIX.

См. также      access, _chmod, fstat, open, sopen, stat

Пример         #include <sys\stat.h>
               #include <stdio.h>
               #include <io.h>

               void make_read_only(char *filename);
               int main(void)
               {
                  make_read_only("NOTEXIST.FIL");
                  make_read_only("MYFILE.FIL");
                  return 0;
               }
               void make_read_only(char *filename)
               {
                  int stat;
                  stat = chmod(filename, S_IREAD);
                  if (stat)
                     printf("Couldn't make %s read-only\n",
                            filename);
                  else
                     printf("Made %s read-only\n", filename);
               }

     chsize
──────────────────────────────────────────────────────────────
Функция        Изменяет размер файла.

Синтаксис      #include<io.h>
               int chsize(int handle, long size);

Прототип в     io.h

Примечания     Изменяет размер   файла,   ассоциированного   с
               handle.  Она может отсечь или расширить файл, в
               зависимости  от  значения  size  в  сравнении с
               исходным размером файла.
               Режим, в котором  Вы  открываете  файл,  должен
               позволять запись.
               Если chsize расширяет файл,  он дополняется ну-
               левыми символами (\0). При отсечении все данные
               после нового конца файла пропадают.

Значение       При успехе  возвращает  0;  в  противном случае
               возвращается -1,  и глобальная переменная errno
               устанавливается в одно из следующих значений:
                  EACCES  Доступ запрещен
                  EBADF   Неверное имя файла
                  ENOSPC  UNIX - не DOS

Переносимость  Эта функция доступна только в DOS.

См. также      close, _creat, creat, open

Пример         #include <string.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
                  int handle;
                  char buf[11] = "0123456789";
                  /* создает текстовый файл, содержащий
                  10 байт */
                  handle = open("DUMMY.FIL", O_CREAT);
                  write(handle, buf, strlen(buf));
                  /* усекает файл до размера в 5 байт */
                  chsize(handle, 5);
                  /* закрывает файл */
                  close(handle);
                  return 0;
               }

     circle
──────────────────────────────────────────────────────────────
Функция        Рисует окружность  данного  радиуса с центром в
               (x,y).

Синтаксис      #include<graphics.h>
               void far circle(int x, int y, int radius);

Прототип в     graphics.h

Примечания     Рисует окружность  текущим  цветом  с центром в
               (x,y) радиусом radius.
         !!!   Параметр linestyle  не  имеет  эффекта для дуг,
               окружностей,  эллипсов и секторов. Используется
               только параметр thickness.
               Если Ваши  окружности не слишком круглы,  наст-
               ройте аспект.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      arc, ellipse,   fillellipse,    getaspectratio,
               sector, setaspectratio

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                   /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy;
                  int radius = 100;
             /* инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)  /* ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  setcolor(getmaxcolor());
                  /* рисует окружность */
                  circle(midx, midy, radius);
                  /* очистка */
                  getch();
                  closegraph();
                  return 0;
               }

     _clear87
──────────────────────────────────────────────────────────────
Функция        Очищает слово статуса плавающей точки.

Синтаксис      #include<float.h>
               unsigned int_clear87(void);

Прототип в     float.h

Примечания     Очищает слово статуса плавающей точки,  которое
               является комбинацией слова статуса 80x87 и дру-
               гих условий, обнаруженных обработчиком исключи-
               тельных ситуаций 80x87.

Значение       Биты в  возвращаемом  значении показывают слово
               статуса плавающей точки перед тем, как оно было
               очищено.  Для  дальнейшей  информации  смотрите
               константы, определенные в float.h.

Переносимость  Эта функция доступна только в DOS.

См. также      _control87, _fpreset, _status87

Пример         #include <stdio.h>
               #include <float.h>

               int main(void)
               {
                  float x;
                  double y = 1.5e-100;
                  printf("\nStatus 87 before error: %X\n",
                         _status87());
                  x = y; /* Переполнение */
                  printf("Status 87 after  error: %X\n",
                         _status87());
                  _clear87();
                  printf("Status 87 after  clear: %X\n",
                         _status87());
                  y = x;
                  return 0;
               }

     cleardevice
──────────────────────────────────────────────────────────────
Функция        Очищает графический экран.

Синтаксис      #include<graphics.h>
               void far cleardevice(void);

Прототип в     graphics.h

Примечания     Заливает экран текущим фоновым цветом  и  уста-
               навливает текущую позицию в (0,0).

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      clearviewport

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                   /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy;
              /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)  /* ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }

                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  setcolor(getmaxcolor());
                  /* для центрирования сообщений */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  /* выводит сообщение на экран */
                  outtextxy(midx, midy,
                        "press any key to clear the screen:");
                  /* ожидание ввода клавиши */
                  getch();
                  /* очищает экран */
                  cleardevice();
                  /* вывод другого сообщения */
                  outtextxy(midx, midy,
                            "press any key to quit:");
                  /* очистка */
                  getch();
                  closegraph();
                  return 0;
               }

     clearerr
──────────────────────────────────────────────────────────────
Функция        Сбрасывает индикатор ошибки.

Синтаксис      #include<stdio.h>
               void clearerr(FILE *stream);

Прототип в     stdio.h

Примечания     Сбрасывает индикатор  ошибки  и индикатор конца
               файла для указанного потока в 0. С тех пор, как
               индикатор  ошибки был установлен,  операции для
               указанного потока продолжают возвращать  статус
               ошибки,  пока  не  будет  вызвана  clearerr или
               rewind.
               Индикатор конца файла сбрасывается каждой  опе-
               рацией ввода.

Значение       Нет.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      eof, feof, ferror, perror, rewind

Пример         #include <stdio.h>

               int main(void)
               {
                  FILE *fp;
                  char ch;

                  /* открывает файл для записи */
                  fp = fopen("DUMMY.FIL", "w");
                  /* попытка чтения - создание
                            ошибочной ситуации */
                  ch = fgetc(fp);
                  printf("%c\n",ch);
                  if (ferror(fp))
                  {
                     /* отображает сообщение об ошибке */
                     printf("Error reading from DUMMY.FIL\n");
                     /* сброс индикаторов ошибки и EOF */
                     clearerr(fp);
                  }
                  fclose(fp);
                  return 0;
               }

     clearviewport
──────────────────────────────────────────────────────────────
Функция        Очищает текущее окно.

Синтаксис      #include<graphics.h>
               void far clearviewport(void);

Прототип в     graphics.h

Примечания     Очищает текущее окно  и  устанавливает  текущую
               позицию в (0,0) относительно данного окна.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      cleardevice, getviewsettings, setviewport

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               #define CLIP_ON 1
                 /* активирует клиппинг в окне */
               int main(void)
               {
                   /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int ht;
             /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)  /* ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  setcolor(getmaxcolor());
                  ht = textheight("W");
                  /* выводит сообщение на полный экран */
                  outtextxy(0, 0,
                         "* <-- (0, 0) in default viewport");
                  /* создает меньшее окно */
                  setviewport(50, 50, getmaxx()-50,
                              getmaxy()-50, CLIP_ON);
                  /* выводит несколько сообщений */
                  outtextxy(0, 0,
                        "* <-- (0, 0) in smaller viewport");
                  outtextxy(0, 2*ht,
                         "Press any key to clear viewport:");
                  /* ожидание ввода клавиши */
                  getch();
                  /* очищает окно */
                  clearviewport();
                  /* выводит другое сообщение */
                  outtextxy(0, 0, "Press any key to quit:");
                  /* очистка */
                  getch();
                  closegraph();
                  return 0;
               }

     clock
──────────────────────────────────────────────────────────────
Функция        Определяет время процессора.

Синтаксис      #include<time.h>
               clock_t clock(void);

Прототип в     time.h

Примечания     Может быть использована для определения времен-
               ного интервала между двумя событиями.
               Для определения  времени в секундах,  значение,
               возвращаемое clock, следует разделить на значе-
               ние макро CLK_TCK.

Значение       Возвращает время процессора, прошедшее с начала
               работы программы.  Если это значение недоступно
               или не может быть представлено, будет возвраще-
               но значение -1.

Переносимость  Эта функция совместима с ANSI C.

См. также      time

Пример         #include <time.h>
               #include <stdio.h>
               #include <dos.h>

               int main(void)
               {
                  clock_t start, end;
                  start = clock();
                  delay(2000);
                  end = clock();
                  printf("The time was: %f\n",
                         (end - start) / CLK_TCK);
                  return 0;
               }

     _close
──────────────────────────────────────────────────────────────
Функция        Закрывает файл.

Синтаксис      #include<io.h>
               int_close(int handle);

Прототип в     io.h

Примечания     Закрывает файл,   ассоциированный   с   handle.
               handle - это обработчик файла,  создаваемый при
               вызовах  _creat,  creat,  creatnew,  creattemp,
               dup, dup2, _open или open.
         !!!   Эта функция не пишет символ Ctrl-Z в конец фай-
               ла. Если Вы хотите окончить файл этим символом,
               Вы должны явно вывести его.

Значение       В случае  успеха  возвращается  0,  в противном
               случае возвращается -1.  _close не выполняется,
               если handle не соответствует открытому файлу; в
               этом случае глобальная переменная  errno  уста-
               навливается в значение
                  EBADF   Неверный номер файла

Переносимость  Эта функция доступна только в DOS.

См. также      close, _creat, open, read, write

Пример         #include <string.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
                  int handle;
                  char buf[11] = "0123456789";
                  /* создать файл длиной 10 байт */
                  handle = open("DUMMY.FIL", O_CREAT);
                  write(handle, buf, strlen(buf));
                  /* закрыть файл */
                  _close(handle);
                  return 0;
               }

     close
──────────────────────────────────────────────────────────────
Функция        Закрывает файл.

Синтаксис      #include<io.h>
               int close(int handle);

Прототип в     io.h

Примечания     Закрывает файл,   ассоциированный   с   handle.
               handle - это обработчик файла,  создаваемый при
               вызовах  _creat,  creat,  creatnew,  creattemp,
               dup, dup2, _open или open.
         !!!   Эта функция не пишет символ Ctrl-Z в конец фай-
               ла. Если Вы хотите окончить файл этим символом,
               Вы должны явно вывести его.

Значение       В случае  успеха  возвращается  0,  в противном
               случае - возвращается -1.
               _close не выполняется,  если  handle  не  соот-
               ветствует  открытому файлу;  в этом случае гло-
               бальная переменная errno устанавливается в зна-
               чение
                  EBADF   Неверный номер файла

Переносимость  Эта функция доступна в системах UNIX.

См. также      chsize, _close,  creat,  creatnew, dup, fclose,
               open, sopen

Пример         #include <string.h>
               #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
                  int handle;
                  char buf[11] = "0123456789";
                  /* создать файл длиной 10 байт */
                  handle = open("NEW.FIL", O_CREAT);
                  if (handle > -1) {
                      write(handle, buf, strlen(buf));
                      /* закрыть файл */
                      close(handle);
                  }
                  else
                  {
                      printf("Error opening file\n");
                  }
                  return 0;
               }

     closegraph
──────────────────────────────────────────────────────────────
Функция        Закрывает графическую систему.

Синтаксис      #include<graphics.h>
               void far closegraph(void);

Прототип в     graphics.h

Примечания     Освобождает всю память,  распределенную  графи-
               ческой  системой,  затем  восстанавливает режим
               экрана,  который был до вызова initgraph.  (Па-
               мять,  распределенная для драйверов,  шрифтов и
               внутреннего буфера,  освобождается  посредством
               _graphfreemem).

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      initgraph, setgraphbufsize

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                   /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int x, y;
              /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)  /* ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  x = getmaxx() / 2;
                  y = getmaxy() / 2;
                  /* выводит сообщение */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  outtextxy(x, y, "Press a key to close
                                   the graphics system:");
                  /* ожидание ввода клавиши */
                  getch();
                  /* закрывает графику */
                  closegraph();
                  printf("We're now back in text mode.\n");
                  printf("Press any key to halt:");
                  getch();
                  return 0;
               }

     clreol
──────────────────────────────────────────────────────────────
Функция        Удаляет конец строки в текстовом окне.

Синтаксис      #include<conio.h>
               void clreol(void);

Прототип в     conio.h

Примечания     Удаляет все символы от позиции курсора до конца
               строки в текущем текстовом окне без  передвиже-
               ния курсора.

Значение       Нет.

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми. Она не совместима с Windows.

См. также      clrscr, delline, window

Пример         #include <conio.h>

               int main(void)
               {
                  clrscr();
                  cprintf("The function CLREOL clears all
                   characters from the\r\n");
                  cprintf("cursor position to the end of the
                         line within the\r\n");
                  cprintf("current text window, without moving
                          the cursor.\r\n");
                  cprintf("Press any key to continue . . .");
                  gotoxy(14, 4);
                  getch();
                  clreol();
                  getch();
                  return 0;
               }

     clrscr
──────────────────────────────────────────────────────────────
Функция        Очищает текстовое окно.

Синтаксис      #include<conio.h>
               void clrscr(void);

Прототип в     conio.h

Примечания     Очищает текущее  текстовое  окно  и  перемещает
               курсор в верхний левый угол (1,1).

Значение       Нет.

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми. Она не совместима с Windows.

См. также      clreol, delline, window

Пример         #include <conio.h>

               int main(void)
               {
                  int i;
                  clrscr();
                  for (i = 0; i < 20; i++)
                     cprintf("%d\r\n", i);
                  cprintf("\r\nPress any key to clear
                          screen");
                  getch();
                  clrscr();
                  cprintf("The screen has been cleared!");
                  getch();
                  return 0;
               }

     complex
──────────────────────────────────────────────────────────────
Функция        Создает комплексные числа.

Синтаксис      #include<complex.h>
               complex complex(double real, double imag);

Прототип в     complex.h

Примечания     Создает комплексные  числа  по заданной вещест-
               венной и мнимой части. Мнимая часть принимается
               0, если она отсутствует.
               complex -   это   констрактор  для  класса  C++
               complex,  который определен в complex.h. Другие
               функции, перечисленные в "См. также", также оп-
               ределены в complex.h. Некоторые из них являются
               перезагруженными версиями функций из библиотеки
               C, объявленных в math.h. Для комплексных версий
               требуется C++.
               Если вам нужна программа на C,  а  не  на  C++,
               доступными для Вас конструкциями являются толь-
               ко struct complex и cabs, которые дают абсолют-
               ное значение комплексного числа.  Обе они опре-
               делены в math.h.
               complex.h также  перезагружает операторы +,  -,
               *,  /, +=, -=, *=, /=, =, ==, !=. Эти операторы
               обеспечивают  комплексную  арифметику в обычном
               смысле.  В выражениях Вы можете свободно смеши-
               вать комплексные числа с int,  double и другими
               числовыми типами.  Операторы << и >> перезагру-
               жаются  для  потокового  ввода  и  вывода комп-
               лексных чисел, как и для других типов данных из
               iostream.h.

Значение       Комплексное число с  заданными  вещественной  и
               мнимой частями.

Переносимость  Комплексные функции  требуют C++ и не переноси-
               мы.  Поскольку мы следуем AT&T C++ версии  2.0,
               возможно,  Вам  удастся  перенести  комплексные
               функции в компиляторы C++,  совместимые с  этим
               стандартом.

См. также      abs, acos,  arg,  asin, atan, atan2, conj, cos,
               cosh, imag, log, log10, norm, polar, pow, real,
               sin, sinh, sqrt, tan, tanh

Пример         #include <iostream.h>
               #include <complex.h>

               int main(void)
               {
                  double x = 3.1, y = 4.2;
                  complex z = complex(x,y);
                  cout << "z = "<< z << "\n";
                  cout << " has real part = "
                       << real(z) << "\n";
                  cout << " and imaginary real part = "
                       << imag(z) << "\n";
                  cout << "z has complex conjugate =  "
                       << conj(z) << " \n";
                  return 0;
               }

     conj
──────────────────────────────────────────────────────────────
Функция        Возвращает число, комплексно-сопряженное данно-
               му.

Синтаксис      #include<complex.h>
               complex conj(complex x);

Прототип в     complex.h

Примечания     conj(z) - это complex(real(z), -imag(z)).

Значение       Число, комплексно-сопряженное данному.

Переносимость  Комплексные функции требуют C++ и не  переноси-
               мы.

См. также      complex, imag, real

Пример         #include <iostream.h>
               #include <complex.h>

               int main(void)
               {
                  double x = 3.1, y = 4.2;
                  complex z = complex(x,y);
                  cout << "z = "<< z << "\n";
                  cout << " has real part = "
                       << real(z) << "\n";
                  cout << " and imaginary real part = "
                       << imag(z) << "\n";
                  cout << "z has complex conjugate =  "
                       << conj(z) << " \n";
                  return 0;
               }

     _control87
──────────────────────────────────────────────────────────────
Функция        Манипулирует управляющим  словом плавающей точ-
               ки.

Синтаксис      #include,float.h>
               unsigned int _control87(unsigned int newcw,
                                       unsigned int mask);

Прототип в     float.h

Примечания     Возвращает или  изменяет управляющее слово пла-
               вающей точки.
               Управляющее слово плавающей точки типа unsigned
               int побитно устанавливает определенные режимы в
               блоке сопроцессора,  а именно: точность, беско-
               нечность  и округление.  Изменение этих режимов
               позволяет замаскировать или разрешить  исключи-
               тельные состояния сопроцессора.
               _control187 проверяет значения  битов  в  mask.
               Если бит в mask равен 1, значение соответствую-
               щего бита в newcw заменяет значение того же би-
               та в управляющем слове плавающей точки.  В про-
               тивном случае значение соответствующего бита  в
               управляющем  слове  плавающей  точки не изменя-
               ется.
               Иллюстрация:
               Исходное слово
               управления:        0100  0011  0110  0011
               mask               1000  0001  0100  1111
               newcw              1110  1001  0000  0101
               Измененные биты    1xxx  xxx1  x0xx  0101
               Если mask равно 0, _control87 возвращает управ-
               ляющее слово плавающей точки без изменения.
               _control87 не  может  изменить бит ненормализа-
               ции,  т.к.  Borland C++ использует связанные  с
               ним исключительные состояния.

Значение       Биты в  возвращаемом  значении  отражают  новое
               состояние  управляющего  слова плавающей точки.
               Полное    определение    битов,    возвращаемых
               _control87, смотри в файле заголовков float.h.

Переносимость  Эта функция доступна только в DOS.

См. также      _clear87, _fpreset, signal, _status87

Пример         Control.c

     coreleft
──────────────────────────────────────────────────────────────
Функция        Возвращает объем  неиспользуемой основной памя-
               ти.

Синтаксис      В моделях tiny, small, medium
               #include<alloc.h>
               unsigned coreleft(void);

               В моделях compact, large, huge
               #include<alloc.h>
               unsigned long coreleft(void);

Прототип в     alloc.h

Примечания     Выдает различные значения, в зависимости от мо-
               дели памяти.

Значение       При малых моделях данных возвращает  количество
               неиспользуемой  памяти  между  вершиной  кучи и
               стеком. При больших моделях - между самым стар-
               шим  по  адресу  распределенным блоком и концом
               доступной памяти.

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      allocmem, brk, farcoreleft, malloc

Пример         #include <stdio.h>
               #include <alloc.h>

               int main(void)
               {
                  printf("The difference between the highest
                         allocated block and\n");
                  printf("the top of the heap is:%lu bytes\n",
                         (unsigned long) coreleft());
                  return 0;
               }

     cos
──────────────────────────────────────────────────────────────
Функция        Вычисляет косинус.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:  КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>     #include <complex.h>
               double cos(double x); complex cos(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:  КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                complex.h

Примечания     Вычисляет косинус заданного аргумента. Угол за-
               дается в радианах.
               Комплексный косинус определяется как:
                  cos(z) = (exp(i * z) + exp(-i * z)) / 2

Значение       Для вещественного аргумента возвращает значение
               от -1 до 1.  Обработка ошибок для этой  функции
               может  быть  модифицирована  с  помощью функции
               matherr.

Переносимость  Вещественная версия доступна в системах UNIX  и
               определена  в  ANSI C.  Комплексная версия этой
               функции требует С++ и, вероятно, не переносима.

См. также      acos, asin, atan, atan2, complex, matherr, sin,
               tan

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  double result;
                  double x = 0.5;
                  result = cos(x);
                  printf("The cosine of %lf is %lf\n", x,
                   result);
                  return 0;
               }

     cosh
──────────────────────────────────────────────────────────────
Функция        Вычисляет гиперболический косинус.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>      #include <complex.h>
               double cosh(double x); complex cosh(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                 complex.h

Примечания     Вычисляет гиперболический косинус заданного ар-
               гумента:
                  cosh(x) = (e ** x + e** (-x)) / 2
               Комплексный косинус определяется как:
                  cosh(z) = (exp(z) + exp(-z)) / 2

Значение       Возвращает гиперболический   косинус  заданного
               аргумента. Когда при корректном значении возни-
               кает  переполнение,  cosh  возвращает  значение
               HUGE_VAL с соответствующим знаком и errno уста-
               навливается в ERANGE. Обработка ошибок для этой
               функции может  быть  модифицирована  с  помощью
               функции matherr.

Переносимость  Вещественная версия  доступна в системах UNIX и
               определена в ANSI C.  Комплексная  версия  этой
               функции требует С++ и, вероятно, не переносима.

См. также      acos, asin, atan, atan2, complex, cos, matherr,
               sin, sinh, tan, tanh

Пример         #include <stdio.h>
               #include <math.h>

               int main(void)
               {
                  double result;
                  double x = 0.5;
                  result = cosh(x);
                  printf("The hyperbolic cosine of %lf is
                          %lf\n", x, result);
                  return 0;
               }

     country
──────────────────────────────────────────────────────────────
Функция        Возвращает зависимую от страны информацию.

Синтаксис      #include<dos.h>
               struct COUNTRY *country(int xcode,
                               struct country *cp);

Прототип в     dos.h

Примечания     Указывает, как  должны  быть  форматированы за-
               висимые от страны данные (такие, как дата, вре-
               мя,  валюта).  Значения,  устанавливаемые  этой
               функцией, зависят от версии DOS.
               Если cp = -1,  текущая страна устанавливается в
               значение xcode,  которое должно быть ненулевым.
               В противном случае структура COUNTRY, указывае-
               мая cp,  заполняется информацией,  зависимой от
               страны, для текущей страны (если xcode установ-
               лено в 0), или для страны, заданной в xcode.
               Структура COUNTRY определена так:
               struct country {
               int co_date;      /* формат даты */
               char co_curr[5];  /* символ валюты */
               char co_thsep[2]; /* разделитель тысяч */
               char co_desep[2]; /* десятичный разделитель */
               char co_dtsep[2]; /* разделитель дат */
               char co_tmsep[2]; /* разделитель времени */
               char co_currstyle;/* представление валюты */
               char co_digits;   /* значащие цифры в валюте */
               char co_time;     /* формат времени */
               char co_case;     /* выбор отображения */
               char co_dasep[2]; /* разделитель данных */
               char co_fill[10]; /* заполнитель */
               };
               co_date - формат даты - имеет значения:
                  0 стиль США (месяц, день, год)
                  1 Европейский стиль (день, месяц, год)
                  2 Японский стиль (год, месяц, день)
               co_currstyle - стиль отображения валюты:
               0 Символ валюты предшествует значению, без про-
               белов между символом и числом.
               1 Символ валюты следует за значением,  без про-
               белов между символом и числом.
               2 Символ валюты предшествует значению, с пробе-
               лом после символа.
               3 Символ валюты следует за значением,  с пробе-
               лом перед символом.

Значение       При успехе возвращается аргумент-указатель  cp;
               при ошибке - нуль.

Переносимость  Эта функция  доступна только в DOS версии 3.0 и
               выше.

Пример         #include <dos.h>
               #include <stdio.h>

               #define USA 0
               int main(void)
               {
                  struct COUNTRY country_info;
                  country(USA, &country_info);
                  printf("The currency symbol for the USA is:
                        %s\n", country_info.co_curr);
                  return 0;
               }

     cprintf
──────────────────────────────────────────────────────────────
Функция        Форматированный вывод на экран.

Синтаксис      #include<conio.h>
               int cprintf(const char *format
                   [,argument,...]);

Прототип в     conio.h

Примечания     Каждый argument  выводится  в  соответствии  со
               спецификатором формата,  содержащимся в строке,
               указываемой format.  Вывод осуществляется в те-
               кущее текстовое окно. Число аргументов и специ-
               фикаторов должны совпадать.
               Детальное описание  спецификаторов  формата см.
               printf.
               Строка выводится либо прямой записью в видеопа-
               мять,  либо посредством вызова BIOS,  в зависи-
               мости   от   значения   глобальной   переменной
               directvideo.
               В отличие от tprintf и printf, cprintf не пере-
               водит символы LF (\n) в пару CR/LF (\r\n).

Значение       Число выведенных символов.

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми. Она не совместима с Windows.

См. также      directvideo(глобальная переменная),    fprintf,
               printf, putch, sprintf, vprintf

Пример         #include <conio.h>

               int main(void)
               {
                  /* очищает экран */
                  clrscr();
                  /* создает текстовое окно */
                  window(10, 10, 80, 25);
                  /* выводит текст в окно */
                  cprintf("Hello world\r\n");
                  /* ожидает нажатия клавиши */
                  getch();
                  return 0;
               }

     cputs
──────────────────────────────────────────────────────────────
Функция        Выводит строку на экран.

Синтаксис      #include<conio.h>
               int cputs(const char *str);

Прототип в     conio.h

Примечания     Пишет строку str,  завершенную нулем, в текущее
               текстовое окно.  Не присоединяет  символ  новой
               строки.  Строка выводится либо прямой записью в
               видеопамять,  либо посредством вызова  BIOS,  в
               зависимости  от  значения глобальной переменной
               directvideo.
               В отличие от tprintf и printf, cprintf не пере-
               водит символы LF (\n) в пары CR/LF (\r\n).

Значение       Последний выведенный символ.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Она не совместима с Windows.

См. также      cgets, directvideo(глобальная      переменная),
               fputs, putch, puts

Пример         #include <conio.h>

               int main(void)
               {
                  /* очищает экран */
                  clrscr();
                  /* создает текстовое окно */
                  window(10, 10, 80, 25);
                  /* выводит текст в окно */
                  cputs("This is within the window\r\n");
                  /* ожидает нажатия клавиши */
                  getch();
                  return 0;
               }

     _creat
──────────────────────────────────────────────────────────────
Функция        Создает новый файл или перезаписывает существу-
               ющий.

Синтаксис      #include<dos.h>
               int _creat(const char *path, int attrib);

Прототип в     io.h

Примечания     Файл всегда   открывается,  как  двоичный.  При
               успешном создании, указатель файла устанавлива-
               ется на начало файла. Файл открывается для чте-
               ния и записи.
               Если файл уже существует, его размер устанавли-
               вается в 0.(По существу, это равносильно удале-
               нию файла и созданию нового файла с тем же име-
               нем).
               attrib может быть одной из  следующих  констант
               (определенных в dos.h):
                  FA_RDONLY  Только для чтения
                  FA_HIDDEN  Скрытый
                  FA_SYSTEM  Системный

Значение       Номер нового  обработчика  файла при успехе,  в
               противном случае возвращается  -1.  При  ошибке
               глобальная  переменная  errno устанавливается в
               одно из следующих значений:
                  ENOENT  Путь или файл не найден
                  EMFILE  Слишком много открытых файлов
                  EACCES  Доступ запрещен

Переносимость  Эта функция доступна только в DOS.

См. также      _chmod, chsize, _close, close, creat, creatnew,
               creattemp

Пример         #include <sys\stat.h>
               #include <process.h>
               #include <string.h>
               #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>
               #include <errno.h>

               int main(void)
               {
                 int handle;
                 char buf[] = "0123456789";
                 /*создает двоичный файл для чтения и записи*/
                 if ((handle = _creat("DUMMY.FIL", 0)) < 0) {
                     switch(errno) {
                         case ENOENT: printf("Error:
                          Path or file not found.\n"); break;
                         case EMFILE: printf("Error:
                          Too many open files.\n"); break;
                         case EACCES: printf("Error:
                          Permission denied.\n"); break;
                         default: printf("Error
                                         creating file.\n");
                                      break;
                     }
                     exit(1);
                  }
                  /* записывает строку и нуль-символ в файл */
                  write(handle, buf, strlen(buf) + 1);
                  /* закрывает файл */
                  close(handle);
                  return 0;
               }

     creat
──────────────────────────────────────────────────────────────
Функция        Создает новый файл или перезаписывает существу-
               ющий.

Синтаксис      #include<sys\stat.h>
               int creat(const char *path, int amode);

Прототип в     io.h

Примечания     Создает новый файл,  заданный в path, или пере-
               записывает   существующий.   amode  применяется
               только для вновь создаваемых файлов.
               Файл создается в режиме, указанном в глобальной
               переменной _fmode (O_TEXT или O_BINARY).
               Если файл существует с атрибутом "для  записи",
               creat усекает файл до длины в 0 байт,  оставляя
               атрибуты неизменными.  Если файл имеет  атрибут
               "только для чтения",  creat возвращает ошибку и
               оставляет файл без изменения.
               creat проверяет только S_IWRITE бит в слове ре-
               жима доступа amode.  Если этот бит = 1,  в файл
               можно писать,  если 0, то файл помечен, "только
               для чтения". Все другие атрибуты DOS устанавли-
               ваются в 0.
               amode может иметь одно  из  следующих  значений
               (определены в sys\stat.h):
               ───────────────────────────────────────────────
                Значение amode      Возможный доступ
               ───────────────────────────────────────────────
                S_IWRITE            Разрешена запись
                S_IREAD             Разрешено чтение
                S_IREAD|S_IWRITE    Разрешено чтение и запись
               ───────────────────────────────────────────────
         !!!   В DOS разрешение записи влечет разрешение  чте-
               ния.

Значение       Номер нового  обработчика  файла при успехе,  в
               противном случае возвращается  -1.  При  ошибке
               глобальная  переменная  errno устанавливается в
               одно из следующих значений:
                  ENOENT  Путь или файл не найден
                  EMFILE  Слишком много открытых файлов
                  EACCES  Доступ запрещен

Переносимость  Эта функция   доступна   в   системах   UNIX.

См. также      chmod, chsize,    close,    _creat,   creatnew,
               creattemp,  dup,  dup2, _fmode(глобальная пере-
               менная), fopen, open, sopen, write

Пример         #include <sys\stat.h>
               #include <string.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
               int handle;
               char buf[11] = "0123456789";
               /* изменяет режим открытия файла */
               /* по умолчанию на двоичный      */
               _fmode = O_BINARY;
               /* создает двоичный файл для чтения и записи */
               handle = creat("DUMMY.FIL",S_IREAD | S_IWRITE);
               /* записывает 10 байтов в файл */
               write(handle, buf, strlen(buf));
               /* закрывает файл */
               close(handle);
               return 0;
               }

     creatnew
──────────────────────────────────────────────────────────────
Функция        Создает новый файл.

Синтаксис      #include<dos.h>
               int creatnew(const char *path, int mode);

Прототип в     io.h

Примечания     Идентична _creat с одним исключением. Если файл
               существует, creatnew возвращает ошибку и остав-
               ляет файл нетронутым.
               mode может  быть  одной  из  следующих констант
               (определенных в dos.h):
                  FA_RDONLY  Только для чтения
                  FA_HIDDEN  Скрытый
                  FA_SYSTEM  Системный

Значение       Номер нового обработчика файла  при  успехе,  в
               противном  случае  возвращается -1.  При ошибке
               глобальная переменная errno  устанавливается  в
               одно из следующих значений:
                  EEXIST  Файл уже существует
                  ENOENT  Путь или файл не найден
                  EMFILE  Слишком много открытых файлов
                  EACCES  Доступ запрещен

Переносимость  Эта функция  доступна  только в DOS версии 3.0.
               Не работает с более ранними версиями DOS.

См. также      close, _creat,    creat,    creattemp,     dup,
               _fmode(глобальная переменная), open

Пример         #include <string.h>
               #include <stdio.h>
               #include <errno.h>
               #include <dos.h>
               #include <io.h>

               int main(void)
               {
                  int handle;
                  char buf[11] = "0123456789";
                  /* попытка создать файл, которого еще нет */
                  handle = creatnew("DUMMY.FIL", 0);
                  if (handle == -1)
                   printf("DUMMY.FIL already exists.\n");
                  else {
                  printf("DUMMY.FIL successfully created.\n");
                   write(handle, buf, strlen(buf));
                   close(handle);
                  }
                  return 0;
               }

     creattemp
──────────────────────────────────────────────────────────────
Функция        Создает уникальный файл.

Синтаксис      #include<dos.h>
               int creattemp(char *path, int attrib);

Прототип в     io.h

Примечания     Файл создается в режиме, указанном в глобальной
               переменной _fmode (O_TEXT или O_BINARY).
               path -  это  имя пути,  оканчивающееся обратным
               слэшем (\).  Уникальное имя файла выбирается  в
               справочнике, заданном path. Вновь созданное имя
               файла запоминается в строке path.  path  должна
               быть  достаточной длины для запоминания резуль-
               тирующего имени файла.  Файл не удаляется авто-
               матически при завершении программы.
               Файл всегда  открывается,  как  двоичный.   При
               успешном  создании указатель файла устанавлива-
               ется на начало файла. Файл открывается для чте-
               ния и записи. amode может быть одной из следую-
               щих констант (определенных в dos.h):
                  FA_RDONLY  Только для чтения
                  FA_HIDDEN  Скрытый
                  FA_SYSTEM  Системный

Значение       Номер нового обработчика файла  при  успехе,  в
               противном  случае  возвращается -1.  При ошибке
               глобальная переменная errno  устанавливается  в
               одно из следующих значений:
                  ENOENT  Путь или файл не найден
                  EMFILE  Слишком много открытых файлов
                  EACCES  Доступ запрещен

Переносимость  Эта функция доступна только в DOS  версии  3.0.
               Не работает с более ранними версиями DOS.

См. также      close, _creat,     creat,     creatnew,    dup,
               _fmode(глобальная переменная), open

Пример         #include <string.h>
               #include <stdio.h>
               #include <io.h>

               int main(void)
               {
                  int handle;
                  char pathname[128];
                  strcpy(pathname, "\\");
                  /* создает уникальный файл
                     в корневом справочнике */
                  handle = creattemp(pathname, 0);
                  printf("%s was the unique file created.\n",
                         pathname);
                  close(handle);
                  return 0;
               }

     cscanf
──────────────────────────────────────────────────────────────
Функция        Форматный ввод с консоли.

Синтаксис      #include<conio.h>
               int cscanf(char *format [,address, ...]);

Прототип в     conio.h

Примечания     cscanf посимвольно   читает  последовательность
               входных полей с консоли. Каждое поле форматиру-
               ется  в  соответствии со спецификацией формата,
               передаваемой cscanf в строке формата,  на кото-
               рую указывает format. Наконец, cscanf записыва-
               ет форматированный ввод по адресам,  переданным
               в  качестве  аргументов,  следующих  за format.
               Ввод отображается на экране.  Количество специ-
               фикаций  формата  и  адресов должно совпадать с
               количеством входных полей.
               Детальное описание спецификаторов  формата  см.
               scanf.
               cscanf может прекратить обработку текущего поля
               до достижения обычного символа конца поля (сим-
               вола-разделителя),  или вообще  завершиться  по
               различным причинам. Подробнее см. scanf.

Значение       cscanf возвращает количество успешно  прочитан-
               ных,  преобразованных  и  записанных  в  память
               входных полей; возвращаемое значение не включа-
               ет прочитанные поля, которые не были записаны в
               память. Если ни одно поле не записано в память,
               возвращается 0.
               Если cscanf  пытается  читать  за концом файла,
               возвращается EOF.

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      fscanf, getche, scanf, sscanf

Пример         #include <conio.h>

               int main(void)
               {
                  char string[80];
                  /* очищает экран */
                  clrscr();
                  /* подсказка пользователю для ввода */
                  cprintf("Enter a string:");
                  /* читает ввод */
                  cscanf("%s", string);
                  /* отображение ввода */
                  cprintf("\r\nThe string entered is: %s",
                          string);
                  return 0;
               }

     ctime
──────────────────────────────────────────────────────────────
Функция        Преобразует дату и время в строку.

Синтаксис      #include<time.h>
               char *ctime(const time_t *time);

Прототип в     time.h

Примечания     Преобразует значение, указываемое time (в виде,
               возвращаемом  функцией  time),  в 26-символьную
               строку в следующем форме,  завершенной символом
               новой строки и нуль-символом:
                  Mon Nov 21 11:31:54 1983\n\0
               Все поля имеют постоянную ширину.
               Установите глобальную   переменную  timezone  в
               значение разности в секундах между  GMT  (грин-
               вичское  время)  и  местным временем (для PST -
               тихоокеанского поясного времени - timezone =  8
               * 60 * 60).  Глобальная переменная daylight не-
               нулевая,  если и только если должен применяться
               стандарт США для преобразования в летнее время.

Значение       Указатель на символьную строку, содержащую дату
               и  время.  Возвращаемое  значение  указывает на
               статическую  строку,  которая  перезаписывается
               при каждым новом вызове ctime.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      asctime, daylight(глобальная       переменная),
               diftime,  ftime,  getdate,  gmtime,  localtime,
               settime, timezone(глобальная переменная), tzset

Пример         #include <stdio.h>
               #include <time.h>

               int main(void)
               {
                  time_t t;
                  t = time(NULL);
                  printf("Today's date and time: %s\n",
                          ctime(&t));
                  return 0;
               }

     ctrlbrk
──────────────────────────────────────────────────────────────
Функция        Установка нового обработчика Ctrl-Break.

Синтаксис      #include<dos.h>
               void ctrlbrk(int(*handler)(void));

Прототип в     dos.h

Примечания     Устанавливает новую          функцию-обработчик
               Ctrl-Break,  на которую указывает handler. Век-
               тор  прерывания 0x23 изменяется для вызова ука-
               занной функции.  ctrlbrk устанавливает обработ-
               чик прерываний DOS,  который вызывает указанную
               функцию; непосредственно она не вызывается.
               Обрабатывающая функция может производить  любое
               число операций и системных вызовов.  Обработчик
               не имеет возврата;  можно использовать  longjmp
               для  возврата  в  произвольную точку программы.
               Обрабатывающая функция возвращает 0 для аварий-
               ного завершения прерванной программы; при любых
               других возвращаемых значениях выполнение  прог-
               раммы продолжается.

Значение       Нет.

Переносимость  Эта функция доступна только в DOS.

См. также      getcbrk, signal

Пример         #include <stdio.h>
               #include <dos.h>

               #define ABORT 0
               int c_break(void)
               {
                  printf("Control-Break pressed.
                         Program aborting ...\n");
                  return (ABORT);
               }
               int main(void)
               {
                  ctrlbrk(c_break);
                  for(;;)
                  {
                     printf("Looping... Press <Ctrl-Break>
                            to quit:\n");
                  }
                  return 0;
               }


               Вывод программы:

               Looping...
               Looping...
               Looping...
               ^C
               Control-Break pressed. Program aborting...
