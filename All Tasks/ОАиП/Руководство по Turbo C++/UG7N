                           ГЛАВА 7.

                           УТИЛИТЫ.

     Borland C++ снабжен набором мощных автономных утилит, ко-
торые  Вы можете использовать вместе с файлами Borland C++ или
с другими модулями.
     Ниже перечислены эти утилиты:
     - BGIOBJ,  утилита преобразования для графических драйве-
ров и шрифтов (создана неавтономной);
     - CPP, препроцессор (создана неавтономной);
     - GREP, утилита файлового поиска (создана неавтономной);
     - IMPDEF, которая генерирует библиотеку файла определения
модуля;
     - IMPLIB, которая генерирует библиотеку импорта;
     - MAKE, автономная утилита управления программой;
     - OBJXREF, перекрестные ссылки объектного модуля (создана
неавтономной);
     - PRJCFG,  которая обновляет опции в проектном  файле  из
файла  конфигурации или преобразует проектный файл в файл кон-
фигурации (создана неавтономной);
     - PRJCNVT, утилита преобразования файлов проекта Турбо Си
в формат Borland C++ (создана неавтономной);
     - PRJMAK, которая преобразует проектные файлы Borland C++
в файлы MAKE (создана неавтономной);
     - THELP, утилита Turbo Help (создана неавтономной);
     - TLIB, билиотекарь Turbo;
     - TLINK, редактор связей Turbo;
     - TOUCH, изменение даты и времени создания файла (создана
неавтономной);
     - TRANCOPY,  которая копирует элементы перехода из одного
проекта в другой (создана неавтономной);
     - TRIGRAPH,  утилита символьного преобразования  (создана
неавтономной);
     В этой главе  описывается,  что  делают  утилиты  IMPDEF,
IMPLIB,  MAKE,  TLIB  и TLINK,  а так же приводятся примеры их
использования с примерами кодов и командных  строк.  Остальные
утилиты  находятся  в текстовом файле UTIL.DOC,  который нахо-
дится на дистрибутивных дисках.

              IMPDEF (файлы определения модуля).

     IMPDEF работает с IMPLIB для настройки библиотеки  импор-
та,  чтобы  приспособиться к потребностям конкретного приложе-
ния.
     Примечание. Библиотека импорта используется для обеспече-
ния доступа к функциям DLL.
     Синтаксис:
      IMPDEF DestName.DEF SourceName.DLL
     Это создает файл определения модуля с именем DestName.DEF
из файла SourceName.DLL.  Файл определения модуля будет выгля-
деть подобно следующему:
      LIBRARY     FileName

      DESCRIPTION 'Description'

      EXPORTS
                  ExportFuncName                 @Ordinal
                  ...
                  ExportFuncName                 @Ordinal
где FileName - это имя корневого файла DLL, Description - зна-
чение утверждения DESCRIPTION,  если DLL был прежде отредакти-
рован с  файлом  определения  модуля,  включающим  утверждение
DESCRIPTION,  ExportFuncName - это имя экспортируемой функции,
а Ordinal - это порядковое значение функции (целое число).
     IMPDEF создает редактируемый исходный файл, который пере-
числяет все экспортные функции в DLL. Можно редактировать этот
файл .DEF,  чтобы он содержал только те функции,  которые были
бы доступны конкретному приложению (по Вашему желанию),  затем
запустить  IMPLIB  по редактируемому файлу .DEF.  В результате
создается библиотека импорта,  содержащая  информацию  импорта
для конкретного подмножества экспортных функций DLL.
     Например, предположим,  что вы распределяете DLL, который
поставляет функции для использования несколькими приложениями.
Каждая экспортная функция в DLL задается  с  _export.  Теперь,
если  все  приложения  используют  все экспорты DLL,  то можно
просто использовать IMPLIB для создания одной  библиотеки  им-
порта и передать эту библиотеку импорта с DLL.  Эта библиотека
импорта  будет  обеспечивать  информацией  импорта  для   всех
экспортов DLL. Библиотека импорта может быть отредактирована в
любом приложении, поэтому для конкретного приложения нужно пе-
речислить каждую функцию DLL,  которую он использует в разделе
IMPORTS своего файла определения модуля.
     Теперь предположим,  что  Вы  хотите  дать  только  часть
экспортов DLL конкретному приложению. Идеальным был бы вариант
откомпилировать приспособленную для этого приложения библиоте-
ку импорта,  которая предоставит информацию импорта только для
того подмножества функций, которое будет использовать приложе-
ние.  Все остальные функции экспорта в DLL будут спрятаны  для
данного приложения.
     Чтобы создать библиотеку  импорта,  удовлетворяющую  этим
условиям, запустите IMPDEF на компиляцию и редактирование DLL.
IMPDEF создаст  файл  определения  модуля,  содержащий  раздел
EXPORTS,  который перечисляет все функции экспорта DLL.  Можно
редактировать этот файл определения модуля,  удаляя  записи  в
разделе EXPORTS для тех функций, которые Вы НЕ хотите видеть в
приспособленной библиотеке  импорта.  Как  только  Вы  удалите
экспорты, которые Вам не нужны, запустите IMPLIB на файл опре-
деления модуля. Результатом будет библиотека импорта, содержа-
щая информацию только для тех функций экспорта,  которые пере-
числены в разделе EXPORTS в файле определения модуля.
     Эта утилита особенно удобна для DLL,  использующих классы
С++ по двум причинам.  Во-первых, если вы используете ключевое
слово _export при определении класса, то все не-inline элемен-
ты-функции и элементы  статических  данных  для  этого  класса
экспортируются. Легче позволить IMPDEF делать файл определения
модуля для Вас,  потому что он перечисляет все  экспортируемые
функции,  автоматически  включая  элементы-функции  и элементы
статических данных.
     Так как имена этих функций укорочены, то будет очень уто-
мительно перечислять их всех в разделе EXPORTS в файле опреде-
ления модуля, поэтому можно создать библиотеку импорта из фай-
ла определения модуля. Если Вы используете IMPDEF для создания
файла определения модуля, то он будет включать порядковые зна-
чения для каждой экспортируемой функции, и вдобавок оригиналь-
ное имя функции в комментариях,  следующее за записью функции,
если экспортируемое имя укорочено.  Например, файл определения
модуля, созданный с помощью IMPDEF для DLL, который использует
классы C++, будет выглядеть следующим образом:
      LIBRARY     FileName

      DESCRIPTION 'Description'

      EXPORTS
            MangledExportFuncName  @Ordinal; ExportFuncName
                  ...
            MangledExportFuncName  @Ordinal; ExportFuncName
     где FileName - это имя корневого файла DLL, Description -
это значение утверждения DESCRIPTION,  если DLL был уже  отре-
дактирован  с файлом определения модуля,  который включает ут-
верждение DESCRIPTION, MangledExportFuncName представляет уко-
роченное имя, Ordinal - это порядковое значение функции (целое
число), а ExportFuncName - представляет собой оригинальное имя
функции.

                 IMPLIB (библиотеки импорта).

     Утилита IMPLIB создает библиотеку импорта,  которая может
быть подставлена вместо части или всего раздела IMPORTS  файла
определения модуля для приложения Windows.
     Если модуль использует функции из DLL,  то есть 2 способа
сказать об этом компилятору:
     - можно добавить раздел IMPORTS в файл определения модуля
и  перечислить каждую функцию из DLL,  которую будет использо-
вать этот модуль,
     - или  можно  включить библиотеку импорта для DLL при ре-
дактировании этого модуля.
     Если Вы  создает приложение Windows,  Вы уже использовали
по крайней мере одну библиотеку импорта IMPORT.LIB. IMPORT.LIB
-  это библиотека импорта для Windows USER.EXE,  GDI.EXE и DLL
KERNEL.EXE.  (IMPORT.LIB редактируется автоматически при пост-
роении  приложения  Windows  в  IDE;  если Вы уже использовали
только IDE для построения приложений, то Вы можете не смотреть
это).
     Библиотека импорта перечисляет некоторые или все  экспор-
тируемые функции для одного или нескольких DLL. IMPLIB создает
библиотеку импорта прямо из DLL или файлов определения  модуля
для DLL (или комбинация их обоих).
     Для создания библиотеки импорта для DLL наберите:
      IMPLIB Options LibName DefFiles Dlls
где Options - это необязательный список одной  и  более  опций
IMPLIB,  LibName (обязательное) - имя для новой библиотеки им-
порта,  DefFiles - список одного или более существующих файлов
определения  модуля для одного или более DLL,  а Dlls - список
одного или более существующих DLL. Вы должны задать по крайней
мере один DLL или файл определения модуля.

                         Таблица 7.1.
                        Опции IMPLIB.
______________________________________________________________
  Опция                           Что она делает
______________________________________________________________
/i говорит  IMPLIB игнорировать WEP, процедуру выхода Windows,
   необходимую для завершения DLL. Используйте эту опцию, если
   Вы задали более одного DLL в командной строке IMPLIB.
     Управление сообщениями:
/t Сжатые предупреждения.
/v Многословные предупреждения.
/w Нет предупреждений.
______________________________________________________________
     Примечание. Перед опциями IMPLIB можно  использовать  или
дефис, или слэш.

                  Создание вновь IMPLIB.LIB.

     Когда Microsoft  выпускает  новые версии Windows,  то Вам
возможно понадобится заменить текущую версию IMPLIB.LIB на но-
вую. Самый простой способ - создать ее самим.
     Эта командная строка строит текущую версию IMPLIB.LIB:
IMPLIB /I IMPORT.LIB GDI.EXE KERNEL.EXE USER.EXE KEYBOARD.DRV
          SOUND.DRV WIN87EM.DLL
     Если Windows расширяется так,  что он использует дополни-
тельные DLL, то все новые DLL также должны появиться в команд-
ной строке.

                 MAKE: управление программой.

     Программа MAKE  фирмы  Borland,  берущая  свое  начало от
программной системы UNIX с таким же именем,  поможет Вам  соз-
дать выполняемую версию текущей программы.
     Многие программы состоят из большого числа исходных  фай-
лов,  каждый  из которых может требовать предварительной обра-
ботки препроцессором, Ассемблером, компилятором и другими ути-
литами, прежде, чем все они будут скомпонованы в одну програм-
му. Если Вы забыли перекомпилировать модуль, который был изме-
нен, или зависит от другого, который изменялся, это может при-
вести к длительному поиску ошибки.  С другой стороны, переком-
пиляция  всех  модулей  (для  надежности) может занять слишком
много времени.
     Утилита MAKE  решает  эту проблему.  Для этого ей на вход
передается описание,  как исходные и объектные  файлы  взаимо-
действуют  между  собой  для  получения завершенной программы.
Утилита MAKE просматривает это описание и  отметку  о  времени
создания всех файлов.  Эти данные используются (если это необ-
ходимо) для создания новейшей версии.  Во время этого процесса
MAKE может запускать различные компиляторы,  ассемблерные язы-
ки, редакторы связей и утилиты, но не более, чем это необходи-
мо для создания готовой программы.
     Примечание. О создании MakeFile для программ Windows  см.
в главе 3.
     Кроме того,  эта утилита полезна и в других  приложениях.
Вы  можете  использовать  MAKE для управления любым процессом,
который включает выбор файлов по именам и производство над ни-
ми некоторых действий для получения конечного результата.  Не-
которые наиболее общие применения - это:  текстовый процессор,
автоматическое  создание  файлов  .BAK,  сортировка  файлов по
расширению в разных справочниках и удаление временных файлов в
их справочниках.

                  Как работает утилита MAKE.

     При создании  новой  версии  Вашей программы утилита MAKE
выполняет следующие действия:
     - Читает специальный файл (называемый MAKEFILE),  который
Вы создали. Этот файл сообщает утилите MAKE, какие объектные и
библиотечные  файлы будут редактироваться вместе для получения
выполняемого файла,  а так же какие исходные файлы и файлы за-
головков  будут  компилироваться для получения соответствующих
объектных файлов;
     - Сравнивает время и дату каждого объектного файла, соот-
ветствующих исходных файлов и файлов заголовков.  Если время и
дата этих файлов более поздние,  чем у объектных файлов,  MAKE
понимает,  что эти файлы модифицировались и требуют перекомпи-
ляции;
     - Вызывает компилятор для перекомпиляции исходного  файла
(если это необходимо);
     - Сравнивает время и дату создания  всех  взаимозависимых
объектных файлов с временем и датой выполняемого файла;
     - Если у какого-нибудь из этих файлов более позднее время
и дата,  чем у выполняемого файла, то вызывается редактор свя-
зей для создания нового выполняемого файла.
     Предостережение! MAKE  сравнивает временные данные о соз-
дании файлов, устанавливаемые операционной системой. Это озна-
чает, что для корректной работы утилиты необходимо, чтобы вре-
мя и дата были установлены  правильно.  Для  этого  проверяйте
состояние батарей питания системных часов.  Слабые батареи мо-
гут привести к тому,  что системные часы покажут  неправильное
время, а МAKE не будет работать так, как должен.
     Если Ваша машина не имеет встроенного календаря  и  часов
(с помощью команд DOS date и time),  устанавливайте правильные
дату и время каждый раз при включении машины.

                         Запуск MAKE.

     Для запуска утилиты наберите после подсказки DOS  команду
MAKE.  Утилита будет искать файл с именем MAKEFILE, если он не
найден  -  файл  MAKEFILE.MAК,  если  он  не  найден  -   файл
BUILTINS.MAК (он будет описан ниже). Если и этот файл не будет
найден - утилита завершит свою работу с выводом  сообщения  об
ошибке.
     Что делать,  если Вы хотите использовать файл  с  именем,
отличным  от MAKEFILE или MAKEFILE.MAК?  Укажите утилите опцию
(-f), как это показано ниже:
     MAKE -FMYFILE.MAK
     Общий синтаксис вызова утилиты MAKE следующий:
        make [опция[опция]][вых_файл[вых_файл...]]
     - где [опция] - это опция утилиты MAKE (будут описаны ни-
же), [вых_файл] - имя файла, который должен быть создан.
     Синтаксические правила вызова MAKE:
     - Слово make отделяется от следующего за ним списка опций
пробелом;
     - Каждая  опция отделяется от предыдущей пробелом.  Опции
могут располагаться в любой последовательности и в любом коли-
честве (сколько уместится в командной строке). После опций, не
задающих строку (-s или -a, например), может стоять знак - или
+, который определяет включена (+) или отключена (-) опция;
     - Необязательный список файлов следует после опций МАКЕ и
отделяется от них пробелом;
     - Каждое имя отделяется от предыдущего пробелом.  Утилита
MAKE просматривает файлы в той последовательности, в какой они
описаны в списке.
     Примечание. MAKE останавливается, если любая команда, ко-
торую он выполняет,  прерывается через Ctrl-Break. Таким обра-
зом, Ctrl-Break останавливает как текущую выполняемую команду,
так и MAKE.
     Если командная  строка не содержит никаких выходных имен,
то MAKE использует первое выходное  имя,  упомянутое  в  явном
правиле. Если в командной строке упомянуто более одного выход-
ного файла, то все они будут построены.

                      BUILTINS.MAK файл.

     Наверно, Вы  заметили,  что  есть макросы и правила МАКЕ,
которые Вы используете снова и снова. Для их обработки сущест-
вуют три способа.
     - Во-первых, помещать их в каждый создаваемый MAKEFILE;
     - Во-вторых,  поместить их в один файл и использовать ди-
рективу !include в создаваемом MAKEFILE (директива описана ни-
же);
     - В третьих, Вы можете поместить все в BUILTINS.MAK файл.
     Во время запуска утилита МАКЕ ищет этот файл,  однако это
не означает,  что он должен быть обязательно создан. Если МАКЕ
находит файл BUILTINS.MAK, она рассматривает этот файл первым.
Если этого файла нет,  производится поиск файла MAKEFILE  (или
того, который указан вместо него).
     Прежде всего поиск файла BUILTINS.MAK производится в  те-
кущем справочнике. Если его там нет, а Вы работаете под управ-
лением версии DOS 3.0 и выше, то поиск продолжается в справоч-
нике,  где  расположен и файл MAKE.EXE.  Вы должны располагать
файл BUILTINS.MAK в том же справочнике, что и файл MAKE.EXE.
     Поиск MAKEFILE производится только в текущем справочнике.
Этот файл содержит правила,  по которым будет создаваться  вы-
полнимая программа. Файлы BUILTINS.MAK и Makefile имеют одина-
ковые синтаксические правила.
     В текущем  справочнике  так же производится поиск файлов,
включаемых по директиве !inclide (описание см.  ниже). Если Вы
используете опцию -l, поиск будет производиться и в справочни-
ке, указанном после этой позиции.

                   Опции командной строки.

     Ниже приведен полный список опций.  Отметим, что регистр,
на котором набраны опции,  имеет большое значение, так как оп-
ция -d не означает тоже самое, что -D.

                         Таблица 7.2.
                         Опции МАКЕ.
______________________________________________________________

Опция                   Что она делает
______________________________________________________________
-? или -h      Вывод справочной информации. По умолчанию опции
               изображаются  со следующим за ними знаком плюс.
               (Это делается по умолчанию).
-а             Проверка автозависимостей объектных файлов.
-B             Построение всех выходных файлов независимо от
               их дат.
-Didentifier   Присваивает идентификатор строке, содержащей
               единичный символ.
-Diden=string  Присваивает идентификатор iden строке,  стоящей
               после знака равенства.  Строка не должна содер-
               жать символов пробела и табуляции.
-ffilename     Предполагает, что указанный файл будет  исполь-
               зован в качестве MAKEFILE. Если filename не су-
               ществует или не имеет расширения,  то предпола-
               гается FILENAME.MAK.
-i             Не проверять статус завершения выполняемой  ко-
               манды  и  продолжать  выполнение  независимо от
               значения кода завершения. Эквивалентно префиксу
               (-) перед командой (см. ниже).
-ldirectory    Задает имя справочника,  в котором искать вклю-
               чаемые файлы.
-K             Хранить (не удалять) временные файлы, созданные
               MAKE.   Все   временные   файлы   имеют   имена
               MAKEnnnn.$$$,  где nnnn лежит  в  диапазоне  от
               0000 до 9999.
-n             Вывести команды, но не выполнять их. Это полез-
               но при отладке MAKEFILE.
-s             Не выводить команды перед  выполнением.  Обычно
               МАКЕ печатает каждую выполняемую команду.
-S             Выгрузить MAKE из памяти на  момент  выполнения
               команды.  Освобождение памяти, занимаемой MAKE,
               позволяет компилировать очень большие модули.
-Uidentifier   Переопределить ранее определенный идентификатор.
-W             Записывает текущие заданные  нестроковые  опции
               (такие как -s и -a) в MAKE.EXE. Это делается по
               умолчанию.
___________________________________________________________________

                          Простое применение MAKE.

     В качестве первого примера рассмотрим простое использова-
ние MAKE,  которое не затрагивает программирования.  Предполо-
жим,  Вы пишете книгу и решили сохранять каждую ее главу в от-
дельном файле. Для простоты предположим, что вся книга состоит
из трех глав в файлах CHAP1.MSS,  CHAP2.MSS и  CHAP3.MSS.  Для
создания  текущего  макета  Вашей  книги Вы пропускаете каждую
главу через программу форматирования (назовем ее  FORM.EXE)  и
используете  команду DOS COPY для объединения всех глав в еди-
ный макет:
                  ┌─────────\                     │\
      Chap1.MSS   │ form.exe >   Chapt1.TXT ┌─────┘ \
                  └─────────/               │        \
                                            │         \
                  ┌─────────\               │ команда  \  Book.TXT
      Chap2.MSS   │ form.exe >   Chapt2.TXT │ DOS      /
                  └─────────/               │ COPY    /
                                            │        /
                  ┌─────────\               └─────┐ /
      Chap3.MSS   │ form.exe >   Chapt3.TXT       │/
                  └─────────/
     Примечание. MAKE также  создает  копии  файлов,  помещает
файлы в различные подсправочники и даже автоматически выполня-
ет Ваши программы.
     Подобно программированию, написание книги требует высокой
сосредоточенности. При написании Вы можете изменять ряд глав и
файлов,  но не захотите отвлекаться на запоминание того, что и
в каком файле Вы изменили.  С другой стороны,  Вам не хотелось
бы при сборке всей книги пропустить какой-либо уже модифициро-
ванный файл.
    Самое неизящное  решение  этой проблемы состоит в создании
командного файла, который преобразует каждый из файлов. Он мо-
жет состоять из следующих команд:
         FORM CHAP1.MSS
         FORM CHAP2.MSS
         FORM CHAP3.MSS
         COPY /A CHAP1.TXT+CHAP2.TXT+CHAP3.TXT BOOK.TXT
     Запуская этот командный файл,  Вы каждый раз будете полу-
чать  измененный макет книги.  Однако,  предположим,  что Ваша
книга разрастется и будет содержать уже 15 глав. Тогда процесс
выполнения этого командного файла станет достаточно долгим.
     MAKE может стать полезной для разрешения задач  подобного
сорта. Все, что Вам надо - это создать файл, обычно называемый
MAKEFILE, который сообщит утилите MAKE, из каких файлов состо-
ит  ВООК.ТХТ  и как его получить.  Этот файл содержит правила,
которые объясняют,  как перестроить BOOK.TXT,  если какой-либо
файл, входящий в его состав, будет модифицирован.
    В нашем примере первое правило в MAKEFILE должно быть :
     book.txt: chap1.txt chap2.txt chap3.txt
               copy /a chap1.txt+chap2.txt+chap3.txt book.txt
     Что это  означает?  Первая  строка (та,  что начинается с
book.txt:) говорит о том, что BOOK.TXT состоит из отформатиро-
ванного текста каждой из трех глав.  При этом, если какая-либо
из этих глав будет обновлена, MAKE должна перестроить всю кни-
гу, используя команду COPY в последующей строке.
     Однако это правило не раскрывает всего существа проблемы.
Каждая из глав зависит от исходного файла (.MSS), поэтому если
они изменяются,  то должны перестраиваться  и  соответствующие
файлы CHAP?.TXT. Для этого в MAKEFILE нужно добавить следующие
правила:
      chap1.txt: chap1.mss
                 form chap1.mss

      chap2.txt: chap2.mss
                 form chap2.mss

      chap3.txt: chap3.mss
                 form chap3.mss
     Каждое их этих правил говорит о том,  что, если это необ-
ходимо,  то каждый исходный текст должен  быть  отформатирован
для получения готовой главы.  Теперь MAKE понимает, что должен
изменить соответствующий  файл  при  изменении  исходного.  То
есть,  если Вы изменили файл СHAP3.MSS, MAKE быстро переформа-
тирует третью главу для получения файла  .TXT,  перед  сборкой
книги BOOK.TXT.
     Этот простой пример можно записать более изящно. Три пра-
вила  очень похожи друг на друга,  фактически,  они отличаются
одним символом в каждом имени файла. При этом очень легко про-
пустить  добавление нового правила при включении в книгу новой
главы. Для решения этих проблем MAKE позволяет создать так на-
зываемое неявное правило,  определяющее зависимость файлов че-
рез их расширение.  В этом случае можно заменить  три  правила
одним неявным:
        .mss.txt:
                  form $*.mss
     Вам еще нужно обновить  первое  правило,  которое  делает
BOOK.TXT, чтобы MAKE знала соединение новых глав в файле выво-
да. Это правило и последующие используют макросы.
     После создания  такого  MAKEFILE,  для  получения готовой
книги (после изменений ее глав) достаточно просто  ввести  ко-
манду MAKE в ответ на подсказку DOS.

                  Создание файлов MAKEFILE.

     Создание программ из отдельных программных файлов,  вклю-
чаемых файлов,  файлов заголовков,  объектных  файлов  и  т.д.
очень похожи на описание предыдущего примера. Основное отличие
заключается в командах,  которые используются на  каждом  шаге
создания программы, а именно - вызов препроцессора, компилято-
ра,  Ассемблера и редактора связей, вместо программы-форматора
и команды DOS COPY.
     MAKEFILE содержит определения и взаимосвязи,  которые по-
могают MAKE создавать новую версию программы. Вы можете созда-
вать так много файлов MAKEFILE, сколько Вам необходимо и назы-
вать их по своему усмотрению. Единственное, что надо помнить -
это то,  что MAKE ищет файл с именем MAKEFILE, если при вызове
не было указано другое имя.
     Создавать этот файл  можно  любым  текстовым  редактором:
встроенным  редактором  Borland  C++,  Sprint,  MicroStar  или
SideKick.  Все правила,  описания и директивы должны  распола-
гаться на одной строке.  Если строка слишком велика,  ее можно
продолжить, набрав последним символом обратный слэш (\).
     Используйте пробел  (или табуляцию) для разделения сосед-
них идентификаторов и отступы для отделения команд в правилах.

                  Компоненты файла MAKEFILE.

     Создание файла MAKEFILE подобно  написанию  программы,  в
которую входят: определения, команды и директивы. В этом файле
допустимы следующие конструкции:
     - комментарии;
     - явные правила;
     - неявные правила;
     - описания макросов;
     - директивы:
          - директивы условного выполнения;
          - директивы включения файлов;
          - директивы обнаружения ошибок;
          - директивы неопределенных макросов.
     Рассмотрим каждую их них подробнее.

                         Комментарии.

     Комментарии начинаются с символа #;  строка, следующая за
ним,  игнорируется  утилитой MAKE.  Комментарий может распола-
гаться где угодно и с любой позиции.
     Обратный слэш  (\) не продолжает комментарий на следующую
строку,  поэтому в новой строке комментарий должен опять начи-
наться  с  символа #.  Фактически нельзя использовать обратный
слэш как символ продолжения строки,  имеющей комментарий. Если
перед  обратным  слэшем  стоит  #,  то  он  не является больше
последним символом в строке;  если за ним следует  #,  то  это
часть самого комментария.
     Ниже приведен пример комментария:
     # MAKEFILE для создания книги
     # этот файл изменяет файл BOOK.TXT
     # каждый раз, когда изменяется один
     # из файлов .MSS
     # Явное правило для создания файла BOOK.TXT
     # из шести глав (с продолжением строк)

     book.txt: chap1.txt chap2.txt chap3.txt \
               chap4.txt chap5.txt chap6.txt
               copy /a chap1.txt+chap2.txt+chap3.txt+chap4.txt+\
                       chap5.txt+chap6.txt book.txt

     # Неявное правило для форматирования отдельных глав

     .mss.txt:
               form $*.mss
     Примечание. Явные  и  неявные  правила  рассматриваются в
разделе по командам.

                        Списки команд.

     И явные,  и неявные правила могут  иметь  список  команд.
Этот раздел описывает те команды, которые допустимы для MAKE.
     Формат команд:
        [префикс...]тело_команды
     Каждая командная строка в списке команд содержит необяза-
тельный список префиксов, стоящий перед телом команды.

                          Префиксы.

     Префиксы, допустимые  в  команде,  модифицируют обработку
команд при работе MAKE.  Префикс - это или знак @,  или  дефис
(-) со следующим за ним без пробела числом.

                         Таблица 7.3.
                        Префиксы МАКЕ.
______________________________________________________________
Префиксы                Что он делает
______________________________________________________________
@    Запрещает выводить на экран выполняемую команду. Вывода
     на экран не будет, даже если в строке запуска MAKE не
     указана опция -s. Этот префикс действует только на ту
     команду, перед которой стоит.
-num Действует, когда MAKE обрабатывает код завершения . Если
     задано число, то MAKE прерывает свою работу в том случае,
     если код, возвращаемый выполняемой командой, больше
     заданного числа. В следующем примере MAKE прервет свою
     работу, если код завершения будет больше 4:
          -4 prog test.x
     Если префикс (-num) не задан, а код завершения не равен
     нулю, MAKE прерывает свою работу и удаляет текущий
     результирующий файл.
-    Если задан префикс дефис без числа (-), то MAKE не
     проверяет код завершения выполненной программы и
     продолжает свою работу независимо от его значения.
______________________________________________________________
     Примечание. Коды завершения - это коды,  возвращаемые вы-
полняемыми командами (внутри программы).

                        Тело команды.

     Тело команды можно рассматривать как обычную  строку  для
COMMAND.COM, за исключением того, что не поддерживается опера-
ция (│).
     В дополнение  к операторам переопределения <,  > и >>,  в
утилите MAKE добавлены операторы << и &&. Эти операторы созда-
ют временные файлы для ввода команд.  Оператор << создает вре-
менный файл и переопределяет стандартный командный  ввод  так,
что он производится из созданного файла. Если у Вас есть прог-
рамма,  которая воспринимает ввод со  стандартного  устройства
ввода (stdin), команда:
        prog <<!
        Это тест
        !
     создаст временный файл,  содержащий строку "Это тест \n",
и переопределит его в качестве  ввода  для  программы  myprog.
Символ  (!),  в данном примере,  является разделителем;  можно
использовать в качестве разделителей любые символы,  кроме # и
\.  Первая  строка,  содержащая  символ разделителя как первый
символ, завершит файл. Остаток строки после символа разделите-
ля  (в данном случае,  знак восклицания),  рассматривается как
часть предыдущей команды.
     Оператор &&  подобен  оператору <<.  Он создает временный
файл, но вместо того, чтобы переназначить этот файл в качестве
стандартного  устройства ввода,  оператор && заменяется именем
временного файла.  Это бывает полезным,  если Вы хотите, чтобы
утилита MAKE создала файл, который передавался бы другой прог-
рамме на вход.  В следующем примере создается "командный файл"
для обработки его программой TLINK:
     MYPROG.EXE: $(MYOBJS)
         tlink /c @&&!
     C0S $(MYOBJS)
     $*
     $*
     $(MYLIBS) EMU.LIB NATHS.LIB CS.LIB
     !
     Отметим, что  макросы (отмеченые символом $) расширяются,
когда файл создан.  Символы $* заменяются  именем  создаваемой
программы  без расширения,  а $(MYOBJS) и $(MYLIBS) заменяются
значениями макросов  MYOBJS  и  MYLIBS.  Поэтому  TLINK  может
рассматривать входной файл, подобный такому:
     C0S a.obj b.obj c.obj d.obj
     MYPROG
     MYPROG
     w.lib x.lib y.lib z.lib EMU.LIB MATHS.LIB CS.LIB
     Все временные файлы удаляются, если не была указана опция
-К в командной строке вызова MAKE.  С помощью этой опции можно
"отладить" временный файл, если он работает некорректно.

                 Пакетная обработка программ.

     Утилита MAKE позволяет запускать некоторые программы, ко-
торые  могут  оперировать со списком файлов в пакетном режиме.
Предположим, что утилита MAKE должна обработать несколько фай-
лов  с  программами  на языке Си с помощью компилятора Borland
C++. MAKE может запустить ВCC.EXE для каждого файла, но наибо-
лее  эффективно  запустить ВCC.EXE с указанием ему списка всех
файлов в одной командной строке. Это позволит избежать многок-
ратной перезагрузки Borland C++.
     Пакетные свойства MAKE позволяют накапливать имена файлов
для обработки одной командой,  собрать их в один список и выз-
вать эту команду один раз для всего списка.
     Для создания пакета в командной строке необходимо исполь-
зовать фигурные скобки:
     команда {пакетный-элемент}... остаток-команды
     Этот командный синтаксис обеспечивает задержку выполнения
команды до тех пор,  пока MAKE не определит, какая команда бу-
дет исполняться следующей.  Если следующая  команда  идентична
предыдущей (за исключением того,  что стоит в скобках), то эти
две команды объединяются в одну  с  передачей  ей  содержимого
обеих скобок.
     Рассмотрим пример. Предположим, что существует три коман-
ды:
        ВCC {file1.c }
        ВCC {file2.c }
        ВCC {file3.c }
     Вместо того, чтобы вызвать Borland C++ три раза, MAKE вы-
полнит одну команду:
        ВCC file1.c file1.c file1.c
     Отметим, что пробелы в конце имени в скобках обязательны,
так как объединение в одну строку производится с учетом всего,
что стоит в скобках.
     Здесь же  рассмотрим пример использования неявного прави-
ла.  Предположим,  Вы хотите откомпилировать программы Си  для
получения файлов .OBJ:
        .c.obj:
                ВCC -c {$< }
     MAKE использует неявное правило для каждого файла Си, ко-
торое расширит макрос $< в фактическое имя файла и добавит это
имя в список файлов для компиляции (вновь отметим наличие про-
бела  внутри скобок).  Этот список будет строиться до тех пор,
пока не произойдет одно из трех событий:
     - MAKE встретит команду, отличную от ВСС;
     - Больше нет команд для обработки;
     - Заполнена вся командная строка.
     Если MAKE обнаружит,  что вся строка заполнена, она поме-
щает в эту строку максимально возможное количество информации,
а остаток  переносит  на  следующую  командную  строку.  Когда
список готов, MAKE вызывает ВСС (с опцией -с) для всего списка
файлов.

                   Выполняемые команды DOS.

     MAKE выполняет перечисленные  ниже  "внутренние"  команды
DOS путем загрузки копии COMMAND.COM:
      break      del        path        set
      cd         dir        prompt      time
      chdir      echo       rd          type
      cls        erase      rem         ver
      copy       for        ren         verify
      ctty       md         rename      vol
      date       mkdir      rmdir
     Поиск любой  другой команды по ее имени производится ути-
литой МАКЕ аналогично тому, как это делает DOS:
     1. Сначала MAKE ищет файл в текущем справочнике, затем во
всех справочниках, указанных в пути доступа.
     2. В каждом справочнике сначала ищется файл с расширением
.COM. Если такой файл не найден,  производится поиск файла с тем же
именем, но  расширением  .EXE.  И наконец,  в случае неудачи ищется
файл с расширением .BAT.
     3. Если  найден  файл с расширением .BAT,  MAKE загружает
копию COMMAND.COM для его выполнения.
     Если Вы указали в командной строке имя файла с расширени-
ем, MAKE ищет только этот файл. Приведем несколько примеров:
     - Эта  команда  используется для изменения текущего спра-
вочника на справочник INCLUDE:
                           сd c:\inclide
     - MAKE использует полный алгоритм для поиска соответству-
ющих файлов при выполнении этой команды:
                           tlink lib\c0s x y,z,z,lib\cs
     - В  следующей  команде  поиск  ведется  только для файла
.COM:
                           prog.com geo.xyz
     - Для  указания  имени выполняемой программы здесь задано
полное имя:
                           с:\myprogs\fil.exe -r

                        Явные правила.

     Явные правила - это такие правила, в которых имена файлов
заданы полно и явно. Формат этих правил:
     вых_файл [вых_файл]...: [вход_файл вход_файл...]
              [команда]
              [команда]
              ...
     где вых_файл - это файл, который должен быть изменен;
         вход_файл - это файл, от которого зависит вых_файл;
         команда - это любая команда DOS (включая файлы .BAT и
                   любые выполняемые файлы .COM или .EXE).
     Явные правила определяют один (или более) выходной  файл,
нуль или более входных файлов и необязательный список выполня-
емых команд.  Имена входных и выходных файлов в списке  явного
правила могут содержать обычные спецификации DOS, принятые для
устройств и справочников,  кроме того,  они могут иметь симво-
лы-спецификаторы (? или *).
     Синтаксис здесь имеет большое значение.
     - Имя  выходного файла (вых_файл) должно находиться в на-
чале строки (позиция 1);
     - Имена входных файлов(а) (вход_файл) должны быть записа-
ны после двоеточия и разделяться по крайней мере одним  пробе-
лом или табуляцией;
     - Каждая команда должна начинаться с  отступа  (с  идущим
перед ней минимум одним пробелом или табуляцией).  Для продол-
жения команды на следующую строку допустимо применение  обрат-
ного слэша (\).
     И имена входных файлов,  и команды  необязательны  (могут
отсутствовать), можно записать явное правило, состоящее только
из
     вых_файл [вых_файл...]
     Основная идея явного правила заключается в том,  что  ко-
манда  или список команд будет создавать или изменять выходной
файл, используя входные файлы. Когда MAKE встречает явное пра-
вило,  то  прежде  всего  она  смотрит,  есть  ли где-нибудь в
MAKEFILE входные файлы,  которые сами должны изменяться по ка-
ким-то правилам.  Если такие файлы есть, то эти правила испол-
няются первыми.
     Когда все исходные файлы будут созданы или изменены, MAKE
проверяет,  существует ли выходной файл.  Если нет, каждая ко-
манда запускается в заданной последовательности. Если выходной
файл существует,  то его дата и  время  последней  модификации
сравниваются с датой и временем каждого исходного файла.  Если
какой-то из исходных файлов был модифицирован раньше  выходно-
го, то выполняется список команд.
     Имя данного файла может встречаться в левой части  явного
правила только один раз в данном выполнении МАКЕ.
     Каждая командная строка в явном правиле начинается с про-
бела. MAKE рассматривает все последующие строки, как продолже-
ние этого правила до тех пор,  пока следующая строка  не  нач-
нется с 1 позиции (то есть без пробела) или не будет достигнут
конец файла. Пустые строки игнорируются.

                        Особый случай.

     Явное правило, в котором нет команд, несколько отличается
от явного правила со списком команд:
     - Если в явном правиле присутствуют команды, то только те
файлы,  от  которых  зависит  выходной  файл,  будут внесены в
список явного правила;
     - Если  явное правило не имеет команд,  выходной файл за-
висит от двух типов файлов: файлов, заданных в явном правиле и
любого  файла,  который подходит для выходного файла в неявном
правиле.  Это позволяет создавать зависимости, управляемые че-
рез неявное правило. Например,
     .c.obj
        tcc -c $<
     prog.obj:
     Программа prog.obj  зависит  от  prog.c;  если произойдет
несовпадение дат и времени, будет выполнена команда:
     ВCC -c prog.c

                           Примеры.

     Ниже приведено несколько примеров явных правил.
     1. prog.exe: myprog.obj prog2.obj
          ВСС myprog.obj prog2.obj
     2. myprog.obj: myprog.c include\stdio.h
          ВСС -c myprog.c
     3. prog2.obj: prog2.c include\stdio.h
          ВСС -c -K prog2.c
     Эти три примеры одного и того же MAKEFILE.  Если  изменя-
лась  программа PROG2.C,  то только она и будет перекомпилиро-
ваться, это истинно и для MYPROG.C. Но если изменялся включае-
мый файл stdio.h,  то перекомпилируются оба файла. (Шаг редак-
тирования будет выполнен в том случае,  если изменяется  любой
из .OBJ файлов, а это произойдет в случае, если будет переком-
пилирован входной файл).

                  Проверка автозависимостей.

     Borland C++ работает с утилитой MAKE,  производящей  про-
верку автозависимостей файлов, включаемых по include. ВCC и ВС
генерируют файлы .OBJ,  в которых содержится  информация  (для
MAKE) о том, какие файлы были включены по include при формиро-
вании этого файла .OBJ.  Опция командной строки MAKE -а позво-
ляет проводить проверку этой информации.
     Когда MAKE выполняет проверку автозависимостей, она чита-
ет  из  объектного  файла информацию об имени,  времени и дате
каждого включаемого по include файлу.  Если любой из них моди-
фицировался,  то  объектный файл перекомпилируется.  Например,
рассмотрим следующее явное правило:
        myprog.obj: myprog.c include\stdio.h
           ВСС -c myprog.c
     Теперь предположим, что исходный файл MYPROG.C был отком-
пилирован ВСС (версия 2.0 и выше):
        #include <stdio.h>
        #include "dcl.h"

        void myprog() {}
     Если теперь запустить MAKE следующей командой:
        make  -a  myprog.obj
то MAKE  проверит  время  и  дату MYPROG.C,  а также stdio.h и
dcl.h.

                       Неявные правила.

     MAKE позволяет описывать неявные правила,  которые  явля-
ются обобщением явных правил и применимы ко всем файлам, имею-
щим указанное расширение.
     Рассмотрим на примере взаимосвязь между двумя типами пра-
вил. Возьмем явное правило, представленное в предыдущем приме-
ре. Это правило типично, поскольку оно отражает основной прин-
цип:  файл .OBJ зависит от файла .С с тем же самым именем, ко-
торый  должен  быть  обработан ВСС.  При этом в MAKEFILE может
оказаться несколько (или несколько дюжин) похожих правил тако-
го же формата.
     Переписав это явное правило в неявном виде, мы можем уда-
лить все одинаковые формы этого явного правила. Неявное прави-
ло будет выглядеть так:
     .c.obj:
        ВСС -c $<
     Это правило означает: "Любой файл с расширением .С должен
быть транслирован в файл с тем же именем и  расширением  .OBJ,
используя следующую последовательность команд". Файл .OBJ соз-
дается во второй строке правила, где $< представляет имя файла
с исходным (.С) расширением. (Символ $< - это специальный мак-
рос, описание которого будет дано ниже. $< будет заменяться на
полное  имя соответствующего исходного файла .С каждый раз при
выполнении команды).
     Синтаксис неявного правила:
     .исход_расширение.вых_расширение:
            [команда]
            [команда]
               ...
     Как и прежде, команды необязательны и должны начинаться с
отступа.  исход_расширение  (начинается  с  позиции  1)  - это
расширение исходного файла; это относится к любому файлу, име-
ющему формат:
     имя_файла.исход_расширение
     Аналогично, вых_расширение  -  это  расширение  выходного
(результирующего) файла и  представляет  любой  файл,  имеющий
формат:
     имя_файла.вых_расширение
где имя_файла - одно и то же имя исходного и выходного файла.
     Другими словами,  это неявное правило заменяет все  явные
правила, которые имеют формат:
     имя_файла.вых_расширение: имя_файла.исход_расширение
            [команда]
            [команда]
               ...
для любого имя_файла.
     Примечание. MAKE использует неявные правила,  если не мо-
жет найти явного правила для данного выходного файла или  если
в явном правиле нет команд для обработки выходного файла.
     Расширение имени файла - это признак для определения, ка-
кое  неявное  правило использовать.  Если найден файл с тем же
именем как выходной,  но с упомянутым исходным расширением, то
применяется неявное правило.
     Предположим, что файл с именем MAKEFILE содержит  следую-
щее правило:
     .c.obj:
            bcc -c $<
     Если Вы имеете программу RATIO.C и хотите откомпилировать
ее в RATIO.OBJ, Вы должны использовать команду:
     make ratio.obj
     MAKE воспримет  RATIO.OBJ как выходной файл и,  поскольку
нет явного правила создания файла RATIO.OBJ, MAKE применит не-
явное правило и сгенерирует команду:
     bcc -c ratio.c
которая, конечно сделает шаг компиляции,  необходимый для соз-
дания RATIO.OBJ.
     MAKE также  использует неявное правило,  если в явном нет
команд. Предположим, Вы написали в начале Вашего MAKEFILE сле-
дующее неявное правило:
     .c.obj:
            bcc -c $<
     Вы можете теперь удалить из правила команды:
        myprog.obj: myprog.c include\stdio.h
           tcc -c myprog.c
и оно все равно будет выполняться, как обычно.
     Если Вы работаете с Borland C++ и разрешили проверку  ав-
тозависимостей  объектных файлов,  Вы можете удалить все явные
описания взаимозависимостей,  которые имеют файлы .OBJ как вы-
ходные.  С  проверкой  автозависимости  и применением неявного
правила,  три примера, приведенные в разделе о явных правилах,
будут выглядеть так:
     .c.obj:
            bcc -c $<

     prog.exe: myprog.obj prog2.obj
               tlink lib\c0s myprog prog2, prog, , lib\cs
     Вы можете  написать несколько неявных правил с одинаковым
расширением выходного файла.  Если существует более одного не-
явного  правила  для данного выходного расширения,  то правила
рассматриваются в той же последовательности,  как они записаны
в MAKEFILE,  до тех пор, пока не будет найдено соответствующее
исходное расширение или MAKE не просмотрит все  представленные
правила.
     MAKE использует первое неявное правило,  которое вызывает
файл  с исходным расширением.  Даже в том случае,  если команд
нет или правило неудачно,  то другие неявные правила больше не
проверяются.
     Все строки,  следующие за неявным правилом,  относятся  к
нему, пока не встретится строка, начинающаяся с первой позиции
(без отступа).

                           Макросы.

     Случается так,  что в MAKEFILE часто используются опреде-
ленные команды,  имена файлов и опции.  Например,  Вы написали
программу Си,  которая использует среднюю модель  памяти,  все
Ваши команды ВСС записаны с переключателем -mm,  который озна-
чает, что надо компилировать в среднюю модель памяти. Но пред-
положим,  Вы  захотели переключиться на большую модель памяти.
Тогда Вы должны найти и заменить все переключатели -mm на -ml.
Или воспользоваться макросом.
     Макрос - это имя,  которое представляет некоторую  строку
символов. Описание макроса представляется в виде имени макроса
и расширенного текста;  в дальнейшем, когда MAKE встречает имя
макроса, оно заменяется на расширенный текст.
     Предположим, Вы определили в начале своего MAKEFILE  сле-
дующий макрос:
     MODEL = m
     Эта строка описывает макрос MODEL, который теперь эквива-
лентен строке m.  Используя этот макрос, можно записать каждую
команду вызова компилятора Си в следующем виде:
     bcc -c -m$(MODEL) myprog.c
     Когда будет  выполняться  MAKE,  каждый  макрос (в данном
случае,  $(MODEL)) заменится на расширенный текст  (здесь  m).
Тогда фактически выполняемая команда будет выглядеть следующим
образом:
     bcc -c -mm myprog.c
     Теперь стало очень легко изменить модели памяти.  Если Вы
замените первую строку на
     MODEL = l
то Вы замените все команды на работу с большой моделью памяти.
Практически первую строку в MAKEFILE можно удалить,  а тип мо-
дели  памяти  указывать  при запуске MAKE в командной строке с
помощью опции -D:
     make -DMODEL = l
     Это говорит MAKE,  что MODEL надо трактовать как макрос с
расширенным текстом l.

                    Определение макросов.

     Определения макросов имеют вид:
     имя_макроса = расширенный_текст
где имя_макроса - это имя макроса, которое должно быть строкой
символов и цифр без пробелов внутри строки,  хотя между именем
и знаком равенства можно поставить пробел. Расширенный_текст -
это любая строка,  содержащая буквы, цифры, пробелы и пунктуа-
цию (он должен быть описан в одну строку).
     Если имя_макроса было уже ранее определено,  либо опреде-
лением макроса в MAKEFILE,  или с помощью опции -D в командной
строке MAKE, то новое определение заменяет старое.
     В макросе имеет значение регистр, на котором набрано имя;
например,  model, MODEL и Model - это все разные идентификато-
ры.

                   Использование макросов.

     Макрос включается  в MAKEFILE с использованием следующего
формата:
     $(имя_макроса)
     Скобки необходимы во всех вызовах,  даже если имя макроса
состоит  из  одной буквы (за исключением предопределенных мак-
росов).  Такая конструкция:  $(имя_макроса) известна как вызов
макроса.
     Когда MAKE обнаруживает вызов макроса,  имя заменяется на
расширенный текст.  Если макрос не определен, он заменяется на
нулевую строку.

                        Особые случаи.

                      Макрос в макросе.

     Макрос не может располагаться в левой части описания мак-
роса,  но может встречаться в правой (расширенный текст).  При
этом расширение этого вложенного макроса будет  происходить  в
момент  расширения основного макроса.  Другими словами,  когда
расширяется вызов макроса,  любой макрос, вставленный в расши-
ренный текст, так же будет расширяться.

                      Макрос в правилах.

     Вызовы макросов расширяются непосредственно в строке пра-
вила.

                     Макрос в директивах.

     Вызовы макросов расширяются непосредственно в  директивах
!if  и  !elif.  Если  макрос,  вызываемый  в директиве !if или
!elif, не определен в данный момент времени, то он расширяется
значением 0 (FALSE).

                      Макрос в командах.

     Вызовы макросов  в командах расширяются в момент выполне-
ния команды.

                  Предопределенные макросы.

     MAKE имеет несколько встроенных макросов: $d, $*, $<, $:,
$.  и $&. Первый определяет, есть ли имя макроса; он использу-
ется в условных директивах !if и !elif.  Остальные макросы для
имен файлов используются в явных и неявных правилах. Вдобавок,
текущие строки среды DOS (строки, которые Вы можете посмотреть
и установить с помощью команды DOS SET) автоматически загружа-
ются как макросы.  Наконец,  MAKE определяет  два  макроса:  _
_MSDOS_ _, определенный в 1 (один); и _ _MAKE_ _, представляю-
щий версию MAKE в шестнадцатиричном  представлении  (для  этой
версии, 0х0300).

                         Таблица 7.4.
                        Макросы МАКЕ.
_____________________________________________________________

 Макрос             Что он делает
_____________________________________________________________

  $d      Проверка определения макроса
  $*      Макрос для базового имени файла с путем доступа
  $<      Макрос для полного имени файла с путем доступа
  $:      Макрос только для пути доступа
  $.      Макрос для полного имени файла без пути доступа
  $&      Макрос для базового имени файла без пути доступа
_____________________________________________________________

                 Заданный макрос теста ($d).

     Заданный макрос теста ($d) расширяется в 1,  если  данное
имя макроса описано,  или в 0,  в противном случае. Содержание
расширенного текста не имеет значения. Этот специальный макрос
допустим только в директивах !if и !elif.
     Например, предположим  Вы  хотите   модифицировать   свой
MAKEFILE таким образом,  что если Вы не указали тип модели па-
мяти,  то использовалась бы средняя  модель.  Тогда  в  начало
MAKEFILE поместите следующую запись:
     !if !$d(MODEL)    # Если MODEL не задана, то
     MODEL = m         # определить ее как m (MEDIUM).
     !endif
     Если Вы теперь запустите MAKE командой:
     make -DMODEL=1
тогда MODEL  будет определена как l,  однако если командой за-
пуска будет:
     make
то MODEL определится как m (по умолчанию).

                     Макросы имени файла.

     Различные макросы имени файла работают подобным  образом,
расширяясь в некоторые вариации имен полного пути доступа фай-
ла, который должен быть построен.

              Макрос базового имени файла ($*).

     Макрос базового имени файла применяется  в  командах  для
явных  и  неявных  правил.  Этот макрос ($*) расширяется в имя
файла без расширения:
     Имя файла:       A:\P\TESTFILE.C
     $* заменится на  A:\P\TESTFILE
     Например, Вы можете модифицировать это явное правило:
       prog.exe: myprog.obj prog2.obj
               tlink lib\c0s myprog prog2, prog, , lib\cs
     следующим образом:
     prog.exe: myprog.obj prog2.obj
               tlink lib\c0s myprog prog2, $*, , lib\cs
     Когда начнет  выполняться  команда  этого явного правила,
макрос $* заменится на имя выходного файла без расширения,  но
с  именем доступа.  Этот макрос очень полезен для неявных пра-
вил.
     Например, неявное правило может выглядеть так:
     .c.obj:
            bcc -c $*

                  Макрос для полного имени файла ($<).

     Макрос для  полного  имени  файла ($<) полезен в командах
явных и неявных правил.  В явном правиле $< расширяется в пол-
ное имя выходного файла, включая расширение:
     Имя файла:          A:\P\TESTFILE.C
     $< расширится в     A:\P\TESTFILE.C
     Например, правило:
     mylib.obj: mylib.c
                copy $< \oldobjs
                bcc -c $*
копирует файл MYLIB.OBJ в справочник \OLDOBJ перед компиляцией
MYLIB.C.
     В неявном правиле, $< заменяется на имя файла плюс исход-
ное расширение. Например, неявное правило:
     .c.obj:
            bcc -c $*.c
производит те же действия, что и правило:
     .c.obj:
            bcc -c $<
поскольку расширение имени выходного файла должно быть .С.

                  Макрос пути доступа ($:).

     Этот макрос  расширяется  именем  пути  доступа без имени
     файла:
          Имя файла: A:\P\TESTFILE.C
          $: расширится в A:\P\

            Макрос имени файла с расширением ($.).

     Этот макрос расширяется в имя файла с расширением, но без
пути доступа:
     Имя файла:          A:\P\TESTFILE.C
     $. расширится в     TESTFILE.C

               Макрос только имени файла ($&).

     Этот макрос расширяется только именем файла,  но без пути
доступа и расширения.
     Имя файла:          A:\P\TESTFILE.C
     $& расширится в     TESTFILE

                          Директивы.

     MAKE фирмы  Borland  позволяет  делать  то,  чего  другие
версии MAKE не делают,  а именно:  использовать директивы, по-
добные директивам в Си, Ассемблере и Турбо Паскале. Эти дирек-
тивы  можно применять для выполнения полезных мощных действий.
Некоторые директивы в MAKEFILE начинаются  с  восклицательного
знака  (это первый символ строки).  Другие начинаются с точки.
Ниже приведен полный список директив MAKE.

                         Таблица 7.5.
                       Директивы MAKE.
_____________________________________________________________
.autodepend    Включает проверку автозависимости
!elif          Условное выполнение
!else          Условное выполнение
!endif         Условное выполнение
!error         Вызывает остановку MAKE и  вывод  сообщения  об
               ошибке
!if            Условное выполнение
.ignore        Указывает MAKE, что надо игнорировать значение
               кода возврата команды
!include       Задает файл, который будет включен в файл
               MAKEFILE
.noautodepend  Выключение проверки автозависимости
.noignore      Выключение .ignore
.nosilent      Указывает MAKE, что надо напечатать команду
               перед ее выполнением
.noswap        Указывает MAKE, что не нужно выполнять
               перекачку памяти
.path.ext      Задает MAKE путь поиска для файла с
               расширением .EXT
.silent        Указывает MAKE, что не надо печатать команду
               перед ее выполнением
.swap          Указывает MAKE, что нужно выполнить перекачку
               памяти
!undef         Означает, что указанный макрос будет считаться
               неопределенным
______________________________________________________________

                     Директивы с точкой.

     Каждая из перечисленных ниже директив имеет соответствую-
щую  опцию  в  командной строке вызова MAKE,  но независимо от
этой опции эти директивы будут выполнять свое действие. Напри-
мер, Вы запустили MAKE следующей командой:
     make -a
но MAKEFILE  содержит директиву .NOAUTODEPEND,  тогда проверка
автоматической зависимости объектных модулей будет отменена.
     .AUTODEPEND и .NOAUTODEPEND включают и выключают проверку
автоматической зависимости. Они соответствуют опции -а команд-
ной строки.
     .IGNORE и .NOIGNORE указывают MAKE, что следует игнориро-
вать  код  возврата выполняемой команды (эквивалентно префиксу
"-" перед командой).  Они соответствуют опции -i  в  командной
строке.
     .SILENT и .NOSILENT указывают,  печатать или нет  команду
перед  ее выполнением.  Они соответствуют опции -s в командной
строке.
     .SWAP и .NOSWAP указывают, удалять или нет MAKE из памяти
перед выполнением команды.  Они соответствуют опции -S  в  ко-
мандной строке.

                     Директива .PATH.EXT.

     Эта директива  в  MAKEFILE  указывает  утилите MAKE,  где
искать все файлы с  данным  расширением.  Например,  следующая
строка в MAKEFILE:
       .PATH.c = C:\CSOURCE

       .c.obj:
              bcc -c $*

       tmp.exe: tmp.obj
         bcc tmp.obj
указывает, что MAKE будет искать файл ТМР.С (исходный файл для
TMP.OBJ) в справочнике C:\CSOURCE вместо текущего справочника.
     Кроме этого,  директива  .PATH  указывает  значение  пути
доступа.  Следующий пример показывает это применение. Исходные
файлы содержатся в одном справочнике,  файлы .OBJ в другом,  а
.EXE - в текущем справочнике.
       .PATH.c   = C:\CSOURCE
       .PATH.obj = C:\OBJS

       .c.obj:
            bcc -c -o$(.PATH.obj)\$& $<

       .obj.exe:
            bcc -e$&.exe $<

       tmp.exe: tmp.obj

                 Директива включения файлов.

     Директива !include указывает файл,  который будет включен
в файл MAKEFILE для обработки в точке,  где стоит эта директи-
ва. Ее формат:
     !include "имя_файла"
     Эти директивы могут быть  вложенными  на  любую  глубину.
Если  директива включения пытается включить файл,  который уже
был включен на некотором внешнем уровне вложения (так что цикл
вложения начинается), то внутренняя директива включения откло-
няется как ошибка.
     Как пользоваться  этой  директивой?  Предположим,  что Вы
создали файл MODEL.MAC, который содержит следующее:
     !if !$d(MODEL)
     MODEL=m
     !endif
     Теперь Вы можете использовать  это  условное  определение
макроса  в  любом  другом  файле  MAKEFILE с помощью директивы
включения:
     !include "MODEL.MAC"
     Когда MAKE встретит эту директиву,  будет открыт и прочи-
тан соответствующий файл,  как если бы он находился в MAKEFILE
сам.

               Директивы условного выполнения.

     Директивы условного  выполнения  (!if,  !elif,  !else   и
!endif) дают возможность создавать гибкие MAKEFILE, т.е. в за-
висимости от условий  может  выполняться  та  или  иная  часть
MAKEFILE.
     Формат этих директив похож на аналогичные директивы в Си,
Ассемблере и Турбо Паскале:
     !if выражение
     [строки]
     !endif

     !if выражение
     [строки]
     !else
     [строки]
     !endif

     !if выражение
     [строки]
     !elif выражение
     [строки]
     !endif
где [строки] может иметь следующие типы утверждений:
     - определение макроса;
     - явное правило;
     - неявное правило;
     - директива включения;
     - директива условного выполнения;
     - директива сообщения об ошибке;
     - директива типа !undef.
     Директивы условного выполнения формируются в группу,  на-
чинающуюся с !if и завершающуюся !endif.
     - В  группе  может  присутствовать  только одна директива
!else.
     - Между  директивами  !if и !else могут располагаться ди-
рективы !elif.
     - Правила, макросы и другие директивы могут располагаться
между разными условными директивами в любом количестве.  Заме-
тим,  что  полные  правила со своими командами не могут преры-
ваться условными директивами.
     - Директивы условного выполнения могут быть вложенными на
любую глубину.
     Любые правила,  команды и директивы должны быть завершены
внутри отдельного исходного файла.
     Они должны быть парными внутри одного и того же исходного
файла (т.е.  начинаться с !if и завершаться !endif). Например,
следующий файл включения ошибочен, так как нет соответствующей
директивы !endif:
     !if $(FILE_COUNT) > 5
        некоторые правила
     !else
        другие правила
     <конец-файла>

         Выражения, допустимые в условных директивах.

     Выражения, допустимые в директивах !if или !elif, исполь-
зуют синтаксис,  подобный Си.  Выражения вычисляются как целые
32-битные числа со знаком.
     Можно вводить десятичные,  восьмеричные и шестнадцатирич-
ные  константы.  Если Вы знаете язык Си,  то запись констант в
MAKEFILE для Вас уже известна - формат тот же самый.  Если  Вы
программируете на языке Ассемблер или Turbo Pascal,  то внима-
тельно посмотрите на следующие примеры.
     Допустимый формат констант:
     4536   # десятичная константа;
     0677   # восьмеричная константа (начинается с 0);
     0х23аF # шестнадцатиричная константа (начинается с 0х).
     В выражениях можно использовать следующие операции:

                         Таблица 7.6.
                       Операторы МАКЕ.
______________________________________________________________
Оператор                  Операция
______________________________________________________________
   Унарные операторы

     -             Отрицание (унарный минус)
     ~             Битовое дополнение
     !             Логическое NOT

   Бинарные операторы
     +             Сложение
     -             Вычитание
     *             Умножение
     /             Деление
     %             Остаток

     >>            Сдвиг вправо
     <<            Сдвиг влево
     &             Побитовая операция И (AND)
     |             Побитовая операция ИЛИ (OR)
     ^             Побитовое исключающее ИЛИ (XOR)

     &&            Логическое И (AND)
     ||            Логическое ИЛИ (OR)

     >             Больше
     <             Меньше
     >=            Больше или равно
     <=            Меньше или равно
     ==            Эквивалентно
     !=            Неэквивалентно

   Тройной оператор
     ?:            Условное выражение
______________________________________________________________
     Операторы имеют такие же приоритеты,  какие и в языке Си.
Для  группирования  операндов  можно использовать скобки.  При
отсутствии скобок все унарные операторы преобладают над бинар-
ными.
     Поскольку чтение большого  числа  операторов  может  быть
затруднительным даже для опытных программистов,  рекомендуется
использовать скобки.
     Можно включать в выражения и макросы; распознается специ-
альный макрос $d().  После расширения макроса выражение должно
иметь правильный синтаксис.

                   Директива вывода ошибок.

     Директива !error указывает MAKE,  что надо остановиться и
вывести диагностику,  представленную текстом после  директивы.
Ее формат:
     !error любой_текст
     Эта директива  может  включаться  в  условные директивы и
обеспечивает остановку и печать  сообщения  в  случае  ошибки.
Например,  Вы  вставили  перед первым явным правилом следующий
код:
     !if !$d(MODEL)
     # если MODEL не определена
     !error MODEL не определена
     !endif
     Если теперь Вы запустите MAKE без определения MODEL,  она
остановится с выводом сообщения:
     Fatal makefile 4: Error directive: MODEL not defined
(Фатальный MAKEFILE 4: Ошибочная директива: MODEL не определе-
на)

              Директива неопределенного макроса.

     Эта директива (!undef) означает, что следующее за ней имя
макроса будет считаться  неопределенным.  Если  указанное  имя
макроса в данный момент действительно не определено, то дирек-
тива не имеет действия. Ее синтаксис:
     !undef имя_макроса

              Сообщения об ошибках утилиты MAKE.

     Диагностические сообщения  MAKE  разбиты  на  два класса:
ошибки и фатальные ошибки.
     - Ошибки  -  это просто сообщения о типе синтаксических и
семантических ошибок в исходном MAKEFILE.
     - Если  происходит  фатальная  ошибка,  выполнение  сразу
останавливается. Вы должны исправить ошибку и повторить выпол-
нение.
      В сообщениях об ошибках,  перечисленных в этом  разделе,
появятся следующие общие имена и значения.  Когда Вы получаете
сообщение об ошибке,  то подставляется соответствующее имя или
значение.
______________________________________________________________
В     руководстве     Что     Вы     увидите     на     экране
______________________________________________________________
argument(s)  Командная  строка  или другой параметр expression
Выражение filename Имя файла  (с  расширением  или  без)  line
number     Номер     строки     message    Строка    сообщения
______________________________________________________________
     Сообщения об ошибках перечислены в лексикографическом по-
рядке ASCII;  сообщения, начинающиеся с символов, стоят первы-
ми. Так как сообщения, начинающиеся с только что перечисленных
переменных,  нельзя упорядочить в алфавитном порядке, то такие
сообщения стоят в начале каждого списка сообщения об ошибках.
     Например, при попытке редактировать связи файла,  назван-
ного NOEXIT.C, можно получить следующее сообщение:
     noexit does not exist--don't know how to make it
(NOEXIT не существует -- не знаю, как компилировать его)
     Для того,  чтобы найти это сообщение об ошибке, Вам нужно
найти:
     filename does not exist--don't know how to make it
в начале списка сообщений об ошибках.
     Если переменная встречается в тексте не в начале  сообще-
ния  об  ошибке  (например,  "Illegal  character  in  constant
expression:  expression" - Недействительный символ в констант-
ном выражении: expression), нужно искать пояснение сообщения в
корректном лексикографическом порядке;  в  данном  случае,  по
букве I.

                      Фатальные  ошибки.

      filename does not exist--don't know how to make it
  (filename не существует -- не знаю, как компилировать его)

     В строящейся последовательности есть несуществующий  файл
и нет правил,  по которым можно определить имя файла для пост-
роения.

            Circular dependency exist in makefile
          (В MAKEFILE обнаружена циклическая связь)

     MAKEFILE указывает,  что файл нуждается в обновлении даты
ПЕРЕД тем,  как его можно будет построить. Возьмем, к примеру,
явные правила:
       filea: fileb
       fileb: filec
       filec: filea
     Подразумевается, что filea зависит от fileb,  который за-
висит от filec,  который в свою очередь зависит от  filea.  Но
это недопустмо, т.к. файл не может зависеть от самого себя (ни
прямо, ни косвенно).

                   Error directive: message
              (Директива вывода ошибки: message)

      При выполнении MAKE вышла на директиву !error в исходном
файле, а текст директивы выводится на экран.

          Incorrect command-line argument: argument
       (Неверный параметр в командной строке: argument)

     В командной  строке  вызова  MAKE встретился недопустимый
аргумент.

      No terminator specified for in-line file operator
       (Для оператора inline файла не задан терминатор)

     MAKEFILE содержит операторы командной строки:  && или <<,
начинающие inline файл, а файл не завершен.

                      Not enough memory
                    (недостаточно памяти )

     Использована вся оперативная память.  Вы должны запустить
MAKE на машине с большей памятью.  Если у Вас уже есть  640  К
памяти,  то  уменьшите  исходные файлы или выгрузите некоторые
резидентные программы.

                  Unable to execute command
                (Невозможно выполнить команду)

     Команда не  может  быть выполнена.  Это может происходить
из-за отсутствия командного файла,  или если он  неверен,  или
команда есть, но разрушена.

                   Unable to open makefile
                (Невозможно открыть MAKEFILE).

     Текущий справочник не содержит файла с именем MAKEFILE  и
нет файла MAKEFILE.МАК.

              Unable to redirect input or output
   (Невозможно переназначить входное и выходное устройство)

     MAKE не может открыть временный файл  для  переназначения
ввода и вывода. Если Вы работаете в сети, убедитесь, что у Вас
есть права для работы в текущем справочнике.

                           Ошибки.

          Bad file name format in include statement
     (Неверный формат имени файла в утверждении include)

  Имена включаемых  файлов должны быть указаны в одинарных ка-
вычках или угловых скобках.  В имени файла  пропущена  кавычка
или угловая скобка.

                  Bad undef statement syntax
             (Неверен синтаксис директивы !undef)

     Утверждение !undef должно содержать единственный  иденти-
фикатор или ничего не содержать как тело утверждения.

                 Character constant too long
            (Символьная константа слишком велика)

     Символьная константа может быть длиной только в один  или
два символа.

                  Command arguments too long
             (В команде слишком много параметров)

     Длина аргументов в команде ограничена длиной 127 символов
(ограничение DOS).

                     Command syntax error
                (Ошибка в синтаксисе команды)

     Это сообщение означает, что:
     - в  первой  строке  правила  присутствуют впередистоящие
     пробелы; - неявное правило не соответствует синтаксису:
       [.расширение.расширение:];
     - явное правило не содержит  перед  символом  :  никакого
     имени;
     - макрос не содержит имени перед символом =.

                       Command too long
                   (Команда слишком длинна)

     Длина команды не должна превышать 128 символов. Вы можете
использовать командный файл.

                       Division by zero
                      (Деление на ноль)

     Делимое или остаток в утверждении !if имеют нулевой дели-
тель.

           Expression syntax error in !if statement
 (Синтаксическая ошибка в выражении в условной директиве !if)

     Выражение в операторе !if имеет неверный формат: непарные
скобки,  пропущенный или лишний оператор,  непарную или пропу-
щенную константу.

                      File name too long
                  (Имя файла слишком длинно)

      Имя файла в директиве !include слишком длинное для обра-
ботки компилятора. Имена файлов в DOS не могут быть длиннее 64
символов.

                    if statement too long
                 (Оператор if слишком длинен)

     Оператор if не должен превышать 4,096 символов.

    Illegal character in constant expression <expression>
        (Недопустимый символ в константном выражении)

     MAKE обнаружила неверный символ в константном  выражении.
Если символ - буква, возможно, что пропущен идентификатор.

                     Illegal octal digit
              (Недопустимая восьмеричная цифра)

     В восьмеричной константе встретилась цифра 8 или 9.

                   Macro expansion too long
             (Расширение макроса слишком длинно)

     Макрос не  может  расширяться более чем в 4,096 символов.
Эта ошибка часто встречается в том  случае,  если  макрос  ре-
курсивно расширяет сам себя.  Макрос не может правильно расши-
ряться сам в себе.

                   Misplaced elif statement
            (Неверное расположение оператора elif)

      Директива !elif   пропустила  соответствующую  директиву
!if.

                   Misplaced else statement
            (Неверное расположение оператора else)

      Встретилась директива !else без соответствующей директи-
вы !if.

                  Misplaced endif statement
           (Неверное расположение оператора endif)

      Встретилась директива  !endif без соответствующей дирек-
тивы !if.

                     No file name ending
                   (Нет конца имени файла)

     При указании  имени файла в предложении include пропущена
закрывающая кавычка или угловая скобка.

               Redefinition of target filename
             (Переопределено имя выходного файла)

     filename, стоящий в левой части правила,  встречается бо-
лее чем в одном явном правиле.

                      Rule line too long
                   (Правило слишком длинно)

     Явное или неявное правило занимает более 4,096 символов.

             Unable to open include file filename
               (Нельзя открыть включаемый файл)

     Файл с указанным именем не найден.  Это может возникать и
в случае, если файл, включаемый по include, включает сам себя.
Проверьте, существует ли указанный файл.

            Unexpected end of file in conditional
                started on line <line number>
(Неожиданный конец файла в условном операторе в строке line number)

     MAKEFILE закончился,  но  MAKE  не  обнаружила  оператора
!endif.  !endif  был либо пропущен,  либо написан с орфографи-
ческой ошибкой.

                Unknown preprocessor statement
           (Неизвестное утверждение препроцессора)

      Символ ! стоит в начале строки, в которой следующий опе-
ратор не соответствует ни одному из:  error,  undef, if, elif,
include, else или endif.

                  TLIB: библиотекарь Турбо.

     TLIB -  это  утилита,  которая управляет библиотеками от-
дельных  объектных  файлов  .OBJ.  Библиотека  -  это  удобный
инструмент для работы с наборами объектных модулей,  как с от-
дельным модулем.
      Библиотеки, созданные TLIB,  включаются системой Borland
C++.  Вы можете использовать TLIB для создания своих собствен-
ных   библиотек,  модификации  библиотек  Borland  C++,  своих
собственных библиотек, библиотек других программистов или ком-
мерческих библиотек, которые Вы приобрели. TLIB позволяет:
     - создавать новую библиотеку из группы объектных модулей;
     - добавлять  объектные модули или другие библиотеки в су-
ществующую библиотеку;
     - удалять объектные модули из существующей библиотеки;
     - заменять объектные модули в существующей библиотеке;
     - извлекать объектные модули из существующей библиотеки;
     - просматривать содержимое новой или существующей библио-
теки.
     Когда модифицируется существующая библиотека, TLIB всегда
создает копию первоначальной библиотеки с расширением .ВАК.
      TLIB может также создавать (и  включать  в  библиотечный
файл) Расширенный Словарь,  который может быть использован для
ускорения процесса редактирования связей. (Детальнее см. опцию
/Е).
      Хотя TLIB - не столь существенная  утилита,  необходимая
для  создания выполняемой программы системой Borland C++,  тем
не менее она является полезным инструментом для  программиста.
TLIB  можно  использовать  при создании больших проектов неза-
висимыми разработчиками.

       Как пользоваться библиотекой объектных модулей.

     Когда Вы пишете программу на Си,  Вы часто создаете набор
"полезных" функций Си, подобных тем, которые есть в библиотеке
времени выполнения Си. Поскольку язык программирования Си под-
держивает модульную структуру программ, Вы можете включать эти
функции в разные,  отдельно компилируемые файлы.  Но, в основ-
ном,  в  каждой  конкретной  программе  Вы  пользуетесь только
частью функций из всего большого их набора. Поэтому становится
достаточно  утомительным  помнить все эти файлы и выбирать те,
которыми Вы пользуетесь.  С другой  стороны,  если  Вы  будете
включать  эти файлы каждый раз в исходные тексты программ,  то
Вы получите очень большую и неудобочитаемую программу.
      Библиотека объектных  модулей разрешит проблему управле-
ния набором функций.  Когда Вы редактируете свою  программу  с
библиотекой,  то редактор просматривает библиотеку и автомати-
чески выбирает только те модули,  которые необходимы для теку-
щей  программы.  В дополнение к этому,  библиотека занимает на
диске меньше места,  чем набор  объектных  модулей,  особенно,
если  они небольшие.  Кроме этого,  библиотека ускоряет работу
редактора связей,  поскольку он открывает один файл вместо то-
го, чтобы открывать каждый файл с объектным модулем.

                    Командная строка TLIB.

     TLIB запускается  после  подсказки DOS с помощью команды,
формат которой приведен ниже, в квадратных скобках указаны не-
обязательные параметры: tlib имя_библиотеки[/C] [/E] [/размер]
[операции] [,список_файлов]
      Чтобы получить справку по использованию TLIB, просто на-
берите TLIB и нажмите Enter.
     В этом разделе мы приведем общий список компонент команд-
ной строки, следующие разделы содержат детальное описание каж-
дой компоненты.

                         Таблица 7.7.
                         Опции TLIB.
_____________________________________________________________
Компоненты        Описание
_____________________________________________________________
tlib       Полное имя библиотеки (если надо, то указывается и
           путь  доступа),  которая  создается  или с которой
           будет вестись работа.  При каждом запуске TLIB это
           имя  должно  быть указано.  Символы ?  и * в имени
           недопустимы.  TLIB  предполагает  расширение  .LIB
           (если   не   указано   другое).   Мы   рекомендуем
           использовать именно это расширение,  т.к. и ВСС, и
           другие  программы  системы  Borland C++ используют
           это   расширение    (.LIB)    для    распознавания
           библиотечных файлов. Замечание: Если библиотека не
           существует и указана операция  add,  TLIB  создает
           библиотеку.
/C         Различать строчные и прописные символы. Обычно эта
           операция не используется.  Детальное описание дано
           ниже.
/E         Создать расширенный словарь.
/P size    Установить размер страницы библиотеки.
operations Список операций, производимых TLIB. Операции можно
           указывать  в  любой  последовательности.  Если  Вы
           просто хотите просмотреть  содержание  библиотеки,
           то не указывайте никаких операций.
listfile   Имя файла,  куда  поместить распечатку содержимого
           библиотеки.  Имя должно отделяться  запятой.  Если
           имя не задано, листинг не генерируется. В листинге
           представляется  алфавитный  список  всех  модулей.
           Запись  для  каждого  модуля  содержит  алфавитный
           список всех public символов,  определенных в  этом
           модуле.  По  умолчанию,  расширение  для  листинга
           .LST.
           Вы можете  указать вывод листинга на экран,  задав
           имя листинга как CON, или на печать, задав имя как
           PRN.
_____________________________________________________________

                       Список операций.

     Список операций  описывает  операции,  выполняемые  TLIB.
Этот список содержит последовательность операций (одна за дру-
гой).  Каждая операция задается одним или двумя символами, ко-
торые ставятся перед именем модуля или файла.  Можно поместить
пробелы вокруг имени действия,  или имени файла или модуля, но
не посередине действия или имени, состоящего из двух символов.
     В командной строке можно поместить сколько угодно  опера-
ций,  но  длина строки ограничена DOS в 127 символов.  Порядок
операций неважен.  TLIB всегда выполняет операции в  следующей
последовательности:
     - Все операции извлечения выполняются первыми;
     - Следующими выполняются все операции удаления;
     - Последними выполняются операции добавления.
     Можно заменить модуль,  сначала удалив его, а затем доба-
вив заменяющий его модуль.

                   Имена файлов и модулей.

     TLIB ищет имя модуля,  взяв данное имя файла  и  разделив
его  на  устройство,  путь доступа и расширение.  (Обычно уст-
ройство, путь доступа и расширение не заданы).
     Заметим, что TLIB поддерживает разумные умолчания. Напри-
мер, добавить модуль с расширением .OBJ из текущего справочни-
ка можно,  указав только его имя,  без пути доступа и расшире-
ния.
     Символы ? и * в именах недопустимы.

                        Операции TLIB.

     В утилите  TLIB для обозначения операций используются три
символа (-,  +,  *),  которые можно использовать отдельно  или
комбинировать парами для получения пяти допустимых операций.
     Для операций,  использующих пару символов, последователь-
ность символов неважна. Ниже представлен список всех операций:

                         Таблица 7.8.
                    Символы действий TLIB.
____________________________________________________________
Символ  Имя                       Описание
____________________________________________________________
 + Добавить TLIB добавляет указанный файл в библиотеку. Если
            в имени  файла  нет  расширения,  предполагается
            .OBJ.   Если   указанный   файл   сам   является
            библиотекой (расширение .LIB),  тогда все  файлы
            будут добавлены в заданную библиотеку.
            Если в библиотеке есть уже  такой  модуль,  TLIB
            выводит сообщение и не добавляет новый модуль.
-  Удалить  Удаляет указанный  модуль  из  библиотеки.  Если
            такого модуля нет, то выводится сообщение.
            Операция удаления  требует  только  имя  модуля.
            TLIB позволяет   ввести   имя   полного  пути  с
            устройством и расширением,  но  игнорирует  все,
            кроме имени модуля.
*  Извлечь  Создает указанный файл, путем копирования в него
            соответствующего  модуля  из библиотеки.  Если в
            библиотеке такого модуля нет,  то  TLIB  выводит
            сообщение и не создает файл. Если указанный файл
            существует - он переписывается.
-* Извлечь &TLIB копирует названный модуль в соответствующее
*- Удалить  имя файла и затем удаляет его из библиотеки.
-+ Заменить TLIB заменяет в библиотеке модуль с указанным
+-          именем на содержимое соответствующего файла. Эта
            операция аналогична двум последовательным
            операциям: Удалить и Добавить.
____________________________________________________________
     Примечание 1.  Для  создания библиотеки добавьте модули в
библиотеку, которая еще не существует.
     Примечание 2.  Нельзя прямо переименовывать модули в биб-
лиотеке.  Чтобы переименовать модуль, извлеките и удалите его,
переименуйте  только что созданный файл и добавьте его обратно
в библиотеку.

               Использование командных файлов.

     Когда Вы работаете с большим  числом  операций  или  надо
часто  повторять одни и те же операции,  пользуйтесь командным
файлом.  Командный файл - это просто текстовый  файл,  который
может  быть  создан  редактором Borland C++ и содержит все или
часть команд для TLIB.  Используя этот файл, Вы можете постро-
ить список команд для TLIB,  значительно превышающий длину ко-
мандной строки DOS.
     Для указания  имени  и  пути доступа к командному файлу в
командной строке вызова TLIB укажите в любой позиции:
     @имя_командного_файла
     Заметим, что длина пути DOS ограничена 128 символами.
     - Для  размещения  в  командном  файле более одной строки
текста используйте символ &, который ставится в конце строки и
означает, что следующая строка является продолжением.
     - Не нужно помещать целую команду TLIB в командный  файл;
файл может предоставлять часть командной строки TLIB, а Вы мо-
жете набрать все остальное.
     - В  командной строке вызова TLIB можно указать несколько
командных файлов.
     Пример написания  и использования командного файла см.  в
разделе "Примеры".

          Опция /Е - создание расширенного словаря.

     Для ускорения работы редактора связей при обработке боль-
ших библиотек (таких как Cx.LIB) Вы можете указать TLIB на не-
обходимость создания расширенного словаря и  помещение  его  в
библиотечный файл.  Этот словарь содержит,  в очень компактной
форме, информацию, которая не включается в стандартный библио-
течный словарь. Эта информация используется TLINK для быстрого
поиска в библиотеке,  особенно если она расположена на  гибком
магнитном диске или низкоскоростном жестком диске. Все библио-
теки на Ваших дистрибутивных дисках содержат расширенный  сло-
варь.
     Для создания расширенного словаря для библиотеки, которая
будет модифицироваться,  используйте опцию /Е при запуске TLIB
для добавления,  удаления или замены модулей в библиотеке. Для
создания расширенного словаря для существующей библиотеки, ко-
торую Вы не хотите модифицировать, используйте опцию /Е и ука-
жите  TLIB операцию удаления несуществующего модуля.  TLIB вы-
даст сообщение о том,  что модуль не найден,  но при этом  все
равно  создаст  расширенный  словарь  для заданной библиотеки.
Например,
     tlib /E mylib -bogus
     TLINK будет игнорировать отладочную информацию в  библио-
теке,  имеющей  расширенный  словарь,  если в командной строке
TLINK не используется опция /е.

            Опция /Р - установить размер страницы.

     Каждый библиотечный файл DOS  содержит  словарь,  который
расположен в конце файла .LIB,  за которым следуют все объект-
ные модули.  Для каждого модуля из библиотеки этот словарь со-
держит 16-битный адрес, указывающий положение модуля в библио-
теке.  Этот адрес задан в значениях размера библиотечной стра-
ницы (по умолчанию - 16 байт).
     Размер страницы определяет максимальный размер всех  объ-
ектных  модулей  в  библиотеке,  который  не может быть больше
65536 страниц.  По умолчанию (и минимальный)  размер  страницы
равен 16 байтам, что позволяет создавать библиотеки размером 1
Мб. Для создания библиотеки большего размера используйте опцию
/Р  для  увеличения  размера страницы;  размер страницы должен
быть степенью 2, не меньше 16 и не больше 32768.
     Все модули в библиотеке должны начинаться с границы стра-
ницы.  Например, в библиотеке с размером страницы 32 (наимень-
ший  допустимый размер,  больший чем 16),  в среднем будет те-
ряться 16 байт на каждый модуль.  При попытке создания библио-
теки,  которая  слишком  велика  для данного размера страницы,
TLIB выдаст сообщение об ошибке и предложит использовать /Р со
следующим большим, чем данный, допустимым размером страницы.

                          Опция /С.

     Когда Вы  добавляете модуль в библиотеку,  TLIB заносит в
библиотеку все public имена,  определенные в этом модуле.  Все
имена должны быть уникальными. Если Вы добавляете в библиотеку
модуль,  который содержит повторяющиеся  имена,  TLIB  выводит
сообщение об ошибке и не добавляет модуль.
     Обычно, когда TLIB проверяет имена,  прописные и строчные
буквы не различаются.  Например, имена lookup и LOOKUP интерп-
ретируются как повторяющиеся.  Поскольку язык Си  ориентирован
на регистр,  используйте опцию /С при добавлении модуля в биб-
лиотеку,  для того чтобы имена,  отличающиеся только регистром
символов,  записывались  в  библиотеку.  Опция /С говорит TLIB
принять модуль с именем,  которое отличается от имени, уже на-
ходящегося в библиотеке, только регистром.
     Может показаться,  что работа TLIB без опции /С не  имеет
смысла, тем более, что язык Си поддерживает отличие в регистре
символов. Однако, кроме редактора связей TLINK, этой библиоте-
кой  могут пользоваться и другие редакторы связей,  которые не
различают прописные и строчные буквы (т.е. stars и Stars - это
одно имя). С другой стороны, TLINK не имеет проблем при разли-
чении прописных и строчных букв,  и он будет правильно воспри-
нимать библиотеку,  содержащую имена,  отличающиеся только ре-
гистром.  В этом примере Borland C++ будет воспринимать stars,
Stars и STARS как три различных идентификатора.  Если Вы пред-
полагаете использовать библиотеку только с  редактором  связей
TLINK, используйте опцию /С.
     Примечание. Если Вы хотите использовать библиотеку с дру-
гими редакторами (или позволите другим программистам использо-
вать библиотеку с другими редакторами) для предохранения Вы не
должны указывать опцию /С.

                           Примеры.

     Ниже приведено  несколько примеров,  демонстрирующих раз-
личные возможности работы с TLIB:
     1. Создать библиотеку с именем MYLIB.LIB,  в состав кото-
рой включить модули X.OBJ, Y.OBJ и Z.OBJ:
     tlib mylib +x +y +z
     2. Создать библиотеку (аналогично первому примеру) и  вы-
вести листинг в файл MYLIB.LST:
     tlib mylib +x +y +z, mylib.lst
     3. Получить листинг существующей библиотеки CS.LIB:
     tlib cs, cs.lst
     4. Заменить  модуль  X.OBJ новой копией,  добавить модуль
A.OBJ и удалить Z.OBJ из библиотеки MYLIB.LIB:
     tlib mylib -+x +a -z
     5. Извлечь модуль Y.OBJ из  библиотеки  MYLIB.LIB  и  по-
местить листинг в файл MYLIB.LST:
     tlib mylib *y, mylib.lst
     6. Создать  новую  библиотеку  ALPHA  с  модулями  A.OBJ,
B.OBJ, ..., G.OBJ, используя командный файл файл. Сначала соз-
дается текстовый файл (ALPHA.RSP), в который помещаются следу-
ющие строки:
     +a.obj +b.obj +c.obj &
            +d.obj +e.obj +f.obj &
            +g.obj
     Затем вызывается  TLIB  с  созданием  листинга  в   файле
ALPHA.LST:
     tlib alpha @alpha.rsp, alpha.lst

                       Редактор связей.

     Интегрированная усовершенствованная  среда   имеет   свой
встроенный  редактор связей.  При вызове компилятора командной
строки ВСС или ВССХ,  TLINK вызывается автоматически,  если Вы
не запретили шаг редактирования связей.  Если Вы запретили шаг
редактирования,  Вы должны вызвать TLINK вручную.  Этот раздел
описывает,  как использовать TLINK или TLINKX (версия защищен-
ного режима) как автономный редактор.  В конце  этого  раздела
находится  полный  список  сообщений  редактора,  генерируемый
встроенным редактором IDE или TLINK.
     По умолчанию,  компилятор командной строки вызывает TLINK
после успешной компиляции;  TLINK объединяет все объектные мо-
дули и библиотечные файлы для получения выполняемой программы.

                        Запуск TLINK.

     Запустить TLINK можно,  набрав в командной строке DOS ко-
манду tlink (с параметрами или без).  Если запустить TLINK без
параметров,  он выведет полный список параметров и опций. Сле-
дующая таблица описывает опции TLINK.
     Примечание. Эта  версия  TLINK  чувствительна  к регистру
своих опций; /t и /T - это разные опции.

                         Таблица 7.9
                         Опции TLINK.
____________________________________________________________
Опции              Что делают
____________________________________________________________
/3        разрешение 32-битных операций
/А=nnnn   задает выравнивание сегментов для образов
          NewExe (Windows)
/c        учитывать регистр символов
/C        разделы файла определения модуля IMPORTS и EXPORTS
          учитывают регистры символов
/d        печатать предупреждения, если в библиотеке
          дублируются имена
/e        игнорировать расширенный словарь
/i        инициализировать все сегменты
/l        включить номера исходных строк
/L        задать пути поиска справочника
/m        включить в файл MAP public имена
/n        не использовать библиотеки по умолчанию
/o        сделать оверлейными следующие модули и библиотеки
/P        упаковать сегменты кода
/s        детализация файла MAP по сегментам
/t        генерировать файл COM (а также /Tdc)
/Td       создать окончательный выполнимый модуль DOS
/Tdc      создать выходной файл DOS.СОМ
/Tde      создать выходной файл DOS.ЕХЕ
/Tw       создать выходной выполнимый код Windows (.DLL или
          .ЕХЕ)
/Twe      создать выходной код приложения Windows (.ЕХЕ)
/Twd      создать выходной код Windows DLL (.DLL)
/v        включить полную информацию для отладчиков
/x        не создавать файл MAP
/ye       подкачка памяти expanded
/yx       подкачка памяти extended
____________________________________________________________
     Примечание. В добавление к слэшу,  можно так же использо-
вать дефис перед командами TLINK.
     Общий синтаксис команды TLINK:
         TLINK objfiles, exefile, mapfile, libfiles, deffile
     Синтаксис задает, что имена должны идти в заданном поряд-
ке,  разделяясь пробелом, а группы одного типа разделяются за-
пятыми.

                Пример редактирования для DOS.

     Если Вы предложите командную строку TLINK:
tlink /c mainline wd ln tx,fin,mfin,work\lib\comm
work\lib\support
то TLINK будет  интерпретировать  это так:
     - Во время редактирования связей учитывать регистр симво-
лов (/с);
     - Будут редактироваться  объектные  файлы:  MAINLINE.OBJ,
WD.OBJ, LN.OBJ, TX.OBJ;
     - Имя выполняемой программы будет FIN.EXE;
     - Карта  распределения памяти - файл .МАР будет иметь имя
MFIN.MAP;
     - Будут  редактироваться  модули  из библиотек COMM.LIB и
SUPPORT.LIB, которые расположены в справочнике WORK\LIB;
     - Файл определения модуля не задан.

              Пример редактирования для Windows.

     Чтобы создать выполнимый код приложения Windows, Вы долж-
ны   использовать   эту   командную   строку:
    tlink /Tw /c \BORLANDC\lib\c0ws winapp1  winapp2,  winapp,
winapp,  \BORLANDC\lib\cwins   \BORLANDC\lib\cs \BORLANDC\lib\
import, winapp.def
где
     - опция /Tw говорит  TLINK  генерировать  выполнимый  код
Windows.
     - опция /с говорит TLINK различать регистры во время  ре-
дактирования.  Заметим,  что разделы EXPORTS и IMPORTS в файле
определения модуля не будут различать регистры до тех пор, по-
ка не будет использоваться опция /С.
     - \BORLANDC\LIB\C0WS является стандартным файлом  инициа-
лизации Windows, а WINAPP1 и WINAPP2 - это объектные файлы мо-
дуля; для всех трех файлов предполагается расширение .OBJ.
     - WINAPP.EXE - имя выходного выполнимого кода Windows.
     - WINAPP.MAP - имя файла .МАР.
     - \BORLANDC\LIB\CWINS - это библиотека времени выполнения
small модели памяти для Windows,  \BORLANDC\LIB\CS  -  обычная
библиотека времени выполнения, а \BORLANDC\LIB\IMPORT - библи-
отека, обеспечивающая доступ к встроенным функциям Windows.
     - WINAPP.DEF - файл определения модуля Windows, использу-
емый для задания дополнительных опций редактора.

             Имена файлов командной строки TLINK.

     Если Вы не задали имя выполнимого файла,  то TLINK извле-
чет это имя, добавив к первому в списке имени объектного файла
расширение .ЕХЕ или .DLL.
     Если Вы  задали  полное  имя выполнимого файла,  то TLINK
создаст файл с этим именем,  но фактический тип этого выполни-
мого файла зависит от других опций и установок в файле опреде-
ления модуля.  Например,  если Вы задали WINAPP.EXE,  но  пре-
доставили опцию /Tvd, то выполнимый файл будет создан как файл
DLL,  названный WINAPP.EXE - вероятно,  Вам бы этого не  хоте-
лось.  Подобно этому, если Вы задали WINAPP.DLL как имя выпол-
нимого файла,  но включили опцию /Td в  командную  строку,  то
файл будет выполнимым кодом DOS.
     Если имя файла .MAP не задано,  то TLINK добавит расшире-
ние .МАР к имени файла .ЕХЕ.  Если библиотеки не включены,  то
редактироваться ничего не будет.  Если Вы не задали файл опре-
деления модуля (.DEF) И использовали опцию /Tw,  то TLINK соз-
даст приложение Windows,  основанное на установках по  умолча-
нию.
     TLINK предполагает и  добавляет  следующие  расширения  к
именам файлов, которые расширения не имеют:
     - .OBJ для объектных файлов;
     - .EXE для выполняемых файлов (при использовании опции /t
или /Tdc расширением имени выполнимого файла станет .СОМ, а не
.ЕХЕ);
     - .DLL для динамических библиотек редактора (при  исполь-
зовании  опции  /Twd  или /Tw и файл определения модуля задает
библиотеку);
     - .MAP для файла МАР;
     - .LIB для библиотечных файлов.
     - .DEF для файлов определения модуля.
     Все имена файлов, КРОМЕ объектных файлов, являются необя-
зательными. Таким образом, например,
     TLINK dosapp dosapp2
редактирует DOSAPP.OBJ и DOSAPP2.OBJ,  создает выполнимый файл
DOS  с  именем  DOSAPP.EXE,  создает  файл   .МАР   с   именем
DOSAPP.MAP, не редактирует библиотеки и не использует файл оп-
ределения модуля.

               Использование командных файлов.

     TLINK позволяет задать различные  параметры  в  командной
строке, в командном файле или комбинации того и другого.
     Командный файл - это такой текстовый файл, который содер-
жит  опции  и/или имена файлов,  которые Вы обычно набираете в
командной строке вызова TLINK.
     Примечание. Поскольку  теперь  TLINK  различает  регистры
своих опций, Вам нужно модифицировать командные, пакетные фай-
лы и МАКЕFILE, предназначенные для предыдущей версии TLINK.
     В отличие  от  командной  строки,  командный  файл  может
располагаться  на  нескольких строках.  Можно прервать длинный
список объектных модулей и файлов библиотек символом + и  про-
должить его на следующей строке. Когда знак плюс встречается в
конце строки,  но сразу же сопровождает одну из  опций  TLINK,
которая  использует плюс для включения опции (как /ye+),  + не
воспринимается как символ продолжения строки.
     Можно расположить  каждую из четырех компонент на отдель-
ной строке:  объектные файлы, выполняемый файл, файл МАР, биб-
лиотеки,  при этом запятых для разделения компонент ставить не
надо.
     Для иллюстрации этих возможностей предположим, что Вы пе-
реписали командную строку:
tlink /c mainline wd ln tx,fin,mfin,work\lib\comm work\lib\support
со следующим командным файлом FINRESP:
     /c mainline wd+
       ln tx,fin
       mfin
       lib\comm lib\support
     Теперь можно вызвать TLINK командой:
     tlink @finresp
     Заметим, что для идентификации командного файла перед его
именем ставится символ @.
     Можно разбить  команду  редактора  на несколько командных
файлов. Например, можно разбить предыдущую командную строку на
два следующих командных файла:
             ┌─────────────────────────────┐                                      ┌─────────────────────────────┐
             │  Имя файла     Содержание   │
             ├─────────────────────────────┤
             │   LISTOBJS     mainline+    │
             │                wd+          │
             │                ln tx        │
             │   LISTLIBS     lib\comm+    │
             │                lib\support  │
             └─────────────────────────────┘
     Тогда TLINK можно вызвать командой:
     tlink /c @listobjs,fin,mfin,@listlibs

                   Файл конфигурации TLINK.

     Версия командной строки  TLINK  сначала  ищет  в  текущем
справочнике файл с именем TLINK.CFG, или в справочнике, из ко-
торого он загружается (DOS 3.0 или выше).
     TLINK.CFG обычным  текстовым  файлом,  содержащим  список
правильных  опций  TLINK.  В  отличие  от   командного   файла
TLINK.CFG не может перечислять группы имен файлов для редакти-
рования.
     Например, следующий файл TLINK.CFG
     /Lc:\BORLANDC\lib\;c:\winapps\lib
     /v /s
     /Tw
говорит TLINK осуществлять поиск библиотек в заданных справоч-
никах, включить отладочную информацию, создать детальную карту
сегмента и создать программу Windows.

         Использование TLINK для модулей Borland C++.

     Borland C++  поддерживает шесть различных моделей памяти:
маленькая (t),  небольшая (s),  компактная (c),  средняя  (m),
большая (l) и очень большая (h). Когда Вы создаете выполняемый
модуль Borland C++ (используя TLINK),  Вы должны включить  мо-
дуль инициализации и библиотеку для модели памяти, которая бу-
дет использована.
     Основной формат  команды  вызова TLINK для редактирования
связей программ Borland C++ имеет следующий вид:
 tlink C0[W|D]x myobjs,exe,[map],[IMPORT] [mylibs]
 [OVRLAY] [CWINx] [EMU|FP87 mathx] Cx,[deffile]
где myobjs - имена файлов .OBJ, которые нужно редактировать, с
заданием пути, если справочник не является текущим;
    exe     - имя, присваиваемое выполняемому файлу;
    [map]   - имя, присваиваемое файлу МАР (необязательное);
    [mylibs] - необязательные имена библиотечных файлов, кото-
рые Вы хотите включить во время редактирования, с заданием пу-
ти, если справочник не является текущим;
    deffile - файл определения модуля  для  выполнимого  файла
Windows.
     Включите пути  для  начального  кода  и  библиотек   (или
используйте  опцию  /L для задания списка путей поиска для на-
чального кода и библиотечных файлов).  Остальные имена в  этой
общей командной строке представляют файлы Borland C++:
     C0x|C0Fx   = модуль инициализации для DOS;
     C0Wx|C0Dx| =  выполнимый файл;  выполнимый файл DOS,  на-
писанный  для  другого  компилятора,  приложения  Windows  или
Windows DLL (выбирается одно) с моделью памяти t (только DOS),
s, c, m, l или h (только DOS);
     IMPORT = библиотека импорта Windows;  библиотека, обеспе-
чивающая доступ к встроенным функциям Windows;
     OVERLAY =   библиотека  управления  оверлеями;  требуется
                только для оверлейных программ (не  совместима
                с Windows);
     CWINx = библиотека  времени  выполнения  для  выполнимого
файла Windows с моделью памяти s, c, m или l;
     emu|fp87 = выбор одной из двух библиотек для арифметики с
                плавающей точкой;
     mathx = математическая библиотека для моделей  памяти  s,
                c, m, l или h;
     Cx = библиотека времени выполнения для моделей памяти  s,
                c, m, l или h;
     Примечание. Если Вы используете  очень  маленькую  модель
памяти и хотите, чтобы TLINK создал файл .СОМ, Вы должны также
задавать опцию /t или /Tdc.


                    Модуль инициализации.

     Модуль инициализации  имеет  имя  C0x.OBJ,  C0Wx.OBJ  или
C0Dx.OBJ (для DOS,  приложения Windows  и  Windows  DLL  соот-
ветственно), где x - это буква, соответствующая одной из моде-
лей памяти:  t (только для DOS),  s, c, m, l или h (только для
DOS). Неудача в редактировании соответствующего модуля инициа-
лизации обычно приводит к длинному списку сообщений  об  ошиб-
ках,  говорящих о том, что определенные идентификаторы не раз-
решены и/или не был создан стек.
     НОВОЕ! Модули   C0Fx.OBJ   обеспечивают  совместимость  с
исходными файлами, предназначенными для приобретенных компиля-
торов. Модули C0Fx.OBJ заменяют модули C0x.OBJ; они должны ре-
дактироваться только с приложениями DOS, а не Windows или DLL.
Эти модули инициализации изменяют модель памяти так,  что сег-
мент стека находится вне сегмента данных.  Соответствующий мо-
дуль C0Fx.OBJ будет использоваться автоматически, если исполь-
зуется опция компилятора командной строки -Fs или -Fm.
     Неудача редактирования  в правильном модуле инициализации
обычно приводит к появлению длинного списка сообщений об ошиб-
ках, говорящих о том, что неразрешимы определенные идентифика-
торы, не был создан стек или произошло переполнение стека.
     Модуль инициализации должен быть первым объектным модулем
в списке.  Этот модуль обеспечивает  правильное  распределение
сегментов  в  программе.  Если  модуль  инициализации  стоит в
списке не первым,  это может привести к неверному расположению
сегментов в памяти, что вызовет ошибки выполнения программы.
     Не забывайте явно указывать  имя  выполняемой  программы,
иначе  TLINK присвоит ей имя C0x.EXE (что Вам возможно не пон-
равится).

                         Библиотеки.

     Последовательность объектов и библиотек в командной стро-
ке вызова TLINK очень важна.  Вы должны всегда помещать модуль
инициализации Borland C++  (С0х.OBJ,  C0Fx.OBJ,  C0Wx.Obj  или
C0Dx.OBJ)  первым  в  списке  объектов,  затем  в определенной
последовательности следуют библиотеки:
     - Ваши собственные библиотеки (если они есть);
     - Если Вы хотите сделать свою программу оверлейной (толь-
ко  DOS),  то  Вы должны включить OVERLAY.LIB;  эта библиотека
должна предшествовать библиотеке Cx.LIB;
     - CWINx.LIB,  если  Ваша  программа будет выполняться под
управлением Windows;
     - Когда Вы используете вычисления с плавающей точкой,  то
FP87.LIB  или  EMU.LIB  (требуются  только  для  DOS),   затем
MATHx.LIB (требуется только для DOS и Windows);
     - Cx.LIB (стандартная библиотека Borland C++ времени  вы-
полнения для DOS или Windows).
     Если Вы хотите создать приложение  Windows  или  DLL,  Вы
должны  редактировать  IMPORT.LIB  для  обеспечения  доступа к
встроенным функциям Windows. IMPORT.LIB можно включать в любом
месте  списка.  Если  Вы  используете какие-нибудь графические
функции   Borland   C++,   Вы   должны   включать   библиотеку
GRAPHICS.LIB.  Графическая библиотека не зависит от модели па-
мяти, но используется только для DOS, а не Windows.
     Если Ваша  программа  использует  вычисления  с плавающей
точкой,  включите библиотеку EMU.LIB или FP87.LIB плюс матема-
тическую  библиотеку  MATHx.LIB.  Первые две библиотеки не за-
висят от модели памяти.
     - Если Вы хотите включить логику эмуляции чисел с плаваю-
щей точкой, то включите библиотеку EMU.LIB. С этой библиотекой
программа будет работать на машинах независимо от того,  имеют
они чип математического сопроцессора (80х87) или нет.
     - Если Вы знаете,  что программа будет работать на машине
с  сопроцессором,  включайте  библиотеку   FP87.LIB,   которая
обеспечивает создание быстрой и короткой программы.
     Математическая библиотека MATHx.LIB зависит от модели па-
мяти. Символ x следует заменить на одну из букв, соответствую-
щую модели:  s, c, m, l, h (наименьшая (t) и небольшая (s) мо-
дели объединены в библиотеке MATHS. LIB).
     Можно всегда включать библиотеки плавающей точки  (только
DOS) в строку вызова TLINK;  если Ваша программа не имеет опе-
раций с плавающей точкой,  в выполняемый код программы  ничего
не добавится.  С другой стороны, если эти библиотеки не указы-
вать в командной строке, при условии, что в программе нет пла-
вающей   арифметики,  время  редактирования  связей  несколько
уменьшится.
     Библиотека времени  выполнения должна включаться всегда и
зависит от модели памяти:  Cx.LIB,  где х - первая буква соот-
ветствующей  модели.  Используйте  такую же библиотеку времени
выполнения для выполнимых файлов Windows и DOS.
     Если Вы не собираетесь использовать все шесть моделей па-
мяти, а Ваш жесткий диск ограничен, то Вы можете хранить файлы
только  для используемой Вами модели памяти.  Ниже представлен
список библиотечных файлов,  необходимых для каждой модели па-
мяти  (также  нужны  FP87.LIB  или  EMU.LIB только для DOS,  а
IMPORT.LIB для Windows) :

                        Таблица 7.10.
              Файлы .OBJ и .LIB приложения DOS.
______________________________________________________________
  Модель   Обычный        Модуль        Математ.    Библиотека
           модуль         инициализации библиотека  времени
           инициализации  совместимости             выполнения
 4______________________________________________________________
  Tiny     C0T.OBJ        C0FT.OBJ      MATHS.LIB   CS.LIB
  Small    C0S.OBJ        C0FS.OBJ      MATHS.LIB   CS.LIB
  Compact  C0C.OBJ        C0FC.OBJ      MATHC.LIB   CC.LIB
  Medium   C0M.OBJ        C0FM.OBJ      MATHM.LIB   CM.LIB
  Large    C0L.OBJ        C0FL.OBJ      MATHL.LIB   CL.LIB
  Huge     C0H.OBJ        C0FH.OBJ      MATHH.LIB   CH.LIB
 4______________________________________________________________

                        Таблица 7.11.
            Файлы .OBJ и .LIB приложения Windows.
______________________________________________________________
  Модель    Модуль          Windows        Математ.    RTL
            инициализации   RTL            библиотека
            приложений
 4______________________________________________________________
     Примечание. RTL - аббревиатура для библиотеки времени вы-
полнения.
     Заметим, что очень маленькая и небольшая модели использу-
ют  одни  и те же библиотеки,  но разные модули инициализации:
C0T.OBJ и C0S.OBJ.

                        Таблица 7.12.
              Файлы .OBJ и .LIB приложения DLL.
______________________________________________________________
  Модель    Модуль          Windows        Математ.    RTL
            инициализации   RTL            библиотека
            для DLL
 4______________________________________________________________
  Small     C0DS.OBJ        CWINC.LIB      MATHS.LIB   CS.LIB
  Compact   C0DC.OBJ        CWINC.LIB      MATHC.LIB   CC.LIB
  Medium    C0DM.OBJ        CWINL.LIB      MATHM.LIB   CM.LIB
  Large     C0DL.OBJ        CWINL.LIB      MATHL.LIB   CL.LIB
 4______________________________________________________________

                  Использование TLINK с ВСС.

     После завершения своей работы (если нет ошибок) стандарт-
ный компилятор Borland C++ - ВСС может автоматически запустить
TLINK с правильным файлом инициализации,  библиотекой и именем
выполнимой программы.
     Для этого  в  командной строке вызова ВСС необходимо ука-
зать имена файлов с явным расширением .OBJ и .LIB:
     bcc -mx myfile.obj sub1.obj mylib.lib
     ВСС запустит TLINK с файлами: C0x.OBJ, EMU.LIB, MATHx.LIB
и  Cx.LIB  (модуль инициализации,  библиотека эмуляции 8087 по
умолчанию,  математическая библиотека и библиотека времени вы-
полнения  для  модели памяти х).  TLINK также присоединит Ваши
собственные модули MAINFILE.OBJ и SUB1.OBJ и  вашу  библиотеку
MYLIB.LIB.
     Для компиляции и редактирования программ Windows включите
одну из опций -W в командной строке компилятора,  так же как и
другие опции.  Редактор сам  позаботится  о  редактировании  в
C0Wx.OBJ, CWINx.LIB и IMPORT.LIB.
     При запуске TLINK,  ВСС использует по умолчанию опцию  /с
(редактирование с различением регистров).  Можно перекрыть эту
опцию по умолчанию с помощью -l-c.

                         Опции TLINK.

     Опции TLINK могут располагаться в любом  месте  командной
строки.  Опции состоят из символа (/),  дефиса (-) и одного из
символов переключателя DOS со следующей за ним опцией. (Симво-
лом переключателя DOS по умолчанию является /.  Можно изменить
его с помощью вызова INT 21H).
     ВАЖНО! Начиная  с  этой  версии TLINK регистр опции имеет
значение (/t и /T - разные опции). Все опции предыдущих версий
были строчными буквами. Если Вы используете опции с прописными
буквами в командных файлах или  МАКЕ  файлах,  предназначенных
для предыдущей версии TLINK, Вам необходимо модифицировать эти
файлы перед использованием их с той версией.
     Если Вы  используете более одной опции,  то пробелы между
ними необязательны (/m/c означает то же самое,  что и /m  /c).
Ниже приведено описание всех опций.

                   Файл конфигурации TLINK.

     Версия командной   строки   TLINK   ищет  файл  с  именем
TLINK.CFG сначала в текущем справочнике,  а затем в справочни-
ке, из которого он загружается (DOS 3.0 или выше).
     TLINK.CFG - это обычный текстовый файл, содержащий список
правильных   опций  TLINK.  В  отличие  от  командного  файла,
TLINK.CFG не может перечислять группы имен файлов для редакти-
рования. Пробелы игнорируются.
     Например, следующий файл TLINK.CFG
     /Lc:\BORLANDC\LIB\;c:\winapps\lib
     /v /c
     /Tw
говорит TLINK осуществлять поиск библиотек в заданных справоч-
никах, включить отладочную информацию, создать детальную карту
сегмента и создать программу Windows.

                  /3 (80386 32-битный код).

     Опцию /3 нужно использовать  тогда,  когда  редактируется
один или более модулей, созданных с помощью TASM или совмести-
мого Ассемблера,  и содержит 32-битный код для 80386 процессо-
ра.  Эта опция увеличивает потребность в памяти TLINK и замед-
ляет редактирование,  поэтому нужно использовать ее  только  в
случае необходимости.

                 /А (выравнивание сегментов).

     Опция /А задает значение байта,  по которому будут вырав-
ниваться сегменты. Сегменты, меньшие заданного значения, будут
дополняться до этого значения. Синтаксис:
     /A = nnnn
где nnnn  -  число,  представляющее  коэффициент выравнивания.
nnnn должно быть степенью числа 2.  Например, /А=16 указывает,
что сегменты должны выравниваться по границе абзаца.
     Значение выравнивания сегмента по  умолчанию  равно  512.
Для  большей эффективности Вы должны использовать меньшее зна-
чение, которое разрешит правильные смещения сегмента в таблице
сегмента. Адреса файла в таблице сегментов умножаются на коэф-
фициент выравнивания для того, чтобы использоваться как смеще-
ния  байта  в  выполнимый файл.  Так как смещения хранятся как
16-битовые слова,  то коэффициент выравнивания в 65536  таймов
является  пределом  смещений  сегментов,  которые  могут  быть
представлены в сегментной  таблице.  Если  Вы  получите  такое
сообщение, увеличьте значение выравнивания сегмента.

              Опция /c (ориентация на регистр).

     Опция /с  указывает,  чтобы  TLINK  различал  прописные и
строчные буквы в public и external именах.

          Опция /С (различение регистров в EXPORTS).

     По умолчанию TLINK обрабатывает разделы EXPORTS и IMPORTS
в файле определения модуля с различением регистров. Опции /С и
/С+ включают различение регистров; /С- выключает.

                Опция /d (дублирование имен).

     Обычно TLINK не сообщает о том,  что  одинаковые  внешние
имена  встречаются в более чем одном библиотечном файле.  Если
имя следует включить в программу,  то TLINK берет первое соот-
ветствующее имя,  которое находит в первом встретившемся файле
из списка файлов командной строки. Поскольку это общее исполь-
зуемое свойство, TLINK обычно не предупреждает о дублированных
именах.  Следующая ситуация иллюстрирует,  как можно использо-
вать эту возможность. Рассмотрим следующий пример.
     Предположим, у Вас есть  две  библиотеки:  SUPPORT.LIB  и
DEBUGSUP.LIB. Предположим, что в библиотеке DEBUGSUP.LIB нахо-
дится подпрограмма с таким  же  именем,  что  и  в  библиотеке
SUPPORT.LIB (но она несколько отличается от другой, как версия
с  отладкой  этой  подпрограммы).  Если  теперь   Вы   укажете
DEBUGSUP.LIB  в  списке  файлов  командной строки вызова TLINK
первой, то в выполняемую программу будет включена процедура из
DEBUGSUP.LIB, а не из SUPPORT.LIB.
     Если Вы не используете эту возможность  и  не  уверены  в
том,  какие подпрограммы дублируются, то можете включить опцию
опцию /d. Тогда TLINK просмотрит все списки внешних имен и вы-
даст  соответствующие  предупреждения,  даже если эти имена не
будут использоваться в этой программе.
     С заданием  этой опции TLINK также позаботится об именах,
которые появятся в файлах .OBJ и .LIB. В этом случае, посколь-
ку  имена,  стоящие  первыми  (левее) в командной строке будут
именами редактируемых файлов,  то будут использоваться имена в
файле .OBJ.
     В системе Borland C++ дистрибутивные библиотеки не содер-
жат  дублирующих имен,  хотя очевидно,  что EMU.LIB и FP87.LIB
(или CS.LIB и CL.LIB) будут иметь такие имена,  но они никогда
не  используются  одновременно в одной командной строке вызова
TLINK. Например, нет дублирующих имен среди EMU.LIB, MATHS.LIB
и CS.LIB.

          Опция /е (отключить расширенный словарь).

     Все библиотечные файлы,  поставляемые с Borland C++,  со-
держат расширенный словарь с  информацией,  позволяющей  TLINK
быстрее  работать.  Такой  словарь может быть добавлен в любую
библиотеку с помощью TLIB и опции /Е.  Опция /е  не  позволяет
TLINK использовать этот словарь.
     Хотя редактирование с библиотеками, содержащими расширен-
ный словарь,  становится быстрее, Вам нужно использовать опцию
/е,  если у вас есть программа,  требующая значительно  больше
памяти  для редактирования при использовании расширенного сло-
варя.

             Опция /i (инициализация сегментов).

     Опция /i отключает инициализацию сегментов, которые долж-
ны  выводиться  в  выполнимый файл,  даже если они не содержат
данных. Обычно эта опция не используется.

                   Опция /l (номера строк).

     Опция /l включает в  файл  .МАР  номера  строк  исходного
текста программы.  Чтобы использовать эту опцию, Вы должны от-
компилировать файлы .OBJ с опцией -y  (опция  Line  Numbers...
включена) или -v (отладочная информация).  Если Вы используете
/х,  чтобы TLINK не создавал файл .МАР вообще,  эта  опция  не
повлияет ни на что.

                 /L (пути поиска библиотек).

     Опция /L позволяет задать список справочников,  в которых
TLINK будет искать библиотеки, если не задан явный путь. TLINK
ищет текущий справочник перед тем,  как будет задана опция /L.
Например,
 TLINK /Lc:\BORLANC\lib;c:\mylibs splash logo,,,utils .\logolib
     С этой командной строкой TLINK  сначала  ищет  в  текущем
справочнике   UTILS.LIB,   затем   ищет  в  C:\BORLANDC\LIB  и
C:\MYLIBS.  Поскольку .\LOGOLIB неявно называет текущий  спра-
вочник,  TLINK не осуществляет поиск библиотек, заданных с оп-
цией /L для поиска LOGOLIB.LIB.
     TLINK также ищет модуль инициализации С или С++ (C0x.OBJ,
C0Wx.OBJ, C0Dx.OBJ) по заданному пути поиска библиотек.

                      Опции /x, /m и /s.

     По умолчанию TLINK всегда создает файл МАР для  выполняе-
мого  файла.  Этот  файл  МАР включает в себя список сегментов
программы,  адрес начала программы и  любые  предупреждения  и
ошибки,  встретившиеся во время редактирования связей. Если Вы
не хотите создать файл МАР, отключите опцию /х.
     Если Вы  хотите создать более полный файл .МАР,  то опция
/m добавит в него список public имен,  отсортированный в алфа-
витном порядке и в последовательности увеличения адресов.  Та-
кой файл .МАР очень полезен при отладке.  Многие отладчики мо-
гут использовать список public имен, чтобы допустить ссылки на
адреса имен при отладке.
     Опция /s делает то же самое, что и /m, но еще добавляет в
файл .МАР детальную карту распределения сегментов. Ниже приве-
ден пример такой карты:
┌───────────────────────────────────────────────────────────────┐
│ Address  Length Class Segment Name  Group  Module  Alignment/ │
│         (Bytes)                                     Combining │
│                                                               │
│ 0000:0000 0E5B C=CODE S=SYMB_TEXT  G=(none) M=SYMB.C ACBP=28  │
│ 00E5:000B 2735 C=CODE S=QUAL_TEXT  G=(none) M=QUAL.C ACBP=28  │
│ 0359:0000 002B C=CODE S=SCOPY_TEXT G=(none) M=SCOPY  ACBP=28  │
│ 035B:000B 003A C=CODE S=LRSH_TEXT  G=(none) M=LRSH   ACBP=20  │
│ 035F:0005 0083 C=CODE S=PADA_TEXT  G=(none) M=PADA   ACBP=20  │
│ 0367:0008 005B C=CODE S=PADD_TEXT  G=(none) M=PADD   ACBP=20  │
│ 036D:0003 0025 C=CODE S=PSBP_TEXT  G=(none) M=PSBP   ACBP=20  │
│ 036F:0008 05CE C=CODE S=BRK_TEXT   G=(none) M=BRK    ACBP=28  │
│ 03CC:0006 066F C=CODE S=FLOAT_TEXT G=(none) M=FLOAT  ACBP=20  │
│ 0433:0006 000B C=DATA S=_DATA      G=DGROUP M=SYMB.C ACBP=48  │
│ 0433:0012 00D3 C=DATA S=_DATA      G=DGROUP M=QUAL.C ACBP=48  │
│ 0433:00E6 000E C=DATA S=_DATA      G=DGROUP M=BRK    ACBP=48  │
│ 0442:0004 0004 C=BSS  S=_BSS       G=DGROUP M=SYMB.C ACBP=48  │
│ 0442:0008 0002 C=BSS  S=_BSS       G=DGROUP M=QUAL.C ACBP=48  │
│ 0442:000A 000E C=BSS  S=_BSS       G=DGROUP M=BRK    ACBP=48  │
└───────────────────────────────────────────────────────────────┘
     Для каждого сегмента в каждом модуле эта карта показывает
адрес,  длину в байтах,  класс, имя сегмента, группу, модуль и
информацию АСВР.
     Если сегмент  появляется в нескольких модулях,  то каждый
модуль появится как отдельная строка (например, SYMB.C). Кроме
поля АСВР,  информация в детальной карте сегмента является на-
половину объясненной.
     АСВР -  это поле зашифровывает атрибуты выравнивания (А),
комбинации (С) и большие атрибуты (В) в набор из четырех бито-
вых  полей,  как определено с помощью Intel.  TLINK использует
только три поля:  А,  С,  В. Это значение представлено в файле
.МАР в шестнадцатиричном виде. Следующие значения объединяются
операцией OR для получения значения АСВР:
______________________________________________________________

Поле             Значение          Описание
______________________________________________________________

Поле А             00            Абсолютный сегмент
(выравнивание)     20            Сегмент выравнен на байт
                   40            Сегмент выравнен на слово
                   60            Сегмент выравнен на параграф
                   80            Сегмент выравнен на страницу
                   А0            Непоименованная абсолютная
                                 часть памяти

Поле С             00            Не может комбинироваться
(комбинирование)   08            Общий сегмент

Поле В             00            Сегмент меньше, чем 64К
(размер)           02            Сегмент точно в 64К
______________________________________________________________
     Когда детальная карта представлена в файле .МАР (т.е. за-
дана опция /s),  в списке public имен могут встретиться имена,
отмеченные флагом "idle" (пусто),  то есть на  эти  имена  нет
ссылок.  Например,  этот фрагмент из раздела public имен файла
МАР указывает,  что на экспортируемые имена Symbol1 и  Symbol3
нет ссылок.
     0C7F:031E    idle    Symbol1
     0000:3EA2            Symbol2
     0C7F:0320    idle    Symbol3

      Опция /n (игнорирование библиотеки по умолчанию).

     Опция /n указывает редактору связей,  что следует игнори-
ровать библиотеки,  по умолчанию задаваемые компилятором.  Эта
опция может понадобиться и в том случае, если Вы собираете мо-
дули, написанные на другом языке.

                        /о (оверлеи).

     Опция /о  приводит  к  тому,  что код во всех модулях или
библиотеках, заданных после этой опции, становится оверлейным.
Она действует до тех пор, пока не встретится следующая запятая
(явная или неявная) или /о- в потоке команды. Опция /o- отклю-
чает  оверлеи.  (Дополнительную  информацию об оверлеях см.  в
главе 6 "Управление памятью" руководства программиста).
     За опцией /о может идти (но необязательно) имя сегментно-
го класса;  это приведет к тому, что все сегменты этого класса
будут оверлейными. Когда такое имя не задано, будут оверлейны-
ми все сегменты класса, заканчивающиеся с CODE. Может быть за-
дано несколько опций /о,  таким образом делая оверлейными сег-
менты нескольких классов;  все опции /о остаются в действии до
тех пор, пока не встретится следующая запятая или /о-.
     Синтаксис /o#xx,  где хх представляет собой  шестнадцати-
ричное число из 2 цифр, перекрывает число прерывания оверлеев,
которое по умолчанию равно 3FH.
     Здесь приведено несколько примеров опции /о:

                        Таблица 7.13.
                   Оверлейные опции TLINK.
_____________________________________________________________
Опция     Результат
_____________________________________________________________
/о             Делает оверлейными все сегменты, пока не
               встретится следующая запятая или /о-.
/о-            Делает невозможными оверлеи.
/оOVY          Делает оверлейными сегменты класса OVY, пока
               не встретится следующая запятая или /о-.
/oCODE /oOVLY  Делает оверлейными сегменты класса CODE или
               класса OVLY до тех пор, пока не встретится
               запятая или /о-.
/o#FO          Использование вектора прерываний 0F0H для
               оверлеев.
_____________________________________________________________
     Если Вы используете опцию /о, то она автоматически отклю-
чится перед обработкой библиотек.  Если Вы хотите сделать биб-
лиотеку оверлейной, Вы должны использовать другую опцию /о не-
посредственно перед всеми библиотеками или непосредственно пе-
ред библиотекой, которую Вы хотите сделать оверлейной.
     Нельзя использовать опцию /о вместе с опцией /Tw;  прило-
жения  Windows  не могут быть оверлейными.  Однако,  для того,
чтобы таких же результатов в Windows, используйте сбрасываемые
сегменты кода.

               /Р (упакованные сегменты кода).

     При использовании /Р,  когда TLINK редактирует выполнимый
файл Windows, TLINK комбинирует столько сегментов кода, сколь-
ко  возможно  в  одном физическом сегменте до предела упаковки
сегмента кода.  Упаковка сегмента кода никогда не создаст сег-
менты, превышающие этот предел; TLINK при необходимости начнет
новый сегмент.
     Пределом упаковки  сегмента  кода  по  умолчанию является
8192 байт (8К). Чтобы изменить его, используйте
     /Р=n
где n задает число байтов от 1 до 65536. Под расширенным режи-
мом 386 возможно Вы захотите, чтобы предел был кратен 4К.
     Хотя оптимальный размер сегмента в расширенном режиме 386
равен 4К,  но размер упаковки сегмента кода по умолчанию равен
8К.  Поскольку обычные сегменты кода бывают от 4К  до  8К,  то
размер упаковки 8К приведет к более эффективной упаковке.
     Поскольку есть определенное число  систем  поддерживающих
каждый  сегмент,  то  упаковка  кода сегмента путем уменьшения
числа сегментов для поддержки значительно  повысит  производи-
тельность.  Опция /Р включает упаковку кода;  по умолчанию она
отключена. /Р- отключает упаковку сегмента кода (полезно, если
Вы  включили  ее  в  файле конфигурации и хотите сделать недо-
пустимой для конкретного редактирования).

          Опция /t (tiny модель памяти файла .СОМ).

     Если Вы откомпилировали программу с tiny моделью памяти и
редактируете  ее  с опцией /t,  то TLINK сгенерирует файл .СОМ
вместо файла .ЕХЕ.  Также при использовании /t расширением  по
умолчанию для выполняемого файла становится .СОМ. Это работает
подобно опции /Tdc.  Ни /t,  ни /Tdc не  совместимы  с  опцией
Windows /Tw.
     Примечание. Файл .СОМ не может занимать более 64К памяти,
не может объявлять сегмент для стека и не должен иметь началь-
ный адрес 0:100H.  Когда для выполняемого  файла  используется
расширение,  отличное от .СОМ (.BIN,  например),  то начальным
адресом может быть 0:0 или 0:100H.
     TLINK не  может  генерировать  отладочную  информацию для
файла .СОМ.  Если Вам требуется отлаживать программу, создайте
и  отладьте  ее  как файл .EXE,  а затем отредактируйте ее как
файл .COM.  Альтернативно,  если имеется Turbo Debugger, можно
использовать  утилиту  TDESTRIP с опцией -с;  это создаст файл
.COM из файла .EXE.

              Опции /Td и /Tw (выходные опции).

     Эти опции называются выходными опциями. Используйте их (с
буквами с, е, d) для создания файла .СОМ, .ЕХЕ или .DLL.
     - /Td создает файл DOS.ЕХЕ.
     - /Tdc создает файл DOS.СОМ.
     - /Tde создает файл DOS.ЕХЕ.
     - /Tw говорит TLINK создать выполнимый файл Windows.  Эта
опция не нужна,  если Вы включили файл  определения  модуля  с
Windows утверждением EXETYPE.  С опцией /Tw или без нее,  если
файл определения модуля имеет утверждение NAME,  то TLINK соз-
дает приложение (.EXE); если файл определения модуля имеет ут-
верждение LIBRARY, то TLINK создает DLL.
     Если файл определения модуля не включен в редактирование,
нужно задать опцию /Tw или /Twe  для  Windows.ЕХЕ,  или  опцию
/Twd для Windows DLL.
     Ни одна из опций /Tw несовместима с опцией /о (оверлейные
модули).
     - /Twe создает файлы Windows.ЕХЕ.  Опция /Twe перекрывает
оператор LIBRARY в файле определения модуля (что обычно приво-
дит к созданию DLL).
     - /Twd создает Windows DLL. Опция /Twd перекрывает опера-
тор NAME в файле определения модуля  (что  обычно  приводит  к
созданию файла .ЕХЕ).

              Опция /v (отладочная информация).

     Опция /v указывает TLINK включить отладочную информацию в
выполняемый файл.  Если эта опция стоит где-нибудь в командной
строке,  то отладочная информация будет включена для всех объ-
ектных  модулей,  содержащих  отладочную   информацию.   Можно
использовать опции /v- или /v+,  чтобы сделать невозможным или
возможным  включение  отладочной  информации  на  основе   мо-
дуль-за-модулем  (но не в одной командной строке с опцией /v).
Например, эта команда
     tlink mod1 /v+ mod2 mod3 /v- mod4
включает отладочную информацию для модулей mod2 и mod3,  но не
включает для mod1 и mod4.
     TLINK не может  генерировать  отладочную  информацию  для
файла .СОМ (он создается с помощью опций /t и /Tdc).  Если Вам
нужно отлаживать программу,  создайте и отладьте ее  как  файл
.EXE,  а затем отредактируйте ее как файл .COM. Альтернативно,
если  имеется  Turbo  Debugger,  можно  использовать   утилиту
TDESTRIP с опцией -с; это создаст файл .COM из файла .EXE.

              /y (память extended или expanded).

     Этот переключатель  управляет использованием TLINK памяти
extanded или expanded для буферизации  ввода/вывода.  Если  во
время  чтения  объектных  файлов или записи выполняемого файла
TLINK потребуется больше памяти для активных структур  данных,
он или очистит буферы,  или вытолкнет их в память extended или
expanded.
     В случае буферизации файла ввода, очистка означает просто
выброс буфера ввода,  так что его пространство можно использо-
вать  для  других структур данных.  В случае буферизации файла
вывода,  очистка означает запись буфера на корректное место  в
выполняемом файле. В любом случае, можно существенно увеличить
скорость редактирования, разрешив перекачку этих буферов в па-
мять extended или expanded.
     Объем TLINK не увеличивается при перекачке;  только улуч-
шается  его  выполнение.  По  умолчанию,  перекачка  в  память
expanded возможна только тогда,  когда невозможна перекачка  в
память extended. Если перекачка разрешена, но нет соответству-
ющей памяти,  в которую должна произойти перекачка, то эта пе-
рекачка и не произойдет. Если Вы редактируете с TLINKХ, редак-
тором защищенного режима,  то ни одна из этих опций  не  имеет
эффекта.
     Этот переключатель имеет несколько форм, показанных ниже:
/ye или /ye+ разрешает перекачку в память expanded
             (по умолчанию)
/ye-         не разрешает перекачку в память expanded
/yx или /yx+ разрешает перекачку в память extended
/yx-         не разрешает перекачку в память extended
             (по умолчанию)

                         Ограничения.

     Предыдущие ограничения, которые теперь отменяются:
     - TLINK теперь генерирует Windows.ЕХЕ и файлы .DLL.
     - Общие переменные теперь поддерживаются.
     - Теперь  допускаются сегменты с одними и теми же именами
и классами,  которые не комбинируются.  Они не комбинируются и
появляются отдельно в файле .МАР.
     - Теперь любой код Mycrosoft можно редактировать с TLINK.
     TLINK можно,  конечно, использовать компиляторами Borland
C++ (как интегрированной среды, так и в режиме командной стро-
ки), TASM и другими.

                   Файл определения модуля.

     Файл определения модуля предоставляет информацию редакто-
ру о содержании и системных требованиях приложения Windows. Он
более специфицировано:
     - называет приложение или библиотеку динамического редак-
тирования (DLL);
     - идентифицирует тип приложения как Windows или OS/2;
     - перечисляет импортируемые и экспортируемые функции;
     - описывает атрибуты сегмента кода  и  данных;  позволяет
задать атрибуты для дополнительных сегментов кода и данных;
     - задает размер кучи и стека;
     - предоставляет для включения программы заглушки DOS.
     Заметим,что утилита IMPLIB может использовать файл  опре-
деления модуля для создания библиотеки импорта. Утилита IMPDEF
может действительно  создавать  файл  определения  модуля  для
использования с IMPLIB.

            Файл определения модуля по умолчанию.

     Файл определения  модуля не является необходимым для соз-
дания выполнимого файла Windows с Borland C++.
     Если файл определения модуля не задан,  то предполагаются
следующие умолчания:
     CODE       PRELOAD MOVEABLE DISCARDABLE
     DATA       PRELOAD MOVEABLE MULTIPLE (для
                приложений) или PRELOAD MOVEABLE
                SINGLE (для DLL)
     HEAPSIZE   4096
     STACKSIZE  5120
     Чтобы заменить оператор EXETYPE, редактор Borland C++ мо-
жет открыть,  какой тип выполнимого файла вы  хотите  создать,
путем проверки установки в IDE или опций в командной строке.
     Можно включить библиотеку импорта  для  подстановки,  для
раздела IMPORTS в определении модуля.
     Можно использовать ключевое слово _export в  определениях
экспортных функций в исходном коде С или С++ для удаления тре-
буемой в разделе EXPORTS.  Заметим,  однако,  что если _export
используется  для  экспорта  функции,  то  эта  функция  будет
экспортироваться скорее именем,  а не порядковым номером  (по-
рядковый номер обычно более эффективен).
     Если Вы хотите изменить несколько атрибутов по умолчанию,
то Вам нужно завести файл определения модуля.

                      Небольшой пример.

     Это определение  модуля  из примера WHELLO,  приведенного
выше.
     NAME            WHELLO
     DESCRIPTION     'C++ Windows Hello World'
     EXETYPE         WINDOWS
     CODE            MOVEABLE
     DATA            MOVEABLE MULTIPLE
     HEAPSIZE        1024
     STACKSIZE       5120
     EXPORTS         MainWindowProc
     Давайте рассмотрим отдельно каждое утверждение этого фай-
ла:
     - NAME задает имя для приложения.  Если Вы хотите постро-
ить DLL вместо приложения,  Вы должны использовать вместо него
оператор LIBRARY.  Каждый файл определения модуля должен иметь
или оператор NAME,  или оператор LIBRARY, но не вместе. Задан-
ное имя должно быть таким же, что и имя выполнимого файла.
     - DESCRIPTION позволяет задать строку, описывающую прило-
жение или библиотеку.
     - EXETYPE может быть  WINDOWS  или  OS2.  В  этой  версии
Borland C++ поддерживается только WINDOWS.
     - CODE задает атрибуты сегментов кода по умолчанию. Опция
MOVEABLE означает,  что сегмент кода можно перемещать в памяти
во время выполнения.
     - DATA  задает  атрибуты  по  умолчанию  сегмента данных.
MOVEABLE означает,  что их можно перемещать в памяти во  время
выполнения.  Windows  позволяет запускать более одного образца
приложения в одно и тоже  время.  Для  поддержки  этого  опции
MULTIPLE  гарантируют,  что  каждый  образец  приложения имеет
собственный сегмент данных.
     - HEAPSIZE задает размер локальной кучи приложения.
     - STACKSIZE задает размер  локального  стека  приложения.
Нельзя  использовать оператор STACKSIZE для создания стека для
DLL.
     - EXPORTS перечисляет те функции в приложении WHELLO, ко-
торые будут вызваны другими приложениями или Windows. Функции,
которые  предназначаются для вызова другими модулями,  называ-
ются  обратными  вызовами,  функциями  обратного  вызова   или
экспортными функциями.
     - Чтобы помочь Вам избежать необходимости создания и под-
держки  больших  разделов  EXPORTS,  Borland C++ предоставляет
ключевое слово _export.  Функции,  помеченные  _export,  будут
идентифицированы редактором и введены в экспортную таблицу для
модуля.  Если во время  компиляции  используется  опция  Smart
Callbacks     (/WS     в    командной    строке    BCC,    или
Options/Compiler/Entry/Exit Code|Windows Smart Callbacks),  то
функции  обратного  вызова НЕ требуют перечисления в операторе
EXPORTS или пометки ключевым словом _export.  Borland C++ ком-
пилирует из таким образом, что они могут быть функциями обрат-
ного вызова.
     Это приложение  не  имеет  оператора  IMPORTS,  поскольку
функциями,  которые оно вызывает из других  модулей,  являются
только функции из Windows API; эти функции импортируются через
автоматическое включение библиотеки импорта IMPORT.LIB.  Когда
приложению  требуется  вызвать другие внешние функции,  то эти
функции должны быть перечислены в операторе IMPORTS, или вклю-
чаться через библиотеку импорта.
     Это приложение не включает  оператор  STUB.  Borland  C++
использует встроенную заглушку для приложений Windows.  Встро-
енная заглушка просто проверяет загружено  ли  приложение  под
Windows,  и,  если нет, завершает приложение с сообщением, что
требуется Windows.  Если Вы хотите написать и включить настро-
енную заглушку,  задайте имя этой заглушки с помощью оператора
STUB.

                  Ссылка определения модуля.

     Этот раздел описывает каждое утверждение в файле  опреде-
ления модуля.

                        Оператор CODE.

     Оператор CODE  задает атрибуты по умолчанию сегментов ко-
да.  Коды сегмента могут иметь любое имя,  но должны принадле-
жать  классам сегментов,  имена которых заканчиваются на CODE.
Например, правильными именами класса сегментов являются CODE и
MYCODE. Синтаксис:
     CODE [FIXED|MOVEABLE]
      [DISCARDABLE|NONDISCARDABLE]
      [PRELOAD|LOADONCALL]
     FIXED означает,  что  сегмент  остается  в  фиксированном
месте памяти;  MOVEABLE означает,  что сегмент  может  переме-
щаться. DISCARDABLE означает, что сегмент может быть отброшен,
если он больше не нужен.  DISCARDABLE подразумевает  MOVEABLE.
NONDISCARDABLE означает, что сегмент не может быть отброшен.
     PRELOAD означает, что сегмент загружается при первой заг-
рузке модуля; LOADONCALL означает, что сегмент загружается при
вызове кода  в  этом  сегменте.  Программа  загрузки  Resource
Compiler и Windows устанавливает сегмент кода, содержащий точ-
ку входа исходной программы к PRELOAD независимо от  установки
файла определения модуля.
     Атрибутами по умолчанию для сегментов кода являются:
      FIXED        NONDISCARDABLE     LOADONCALL

                        Оператор DATA.

     Оператор DATA задает атрибуты по умолчанию сегментов дан-
ных.
     Синтаксисом оператора DATA является:
 DATA [NONE|SINGLE|MILTIPLE] [FIXED|MOVEABLE]
     NONE означает,  что нет сегмента данных.  Если Вы задаете
NONE,  не включайте никаких других опций.  Эта опция допустима
только для библиотек.
     SINGLE означает,  что отдельный сегмент разделяется всеми
образцами модуля. MULTIPLЕ означает, что каждый образец прило-
жения имеет сегмент. SINGLE действителен только для библиотек;
MILTIPLЕ действителен только для приложений.
     FIXED означает,  что  сегмент  остается  в  фиксированном
месте  памяти.  MOVEABLE  означает,  что сегмент может переме-
щаться.
     Атрибутами по  умолчанию для сегмента данных в приложении
являются FIXED и MULTIPLE. Атрибутами по умолчанию для библио-
тек являются FIXED и SINGLE.
     Автоматический сегмент данных - это сегмент,  группой ко-
торого являются DGROUP. Этот физический сегмент также содержит
локальную кучу и стек (см.  операторы файла определения модуля
HEAPSIZE и STACKSIZE).  Программа загрузки Resource Compiler и
Windows устанавливает автоматический сегмент данных в  PRELOAD
независимо от установки в файле определения модуля.

                    Оператор DESCRIPTION.

     Оператор DESCRIPTION вставляет текст в модуль приложения.
Оператор DESCRIPTION обычно используется для запоминания авто-
ра, даты и авторских прав. DESCRIPTION - необязательный опера-
тор. Синтаксис : DESCRIPTION 'TEXT'
     TEXT задает строку ASCII,  ограниченную одиночными кавыч-
ками.

                      Оператор EXETYPE.

     Оператор EXETYPE задает по умолчанию тип заголовка  (OS/2
или  Windows) выполнимого файла (.EXE).  В этой версии Borland
C++ можно задать только WINDOWS. Синтаксис: EXETYPE Type
     Type задает тип заголовка, который TLINK пишет в выполни-
мый файл.

                      Оператор EXPORTS.

     Оператор EXPORTS задает имена и атрибуты функций, которые
будут экспортироваться. Ключевое слово EXPORTS помечает начало
определений.  Оно может сопровождаться любым количеством опре-
делений экспортов, каждый на отдельной строке. Синтаксис:
  EXPORTS
    ExportName[Ordinal][RESIDENTNAME][NODATA][Parameter]
     ExportName задает  строку  ASCII,  задающую   имена   для
экспортирования. Она имеет следующую форму:
     <EntryName>=[InternalName]
     InternalName -  имя,  используемое  внутри приложения для
ссылки на эту запись. EntryName - имя, перечисленное в таблице
записей выполнимого файла.
     Ordinal задает порядковый номер функции. Он имеет следую-
щую форму :
    @ordinal
     где ordinal - целое значение,  задающее порядковое значе-
ние функции.
     Когда модуль  приложения или модуль DLL вызывает функцию,
экспортируемую из DLL, то вызывающий модуль может ссылаться на
функцию с помощью имени или порядкового значения.  В отношении
скорости ссылка на функцию  посредством  порядкового  значения
быстрее, так как для размещения функции не требуется сравнива-
ние строк.  В отношении распределения  памяти  экспортирование
функции  с  помощью  порядкового  номера  (с точки зрения этой
функции DLL) и импортирование/вызов функции с помощью порядко-
вого значения (с точки зрения вызывающего модуля) более эффек-
тивно. Когда функция экспортируется с помощью порядкового зна-
чения, имя находится в нерезидентной таблице имен. Когда функ-
ция экспортируется с помощью имени,  имя находится в резидент-
ной таблице имен. Резидентная таблица имен для модуля является
резидентной в памяти,  когда бы модуль не загрузился;  нерези-
дентная таблица таковой не является.
     Опция RESIDENTNAME позволяет задать имена функций,  кото-
рые должны быть резидентными все время. Она полезна только при
экспортировании с помощью порядкового значения (когда имена не
будут резидентными по умолчанию).
     Опция NODATA позволяет задать те функции,  которые не яв-
ляются границей для определенного сегмента данных. Функция бу-
дет использовать текущий сегмент данных.
     Parameter - это не обязательное целое значение,  задающее
количество слов,  которые функция ожидает для передачи  в  ка-
честве параметров.

                      Оператор HEAPSIZE.

     Оператор HEAPSIZE задает число байтов, необходимых прило-
жению для его локальной кучи.  Приложение использует локальную
кучу всякий раз при распределении локальной памяти. Синтаксис:
     HEAPSIZE bytes
     bytes -  целое  значение,  задающее размер кучи в байтах.
оно не должно превышать 65536 (размер физического сегмента).
     Размер кучи по умолчанию равен нулю. Минимальный размер -
256  байт.  Общая  сумма   автоматического   сегмента   данных
(DEGROUP), локальной кучи и стека не должна превышать 65536.

                      Оператор IMPORTS.

     Оператор IMPORTS задает имена и атрибуты функций, которые
будут импортироваться из библиотек динамического  редактирова-
ния. Вместо перечисления импортируемых функций DLL в операторе
IMPORTS можно либо задать библиотеку импорта для DLL в команд-
ной  строке TLINK,  либо - в IDE - включить библиотеку импорта
для DLL в проекте.
     Ключевое слово  IMPORTS помечает начало определений.  Оно
может сопровождаться любым числом определений импорта,  каждое
на отдельной строке. Синтаксис:
     IMPORTS
       [InternalName=]ModuleName.Entry
     InternalName - это строка ASCII, задающая уникальное имя,
которое приложение будет использовать для вызова функции.
     ModuleName задает  один  или  более  прописных   символов
ASCII,  которые  задают  имя  выполнимого модуля,  содержащего
функцию.  Имя модуля должно соответствовать имени  выполнимого
файла. Например, файл SAMPLE.DLL имеет имя модуля SAMPLE.
     Entry задает функцию для импортирования.  Это может  быть
или  строка  ASCII,  которая  содержит имя функции,  или целое
число, представляющее собой порядковое значение этой функции.

                      Оператор LIBRARY.

     Оператор LIBRARY задает имя модуля DLL.  Файл определения
модуля может содержать или оператор NAME для указания приложе-
ния, или оператор LIBRARY для указания DLL, но не оба сразу.
     Как имя  модуля приложения,  имя модуля библиотеки должно
соответствовать имени выполнимого файла.  Например, библиотека
MYLIB.DLL имеет имя модуля MYLIB. Синтаксис:
     LIBRARY LibraryName
     LibraryName задает строку ASCII, задающую имя модуля биб-
лиотеки.
     Начальный адрес  модуля библиотеки определяется с помощью
объектных файлов библиотеки;  это внутренне определенная функ-
ция.
     LibraryName - не обязательный параметр.  Если параметр не
включен,  TLINK  использует  часть имени выполнимого файла (то
есть имя с удаленным расширением).
     Если файл  определения  модуля  не  включает  ни оператор
NAME, ни LIBRARY, то TLINK предполагает наличие оператора NAME
без параметра ModuleName.

                        Оператор NAME.

     Оператор NAME  определяет имя выполнимого модуля приложе-
ния.  Имя модуля  идентифицирует  модуль  при  экспортировании
функций. Синтаксис:
     NAME ModuleName
     ModuleName определяет  один  или более прописных символов
ASCII,  задающих имя выполнимого  модуля.  Имя  модуля  должно
соответствовать имени выполнимого файла.  Например, приложение
с выполнимым файлом SAMPLE.EXE имеет имя модуля "SAMPLE".
     Параметр ModuleName необязателен.  Если параметр не вклю-
чен,  TLINK предполагает,  что имя модуля соответствует  имени
выполнимого файла.  Например,  если Вы не задали имя модуля, а
выполнимый файл называется MYAPP.EXE,  то TLINK  предполагает,
что именем модуля будет "MYAPP".
     Если файл определения модуля  не  включает  ни  оператора
NAME, ни LIBRARY, то TLINK предполагает наличие оператора NAME
без параметра ModuleName.

                      Оператор SEGMENTS.

     Оператор SEGMENTS определяет атрибуты  сегмента  дополни-
тельных сегментов кода и данных. Синтаксис:
     SEGMENTS
       SegmentName[CLASS'ClassName'][MinAlloc]
       [FIXED|MOVEABLE][DISCARDABLE|NONDISCARDABLE]
       [SHARED|NONSHARED][PRELOAD|LOADONCALL]
     SegmentName определяет символьную строку с именем  нового
сегмента.  Это может быть любое имя, включая стандартные имена
сегмента _TEXT и _DATA, которые представляют собой стандартные
сегменты кода и данных.
     ClassName - это необязательное ключевое  слово,  задающее
имя  класса  заданного  сегмента.  Если  имя класса не задано,
TLINK использует имя класса CODE по умолчанию.
     MinAlloc - необязательное целое значение,  задающее мини-
мальный размер размещения для сегмента. Сейчас TLINK игнориру-
ет это значение.
     FIXED означает,  что  сегмент  остается  в  фиксированном
месте памяти. Опция MOVEABLE означает, что сегмент может пере-
мещаться при необходимости, в целях уплотнения памяти.
     DISCARDABLE означает,  что  сегмент может быть отвергнут,
если он больше не нужен;  NONDISCARDABLE означает, что сегмент
не может быть отвергнут.
     PRELOAD означает,  что  сегмент  загружается  немедленно;
LOADONCALL  означает,  что сегмент загружается при доступе или
вызове.  Resource Compiler может перекрыть опцию LOADONCALL  и
вместо нее сразу загрузить сегменты.
     Атрибуты по умолчанию для дополнительных сегментов описы-
ваются для сегментов CODE и DATA (в зависимости от типа допол-
нительного сегмента).

                     Оператор STACKSIZE.

     Оператор STACKSIZE определяет число  байтов,  необходимых
приложению для локального стека. Приложение использует локаль-
ный стек всякий  раз,  когда  он  делает  вызовы  функций.  Не
используйте оператор STACKSIZE для библиотек динамического ре-
дактора. Синтаксис:
     STACKSIZE bytes
     bytes - целочисленное значение,  задающее размер стека  в
байтах.
     Если приложение не делает вызовы функций, то STACKSIZE по
умолчанию равен 0. Если Ваше приложение делает вызовы функций,
то минимальный размер равен  5120  байтов  (если  Вы  зададите
меньше,  то  он будет изменен на 5120).  Общая сумма автомати-
ческого сегмента данных (DGROUP),  локальной кучи и  стека  не
должна превышать 65536.

                        Оператор STUB.

     Оператор STUB  добавляет выполнимый файл DOS,  заданный с
помощью FileName, к началу модуля. Заглушка выполнимого модуля
должна  показывать  предупреждение  и  завершать работу,  если
пользователь не загрузил Windows.
     Borland C++ добавляет встроенную заглушку к началу прило-
жения Windows, если с помощью оператора STUB не была определе-
на другая заглушка.  Более того Вы не должны использовать опе-
ратор STUB только для включения WINSTUB.EXE, потому что редак-
тор сделает это для Вас автоматически. Синтаксис:
     STUB "FileName"
     FileName задает имя выполнимого файла DOS,  которое будет
добавлено к модулю. Имя должно иметь формат имени файла DOS.
     Если файл  с именем FileName не находится в текущем спра-
вочнике, то TLINK ищет файл в справочниках, определенных поль-
зовательской переменной PATH.

                    Сообщения об ошибках.

     TLINK имеет  три  типа ошибок:  фатальные,  нефатальные и
предупреждения.
     - Фатальные   ошибки  приводят  к  немедленной  остановке
TLINK; файл .ЕХЕ удаляется.
     - Нефатальные ошибки не удаляют файлы .ЕХЕ и .МАР,  но не
пытайтесь после этого выполнить файл .ЕХЕ.  В IDE ошибки трак-
туются как фатальные.
     - Предупреждения дают возможность  зафиксировать  опреде-
ленные условия.  Когда появляются предупреждения, файлы .ЕХЕ и
.МАР все же создаются.
     Сообщения об ошибках перечислены в лексикографическом по-
рядке.

Предупреждение
    Filename (linenum): Duplicate external name in exports
       (Дублирование external имени в разделе EXPORTS)

     Две функции экспорта,  перечисленные в разделе EXPORTS  в
файле определения модуля, задают одинаковое external имя. Нап-
ример,
     EXPORTS
       AnyProc=MyProc1
       AnyProc=MyProc2

Предупреждение
    Filename (linenum): Duplicate internal name in exports
       (Дублирование internal имени в разделе EXPORTS)

     Две функции  импорта,  перечисленные  в разделе EXPORTS в
файле определения модуля, задают одинаковое internal имя. Нап-
ример,
     EXPORTS
       AnyProc1=MyProc
       AnyProc2=MyProc

Предупреждение
    Filename (linenum): Duplicate internal name in imports
       (Дублирование internal имени в разделе IMPORTS)

     Две функции импорта,  перечисленные в разделе  IMPORTS  в
файле определения модуля, задают одинаковое internal имя. Нап-
ример,
     IMPORTS
       AnyProc=MyMod1.MyProc1
       AnyProc=MyMod2.MyProc2
или
     IMPORTS
       MyMod1.MyProc
       MyMod2.MyProc

Фатальная ошибка
              Filename(linenum): File read error
                    (Ошибка чтения файла)

     Ошибка DOS  происходит при чтении TLINK файла определения
модуля. Обычно это означает преждевременный конец файла.

Фатальная ошибка
          filename(linenum): Incompatible attribute
                   (Несовместимый атрибут)

     Эта ошибка указывает на то,  что  TLINK  встретил  несов-
местимые  атрибуты  сегмента в операторе CODE или DATA (Напри-
мер, PRELOAD и LOADONCALL не могут быть атрибутами одного сег-
мента).

Фатальная ошибка
           filename(linenum): Missing internal name
                   (Пропущено внешнее имя)

     В разделе IMPORTS файла определения модуля была ссылка на
запись,  заданную через имя модуля и порядковое  число.  Когда
запись передается с помощью порядкового значения, то определе-
нию этого импорта должно быть присвоено внешнее имя. Это внеш-
нее  имя,  которое использует Ваша программа для ссылки на им-
портируемое определение.  Синтаксис в файле определения модуля
должен быть следующим:
     <internalname>=<modulename>.<ordinal>

Фатальная ошибка
               filename(linenum): Syntax error
                   (Синтаксическая ошибка)

     TLINK нашел синтаксическую ошибку в файле определения мо-
дуля.  Filename  и  linenum говорят о том,  где произошла син-
таксическая ошибка.

Предупреждение
   symbol conflicts with module <module> in module <module>
  (symbol конфликтует с модулем <module> в модуле <module>)

     Это указывает на несовместимость  symbol  в  определении.
Это означает,  что или с этим именем встретились две виртуаль-
ные функции сс разными размерами,  или TLINK нашел одну вирту-
альную функцию и одно командное определение с одинаковыми име-
нами.

Предупреждение или ошибка
           symbol is duplicated in module <module1>
         (Имя symbol дублируется в модуле <module1>)

     Это сообщение может быть результатом конфликта между дву-
мя  именами  (public или communal),  заданными в одном модуле.
Это может случиться, если оба имена встретились в одном объек-
тном  файле.  Предупреждение  может  появиться и в том случае,
если TLINK нашел дублированные имена  в  одной  библиотеке;  в
этом случае TLINK использует первое определение.

Предупреждение или ошибка
      symbol defined in module1 is duplicated in module2
           (Имя symbol, заданное в модуле module1,
                дублируется в модуле module2)

     Это сообщение может быть результатом конфликта между дву-
мя  именами  (public или communal).  Это обычно означает,  что
указанное имя определяется в каждом из названных модулей.  Это
может случиться, если оба данных объектных файла указаны в ко-
мандной строке,  потому что  TLINK  не  знает,  какой  из  них
действителен.  Предупреждение  может появиться и в том случае,
если TLINK нашел одно из дублированных имен  в  библиотеке,  а
другое в файле .OBJ; в этом случае TLINK использует имя в объ-
ектном файле.

Фатальная ошибка
                  32-bit record encountered
               (Встретилась 32-битовая запись)

     Это сообщение появляется тогда,  когда встретился объект-
ный  файл,  содержащий 80386 32-битовые записи,  а опция /3 не
была использована. Просто запустите вновь TLINK с опцией /3.

Предупреждение
         Attempt to export non-public symbol <symbol>
       (Попытка экспортировать не-public имя <symbol>)

     Имя <symbol> было в списке раздела EXPORTS в файле  опре-
деления модуля,  но не было найдено среди public имен в редак-
тируемых файлах.  Это подразумевает или пропуск буквы в имени,
или ошибку в регистре, или процедура с этим именем не найдена.

Ошибка
              Automatic data segment exceeds 64K
        (Сегмент автоматических данных превышает 64К)

     Сумма физического сегмента DGROUP, локальной кучи и стека
превышает 64К.  Или задайте меньшие  значения  для  операторов
HEAPSIZE и STACKSIZE в файле определения модуля, или уменьшите
размер ближних данных в  DGROUP.  Файл  .МАР  покажет  размеры
составных сегментов в DGROUP.  Опция /s командной строки TLINK
может быть полезна для нахождения модуля.

Фатальная ошибка
                 Bad character in parameters
                 (плохой символ в параметре)

     В командной строке или командном файле встретился один из
следующих символов:
     " * < = > ? [ ] |
или любой управляющий символ, отличный от горизонтальной табу-
ляции, перевода строки, возврата каретки или Ctrl-Z.

Фатальная ошибка
                   Bad object file filename
               (Плохой объектный файл filename)

     Встретился плохо сформированный объектный файл.  Наиболее
частой  причиной  этого  может быть указание исходного файла в
качестве объектного или указание объектного файла, который был
построен не до конца. Это может произойти и в том случае, если
машина висла во время компиляции или компилятор не удалял объ-
ектный выходной файл при нажатии Ctrl-Break.

Фатальная ошибка
            Bad version number in parameter block
           (Плохой номер версии в блоке параметров)

     Эта ошибка указывает на внутреннюю несовместимость в IDE.
Если это произошло, выйдите и перезагрузите IDE. Эта ошибка не
произойдет в автономной версии.

Фатальная ошибка
  Cannot generate COM file: data below initial CS:IP defined
 (Не могу генерировать файл СОМ: данные выходят за исходный CS:IP)

     Эта ошибка  происходит из-за попытки генерации данных или
кода за начальным адресом (обычно 100) файла .СОМ. Убедитесь в
том, что начальный адрес установлен в 100 с помощью инструкции
(ORG 100H).  Это сообщение об ошибке не  может  встретиться  в
программах, написанных на языках высокого уровня. Если это все
же произошло, обеспечьте редактирование связей корректных объ-
ектных модулей запуска (С0).

Фатальная ошибка
Cannot generate COM file: invalid initial entry point address
  (Не могу генерировать файл СОМ: недействительный исходный адрес
                         точки входа)

     Вы используете опцию /t или /Tdc, а начальный адрес прог-
раммы не равен 100H, что требуется при работе с файлами .СОМ.

Фатальная ошибка
        Cannot generate COM file: program exceeds 64 K
  (Не могу генерировать файл СОМ: программа превышает 64 К)

     Вы используете  опцию /t или /Tdc,  но общий размер прог-
раммы превышает допустимый предел для файла .СОМ.

Фатальная ошибка
 Cannot generate COM file: segment-relocatable items present
               (Не могу генерировать файл СОМ:
        присутствуют сегментно-переносимые элементы )

     Вы используете  опцию  /t или /Tdc,  а программа содержит
сегментно-относительные настройки, которые не разрешены в фай-
лах
.СОМ.

Фатальная ошибка
     Cannot generate  COM  file:  stack  segment  present
 (Не  могу генерировать файл СОМ: присутствует сегмент стека)

     Вы используете опцию /t или /Tdc,  а программа  объявляет
сегмент стека, который недопустим с файлами .СОМ.

Ошибка
                  Common segment exceeds 64K
                (Общий сегмент превышает 64К)

     Программа имеет  более  64К  ближних неинициализированных
данных.  Попытайтесь объявить  некоторые  неинициализированные
данные как дальние.

Предупреждение
           Debug info switch ignored for .COM files
(Переключатель отладочной информации игнорируется для файлов .СОМ)

     Borland C++  не  включает  отладочную информацию для .СОМ
файлов.

Фатальная ошибка
                    DOS error, ax = number
                   (Ошибка DOS, ах = число)

     Это происходит тогда,  когда вызов DOS возвращает  неожи-
данную ошибку.  Печатаемое значение ах является результирующим
кодом ошибки.  Оно может указывать на внешнюю ошибку TLINK или
ошибку DOS. Вызовами DOS, которые делает TLINK, где может про-
изойти эта ошибка,  являются только чтение,  запись,  поиск  и
закрытие.

Предупреждение
             Duplicate ordinal number in exports
        (Дублирование порядкового значения в EXPORTS)

     Это предупреждение появляется тогда, когда TLINK встретил
два экспорта с  одинаковыми  порядковыми  значениями.  Сначала
проверьте файл определения модуля,  чтобы убедиться в том, что
нет дублированных  порядковых  значений,  заданных  в  разделе
EXPORTS. Если там все в порядке, тогда Вы редактируете модули,
задающие экспорты посредством порядковых значений,  и при этом
происходит две вещи: или две записи экспорта определяют одина-
ковые порядковые значения,  или раздел экспортов в файле опре-
деления  модуля дублирует порядковое значение в записи экспор-
та.
     Записи экспорта  (EXPDEF) являются записями комментариев,
которые находятся в объектных файлах и библиотеках  и  задают,
какие  конкретные переменные будут экспортироваться.  Необяза-
тельно,  эти записи могут  задавать  порядковые  значения  при
экспортировании посредством порядковых значений.

Ошибка
  Fixup overflow at segment:xxxxh, target = segment:xxxh in
                       module <module>
  Fixup overflow  at  segment:xxxxh,  target  =  symbol  in
                       module <module>
           (Переполнение настройки в модуле module
   в сегменте segment:xxxh, target = сегмент или имя:xxxh).

     Это указывает  на  некорректные  ссылки данных или кода в
объектном файле,  который TLINK должен настроить во время  ре-
дактирования.
     Это сообщение чаще всего  имеет  причиной  несоответствие
моделей памяти. Наиболее вероятной причиной служит вызов функ-
ции near в другом сегменте кода.  Эта ошибка  может  произойти
из-за того,  что Вы генерируете вызов near к переменным данных
или ссылку данных на функцию.  В любом  случае  имя  target  в
сообщении  об ошибке - это переменная или функция,  на которую
ссылаются. Ссылка находится в названном модуле, ищите в исход-
ном файле этого модуля неправильную ссылку.
     В программе языка Ассемблер ошибка переполнения настройки
часто происходит в том случае,  если Вы объявили внешнюю пере-
менную внутри определения сегмента,  а фактически эта перемен-
ная находится в другом сегменте.
     Если эта техника не поможет идентифицировать причину неу-
дачи или Вы программируете на языке Ассемблер или другом языке
высокого уровня,  отличного от Borland C++, то возможны другие
причины для этой ошибки.  Даже в Borland C++ это сообщение мо-
жет генерироваться вследствие того,  что Вы используете  имена
сегментов и групп,  отличные от значений по умолчанию для дан-
ной модели памяти.

Фатальная ошибка
                       Group exceed 64K
             (Размер группы group превышает 64К)

     Это сообщение появляется в том случае, если группа превы-
шает 64К, когда комбинируются сегменты группы.

Предупреждение
              Group 1 overlaps group 2 in module
 (Группа group 1 перекрывает группу group 2 в модуле module)

     Это означает,  что  TLINK встретил вложенные группы.  Это
предупреждение появляется  только  тогда,  когда  используются
оверлеи или идет редактирование программы Windows.

Фатальная ошибка
    Illegal group difinition: <group> in module <modele1>
(Неправильное определение группы: <group> в модуле <modele1>)

     Эта ошибка  происходит  из-за  уродливой  записи GRPDEF в
файле .OBJ.  Последняя может происходить из-за встроенных фай-
лов .OBJ или ошибки в трансляторе, используемого для генерации
файла .OBJ.  Если это происходит в  файле,  созданным  Borland
C++, перекомпилируйте этот файл.

Фатальная ошибка
               Internal linker error errorcode
           (Внутренняя ошибка редактора errorcode)

     Эта ошибка встречается во внутренней логике TLINK. Она не
должна встречаться на практике.

Предупреждение
                Invalid entry at segment:xxxxh
              (Неверная запись в сегменте xxxxh)

     Редкая внутренняя ошибка TLINK,  перечисленная здесь  для
полноты.  Эта ошибка указывает, что была пропущена необходимая
запись из таблицы записей выполнимого файла Windows.

Ошибка
                  Invalid entry point offset
               (Неверное смещение точки входа)

     Это сообщение появляется только при редактировании связей
модулей с 32-битными записями.  Это означает, что смещение на-
чальной точки входа программы превышает предел DOS в 64К.

Фатальная ошибка
                 Invalid initial stack offset
             (Неверное начальное смещение стека)

     Это сообщение появляется только при редактировании связей
модулей  с  32-битными записями.  Это означает,  что начальное
значение указателя стека превышает допустимый предел DOS в  64
К.

Фатальная ошибка
       Invalid limit specified for code segment packing
    (Неверный предел, заданный для упаковки сегмента кода)

     Эта ошибка происходит, если Вы используете опцию /Р и за-
даете предельный размер,  выходящий из  диапазона.  Правильный
предельный  размер находится в диапазоне от 1 до 65536 байтов;
по умолчанию 4096 байт.

Фатальная ошибка
             Invalid segment definition in module
       (Неверное определение сегмента в модуле module)

     Это сообщение обычно появляется только в том случае, если
компилятор создал плохой объектный файл.  Если это произошло в
файле, созданном с Borland C++, перекомпилируйте его.

Ошибка
         Invalid size specified for segment alignment
   (Неверное значение, заданное для выравнивания сегмента)

     Эта ошибка происходит в том случае, если для опции /А за-
дано неверное значение.  Размер, заданный с помощью /А, должен
быть целым числом, кратным двум и меньшим 64К. Обычными значе-
ниями являются 16 и 512.  Эта ошибка происходит только при ре-
дактировании для Windows.

Предупреждение
                  No automatic data segment
            (Нет автоматического сегмента данных)

     Не найдена группа с именем DGROUP. Поскольку файлы иници-
ализации Borland C++ определяют DGROUP,  Вы увидите эту ошибку
только в том случае, если Вы не редактировали с файлом инициа-
лизации,  а  Ваша  программа  не  определила  DGROUP.  Windows
использует  DGROUP  для  поиска  локального  сегмента  данных.
DGROUP требуется для приложений Windows (но не DLL), если DATA
NONE не задано в файле определения модуля.

Предупреждение
     No module definition file specified: using defaults
(Не задан файл определения модуля: используется по умолчанию)

     Был вызван TLINK с одной из опций Windows, а файл опреде-
ления модуля не был задан.

Предупреждение
             No program starting address defined
             (Не задан исходный адрес программы)

     Это предупреждение означает, что нет модуля, определяюще-
го исходный адрес запуска программы. Чаще всего это происходит
из-за того, что Вы забыли отредактировать в модуле инициализа-
ции С0х.OBJ.  Это предупреждение не должно появляться при  ре-
дактировании Windows DLL.

Предупреждение
                           No stack
                         (Нет стека)

     Это предупреждение появляется тогда,  когда не задан сег-
мент стека в каком-то из объектных файлов или в какой-то  биб-
лиотеке, включаемых в редактирование связей. Это обычное сооб-
щение для tiny модели памяти в  Borland  C++,  или  для  любой
прикладной  программы,  преобразуемой в файл .СОМ.  Для других
программ (кроме DLL) это указывает на наличие ошибки.
     Примечание. Если программа Borland C++ выдает такое сооб-
щение для любой другой,  но не tiny модели памяти,  убедитесь,
что Вы используете корректные объектные файлы запуска С0х.

Предупреждение
         No stub for fixup at segment:xxxxh in module
   (Нет заглушки для настройки в сегменте: xxxxh в модуле)

     Эта ошибка встречается тогда, когда целью настройки явля-
ется оверлейный сегмент, а сегмент заглушки не найден для это-
го сегмента.  Обычно это является следствием того,  что имя не
объявлено как public в оверлее, а на него есть ссылка из этого
же модуля.

Фатальная ошибка
                      Not enough memory
                    (Недостаточно памяти)

     Не хватает памяти для выполнения TLINK. Попытайтесь изба-
виться от загруженных в настоящий момент  времени  резидентных
программ  и  уменьшить  размер активного диска RAM.  Затем за-
пустите TLINK снова.

Фатальная ошибка
                        Out of memory
               (Не хватает оперативной памяти)

     TLINK при выполнении вышел за пределы динамически распре-
деленной  памяти,  необходимой в процессе редактирования.  Эта
ошибка является вместилищем самых разнообразных причин при за-
пуске с пределом использования памяти в TLINK.  Это обычно оз-
начает, что слишком много модулей, групп, сегментов и т.д. бы-
ло определено объектными файлами, редактирующимися вместе.

Предупреждение
      Overlays generated and no overlay manager included
    (Оверлеи генерируются, а менеджер оверлеев не включен)

     Это предупреждение   появляется  тогда,  когда  создаются
оверлеи, а имя _ _OVRTRAP_ _ не определено ни в одном редакти-
руемом объектном модуле или библиотеке. Стандартная библиотека
оверлеев (OVERLAY.LIB) задает это имя.

Предупреждение
           Overlays ignored in new executable image
       (Оверлеи игнорируются в новом выполнимом образе)

     Ошибка случается  при  попытке  редактировать   программу
Windows с включенной опцией /о.  Выполнимый код Windows не мо-
жет быть оверлейным,  хотя с  отбрасываемыми  сегментами  кода
можно достигнуть того же эффекта.

Ошибка
       Program entry point may not reside in an overlay
    (Точка входа программы не может находиться в оверлее)

     Хотя почти  все  приложения  могут  быть оверлейными,  но
исходный адрес запуска не  может  находиться  в  оверлее.  Это
сообщение  обычно появляется вследствие задания опции /о перед
модулем запуска (С0х). С0х содержит исходную точку входа прог-
раммы,  которая не может быть оверлейной.  Чтобы зафиксировать
это, просто задайте опцию /о после модуля запуска.

Фатальная ошибка
            Relocation item exeeds 1 MB DOS limit
      (Элемент перемещения превышает предел DOS в 1 МВ)

     Формат выполнимого файла DOS не поддерживает элементы пе-
ремещения для размещения, превышающего 1 МВ. Хотя DOS не может
ЗАГРУЗИТЬ образ, но расширитель DOS может это сделать, и таким
образом TLINK поддерживает генерацию образов больших,  чем мо-
жет загрузить DOS.  Даже  если  образ  загружается  с  помощью
расширителя   DOS,  формат  выполнимого  файла  DOS  ограничен
описанными элементами перемещения в первом 1 МВ образа.

Фатальная ошибка
             Relocation offset overflow in module
     (Переполнение смещения перемещения в модуле module)

     Это сообщение появляется только при редактировании связей
модулей с 32-битными записями и указывает на то,  что смещение
перемещения (настройка сегмента)  больше  допустимого  предела
DOS в 64К.

Фатальная ошибка
                  Relocation table overflow
              (Таблица перемещений переполнена)

     Редактируемый файл содержит больше базовых настроек,  чем
может хранить стандартная  таблица  перемещений  DOS  (базовые
настройки  создаются  вероятней всего при вызове дальних функ-
ций).  Эта ошибка происходит только для модулей  с  32-битными
записями.

Фатальная ошибка
                     Segment exceeds 64K
                   (Сегмент превышает 64К)

     Это сообщение появляется в случае,  если для данного сег-
мента данных или кода определено слишком много  данных,  когда
комбинируются  сегменты  с  одинаковыми  именами  в  различных
исходных файлах.

Предупреждение
        Segment is in two groups: group 1 and group 2
  (Сегмент segment находится в двух группах: группе 1 и группе 2)

     Редактор связей нашел конфликтующие заявки от  двух  наз-
ванных  групп.  Обычно  это  происходит только в программах на
языке Ассемблер.  Это означает,  что два модуля назначили сег-
мент двум различным группам.

Фатальная ошибка
              Segment alignment factor too small
       (Коэффициент выравнивания сегмента слишком мал)

     Эта ошибка происходит в том случае,  если коэффициент вы-
равнивания сегмента (установленный с помощью опции /А) слишком
мал,  чтобы представлять адреса файлов сегментов в файле .ЕХЕ.
Эта ошибка случается только при редактировании для Windows.

Фатальная ошибка
             Segment too large for segment table
        (Сегмент слишком велик для таблицы сегментов)

     На практике эта ошибка никогда не происходит. Она означа-
ет,  что  сегмент  превышает  64К  и  его размер не может быть
представлен в выполнимом файле.  Эта  ошибка  может  произойти
только при редактировании для Windows; формат выполнимого фай-
ла,  используемый для Windows, не поддерживает сегменты больше
64К.

Фатальная ошибка
                   Stub program exceeds 64K
              (Программа заглушки превышает 64К)

     Эта ошибка происходит,  если программа заглушки DOS,  на-
писанная для приложения Windows, превышает 64К. Программы заг-
лушки определяются через оператор STUB файла определения моду-
ля. TLINK поддерживает программы заглушки только до 64К.

Фатальная ошибка
                     Table limit exceeded
             (Превышен допустимый предел таблицы)

     Это сообщение появляется вследствие переполнения внутрен-
них таблиц редактора связей. Обычно это означает, что редакти-
руемые программы превысили способности  редактора  связей  для
external или public имен и для определений логического сегмен-
та. Каждый образец отдельного имени сегмента в объектном файле
рассматривается  как  логический  сегмент;  если два объектных
файла определяют этот сегмент,  то в результате получится  два
логических сегмента.

Ошибка
              Too many error or warning messages
    (Слишком много сообщений об ошибке или предупреждений)

     В командной  строке  или  в  IDE  можно установить предел
числа ошибок или предупреждений, которые могут произойти перед
остановкой  редактирования.  Эта  ошибка указывает,  что TLINK
достиг этого предела.

Фатальная ошибка
                 Unable to open file filename
              (Невозможно открыть файл filename)

     Это происходит в том случае,  если названный файл не  су-
ществует или его имя содержит орфографические ошибки.

Ошибка
                  Undefined symbol in module
         (Неопределенное имя symbol в модуле module)

     На это  имя есть ссылка в данном модуле,  но оно нигде не
определено во множестве объектных файлов и библиотек, включае-
мых в редактирование.
     Убедитесь, что имя написано правильно.  Обычно эту ошибку
можно увидеть в TLINK для имен Borland C++,  если нет правиль-
ного соответствия для объявлений имен типа pascal  и  cdecl  в
различных  исходных  файлах,  или если опущено имя файла .OBJ,
необходимое Вашей программе.  Если Вы редактируете код  С++  с
модулями С, то возможно, Вы забыли добавить к внешним объявле-
ниям С extern "C"{...}.

Фатальная ошибка
                        Unknown option
                     (Неизвестная опция)

     В командной строке или командном  файле  встретился  слэш
(/),  дефис  (-) или символ переключателя DOS без следующей за
ними допустимой опции. Это может означать, что Вы использовали
неправильный регистр при задании опции.

Ошибка
                          User break
                (Пользовательское прерывание)

     TLINK прервал    редактирование    при   нажатии   клавиш
Ctrl-Break.

Фатальная ошибка
                   Write failed, disk full?
               (Не могу записать, диск полон?)

     Это происходит в случае, если TLINK не может записать все
данные при попытке записи.  Причиной этого обычно бывает пере-
полнение диска.
