     delay
──────────────────────────────────────────────────────────────
Функция        Приостанавливает выполнение  на заданный интер-
               вал (в миллисекундах).

Синтаксис      #include<dos.h>
               void delay(unsigned milliseconds);

Прототип в     dos.h

Примечания     Приостанавливает выполнение  текущей  программы
               на число  миллисекунд,  указанное  в  аргументе
               milliseconds.  Теперь  более  нет необходимости
               производить калибрующий вызов для этой функции.
               Она работает с точностью до миллисекунд.

Значение       Нет.

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми. Она не совместима с Windows.

См. также      nosound, sleep, sound

Пример         /* Издает звук частотой 440 гц
                  в течение 500 миллисекунд  */
               #include <dos.h>

               int main(void)
               {
                  sound(440);
                  delay(500);
                  nosound();
                  return 0;
               }

     delline
──────────────────────────────────────────────────────────────
Функция        Удаляет строку в текстовом окне.

Синтаксис      #include<conio.h>
               void delline(void);

Прототип в     conio.h

Примечания     Удаляет строку,  в  которой  находится курсор и
               сдвигает все строки,  находящиеся ниже нее,  на
               строку  вверх.  Работает с текущим активным ок-
               ном.

Значение       Нет.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Она не совместима с Windows.

См. также      clreol, clrscr, insline, window

Пример         #include <conio.h>

               int main(void)
               {
                  clrscr();
                  cprintf("The function DELLINE deletes \
                          the line containing the\r\n");
                  cprintf("cursor and moves all lines \
                          below it one line up.\r\n");
                  cprintf("DELLINE operates within the \
                          currently active text\r\n");
                  cprintf("window.  Press any key to \
                          continue . . .");
                  /* Перемещает курсор в первую
                     колонку второй строки */
                  gotoxy(1,2);
                  getch();
                  delline();
                  getch();
                  return 0;
               }

     detectgraph
──────────────────────────────────────────────────────────────
Функция        Опрашивает аппаратуру  и  выбирает  графический
               драйвер и режим.

Синтаксис      #include<graphics.h>
               void far detectgraph(int far *graphdriver,
               int far *graphmode);

Прототип в     graphics.h

Примечания     Определяет графический адаптер Вашего компьюте-
               ра и выбирает графический режим, обеспечивающий
               наивысшее разрешение.  Если графический адаптер
               не обнаружен,  параметр *graphdriver устанавли-
               вается в grNotDetected (-2) и graphresult возв-
               ращает grNotDetected (-2).
               *graphdriver - целое, определяющее используемый
               графический драйвер.  Вы можете задать его зна-
               чение,  используя  константу перечислимого типа
               graphics_drivers, определенного в graphics.h, и
               приведенного      в      следующей     таблице:
               ───────────────────────────────────────────────
Таблица 2.1.    Константы типа      Числовое
Константы       graphics_drivers    значение
detectgraph.   ───────────────────────────────────────────────
                DETECT              0 (запрос автообнаружения)
                CGA                 1
                MCGA                2
                EGA                 3
                EGA64               4
                EGAMONO             5
                IBM8514             6
                HERCMONO            7
                ATT400              8
                VGA                 9
                PC3270             10
               ───────────────────────────────────────────────
               *graphmode - целое, определяющее начальный гра-
               фический  режим  (если  *graphdriver  не  равно
               DETECT:  в этом случае *graphmode  устанавлива-
               ется в значение, соответствующее наивысшему до-
               пустимому для  графического  драйвера  разреше-
               нию).  Вы  можете  задать  значение *graphmode,
               используя    константу    перечислимого    типа
               graphics_modes,  определенного в graphics.h,  и
               приведенного в следующей таблице:

Таблица 2.2.        Информация по графическим драйверам.
──────────────────────────────────────────────────────────────
Графи-      Имя         Зна-    Разрешение   Палитра     Граф.
ческий      конcтанты   чение   (Столбцов*               стра-
драйвер                          *строк)                 ниц
──────────────────────────────────────────────────────────────
CGA         CGAC0         0     320x200      C0           1
            CGAC1         1     320x200      С1           1
            CGAC2         2     320x200      С2           1
            CGAC3         3     320x200      C3           1
            CGAHI         4     640x200      2 цвета      1
MCGA        MCGA0         0     320х200      C0           1
            MCGA1         1     320х200      C1           1
            MCGA2         2     320х200      C2           1
            MCGA3         3     320х200      C3           1
            MCGAMED       4     640х200      2 цвета      1
            MCGAHI        5     640х480      2 цвета      1
EGA         EGALO         0     640х200      16 цветов    4
            EGAHI         1     640х350      16 цветов    2
EGA64       EGA64LO       0     640х200      16 цветов    1
            EGA64HI       1     640х350      4 цвета      1
EGA-MONO    EGAMONOHI     3     640х350      2 цвета      1*
            EGAMONOHI     3     640х350      2 цвета      2**
HERC        HERCMONOHI    0     720х348      2 цвета      2
ATT400      ATT400C0      0     320х200      C0           1
            ATT400C1      1     320х200      C1           1
            ATT400C2      2     320х200      C2           1
            ATT400C3      3     320х200      C3           1
            ATT400MED     4     640х200      2 цвета      1
            ATT400HI      5     640х400      2 цвета      1
VGA         VGALO         0     640х200      16 цветов    2
            VGAMED        1     640х350      16 цветов    2
            VGAHI         2     640х480      16 цветов    1
PC3270      PC3270HI      0     720х350      2 цвета      1
IBM8514     IBM8514HI     1     1024х768     256 цветов
            IBM8514LO     0     640х480      256 цветов
──────────────────────────────────────────────────────────────
               * 64К видеопамяти на плате EGAMONO
               ** 256К видеопамяти на плате EGAMONO
               Замечание. Основная  причина для непосредствен-
               ного вызова detectgraph - необходимость устано-
               вить графический режим, отличный от того, кото-
               рый detectgraph рекомендует для initgraph.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      graphresult, initgraph

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               /* имена поддерживаемых адаптеров */
               char *dname[] = { "requests detection",
                      "a CGA", "an MCGA", "an EGA",
                      "a 64K EGA", "a monochrome EGA",
                      "an IBM 8514",
                      "a Hercules monochrome",
                      "an AT&T 6300 PC", "a VGA",
                      "an IBM 3270 PC" };
               int main(void)
               {
              /* сюда возвращается информация по аппаратуре */
                  int gdriver, gmode, errorcode;
              /*определение доступного графического адаптера*/
                  detectgraph(&gdriver, &gmode);
                  /* чтение результата вызова detectgraph */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1);  /* завершение с кодом ошибки */
                  }
                  /* отображение полученной информации */
                  clrscr();
                  printf("You have %s video display card.\n",
                          dname[gdriver]);
                  printf("Press any key to halt:");
                  getch();
                  return 0;
               }

     difftime
──────────────────────────────────────────────────────────────
Функция        Вычисляет разницу  во времени между двумя собы-
               тиями.

Синтаксис      #include<time.h>
               double difftime(time_t time2, time_t time1);

Прототип в     time.h

Примечания     Вычисляет время в секундах,  прошедшее от time1
               до time2.

Значение       Типа double.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      asctime, ctime,   daylight(глобальная  перемен-
               ная),  gmtime,  localtime,  time, timezone(гло-
               бальная переменная)

Пример         #include <time.h>
               #include <stdio.h>
               #include <dos.h>
               #include <conio.h>

               int main(void)
               {
                  time_t first, second;
                  clrscr();
                  first = time(NULL);  /* системное время */
                  delay(2000);         /* ожидает 2 секунды */
                  second = time(NULL);
                  printf("The difference is: %f seconds\n",
                          difftime(second,first));
                  getch();
                  return 0;
               }

     disable
──────────────────────────────────────────────────────────────
Функция        Запрещает прерывания.

Синтаксис      #include<dos.h>
               void disable(void);

Прототип в     dos.h

Примечания     Предназначена для обеспечения гибкости при  уп-
               равлении    аппаратными   прерываниями.   Макро
               disable запрещает прерывания. Разрешаются толь-
               ко NMI (немаскируемые прерывания).

Значение       Нет.

Переносимость  Это макро доступно только для процессоров архи-
               тектуры 80x86.

См. также      enable, getvect

Пример         /*** Примечание:
               Это пользовательская программа обработки преры-
               вания.  Вы не сможете откомпилировать эту прог-
               рамму с включенным Test Stack Overflow и  полу-
               чить  выполнимый  файл,  который будет работать
               корректно. */

               #include <stdio.h>
               #include <dos.h>
               #include <conio.h>

               #define INTR 0X1C    /* прерывание таймера */

               void interrupt ( *oldhandler)(void);
               int count=0;
               void interrupt handler(void)
               {
               /* запрещение    прерываний   на   время
                  обработки прерывания */
                  disable();
               /* приращение глобального счетчика */
                  count++;
               /* разрешение прерываний в конце обработки */
                  enable();
               /* вызов старого обработчика прерывания */
                  oldhandler();
               }
               int main(void)
               {
               /* сохранение старого вектора прерывания */
                  oldhandler = getvect(INTR);
               /* установка нового обработчика прерывания */
                  setvect(INTR, handler);
               /* цикл, пока счетчик меньше 20 */
                  while (count < 20)
                     printf("count is %d\n",count);
               /* восстановление старого обработчика */
                  setvect(INTR, oldhandler);
                  return 0;
               }

     div
──────────────────────────────────────────────────────────────
Функция        Делит целое на целое, возвращая частное и оста-
               ток.

Синтаксис      #include<stdlib.h>
               div_t div(int numer, int denom);

Прототип в     stdlib.h

Примечания     Делит целое на целое, возвращая частное и оста-
               ток как тип div_t.  numer и denom - числитель и
               знаменатель соответственно.  div_t - это струк-
               тура, определенная (с typedef) в stdlib как:
                  typedef struct {
                    int quot;    /* частное */
                    int rem;     /* остаток */
                  } div_t;

Значение       Структура с    элементами    quot(частное)    и
               rem(остаток).

Переносимость  Эта функция совместима с ANSI C.

См. также      idiv

Пример         #include <stdlib.h>
               #include <stdio.h>

               div_t x;
               int main(void)
               {
                  x = div(10,3);
                  printf("10 div 3 = %d remainder %d\n",
                         x.quot, x.rem);
                  return 0;
               }

               Вывод программы

               10 div 3 = 3 remainder 1

     dosexterr
──────────────────────────────────────────────────────────────
Функция        Выдает расширенную информацию об ошибке DOS.

Синтаксис      #include<dos.h>
               int dosexterr(struct DOSERROR *eblkp);

Прототип в     dos.h

Примечания
               Заполняет структуру    DOSERROR,    указываемую
               eblkp,  расширенной информацией об ошибке после
               неудачного вызова функции DOS.  Структура опре-
               делена как:
               struct DOSERROR {
                 int de_exterror;/* расширенный код ошибки */
                 char de_class;  /* класс ошибки */
                 char de_action; /* действие */
                 char de_locus;  /* местоположение ошибки */
               };
               Значения структуры получаются посредством вызо-
               ва  функции DOS 0x59.  Значение de_exterror = 0
               указывает, что предшествующий вызов функции DOS
               был без ошибки.

Значение       de_exterror

Переносимость  Эта функция доступна только в DOS  версии  3.0.
               Она не работает в более ранних версиях.

Пример         #include <stdio.h>
               #include <dos.h>

               int main(void)
               {
                 FILE *fp;
                 struct DOSERROR info;
                 fp = fopen("perror.dat","r");
                 if (!fp) perror("Unable to open file for
                                 reading");
                 dosexterr(&info);
                 printf("Extended DOS error information:\n");
                 printf("Extended error: %d\n",info.exterror);
                 printf("           Class: %x\n",info.class);
                 printf("          Action: %x\n",info.action);
                 printf("      Error Locus: %x\n",info.locus);
                 return 0;
               }

     dostounix
──────────────────────────────────────────────────────────────
Функция        Преобразует дату и время в формат UNIX.

Синтаксис      #include<dos.h>
               long dostounix(struct date *d,
                              struct dostime *t);

Прототип в     dos.h

Примечания     Преобразует дату и время из формата,  в котором
               они возвращаются из getdate и gettime, в формат
               UNIX.  d указывает на структуру date,  а t - на
               структуру dostime, содержащие корректную инфор-
               мацию DOS о дате и времени.

Значение       Дата и время в формате  UNIX:  число  секунд  с
               00:00:00 на 1 января 1970 года (GMT).

Переносимость  Эта функция доступна только в DOS.

См. также      unixtodos

Пример         #include <time.h>
               #include <stddef.h>
               #include <dos.h>
               #include <stdio.h>

               int main(void)
               {
                  time_t t;
                  struct time d_time;
                  struct date d_date;
                  struct tm *local;
                  getdate(&d_date);
                  gettime(&d_time);
                  t = dostounix(&d_date, &d_time);
                  local = localtime(&t);
                  printf("Time and Date:%s\n",asctime(local));
                  return 0;
               }

     drawpoly
──────────────────────────────────────────────────────────────
Функция        Рисует ломаную линию.

Синтаксис      #include<graphics.h>
               void far drawpoly(int numpoints,
                                 int far *polypoints);

Прототип в     graphics.h

Примечания     Рисует ломаную  линию   из   numpoints   точек,
               используя текущий тип и цвет линии. *polypoints
               указывает на последовательность из (numpoints *
               2)  целых.  Каждая пара дает x- и y- координаты
               точек ломаной.
         !!!   Для рисования замкнутой фигуры с n вершинами Вы
               должны задать n + 1 пару координат, где n-я па-
               ра совпадает с 0-ой.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      fillpoly, floodfill, graphresult, setwritemode

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {

                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int maxx, maxy;
                  /* наш массив для ломаной */
                  int poly[10];
              /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1);  /* завершение с кодом ошибки */
                  }
                  maxx = getmaxx();
                  maxy = getmaxy();
                  poly[0] = 20;         /* первая вершина */
                  poly[1] = maxy / 2;
                  poly[2] = maxx - 20;  /* вторая вершина */
                  poly[3] = 20;
                  poly[4] = maxx - 50;  /* третья вершина */
                  poly[5] = maxy - 20;
                  poly[6] = maxx / 2;  /* четвертая вершина */
                  poly[7] = maxy / 2;
                  poly[8]=poly[0];/* drawpoly не замыкает   */
                  poly[9]=poly[1];/* ломаную автоматически!*/
                  drawpoly(5, poly);/* рисование ломаной */
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     dup
──────────────────────────────────────────────────────────────
Функция        Создает копию обработчика файла.

Синтаксис      #include<io.h>
               int dup(int handle);

Прототип в     io.h

Примечания     Создает новый обработчик файла,  который совпа-
               дает с оригиналом по следующим характеристикам:
               - имеет тот же файл и устройство
               - имеет  тот же указатель файла (изменение ука-
               зателя  файла  одним  из   обработчиков   соот-
               ветственно изменяет указатель файла в другом)
               - имеет тот же режим доступа
               handle - это номер обработчика,  полученный при
               вызове _creat,  creat,  _open,  open,  dup  или
               dup2.

Значение       При успешном завершении возвращается номер  но-
               вого обработчика;  в противном случае возвраща-
               ется -1. При ошибке глобальная переменная errno
               устанавливается в одно из следующих значений:
                  EMFILE  Слишком много открытых файлов
                  EBADF   Неверный номер файла

Переносимость  Эта функция доступна во всех системах UNIX.

См. также      _close, close,    _creat,    creat,   creatnew,
               creattemp, dup2, fopen, _open, open

Пример         #include <string.h>
               #include <stdio.h>
               #include <conio.h>
               #include <io.h>
               void flush(FILE *stream);
               int main(void)
               {  FILE *fp;
                  char msg[] = "This is a test";
                  /* создает файл */
                  fp = fopen("DUMMY.FIL", "w");
                  if (fp) {
                      /* пишет данные в файл */
                      fwrite(msg, strlen(msg), 1, fp);
                      clrscr();
                      printf("Press any key to
                              flush DUMMY.FIL:");
                      getch();
                      /* сбрасывает данные в DUMMY.FIL
                         без его закрытия */
                      flush(fp);
                      printf("\nFile was flushed,
                              Press any key to quit:");
                      getch();
                  }
                  else {
                      prontf("Error opening file!\n");
                  }
                  return 0;
               }
               void flush(FILE *stream)
               {  int duphandle;
                  /* сбрасывает внутренний буфер BC */
                  fflush(stream);
                  /* создает копию обработчика файла */
                  duphandle = dup(fileno(stream));
                  /* закрывает обработчик-копию,
                     чтобы сбросить буфер DOS */
                  close(duphandle);
               }

     dup2
──────────────────────────────────────────────────────────────
Функция        Копирует обработчик файла(oldhandle) в  сущест-
               вующий обработчик файла(newhandle).

Синтаксис      #include<io.h>
               int dup2(int oldhandle, int newhandle);

Прототип в     io.h

Примечания     Создает новый обработчик файла,  который совпа-
               дает с оригиналом по следующим характеристикам:
               - имеет тот же файл и устройство
               - имеет тот же указатель файла (изменение  ука-
               зателя   файла   одним  из  обработчиков  соот-
               ветственно изменяет указатель файла в другом)
               - имеет тот же режим доступа
               Новый обработчик  файла  создается  с   номером
               newhandle.  Если  файл,  связанный с newhandle,
               открыт во время вызова dup2, этот файл закрыва-
               ется.  newhandle и oldhandle - это номера обра-
               ботчиков,  полученные при вызове  creat,  open,
               dup или dup2.

Значение       При успешном завершении возвращается 0;  в про-
               тивном случае возвращается -1.  При ошибке гло-
               бальная переменная errno устанавливается в одно
               из следующих значений:
                  EMFILE  Слишком много открытых файлов
                  EBADF   Неверный номер файла

Переносимость  Эта функция доступна в некоторых системах UNIX,
               но не в System III.

См. также      _close, close,   _creat,    creat,    creatnew,
               creattemp, dup, fopen, _open, open

Пример         #include <sys\stat.h>
               #include <string.h>
               #include <fcntl.h>
               #include <io.h>
               #include <stdio.h>

               #define STDOUT 1

               int main(void)
               {
                  int fptr, oldstdout;
                  char msg[] = "This is a test";
                  /* создает файл */
                  fptr = open("DUMMY.FIL", O_CREAT | O_RDWR,
                     S_IREAD | S_IWRITE);
                  if (fptr) {
                      /* дублирует обработчик
                         для стандартного вывода */
                      oldstdout = dup(STDOUT);
                      /* перенаправляет стандартный вывод
                         в DUMMY.FIL, копируя обработчик
                         этого файла в обработчик для
                         стандартного вывода */
                      dup2(fptr, STDOUT);
                      /* закрывает обработчик для DUMMY.FIL */
                      close(fptr);
                      /* вывод перенаправлен в DUMMY.FIL */
                      write(STDOUT, msg, strlen(msg));
               /* восстанавливает оригинальный обработчик  для
               стандартного вывода */
                      dup2(oldstdout, STDOUT);
                      /* закрывает дубликат обработчика
                       для STDOUT */
                      close(oldstdout);
                  }
                  else {
                      prontf("Error opening file\n");
                  }
                  return 0;
               }

     ecvt
──────────────────────────────────────────────────────────────
Функция        Преобразует число с плавающей точкой в строку.

Синтаксис      #include<stdlib.h>
               char *ecvt(double value, int ndig,
                          int *dec, int *sign);

Прототип в     stdlib.h

Примечания     Преобразует value в  завершенную  нуль-символом
               строку, состоящую из ndig цифр и начинающуюся с
               самой левой значащей цифры, и возвращает указа-
               тель  на  эту строку.  Позиция десятичной точки
               относительно начала  строки  помещается  в  dec
               (отрицательное значение dec означает, что деся-
               тичная  точка  располагается  слева  от  начала
               возвращаемой строки).  Сама возвращаемая строка
               не содержит десятичной точки.  Если знак  value
               отрицательный - слово, указываемое sign, отлич-
               но от нуля; в противном случае оно = 0. Младшая
               значащая цифра округляется.

Значение       Возвращаемое значение  указывает на статическую
               строку, которая перезаписывается при каждом вы-
               зове ecvt.

Переносимость  Эта функция  доступна  в системах UNIX.  Она не
               содержится в ANSI C и не рекомендуется для  пе-
               реносимых программ.

См. также      fcvt, gcvt, sprintf

Пример         #include <stdlib.h>
               #include <stdio.h>

               int main(void)
               {
                  char *string;
                  double value;
                  int dec, sign;
                  int ndig = 10;
                  value = 9.876;
                  string = ecvt(value, ndig, &dec, &sign);
                  printf("string = %s      dec = %d \
                         sign = %d\n", string, dec, sign);
                  value = -123.45;
                  ndig= 15;
                  string = ecvt(value,ndig,&dec,&sign);
                  printf("string = %s dec = %d sign = %d\n",
                         string, dec, sign);
                  value = 0.6789e5; /* научная нотация */
                  ndig = 5;
                  string = ecvt(value,ndig,&dec,&sign);
                  printf("string = %s           dec = %d\
                         sign = %d\n", string, dec, sign);
                  return 0;
               }

      ellipse
──────────────────────────────────────────────────────────────
Функция        Рисует эллиптическую дугу.

Синтаксис      #include<graphics.h>
               void far ellipse(int x, int y,
                                int stangle, int endangle,
                                int xradius, int yradius);

Прототип в     graphics.h

Примечания     Рисует текущим цветом дугу эллипса с центром  в
               точке  (x,  y)  и горизонтальной и вертикальной
               полуосями xradius и yradius соответственно. Ду-
               га  рисуется  от начального угла stangle до ко-
               нечного угла endangle.  При начальном угле 0  и
               конечном 360 будет рисоваться полный эллипс.
               Начальный и  конечный углы дуги измеряются про-
               тив часовой стрелки,  причем 0  градусов  соот-
               ветствует "3 часам", 90 градусов - "12 часам" и
               т.д.
         !!!   Параметр linestyle не оказывает влияния на  ду-
               ги, окружности, эллипсы и секторы. Используется
               только параметр thickness.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См. также      arc, circle,    fillellipse,    getaspectratio,
               sector, setaspectratio

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy;
                  int stangle = 0, endangle = 360;
                  int xradius = 100, yradius = 50;
              /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  setcolor(getmaxcolor());
                  /* рисует эллипс */
                  ellipse(midx, midy, stangle, endangle,
                          xradius, yradius);
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     __emit__
──────────────────────────────────────────────────────────────
Функция        Вставляет литеральные значения  непосредственно
               в код.

Синтаксис      #include <dos.h>
               void __emit__(argument,...);

Прототип в     dos.h

Примечания     __emit__ - это inline-функция, которая позволя-
               ет   Вам  вставлять  литеральные  значения  не-
               посредственно в объектный код. Она используется
               для генерации машинных инструкций без использо-
               вания встроенного или иного ассемблера.
               Вообще говоря,  аргументы __emit__ являются од-
               нобайтовыми   машинными  инструкциями.  Однако,
               благодаря возможностям этой функции, можно соз-
               давать  более  сложные конструкции,  содержащие
               ссылки на переменные языка C.
               Вы должны использовать эту функцию, только если
               Вы хорошо знакомы с машинным  языком  семейства
               80x86.  Вы  можете использовать эту функцию для
               размещения произвольных байт в коде инструкции;
               если некоторые из этих байт некорректны,  пове-
               дение программы непредсказуемо и может привести
               к зависанию компьютера. Borland C++ не пытается
               как-либо анализировать корректность вызова этой
               функции.  Если Вы пишете инструкции, изменяющие
               регистры процессора или память,  Borland C++ не
               распознает  это  и не может корректно сохранить
               регистры,  как он это делает во многих  случаях
               при  вставке  ассемблерного кода (например,  он
               распознает использование регистров SI и  DI  во
               вставляемых  инструкциях).  Ответственность при
               использовании этой  функции  целиком  лежит  на
               Вас.
               В __emit__ можно передавать любое  число  аргу-
               ментов,  но  не  менее  одного.  Аргументы этой
               функции не интерпретируются как аргументы любой
               другой функции языка.  Аргумент, передаваемый в
               __emit__,  не будет никак преобразован. Сущест-
               вуют  специальные ограничения на вид аргументов
               в __emit__.  Они должны иметь форму  выражений,
               которые  можно  использовать  для инициализации
               статических объектов.  Это означает,  что могут
               быть использованы целые константы,  константы с
               плавающей точкой и адреса статических объектов.
               Значения  таких  выражений  пишутся в объектный
               код в точке вызова, точно, как если бы они были
               использованы  для  инициализации данных.  Могут
               быть также использованы адреса  параметров  или
               автопеременных,  плюс или минус постоянное сме-
               щение. Для таких аргументов в объектный код за-
               писывается  их смещение относительно BP.  Число
               байт,  помещаемых в объектный код,  зависит  от
               типа аргумента, за исключением следующих случа-
               ев: - Знаковая целая константа в диапазоне от 0
               до 255 (т.е.  0x90) рассматривается как символ.
               - Если используется  адрес  автопеременной  или
               параметра,  то записывается байт, если смещение
               переменной от BP лежит в диапазоне от  -128  до
               127,  и  слово - в противном случае.  Байты пи-
               шутся как:
                  __emit__(0x90);
               Если Вы хотите записать слово,  а значение, ко-
               торое  Вы передаете,  не превышает 255,  просто
               сделайте приведение к беззнаковому типу:
                  __emit__(0xB8, (unsigned)17);
               или
                  __emit__(0xB8, 17u);
               Запись двух- или четырехбайтового значения  ад-
               реса  может  быть обеспечена приведением к void
               near* или void far* соответственно.

Значение       Нет.

Переносимость  Эта функция  доступна  только  для  процессоров
               Intel 80x86.

Пример         #include <dos.h>

               int main(void)
               {
               /* вставляет код, который вызывает
                  печать экрана через прерывание 0x05 */
                  __emit__(0xcd,0x05);
                  return 0;
               }

       enable
──────────────────────────────────────────────────────────────
Функция        Разрешает аппаратные прерывания.

Синтаксис      #include<dos.h>
               void enable(void);

Прототип в     dos.h

Примечания     Предназначена для  обеспечения гибкости при уп-
               равлении аппаратными прерываниями. Макро enable
               разрешает  прерывания,  допуская  возникновение
               любых аппаратных прерываний.

Значение       Нет.

Переносимость  Это макро доступно только для процессоров архи-
               тектуры 80x86.

См. также      disable, getvect

Пример         #include <dos.h>

               void interrupt (*oldhandler)(void);
               int count=0;
               void interrupt handler(void)
               {
               /* запрещение прерываний */
                  disable();
                  count++;
               /* разрешение прерываний */
                  enable();
               }

               int main(void)
               {
               /* сохранение старого вектора */
                  oldhandler = getvect(0x1c);
               /* установка нового обработчика */
                  setvect(0x1c, handler);
                  while (count < 20);
               /* восстановление старого обработчика */
                  setvect(0x1c, oldhandler);
                  return 0;
               }

     eof
──────────────────────────────────────────────────────────────
Функция        Проверяет условие конца файла.

Синтаксис      #include<io.h>
               int eof(int handle);

Прототип в     io.h

Примечания     Проверяет, достигнут ли конец файла, связанного
               с обработчиком handle.

Значение       Если текущая позиция есть конец файла,  возвра-
               щается 1;  в противном случае - 0.  Значение -1
               указывает на ошибку;  при этом глобальная пере-
               менная errno устанавливается в значение
                  EBADF  Неверный номер файла

Переносимость  Эта функция доступна только в DOS.

См. также      clearerr, feof, ferror, perror

Пример         #include <sys\stat.h>
               #include <string.h>
               #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>

               int main(void)
               {
                  FILE *temp_file;
                  int handle;
                  char msg[] = "This is a test";
                  char ch;
                  /* создает временный файл
                     с уникальным именем */
                  if ((temp_file = tmpfile()) == NULL) {
                      perror("OPENING FILE:");
                      exit(1);
                  }
                  /* получает номер обработчика
                     для этого файла */
                  /* пишет данные в файл */
                  write(handle, msg, strlen(msg));
                  /* позиционирование в начало файла */
                  lseek(handle, 0L, SEEK_SET);
                  /* читает символы из файла пока не EOF */
                  do {
                     read(handle, &ch, 1);
                     printf("%c", ch);
                  } while (!eof(handle));
                  /* закрывает и уничтожает временный файл */
                  fclose(temp_file);
                  return 0;
               }

   execl, execle, execlp, execlpe,
   execv, execve, execvp, execvpe
──────────────────────────────────────────────────────────────
Функция        Загружает и выполняет другие программы.

Синтаксис      #include<process.h>
               int execl(char *path,
                      char *arg0, *arg1,..., *argn, NULL);
               int execle(char *path, char *arg0, *arg1,...,
                      *argn, NULL, char **env);
               int execlp(char *path,
                      char *arg0, *arg1,..., *argn, NULL);
               int execlpe(char *path, char *arg0, *arg1,...,
                      *argn, NULL, char **env);
               int execv(char *path, char *argv[]);
               int execve(char *path,char *argv[],char **env);
               int execvp(char *path, char *argv[]);
               int execvpe(char *path,char *argv[],char **env);

Прототип в     process.h

Примечания     Функции семейства exec... загружают и запускают
               (выполняют) другие программы, известные как до-
               черние   процессы.   Когда   происходит   вызов
               exec...,  дочерний процесс загружается в память
               вместо  родительского процесса.  Для загрузки и
               выполнения этого процесса должно иметься доста-
               точно основной памяти.
               path -  это имя файла для вызываемого дочернего
               процесса.  Функции exec... ищут этот файл с по-
               мощью стандартного алгоритма поиска DOS:
               - Если явно не задано расширение  имени  файла,
               ищется  в  точности то имя,  которое задано;  в
               случае неудачи DOS добавляет .COM к имени файла
               и повторяет поиск; если опять неудача, добавля-
               ется .EXE и поиск снова повторяется.
               - Если задано расширение или точка в имени фай-
               ла, ищется только то имя, которое задано.
               Суффиксы l,  v,  p и e, добавляемые к имени се-
               мейства exec...,  определяют некоторые дополни-
               тельные возможности этих функций.
               p
               Функция будет искать файл во всех справочниках,
               указанных в переменной среды DOS PATH. Без это-
               го  суффикса функция будет искать файл только в
               текущем справочнике.
               l
               Указатели на аргументы arg0,  arg1,  ...,  argn
               передаются как отдельные аргументы. Обычно суф-
               фикс l используется,  когда заранее  точно  из-
               вестно количество передаваемых аргументов.
               v
               Указатели на  аргументы  arg[0],  arg[1],  ...,
               arg[n] передаются как массив указателей. Обычно
               суффикс  v  используется,  когда  может переда-
               ваться переменное число аргументов.
               e
               Аргумент envp может быть передан дочернему про-
               цессу, чтобы изменить его среду. Без суффикса e
               дочерний процесс наследует среду родительского.
               Каждая функция  семейства exec...  ДОЛЖНА иметь
               один из двух суффиксов,  определяющих аргументы
               (либо l,  либо v). Суффиксы, определяющие объем
               поиска файла и наследование среды (p  и  e)  не
               обязательны.
               Например:
               - execl передает отдельные аргументы,  ищет до-
               черний  процесс  только  в текущем или корневом
               справочнике и передает дочернему процессу среду
               родительского.
               - execvpe передает массив указателей,  включает
               в  круг  поиска  дочернего  процесса переменную
               PATH и в качестве среды дочернего процесса  пе-
               редает аргумент envp.
               Функции exec...  должны  передавать   дочернему
               процессу  по  крайней  мере один аргумент (arg0
               или arg[0]):  этот аргумент,  по соглашениям  о
               связях,  является  копией path.  (Использование
               иного значения для "нулевого" аргумента не  бу-
               дет  приводить  к  ошибке).  В DOS 3.x значение
               path доступно дочернему процессу;  в более ран-
               них версиях дочерний процесс не может использо-
               вать передаваемое значение "нулевого" аргумента
               (arg0 или arg[0]).
               Когда используется суффикс l,  arg0 обычно ука-
               зывает на path,  а arg1,..., argn - на символь-
               ные строки,  составляющие новый список аргумен-
               тов.  После  argn  должен обязательно следовать
               нуль-символ, определяющий конец списка.
               Когда используется   суффикс  e,  Вы  передаете
               список новых установок переменных  среды  через
               аргумент envp.  Этот аргумент - массив указате-
               лей на строки символов.  Каждый  указатель  ад-
               ресует завершающуюся нуль-символом строку вида
                  envvar = value
               где envvar  -  имя переменной среды,  а value -
               строка-значение этой переменной. Последний эле-
               мент envp[] - нуль-символ.  Если envp пуст, до-
               черний процесс наследует среду родительского.
               Суммарная длина arg0+arg1+...+argn (или arg[0]+
               arg[1]+...+arg[n]),  включая пробелы, разделяю-
               щие аргументы,  но исключая хвостовые нуль-сим-
               волы, должна быть < 128 байтов.
               Когда происходит  вызов  exec...,  все открытые
               файлы остаются открытыми в дочернем процессе.

Значение       При успешном выполнении exec... ничего не возв-
               ращают. В случае ошибки функции exec... возвра-
               щают -1, а глобальная переменная errno получает
               одно из следующих значений:
                 E2BIG      Слишком длинный список аргументов
                 EACCES     Доступ запрещен
                 EMFILE     Слишком много открытых файлов
                 ENOENT     Путь или файл не найден
                 ENOEXEC    Файл не имеет EXE-формата
                 ENOMEM     Недостаточно памяти

Переносимость  Функции exec... доступны только в DOS.

См. также      abort, atexit,    _exit,    exit,     _fpreset,
               searchpath, spawn..., system

Пример         #include <stdio.h>
               #include <stdlib.h>
               int main(int argc, char *argv[])
               {
                  int i;
                  printf("Child running...\n");
                  printf("%s\n", getenv("PATH"));
                  for (i = 0; i < argc; i++)
                    printf("argv[%d]: %s\n", i, argv[i]);
                  return 0;
               }

Для каждой     #include <process.h>
функции -      #include <stdio.h>
свой пример!   #include <errno.h>
               #include <dos.h>
               int main(int argc, char *argv[])
               {
                  int loop;
                  printf("%s running...\n\n", argv[0]);
                  if (argc == 1) { /* параметр один? */
                     printf("%s calling itself again...\n",
                            argv[0]);
                     execl(agrv[0], argv[0],
                           "ONE", "TWO", "THREE", NULL);
                     perror("EXEC:");
                     exit(1);
                  }
                  printf("%s called with arguments:\n",
                         argv[0]);
                 /*показывает все параметры командной строки*/
                  for (loop = 1; loop <= argc; loop++)
                     puts(argv[loop]);
                  return 0;
               }

               #include <process.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <errno.h>
               #include <dos.h>
               int main(int argc, char *argv[], char *env[])
               {
                  int loop;
                  char *new_env[] = { "TESTING", NULL };
                  printf("%s running...\n\n", argv[0]);
                  if (argc == 1) { /* параметр один? */
                     printf("%s calling itself again...\n",
                            argv[0]);
                     execle(agrv[0], argv[0], "ONE", "TWO",
                            "THREE", NULL, new_env);
                     perror("EXEC:");
                     exit(1);
                  }
                  printf("%s called with arguments:\n",
                         argv[0]);
                 /*показывает все параметры командной строки*/
                  for (loop = 1; loop <= argc; loop++)
                     puts(argv[loop]);
                  /* показывает первый параметр среды */
                  printf("value of env[0]: %s\n", env[0]);
                  return 0;
               }

               #include <process.h>
               #include <stdio.h>
               #include <errno.h>
               int main(int argc, char *argv[])
               {
                  int i;
                  printf("Command line arguments:\n");
                  for (i = 0; i < argc; i++)
                     printf("[%2d] : %s\n", i, argv[i]);
                  printf("About to exec child with
                          arg1 arg2 ...\n");
                  execlp("CHILD.EXE", "CHILD.EXE", "arg1",
                          "arg2", NULL);
                  perror("exec error");
                  exit(1);
                  return 0;
               }

               #include <process.h>
               #include <stdio.h>
               #include <errno.h>
               int main(int argc, char *argv[], char **envp)
               {
                  int i;
                  printf("Command line arguments:\n");
                  for (i = 0; i < argc; i++)
                     printf("[%2d] : %s\n", i, argv[i]);
                  printf("About to exec child with
                          arg1 arg2 ...\n");
                  execlpe("CHILD.EXE", "CHILD.EXE", "arg1",
                          "arg2", NULL, envp);
                  perror("exec error");
                  exit(1);
                  return 0;
               }

               #include <process.h>
               #include <stdio.h>
               #include <errno.h>
               void main(int argc, char *argv[])
               {
                  int i;
                  printf("Command line arguments:\n");
                  for (i = 0; i < argc; i++)
                     printf("[%2d] : %s\n", i, argv[i]);
                  printf("About to exec child with
                          arg1 arg2 ...\n");
                  execv("CHILD.EXE", argv);
                  perror("exec error");
                  exit(1);
               }

               #include <process.h>
               #include <stdio.h>
               #include <errno.h>
               void main(int argc, char *argv[], char **envp)
               {
                  int i;
                  printf("Command line arguments:\n");
                  for (i = 0; i < argc; i++)
                     printf("[%2d] : %s\n", i, argv[i]);
                  printf("About to exec child with
                          arg1 arg2 ...\n");
                  execve("CHILD.EXE", argv, envp);
                  perror("exec error");
                  exit(1);
               }

               #include <process.h>
               #include <stdio.h>
               #include <errno.h>
               void main(int argc, char *argv[])
               {
                  int i;
                  printf("Command line arguments:\n");
                  for (i = 0; i < argc; i++)
                     printf("[%2d] : %s\n", i, argv[i]);
                  printf("About to exec child with
                          arg1 arg2 ...\n");
                  execvp("CHILD.EXE", argv);
                  perror("exec error");
                  exit(1);
               }

               #include <process.h>
               #include <stdio.h>
               #include <errno.h>
               void main(int argc, char *argv[], char **envp)
               {
                  int i;
                  printf("Command line arguments:\n");
                  for (i = 0; i < argc; i++)
                     printf("[%2d] : %s\n", i, argv[i]);
                  printf("About to exec child with
                          arg1 arg2 ...\n");
                  execvpe("CHILD.EXE", argv, envp);
                  perror("exec error");
                  exit(1);
               }

    _exit
──────────────────────────────────────────────────────────────
Функция        Завершает программу.

Синтаксис      #include<stdlib.h>
               void _exit(int status);

Прототип в     process.h, stdlib.h

Примечания     Завершает программу без закрытия файлов, сброса
               выходных  буферов  и  вызова каких-либо функций
               выхода.  Вызывающий процесс использует  status,
               как код возврата из процесса. Обычно значение 0
               используется для указания нормального выхода, а
               ненулевое значение указывает на ошибку.

Значение       Нет.

Переносимость  Эта функция доступна в системах UNIX.

См. также      abort, atexit, exec..., exit, spawn...

Пример         #include   <stdlib.h>
               #include   <stdio.h>
               void done(void);
               int main(void)
               {
                  atexit(done);
                  _exit(0);
                  return 0;
               }
               void done()
               {
                  printf("hello\n");
               }

    exit
──────────────────────────────────────────────────────────────
Функция        Завершает программу.

Синтаксис      #include<stdlib.h>
               void exit(int status);

Прототип в     process.h, stdlib.h

Примечания     Завершает вызывающий процесс. Перед завершением
               закрываются  все файлы,  записываются ожидающие
               вывода выходные буфера и вызываются  все  заре-
               гистрированные посредством atexit функции выхо-
               да.

               Вызывающий процесс  использует status,  как код
               возврата из процесса. Обычно значение 0 исполь-
               зуется для указания нормального выхода, а нену-
               левое значение указывает на ошибку.  status мо-
               жет  быть установлен в одно из следующих значе-
               ний:
               EXIT_SUCCES  Нормальное завершение программы
               EXIT_FAILURE Аварийное завершение программы -
                            сигнализирует операционной системе
                            об ошибочном завершении программы

Значение       Нет.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      abort, atexit,  exec...,  _exit,  keep, signal,
               spawn...

Пример         #include <stdlib.h>
               #include <conio.h>
               #include <stdio.h>
               int main(void)
               {
                  int status;
                  printf("Enter either 1 or 2\n");
                  status = getch();
               /* устанавливает уровень ошибки DOS */
                  exit(status - '0');
               /* эта строка никогда не достигается */
                  return 0;
               }

     exp
──────────────────────────────────────────────────────────────
Функция        Вычисляет экспоненту x.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:  КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>     #include <complex.h>
               double exp(double x); complex exp(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:  КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                complex.h

Примечания     exp вычисляет экспоненциальную функцию e **  x.
               Комплексная  экспоненциальная функция определя-
               ется как:
               exp(x + i * y) = exp(x) * (cos(y) + i * sin(y))

Значение       e ** x.
               Иногда аргументы,  переданные в exp, приводят к
               переполнению  или  невычисляемому   результату.
               Когда  верное  значение  вызывает переполнение,
               exp возвращает значение HUGE_VAL.  Если резуль-
               тат слишком велик,  глобальная переменная errno
               устанавливается в значение
                  ERANGE Результат вне диапазона
               При исчезновении порядка exp возвращает 0.0,  и
               глобальная переменная errno не изменяется.
               Обработка ошибок для этой  функции  может  быть
               модифицирована посредством функции matherr.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      frexp, ldexp,  log, log10, matherr, pow, pow10,
               sqrt

Пример         #include <stdio.h>
               #include <math.h>
               int main(void)
               {
                  double result;
                  double x = 4.0;
                  result = exp(x);
                  printf("'e' raised to the power \
                         of %lf (e ^ %lf) = %lf\n",
                         x, x, result);
                   return 0;
               }

    fabs
──────────────────────────────────────────────────────────────
Функция        Вычисляет абсолютное значение числа с плавающей
               точкой.

Синтаксис      #include<math.h>
               double fabs(double x);

Прототип в     math.h

Примечания     Вычисляет абсолютное  значение x типа double.

Значение       Возвращает абсолютное  значение x.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      abs, cabs, labs

Пример         #include <stdio.h>
               #include <math.h>
               int main(void)
               {  float  number = -1234.0;
                  printf("number: %f  absolute value: %f\n",
                         number, fabs(number));
                  return 0;
               }

  farcalloc
──────────────────────────────────────────────────────────────
Функция        Распределяет память в дальней куче.

Синтаксис      #include <alloc.h>
               void far *farcalloc(unsigned long nunits,
                                   unsigned long unitsz);

Прототип в     alloc.h

Примечания     Распределяет память в дальней куче для массива,
               содержащего nunits элементов длиной unitsz байт
               каждый.
               При  распределении  в  дальней куче:
               - вся доступная RAM-память может быть распреде-
               лена.
               -  могут  быть распределены блоки больше 64К.
               - для доступа к распределенным блокам использу-
               ются дальние или (если блоки больше 64K) сверх-
               дальние указатели.
               В моделях памяти compact, large, huge эта функ-
               ция подобна, но не идентична calloc. Она прини-
               мает параметры типа unsigned long,  а calloc  -
               параметры типа unsigned.
               В модели памяти tiny эта функция не может  быть
               использована.

Значение       Указатель на  вновь  распределенный  блок   или
               NULL,  если недостаточно памяти для распределе-
               ния.

Переносимость  Эта функция доступна только в DOS.

См. также      calloc, farcoreleft, farfree, farmalloc, malloc

Пример         #include <stdio.h>
               #include <alloc.h>
               #include <string.h>
               #include <dos.h>
               int main(void)
               {  char far *fptr;
               char *str = "Hello";
               /* распределяет память для дальнего указателя*/
               fptr = farcalloc(10, sizeof(char));
               if (fptr) {
               /* копирует "Hello" в распределенную память */
               /* Замечание: здесь используется movedata,
                 поскольку мы можем находиться в малых
                 моделях памяти; в этом случае обычная
                 процедура копирования строки не
                 может быть использована, ибо она предполагает
                 ближние указатели */
                  movedata(FP_SEG(str), FP_OFF(str),
                           FP_SEG(fptr), FP_OFF(fptr),
                           strlen(str));
                /*отображает строку (заметьте модификатор F)*/
                  printf("Far string is: %Fs\n", fptr);
                  /* освобождение памяти */
                  farfree(fptr);
               }
               return 0;
               }

     farcoreleft
──────────────────────────────────────────────────────────────
Функция        Возвращает количество неиспользуемой  памяти  в
               дальней куче.

Синтаксис      #include <alloc.h>
               unsigned long farcoreleft(void);

Прототип в     alloc.h

Примечания     Возвращает количество неиспользуемой  памяти  в
               дальней  куче  после последнего распределенного
               блока.  В модели памяти tiny эта функция не мо-
               жет быть использована.

Значение       Возвращает количество  неиспользуемой  памяти в
               дальней  куче  между  последним  распределенным
               блоком и концом доступной памяти.

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      coreleft, farcalloc, farmalloc

Пример         #include <stdio.h>
               #include <alloc.h>
               int main(void)
               {  printf("The difference between the
                          highest allocated block in the
                          far\n");
                  printf("heap and the top of the far heap
                          is: %lu bytes\n", farcoreleft());
                  return 0;
               }

      farfree
──────────────────────────────────────────────────────────────
Функция        Освобождает блок в дальней куче.

Синтаксис      #include <alloc.h>
               void farfree(void far *block);

Прототип в     alloc.h

Примечания     Освобождается блок памяти, предварительно расп-
               ределенный в дальней куче.
               В модели  памяти tiny эта функция не может быть
               использована.
               В малых и средних моделях памяти блоки, распре-
               деленные с помощью  farmalloc,  не  могут  быть
               освобождены обычным free, а блоки, распределен-
               ные с помощью malloc, не могут быть освобождены
               посредством  farfree.  В  этих моделях две кучи
               совершенно различны.

Значение       Нет.

Переносимость  Эта функция доступна только в DOS.

См. также      farcalloc, farmalloc

Пример         #include <stdio.h>
               #include <alloc.h>
               #include <string.h>
               #include <dos.h>
               int main(void)
               {  char far *fptr;
               char *str = "Hello";
               /*распределяет память для дальнего указателя*/
               fptr = farcalloc(10, sizeof(char));
               if (fptr) {
               /* копирует "Hello" в распределенную память */
               /* Замечание: здесь используется movedata,
                поскольку мы можем находиться в малых
                моделях памяти; в этом случае обычная
                процедура копирования строки не
                может быть использована, ибо она предполагает
                ближние указатели */
                  movedata(FP_SEG(str), FP_OFF(str),
                           FP_SEG(fptr), FP_OFF(fptr),
                           strlen(str));
               /*отображает строку (заметьте модификатор F)*/
                  printf("Far string is: %Fs\n", fptr);
                  /* освобождение памяти */
                  farfree(fptr);
               }
                  return 0;
               }

    farheapcheck
──────────────────────────────────────────────────────────────
Функция        Проверяет корректность дальней кучи.

Синтаксис      #include <alloc.h>
               int farheapcheck(void);

Прототип в     alloc.h

Примечания     Просматривает дальнюю кучу и проверяет для каж-
               дого блока его указатели,  размер и другие кри-
               тические атрибуты.

Значение       Возвращаемое значение меньше  0  при  ошибке  и
               больше 0 при успешном завершении:
                 _HEAPEMPTY    Куча отсутствует (1).
                 _HEAPOK       Куча корректна (2).
                 _HEAPCORRUPT  Куча испорчена (-1).

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      heapcheck

Пример         #include <stdio.h>
               #include <alloc.h>
               #define NUM_PTRS  10
               #define NUM_BYTES 16
               int main(void)
               {   char far *array[ NUM_PTRS ];
                   int i;
                   for(i = 0; i < NUM_PTRS; i++)
                       array[i] = farmalloc(NUM_BYTES);
                   for(i = 0; i < NUM_PTRS; i += 2)
                       farfree(array[i]);
                   if (farheapcheck() == _HEAPCORRUPT)
                       printf("Heap is corrupted.\n");
                   else
                       printf("Heap is OK.\n");
                   return 0;
               }

    farheapcheckfree
──────────────────────────────────────────────────────────────
Функция        Проверяет свободные   блоки   дальней  кучи  на
               постоянное значение.

Синтаксис      #include <alloc.h>
               int farheapcheckfree(unsigned int fillvalue);

Прототип в     alloc.h

Значение       Возвращаемое значение  меньше  0  при  ошибке и
               больше 0 при успешном завершении:
                _HEAPEMPTY   Куча отсутствует (1).
                _HEAPOK      Куча корректна (2).
                _HEAPCORRUPT Куча испорчена (-1).
                _BADVALUE    Значение  отлично  от  указанного
                             в fillvalue (-3).

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      farheapfillfree, heapcheckfree

Пример         #include <mem.h>
               #include <stdio.h>
               #include <alloc.h>
               #define NUM_PTRS  10
               #define NUM_BYTES 16
               int main(void)
               {  char far *array[NUM_PTRS];
                  int i;
                  int j;
                  int res;
                  for (i = 0; i < NUM_PTRS; i++)
                    if ((array[i]=farmalloc(NUM_BYTES))==NULL)
                     {  printf("No memory for allocation\n");
                        return 1;
                     }
                  for (i = 0; i < NUM_PTRS; i += 2)
                     farfree(array[i]);
                  if(farheapfillfree(1) < 0) {
                     printf("Heap corrupted.\n");
                     return 1;
                  }
                  for (i = 1; i < NUM_PTRS; i += 2)
                     for (j = 0; j < NUM_BYTES; j++)
                        array[i][j] = 0;
                  res = farheapcheckfree(1);
                  if (res < 0)
                     switch(res) {
                        case _HEAPCORRUPT:
                           printf("Heap corrupted.\n");
                           return 1;
                        case _BADVALUE:
                         printf("Bad value in free space.\n");
                         return 1;
                        default:
                           printf("Unknown error.\n");
                           return 1;
                     }
                  printf("Test successful.\n");
                  return 0;
               }

     farheapchecknode
──────────────────────────────────────────────────────────────
Функция        Проверяет отдельный узел в дальней куче.

Синтаксис      #include <alloc.h>
               int farheapchecknode(void *node);

Прототип в     alloc.h

Примечания     Если узел ранее был освобожден,  то функция мо-
               жет    вернуть   _BADNODE   вместо   ожидаемого
               _FREEENTRY.  Это объясняется тем,  что  смежные
               свободные блоки в куче сливаются, и запрашивае-
               мого блока может не существовать.

Значение       Возвращаемое значение меньше  0  при  ошибке  и
               больше 0 при успешном завершении:
                 _HEAPEMPTY    Куча отсутствует (1).
                 _HEAPCORRUPT  Куча испорчена (-1).
                 _BADNODE      Узел не найден (-2).
                 _FREEENTRY    Узел свободен (3).
                 _USEDENTRY    Узел распределен (4).

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      heapchecknode

Пример         #include <stdio.h>
               #include <alloc.h>
               #define NUM_PTRS  10
               #define NUM_BYTES 16
               int main(void)
               {  char far *array[NUM_PTRS];
                  int i;
                  for(i = 0; i < NUM_PTRS; i++)
                     array[i] = farmalloc(NUM_BYTES);
                  for(i = 0; i < NUM_PTRS; i += 2)
                     farfree( array[i] );
                  for(i = 0; i < NUM_PTRS; i++) {
                     printf("Node %2d ", i);
                     switch(farheapchecknode(array[i])) {
                        case _HEAPEMPTY:
                           printf("No heap.\n");
                           break;
                        case _HEAPCORRUPT:
                           printf("Heap corrupt.\n");
                           break;
                        case _BADNODE:
                           printf("Bad node.\n");
                           break;
                        case _FREEENTRY:
                           printf("Free entry.\n");
                           break;
                        case _USEDENTRY:
                           printf("Used entry.\n");
                           break;
                        default:
                           printf("Unknown return code.\n");
                           break;
                     }
                  }
                  return 0;
               }

    farheapfillfree
──────────────────────────────────────────────────────────────
Функция        Заполняет свободные блоки дальней кучи постоян-
               ным значением.

Синтаксис      #include <alloc.h>
               int farheapfillfree(unsigned int fillvalue);

Прототип в     alloc.h

Значение       Возвращаемое значение меньше  0  при  ошибке  и
               больше 0 при успешном завершении:
                 _HEAPEMPTY    Куча отсутствует (1).
                 _HEAPOK       Куча корректна (2).
                 _HEAPCORRUPT  Куча испорчена (-1).

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      farheapcheckfree, heapfillfree

Пример         #include <mem.h>
               #include <stdio.h>
               #include <alloc.h>
               #define NUM_PTRS  10
               #define NUM_BYTES 16
               int main(void)
               {  char far *array[NUM_PTRS];
                  int i, j;
                  int res;
                  for (i = 0; i < NUM_PTRS; i++)
                    if ((array[i]=farmalloc(NUM_BYTES))==NULL)
                     {  printf("No memory for allocation\n");
                        return 1;
                     }
                  for (i = 0; i < NUM_PTRS; i += 2)
                     farfree(array[i]);
                  if (farheapfillfree(1) < 0) {
                     printf("Heap corrupted.\n");
                     return 1;
                  }
                  for (i = 1; i < NUM_PTRS; i += 2)
                     for (j = 0; j < NUM_BYTES; j++)
                        array[i][j] = 0;
                  res = farheapcheckfree(1);
                  if (res < 0)
                     switch(res) {
                        case _HEAPCORRUPT:
                           printf("Heap corrupted.\n");
                           return 1;
                        case _BADVALUE:
                         printf("Bad value in free space.\n");
                         return 1;
                        default:
                           printf("Unknown error.\n");
                           return 1;
                     }
                  printf("Test successful.\n");
                  return 0;
               }

     farheapwalk
──────────────────────────────────────────────────────────────
Функция        farheapwalk используется для  последовательного
               прохода по всем узлам дальней кучи.

Синтаксис      #include <alloc.h>
               int farheapwalk(struct farheapinfo *hi);

Прототип в     alloc.h

Примечания     farheapwalk предполагает,  что  куча корректна.
               Используйте farheapcheck для  верификации  кучи
               перед  использованием  farheapwalk.  При вызове
               для последнего блока кучи возвращается _HEAPOK.
               При  следующем  вызове farheapwalk возвращается
               _HEAPEND.
               farheapwalk получает указатель на структуру ти-
               па heapinfo (определенную в alloc.h).  При пер-
               вом вызове farheapwalk установите поле hi.ptr в
               NULL.
               farheapwalk возвращает в  этом  поле  адрес  на
               первый  блок.  hi.size  содержит размер блока в
               байтах.  hi.in_use - это флаг, который установ-
               лен, если блок распределен.

Значение       _HEAPEMPTY    Куча отсутствует (1).
               _HEAPOK       Куча корректна (2).
               _HEAPEND      Конец кучи (5).

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      heapwalk

Пример         #include <stdio.h>
               #include <alloc.h>
               #define NUM_PTRS  10
               #define NUM_BYTES 16
               int main( void )
               {  struct farheapinfo hi;
                  char far *array[NUM_PTRS];
                  int i;
                  for(i = 0; i < NUM_PTRS; i++)
                     array[i] = farmalloc(NUM_BYTES);
                  for(i = 0; i < NUM_PTRS; i += 2)
                     farfree(array[i]);
                  hi.ptr = NULL;
                  printf("   Size   Status\n");
                  printf("   ----   ------\n");
                  while(farheapwalk(&hi) == _HEAPOK)
                     if (hi.in_use)
                         printf("%7u   used\n", hi.size);
                     else
                         printf("%7u   free\n", hi.size);
                  return 0;
               }

    farmalloc
──────────────────────────────────────────────────────────────
Функция        Распределяет память в дальней куче.

Синтаксис      #include <alloc.h>
               void far *farmalloc(unsigned long nbytes);

Прототип в     alloc.h

Примечания     Распределяет в  дальней куче блок памяти длиной
               nbytes байт .
               При  распределении  в  дальней куче:
               - вся доступная RAM-память может быть распреде-
               лена.
               -  могут  быть распределены блоки больше 64К.
               - для доступа к распределенным блокам использу-
               ются дальние или (если блоки больше 64K) сверх-
               дальние указатели.
               В моделях памяти compact, large, huge эта функ-
               ция подобна, но не идентична malloc. Она прини-
               мает  параметры типа unsigned long,  а malloc -
               параметры типа unsigned.
               В модели  памяти tiny эта функция не может быть
               использована.

Значение       Указатель на   вновь  распределенный  блок  или
               NULL,  если недостаточно памяти для распределе-
               ния.

Переносимость  Эта функция доступна только в DOS.

См. также      farcalloc, farcoreleft,   farfree,  farrealloc,
               malloc

Пример         #include <stdio.h>
               #include <alloc.h>
               #include <string.h>
               #include <dos.h>
               int main(void)
               {  char far *fptr;
               char *str = "Hello";
               /*распределяет память для дальнего указателя*/
               fptr = farmalloc(10);
               /* копирует "Hello" в распределенную память */
               /* Замечание: здесь используется movedata,
                 поскольку мы можем находиться в малых
                 моделях памяти; в этом случае обычная
                 процедура копирования строки не
                 может быть использована, ибо она предполагает
                 ближние указатели */
               movedata(FP_SEG(str), FP_OFF(str),
                        FP_SEG(fptr), FP_OFF(fptr),
                        strlen(str));
               /* отображает строку (заметьте модификатор F)*/
               printf("Far string is: %Fs\n", fptr);
               /* освобождение памяти */
               farfree(fptr);
               return 0;
               }

    farrealloc
──────────────────────────────────────────────────────────────
Функция        Модифицирует блоки,  распределенные  в  дальней
               куче.

Синтаксис      #include <alloc.h>
               void far *farrealloc(void far *oldblock,
                                    unsigned long nbytes);

Прототип в     alloc.h

Примечания     Изменяет размер распределенного блока в nbytes,
               копируя содержимое в новую область памяти, если
               необходимо.
               При  распределении  в  дальней куче:
               - вся доступная RAM-память может быть распреде-
               лена.
               -  могут  быть распределены блоки больше 64К.
               - для доступа к распределенным блокам использу-
               ются дальние или (если блоки больше 64K) сверх-
               дальние указатели.
               В модели памяти tiny эта функция не может  быть
               использована.

Значение       Возвращает адрес перераспределенного блока, ко-
               торый может отличаться от исходного.  Если блок
               не  может  быть  перераспределен,  возвращается
               NULL.

Переносимость  Эта функция доступна только в DOS.

См. также      farmalloc, realloc

Пример         #include <stdio.h>
               #include <alloc.h>
               int main(void)
               {  char far *fptr;
                  fptr = farmalloc(10);
                  printf("First address: %Fp\n", fptr);
                  fptr = farrealloc(fptr,20);
                  printf("New address  : %Fp\n", fptr);
                  farfree(fptr);
                  return 0;
               }

    fclose
──────────────────────────────────────────────────────────────
Функция        Закрывает поток ввода-вывода.

Синтаксис      #include <stdio.h>
               int fclose(FILE *stream);

Прототип в     stdio.h

Примечания     Закрывает указанный поток  ввода-вывода.  Перед
               закрытием сбрасываются все буфера,  связанные с
               этим потоком.  Буфера, распределенные системой,
               освобождаются.  Буфера,  назначенные  setbuf  и
               setvbuf, автоматически не освобождаются. (Одна-
               ко  если setvbuf получил NULL в качестве указа-
               теля на буфер,  при закрытии он будет  освобож-
               ден).

Значение       Возвращается 0  при  успешном  завершении и EOF
               при любой обнаруженной ошибке.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      close, fcloseall,    fdopen,   fflush,   fopen,
               freopen

Пример         #include <string.h>
               #include <stdio.h>
               int main(void)
               {  FILE *fp;
                  char buf[11] = "0123456789";
                  /* создает файл длиной 10 байт */
                  fp = fopen("DUMMY.FIL", "w");
                  if (fp) {
                      fwrite(&buf, strlen(buf), 1, fp);
                      /* закрывает файл */
                      fclose(fp);
                  }
                  else {
                      printf("Unable to open file!\n");
                  }
                  return 0;
               }

    fcloseall
──────────────────────────────────────────────────────────────
Функция        Закрывает все открытые потоки ввода-вывода.

Синтаксис      #include <stdio.h>
               int fcloseall(void);

Прототип в     stdio.h

Примечания     Закрывает все   открытые  потоки  ввода-вывода,
               кроме stdin, sdout, stdprn, stderr и stdaux.

Значение       Общее число закрытых потоков.  При  обнаружении
               любой ошибки возвращается EOF.

Переносимость  Эта функция доступна в системах UNIX.

См. также      fclose, fdopen, flushall, fopen, freopen

Пример         #include <stdio.h>
               int main(void)
               {  int streams_closed;
                  /* открывает два потока */
                  fopen("DUMMY.ONE", "w");
                  fopen("DUMMY.TWO", "w");
                  /* закрывает открытые потоки */
                  streams_closed = fcloseall();
                  if (streams_closed == EOF)
                     /* выводит сообщение об ошибке */
                     perror("Error");
                  else
                   /*печатает результат функции fcloseall()*/
                     printf("%d streams were closed.\n",
                            streams_closed);
                  return 0;
               }

     fcvt
──────────────────────────────────────────────────────────────
Функция        Преобразует число с плавающей точкой в строку.

Синтаксис      #include <stdlib.h>
               char *fcvt(double value, int ndig, int *dec,
                          int *sign);

Прототип в     stdlib.h

Примечания     Преобразует value  в  завершенную нуль-символом
               строку, состоящую из ndig цифр и начинающуюся с
               самой левой значащей цифры, и возвращает указа-
               тель на эту строку.  Позиция  десятичной  точки
               относительно  начала  строки  помещается  в dec
               (отрицательное значение dec означает, что деся-
               тичная  точка  располагается  слева  от  начала
               возвращаемой строки).  Сама возвращаемая строка
               не  содержит десятичной точки.  Если знак value
               отрицательный - слово, указываемое sign, отлич-
               но от нуля; в противном случае оно = 0. Младшая
               значащая цифра округляется.

Значение       Возвращаемое значение указывает на  статическую
               строку, которая перезаписывается при каждом вы-
               зове ecvt.

Переносимость  Эта функция доступна в системах  UNIX.  Она  не
               содержится  в ANSI C и не рекомендуется для пе-
               реносимых программ.

См. также      ecvt, gcvt, sprintf

Пример         #include <stdlib.h>
               #include <stdio.h>
               int main(void)
               {  char *str;
                  double num;
                  int dec, sign;
                  int ndig = 5;
                  /* обычное число */
                  num = 9.876;
                  str = fcvt(num, ndig, &dec, &sign);
                  printf("string = 10%s decimal place = %d
                         sign = %d\n", str, dec, sign);
                  /* отрицательное число */
                  num = -123.45;
                  str = fcvt(num,ndig,&dec,&sign);
                  printf("string = %10s decimal place = %d
                         sign = %d\n", str, dec, sign);
                  /* научная нотация */
                  num = 0.678e5;
                  str = fcvt(num,ndig,&dec,&sign);
                  printf("string = %10s decimal place = %d
                         sign = %d\n", str, dec, sign);
                  return 0;
               }

   fdopen
──────────────────────────────────────────────────────────────
Функция        Связывает поток   ввода-вывода  с  обработчиком
               файла.

Синтаксис      #include <stdio.h>
               FILE *fdopen(int handle, char *type);

Прототип в     stdio.h

               Примечания Связывает поток ввода-вывода с обра-
               ботчиком файла,  полученным из creat, dup, dup2
               или open. Тип потока должен соответствовать ре-
               жиму открытия handle.  Строка type должна иметь
               одно из следующих значений:
               r  Открывает только для чтения.
               w  Создает для записи.
               a
               Добавляет; открывает для записи в  конец  файла
               или создает для записи, если файла не существу-
               ет.
               r+
               Открывает существующий файл  для  корректировки
               (чтения и записи).
               w+ Создает новый файл для корректировки.
               a+
               Открывает для добавления; открывает (или созда-
               ет, если файла не существует) для корректировки
               (чтения и записи) в конец файла.
               Чтобы указать, что файл был открыт или создан в
               текстовом режиме,  добавьте t к значению строки
               type (rt, w+t и т.д.); аналогично, для указания
               двоичного режима, добавьте b в строку type (wb,
               a+b и т.д.).
               Если t или b не указаны в  строке  type,  режим
               определяется глобальной переменной _fmode. Если
               _fmode установлена в O_BINARY, файлы будут отк-
               рываться как двоичные.  Если _fmode установлена
               в O_TEXT,  файлы будут открываться как  тексто-
               вые. Эти O_... константы определены в fcntl.h.
               Когда файл  открывается  для  корректировки,  и
               ввод,  и  вывод  могут  осуществляться  в соот-
               ветствующем потоке.  Однако, вывод не может не-
               посредственно  следовать за вводом без промежу-
               точных обращений к fseek или rewind,  и ввод не
               может  непосредственно следовать за выводом без
               промежуточных обращений к fseek или rewind, или
               ввода, который обнаруживает конец файла.

Значение       При успешном завершении, fdopen возвращает ука-
               затель  на  вновь  открытый  поток.  При ошибке
               возвращается NULL.

Переносимость  Эта функция доступна в системах UNIX.

См. также      fclose, fopen, freopen, open

Пример         #include <sys\stat.h>
               #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>
               int main(void)
               {  int handle;
                  FILE *stream;
                  /* открывает файл */
                  handle = open("DUMMY.FIL", O_CREAT,
                                 S_IREAD | S_IWRITE);
                  /* связывает файл с потоком */
                  stream = fdopen(handle, "w");
                  if (stream == NULL)
                     printf("fdopen failed\n");
                  else {
                     fprintf(stream, "Hello world\n");
                     fclose(stream);
                  }
                  return 0;
               }

    feof
──────────────────────────────────────────────────────────────
Функция        Обнаруживает конец файла в потоке ввода-вывода.

Синтаксис      #include <stdio.h>
               int feof(FILE *stream);

Прототип в     stdio.h

Примечания     feof - это макро,  которое проверяет  индикатор
               конца  файла для заданного потока ввода-вывода.
               Если он  однажды  установлен,  операции  чтения
               возвращают его до тех пор, пока не будет вызва-
               но rewind или файл не будет закрыт.
               Индикатор конца файла  переустанавливается  при
               каждой операции ввода.

Значение       feof возвращает ненулевое значение,  если инди-
               катор  конца файла был обнаружен последней опе-
               рацией ввода из указанного потока,  и  0,  если
               конец файла еще не был достигнут.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      clearerr, eof, ferror, perror

Пример         #include <stdio.h>
               int main(void)
               {  FILE *stream;
                  /* открывает файл для чтения */
                  stream = fopen("DUMMY.FIL", "r");
                  /* читает символ из файла */
                  fgetc(stream);
                  /* проверка EOF */
                  if (feof(stream))
                     printf("We have reached end-of-file\n");
                  /* закрывает файл */
                  fclose(stream);
                  return 0;
               }

    ferror
──────────────────────────────────────────────────────────────
Функция        Обнаруживает ошибки в потоке ввода-вывода.

Синтаксис      #include <stdio.h>
               int ferror(FILE *stream);

Прототип в     stdio.h

Примечания     ferror - это макро,  которое проверяет заданный
               поток  ввода-вывода  на ошибки чтения и записи.
               Если индикатор ошибок потока был установлен, он
               остается таковым до вызова clearerr или rewind,
               или пока поток не будет закрыт.

Значение       Возвращает ненулевое значение,  если была обна-
               ружена ошибка.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      clearerr, eof, feof, fopen, getc, perror

Пример         #include <stdio.h>

               int main(void)
               {  FILE *stream;
                  /* открывает файл для записи */
                  stream = fopen("DUMMY.FIL", "w");
                  /* вызывает условие ошибки попыткой чтения*/
                  (void) getc(stream);
                  /* проверяет ошибку в потоке */
                  if ferror(stream) {
                     /* отображает сообщение об ошибке */
                     printf("Error reading from DUMMY.FIL\n");
                     /* сбрасывает индикаторы ошибки и EOF */
                     clearerr(stream);
                  }
                  fclose(stream);
                  return 0;
               }

    fflush
──────────────────────────────────────────────────────────────
Функция        Очищает поток.

Синтаксис      #include <stdio.h>
               int fflush(FILE *stream);

Прототип в     stdio.h

Примечания     Если данный поток stream  имеет  буферизованный
               вывод,  fflush пишет выведенные в него данные в
               связанный с ним файл.
               После выполнения fflush поток  остается  откры-
               тым.  fflush никак не воздействует на небуфери-
               зованный поток.

Значение       Возвращается 0  при  успешном  завершении и EOF
               при любой обнаруженной ошибке.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C. Она не совместима с Windows.

См. также      fclose, flushall, setbuf, setvbuf

Пример         #include <string.h>
               #include <stdio.h>
               #include <conio.h>
               #include <io.h>
               void flush(FILE *stream);
               int main(void)
               {  FILE *stream;
                  char msg[] = "This is a test";
                  /* создает файл */
                  stream = fopen("DUMMY.FIL", "w");
                  /* пишет данные в файл */
                  fwrite(msg, strlen(msg), 1, stream);
                  clrscr();
                  printf("Press any key to flush DUMMY.FIL:");
                  getch();
                  /* сбрасывает данные в DUMMY.FIL
                     без его закрытия */
                  flush(stream);
                  printf("\nFile was flushed,
                          Press any key to quit:");
                  getch();
                  return 0;
               }
               void flush(FILE *stream)
               {  int duphandle;
                  /* сбрасывает внутренний буфер BC */
                  fflush(stream);
                  /* создает копию обработчика файла */
                  duphandle = dup(fileno(stream));
                  /* закрывает обработчик-копию,
                     чтобы сбросить буфер DOS */
                  close(duphandle);
               }

    fgetc
──────────────────────────────────────────────────────────────
Функция        Читает символ из потока вводы-вывода.

Синтаксис      #include <stdio.h>
               int fgetc(FILE *stream);

Прототип в     stdio.h

Примечания     Возвращает следующий символ из указанного вход-
               ного потока.

Значение       В случае  успешного завершения fgetc возвращает
               прочитанный символ,  преобразованный в тип  int
               без  расширения  знакового разряда.  При ошибке
               или достижении конца файла он возвращает EOF.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      fgetchar, fputc,  getc, getch, getchar, getche,
               ungetc, ungetch

Пример         #include <string.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {  FILE *stream;
                  char string[] = "This is a test";
                  char ch;
                  /* открывает файл для корректировки */
                  stream = fopen("DUMMY.FIL", "w+");
                  /* пишет строку в файл */
                  fwrite(string, strlen(string), 1, stream);
                  /* позиционирует файл в начало */
                  fseek(stream, 0, SEEK_SET);
                  do {
                     /* читает символ из файла */
                     ch = fgetc(stream);
                     /* отображает символ */
                     putch(ch);
                  } while (ch != EOF);
                  fclose(stream);
                  return 0;
               }

     fgetchar
──────────────────────────────────────────────────────────────
Функция        Читает символ из stdin.

Синтаксис      #include <stdio.h>
               int fgetchar(void);

Прототип в     stdio.h

Примечания     Возвращает следующий символ из stdin.  Он опре-
               делен как fgetc(stdin).

Значение       В случае  успешного завершения fgetchar возвра-
               щает прочитанный символ,  преобразованный в тип
               int без расширения знакового разряда. При ошиб-
               ке или достижении  конца  файла  он  возвращает
               EOF.

Переносимость  Эта функция  доступна в системах UNIX.

См. также      fgetc, fputchar, getchar

Пример         #include <stdio.h>
               int main(void)
               {  char ch;
                  /* запрос ввода */
                  printf("Enter a character followed by
                         <Enter>: ");
                  /* читает символ из stdin */
                  ch = fgetchar();
                  /* отображение прочитанного */
                  printf("The character read is: '%c'\n",
                         ch);
                  return 0;
               }

   fgetpos
──────────────────────────────────────────────────────────────
Функция        Получает текущий указатель файла.

Синтаксис      #include <stdio.h>
               int fgetpos(FILE *stream, fpos_t *pos);

Прототип в     stdio.h

Примечания     Запоминает позицию указателя файла,  связанного
               с данным потоком ввода-вывода,  по адресу, ука-
               зываемому pos.  Точное значение указателя файла
               относится  к  внутренней кухне;  иными словами,
               оно безразлично для Ваших целей.
               Тип fpos_t определен в stdio.h как
                  typedef long fpos_t;

Значение       При успешном завершении возвращается 0.  В слу-
               чае  ошибки возвращается ненулевое значение,  и
               глобальная переменная errno  устанавливается  в
               значения EBADF или EINVAL.

Переносимость  Эта функция совместима с ANSI C.

См. также      fseek, fsetpos, ftell, tell

Пример         #include <string.h>
               #include <stdio.h>
               int main(void)
               {  FILE *stream;
                  char string[] = "This is a test";
                  fpos_t filepos;
                  /* открывает файл для корректировки */
                  stream = fopen("DUMMY.FIL", "w+");
                  /* пишет строку в файл */
                  fwrite(string, strlen(string), 1, stream);
                  /* получает позицию указателя файла */
                  fgetpos(stream, &filepos);
                  printf("The file pointer is at byte
                         %ld\n", filepos);
                  fclose(stream);
                  return 0;
               }

      fgets
──────────────────────────────────────────────────────────────
Функция        Читает строку из потока-ввода-вывода.

Синтаксис      #include <stdio.h>
               char *fgets(char *s, int n, FILE *stream);

Прототип в     stdio.h

Примечания     Читает символы из потока  stream  в  строку  s.
               Чтение завершается,  когда считаны n - 1 символ
               или символ конца строки. fgets сохраняет символ
               конца  строки в конце s.  В конец s добавляется
               также нуль-символ, чтобы пометить конец строки.

Значение       При успешном выполнении возвращается  указатель
               на строку s; в случае ошибки или при достижении
               конца файла возвращается NULL.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C. Она также определена в Kernighan
               & Ritchie.

См. также      cgets, fputs, gets

Пример         #include <string.h>
               #include <stdio.h>
               int main(void)
               {  FILE *stream;
                  char string[] = "This is a test";
                  char msg[20];
                  /* открывает файл для корректировки */
                  stream = fopen("DUMMY.FIL", "w+");
                  /* пишет строку в файл */
                  fwrite(string, strlen(string), 1, stream);
                  /* позиционирует файл в начало */
                  fseek(stream, 0, SEEK_SET);
                  /* читает строку из файла */
                  fgets(msg, strlen(string)+1, stream);
                  /* отображает строку */
                  printf("%s", msg);
                  fclose(stream);
                  return 0;
               }

   filelength
──────────────────────────────────────────────────────────────
Функция        Получает размер файла в байтах.

Синтаксис      #include <io.h>
               long filelength(int handle);

Прототип в     io.h

Примечания     Возвращает длину файла, связанного с handle.

Значение       При успешном  выполнении  возвращается значение
               длины файла в  байтах  типа  long.  При  ошибке
               возвращается  -1  и глобальная переменная errno
               устанавливается в значение
                  EBADF  Неверный номер файла

Переносимость  Эта функция доступна только в DOS.

См. также      fopen, lseek, open

Пример         #include <string.h>
               #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>
               #include <sys\stat.h>
               int main(void)
               {  int handle;
                  char buf[11] = "0123456789";
                  /* создает файл в 10 байт */
                  handle = open("DUMMY.FIL",
                   O_RDWR|O_CREAT|O_TRUNC, S_IREAD|S_IWRITE);
                  write(handle, buf, strlen(buf));
                  /* выводит размер файла */
                  printf("file length in bytes: %ld\n",
                          filelength(handle));
                  /* закрывает файл */
                  close(handle);
                  return 0;
               }

   fileno
──────────────────────────────────────────────────────────────
Функция        Получает номер обработчика файла.

Синтаксис      #include <stdio.h>
               int fileno(FILE *stream);

Прототип в     stdio.h

Примечания     fileno - это макро,  которое  возвращает  номер
               обработчика  файла  для  заданного  потока вво-
               да-вывода. Если поток stream имеет более одного
               обработчика, fileno возвращает обработчик, наз-
               наченный потоку при его первом открытии.

Значение       Номер обработчика файла,  связанный  с  потоком
               ввода-вывода stream.

Переносимость  Эта функция доступна в системах UNIX.

См. также      fdopen, fopen, freopen

Пример         #include <stdio.h>
               int main(void)
               {  FILE *stream;
                  int handle;
                  /* создает файл */
                  stream = fopen("DUMMY.FIL", "W");
                  /* получает номер обработчика файла,
                     связанного с потоком */
                  handle = fileno(stream);
                  /* выводит номер обработчика */
                  printf("handle number: %d\n", handle);
                  /* закрывает файл */
                  fclose(stream);
                  return 0;
               }

   fillellipse
──────────────────────────────────────────────────────────────
Функция        Рисует и закрашивает эллипс.

Синтаксис      #include <graphics.h>
               void far fillellipse(int x, int y,
                                 int xradius, int yradius);

Прототип в     graphics.h

Примечания     Рисует эллипс с центром в точке (x,  y) и гори-
               зонтальной и вертикальной полуосями  xradius  и
               yradius  соответственно и закрашивает его теку-
               щими цветом и шаблоном заполнения.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См. также      arc, circle, ellipse, getaspectratio, pieslice,
               setaspectratio

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy, i;
                  int xradius = 100, yradius = 50;
            /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  midx = getmaxx() /2;
                  midy = getmaxy() /2;
                  /* цикл по шаблонам заполнения */
                  for (i = EMPTY_FILL; i < USER_FILL; i++) {
                     /* установка шаблона */
                     setfillstyle(i, getmaxcolor());
                     /* рисование закрашенного эллипса */
                     fillellipse(midx, midy, xradius,yradius);
                     getch();
                  }
                  /* выход из графики */
                  closegraph();
                  return 0;
               }

     fillpoly
──────────────────────────────────────────────────────────────
Функция        Рисует и закрашивает многоугольник.

Синтаксис      #include <graphics.h>
               void far fillpoly(int numpoins,
                                 int far *polypoints);

Прототип в     graphics.h

Примечания     Рисует контур многоугольника с numpoints верши-
               нами текущим цветом и типом  линии(в  точности,
               как  это делает drawpoly),  а затем закрашивает
               его текущими цветом и шаблоном заполнения.
               polypoints указывает на  последовательность  из
               (numpoints  * 2) целых чисел.  Каждая пара дает
               x- и y-координаты вершины многоугольника.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      drawpoly, floodfill, graphresult, setfillstyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int i, maxx, maxy;
                  /* наш массив для ломаной */
                  int poly[8];
              /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  maxx = getmaxx();
                  maxy = getmaxy();
                  poly[0] = 20;         /* 1-я вершина */
                  poly[1] = maxy / 2;
                  poly[2] = maxx - 20;  /* 2-я вершина */
                  poly[3] = 20;
                  poly[4] = maxx - 50;  /* 3-я вершина */
                  poly[5] = maxy - 20;
                  /* 4-я вершина, fillpoly автоматически
                     замыкает ломаную */
                  poly[6] = maxx / 2;
                  poly[7] = maxy / 2;
                  /* цикл по шаблонам заполнения */
                  for (i = EMPTY_FILL; i < USER_FILL; i++) {
                     /* установка шаблона */
                     setfillstyle(i, getmaxcolor());
                     /* рисует заполненный многоугольник */
                     fillpoly(4, poly);
                     getch();
                  }
                  /* выход из графики */
                  closegraph();
                  return 0;
               }

    findfirst
──────────────────────────────────────────────────────────────
Функция        Ищет справочник на диске.

Синтаксис      #include <dir.h>
               #include <dos.h>
               int findfirst(const char *pathname,
                           struct ffblk *ffblk, int attrib);

Прототип в     dir.h

Примечания     Начинает поиск справочника, используя системную
               функцию DOS 0x4E.
               pathname - это строка,  содержащая необязатель-
               ный спецификатор устройства,  путь и имя файла.
               Имя файла может содержать символы шаблона (*  и
               ?). Если соответствующий файл найден, структура
               ffblk заполняется информацией по файлу из спра-
               вочника. Формат структуры ffblk:
               struct  ffblk {
                 char ff_reserved[21];/*зарезервировано DOS*/
                 char ff_attrib;       /* атрибут */
                 int ff_ftime;         /* время */
                 int ff_fdate;         /* дата */
                 long ff_fsize;        /* размер */
                 char ff_name[13];     /* имя файла */
               };
               attrib - байт атрибута файла  DOS,  может  быть
               одной  из  следующих  констант,  определенных в
               dos.h:
                  FA_RDONLY   Только для чтения
                  FA_HIDDEN   Скрытый
                  FA_SYSTEM   Системный
                  FA_LABEL    Метка тома
                  FA_DIREC    Справочник
                  FA_ARCH     Архив
               За дальнейшей информацией об этих атрибутах об-
               ратитесь к Вашему руководству по DOS.
               Заметим, что ff_ftime и ff_fdate содержат бито-
               вые поля для значений даты и времени. Структура
               этих полей определена DOS. Обе 16-битные струк-
               туры делятся на три поля.
                  ff_ftime:
               биты 0-4 Секунды,деленные на 2 (10-это 20 сек.)
               биты 5-10  Минуты
               биты 11-15 Часы
                  ff_fdate:
               биты 0-4   День
               биты 5-8   Месяц
               биты 9-15  Год, начиная с 1980 (9-это 1989 г.)
               Структура ftime, объявленная в io.h, использует
               битовые поля даты и времени аналогичной  струк-
               туры. См. gettime и settime.

Значение       При успешном обнаружении файла, соответствующе-
               го пути поиска pathname,  возвращается 0.  Если
               таковых файлов больше не  обнаружено,  или  имя
               файла содержит ошибку,  возвращается -1, и гло-
               бальная переменная errno устанавливается в зна-
               чение
                  ENOENT   Путь или имя файла не найден
               а глобальная переменная doserrno -  в  одно  из
               следующих значений:
                  ENOENT   Путь или имя файла не найден
                  ENMFILE  Больше файлов нет

Переносимость  Эта функция доступна только в DOS.

См. также      findnext

Пример         #include <stdio.h>
               #include <dir.h>
               int main(void)
               {  struct ffblk ffblk;
                  int done;
                  printf("Directory listing of *.*\n");
                  done = findfirst("*.*",&ffblk,0);
                  while (!done) {
                     printf("  %s\n", ffblk.ff_name);
                     done = findnext(&ffblk);
                  }
                  return 0;
               }

               Вывод программы:

               Directory listing of *.*
                 FINDFRST.C
                 FINDFRST.OBJ
                 FINDFRST.MAP
                 FINDFRST.EXE

    findnext
──────────────────────────────────────────────────────────────
Функция        Продолжает поиск, начатый findfirst.

Синтаксис      #include <dir.h>
               int findnext(struct ffblk *ffblk);

Прототип в     dir.h

Примечания     Используется для  обнаружения  последующих фай-
               лов, соответствующих пути pathname, заданному в
               findfirst. ffblk - это структура, уже заполнен-
               ная вызовом findfirst.  Она содержит информацию
               для  продолжения поиска.  Каждый вызов findnext
               возвращает одно имя файла,  пока не будут обна-
               ружены все файлы в справочнике, соответствующем
               pathname.

Значение       При успешном обнаружении файла, соответствующе-
               го пути поиска pathname,  возвращается 0.  Если
               таковых файлов больше не  обнаружено,  или  имя
               файла содержит ошибку,  возвращается -1, и гло-
               бальная переменная errno устанавливается в зна-
               чение
                  ENOENT   Путь или имя файла не найден
               а глобальная переменная doserrno -  в  одно  из
               следующих значений:
                  ENOENT   Путь или имя файла не найден
                  ENMFILE  Больше файлов нет

Переносимость  Эта функция доступна только в DOS.

См. также      findfirst

Пример         #include <stdio.h>
               #include <dir.h>
               int main(void)
               {  struct ffblk ffblk;
                  int done;
                  printf("Directory listing of *.*\n");
                  done = findfirst("*.*",&ffblk,0);
                  while (!done) {
                     printf("  %s\n", ffblk.ff_name);
                     done = findnext(&ffblk);
                  }
                  return 0;
               }

               Вывод программы:

               Directory listing of *.*
                 FINDFRST.C
                 FINDFRST.OBJ
                 FINDFRST.MAP
                 FINDFRST.EXE

   floodfill
──────────────────────────────────────────────────────────────
Функция        Закрашивает ограниченную область.

Синтаксис      #include <graphics.h>
               void far floodfill(int x, int y, int border);

Прототип в     graphics.h

Примечания
               Эта процедура   используется  для  закрашивания
               замкнутой  области  на  растровых  устройствах.
               Точка (x,y) является точкой затравки внутри за-
               полняемой области.  Область,  ограниченная цве-
               том, указанным в border, закрашивается текущими
               цветом и шаблоном заполнения.  Если точка  зат-
               равки  находится внутри области,  закрашивается
               внутренняя часть области; если вне - закрашива-
               ется   внешняя   часть   области.   Используйте
               fillpoly вместо  floodfill  везде,  где  только
               возможно,  для совместимости с будущими версия-
               ми.
         !!!   floodfill не работает с драйвером IBM-8514.

Значение       Если при закрашивании области возникает ошибка,
               graphresult возвращает значение -7.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает только с ПЭВМ IBM PC  и  совместимыми,
               оснащенными  дисплеем  с графическим адаптером.
               Эта функция не совместима с Windows.

См. также      drawpoly, fillpoly,   graphresult,    setcolor,
               setfillstyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {
                  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int maxx, maxy;
             /*инициализация графики и локальных переменных*/
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk) { /* ошибка */
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  maxx = getmaxx();
                  maxy = getmaxy();
                  /* выбирает цвет рисования */
                  setcolor(getmaxcolor());
                  /* выбирает цвет заполнения */
                  setfillstyle(SOLID_FILL, getmaxcolor());
                  /* рисует бордюр вокруг экрана */
                  rectangle(0, 0, maxx, maxy);
                  /* рисует несколько окружностей */
                  circle(maxx / 3, maxy /2, 50);
                  circle(maxx / 2, 20, 100);
                  circle(maxx-20, maxy-50, 75);
                  circle(20, maxy-20, 25);
                  /* ожидает ввода с клавиатуры */
                  getch();
                  /* закрашивает ограниченную область */
                  floodfill(2, 2, getmaxcolor());
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

       floor
──────────────────────────────────────────────────────────────
Функция        Округляет по недостатку.

Синтаксис      #include <math.h>
               double floor(double x);

Прототип в     math.h

Примечания     Находит максимальное целое, не превышающее x.

Значение       Найденное целое типа double.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      ceil, fmod

Пример         #include <stdio.h>
               #include <math.h>
               int main(void)
               {
                  double number = 123.54;
                  double down, up;
                  down = floor(number);
                  up = ceil(number);
                  printf("original number     %10.2lf\n",
                         number);
                  printf("number rounded down %10.2lf\n",
                         down);
                  printf("number rounded up   %10.2lf\n",
                         up);
                  return 0;
               }

    flushall
──────────────────────────────────────────────────────────────
Функция        Очищает все потоки.

Синтаксис      #include <stdio.h>
               int flushall(void);

Прототип в     stdio.h

Примечания     Очищает все буфера, связанные с открытыми вход-
               ными потоками, и записывает все буфера, связан-
               ные с открытыми  выходными  потоками,  в  соот-
               ветствующие файлы.  Любая операция чтения, сле-
               дующая за flushall, читает новые данные в буфе-
               ра из входных файлов. После выполнения flushall
               потоки остаются открытыми.

Значение       Число открытых входных и выходных потоков.

Переносимость  Эта функция доступна в системах UNIX.

См. также      fclose, fcloseall, fflush

Пример         #include <stdio.h>
               int main(void)
               {
                  FILE *stream;
                  /* открывает файл */
                  stream = fopen("DUMMY.FIL", "w");
                  /* очищает все открытые потоки */
                  printf("%d streams were flushed.\n",
                         flushall());
                  /* закрывает файл */
                  fclose(stream);
                  return 0;
               }

     _fmemccpy
──────────────────────────────────────────────────────────────
     См. memccpy.

     _fmemchr
──────────────────────────────────────────────────────────────
     См. memchr.

     _fmemcmp
──────────────────────────────────────────────────────────────
     См. memcmp.

     _fmemcpy
──────────────────────────────────────────────────────────────
     См. memcpy.

     _fmemicmp
──────────────────────────────────────────────────────────────
     См. memicmp.

     _fmemset
──────────────────────────────────────────────────────────────
     См. memset.

     fmod
──────────────────────────────────────────────────────────────
Функция        Вычисляет x mod y.

Синтаксис      #include <math.h>
               double fmod(double x, double y);

Прототип в     math.h

Примечания
               Вычисляет остаток  f  - число,  удовлетворяющее
               условию x = ay + f, где a-целое,  и 0 <= f < y.

Значение       Остаток f. Если y = 0, возвращается 0.

Переносимость  Эта функция совместима с ANSI C.

См. также      ceil, floor, modf

Пример         #include <stdio.h>
               #include <math.h>
               int main(void)
               {
                  double x = 5.0, y = 2.0;
                  double result;
                  result = fmod(x,y);
                  printf("The remainder of (%lf / %lf) is
                          %lf\n", x, y, result);
                  return 0;
               }

   fnmerge
──────────────────────────────────────────────────────────────
Функция        Строит путь из отдельных компонент.

Синтаксис      #include <dir.h>
               void fnmerge(char *path, const char *drive,
                         const char *dir, const char *name,
                         const char *ext);

Прототип в     dir.h

Примечания     Пример: путь X:\DIR\SUBDIR\NAME.EXT строится из
                  drive = X:
                  dir   = \DIR\SUBDIR\
                  name  = NAME
                  ext   = .EXT
               fnmerge предполагает,  что  в  path  достаточно
               места  для  имени  пути.  Максимально возможная
               длина пути содержится в константе MAXPATH,  оп-
               ределенной в dir.h.
               fnmerge и  fnsplit  взаимно  обратны:  если  Вы
               расщепляете  данный путь path с помощью fnsplit
               и применяете к полученным компонентам  fnmerge,
               Вы получаете снова path.

Значение       Нет.

Переносимость  Эта функция доступна только в DOS.

См. также      fnsplit

Пример         #include <string.h>
               #include <stdio.h>
               #include <dir.h>
               int main(void)
               {
                   char s[MAXPATH];
                   char drive[MAXDRIVE];
                   char dir[MAXDIR];
                   char file[MAXFILE];
                   char ext[MAXEXT];
                   /* получает текущий справочник */
                   getcwd(s,MAXPATH);
                   /* добавляет в конец символ \ */
                   strcat(s,"\\");
                   /* расщепляет строку на элементы */
                   fnsplit(s,drive,dir,file,ext);
                   strcpy(file,"DATA");
                   strcpy(ext,".TXT");
                   /* сливает элементы в строку */
                   fnmerge(s,drive,dir,file,ext);
                   /* отображает результат */
                   puts(s);
                   return 0;
               }

   fnsplit
──────────────────────────────────────────────────────────────
Функция        Расщепляет полное имя пути на его компоненты.

Синтаксис      #include <dir.h>
               int fnsplit(const char *path, char *drive,
                           char *dir, char *name, char *ext);

Прототип в     dir.h

Примечания     Строка path  интерпретируется  как  полное  имя
               файла вида:  X:\DIR\SUBDIR\NAME.EXT и расщепля-
               ется на четыре компонента, которые записываются
               в строки,  указываемые drive,  dir, name и ext.
               (Указатели на все компоненты должны присутство-
               вать,  однако некоторые или все  из  них  могут
               быть NULL, и в этом случае соответствующий ком-
               понент будет выделен, но никуда не записан).
               Максимальные размеры этих строк заданы констан-
               тами MAXDRIVE, MAXPATH, MAXFILE и MAXEXT (опре-
               делены в dir.h) с учетом завершающего нуль-сим-
               вола.
               ───────────────────────────────────────────────
               Константа  Максимум     Строка
               ───────────────────────────────────────────────
               MAXPATH     (80)      path
               MAXDRIVE    (3)       drive; включая ":"
               MAXDIR      (66)      dir;   включая все "\"
               MAXFILE     (9)       name
               MAXEXT      (5)       ext;   включая "."
               ───────────────────────────────────────────────
               fnsplit предполагает,  что  имеется  достаточно
               места для записи каждого непустого компонента.
               Когда fnsplit расщепляет path, знаки пунктуации
               интерпретируются так:
               - drive включает ":" (С:, А:, и т.п).
               - dir включает все "\".
               - name включает имя файла.
               - ext включает точку,  предшествующую  расшире-
               нию.
               fnmerge и  fnsplit  взаимно  обратны:  если  Вы
               расщепляете  данный путь path с помощью fnsplit
               и применяете к полученным компонентам  fnmerge,
               Вы получаете снова path.

Значение       Возвращает целое (составленное из 5 флагов, оп-
               ределенных в dir.h),  указывающее, какие компо-
               ненты представлены в path.  Флаги и компоненты,
               представляемые ими:
                   EXTENSION     Расширение
                   FILENAME      Имя файла
                   DIRECTORY     Справочник
                   DRIVE         Устройство
                   WILDCARDS     Символы шаблона (* или ?)

Переносимость  Эта функция доступна только в DOS.

См. также      fnmerge

Пример         #include <stdlib.h>
               #include <stdio.h>
               #include <dir.h>
               int main(void)
               {   char *s;
                   char drive[MAXDRIVE];
                   char dir[MAXDIR];
                   char file[MAXFILE];
                   char ext[MAXEXT];
                   int flags;
                   /* получает переменную среды comspec */
                   s=getenv("COMSPEC");
                   flags=fnsplit(s,drive,dir,file,ext);
                   printf("Command processor info:\n");
                   if (flags & DRIVE)
                      printf("\tdrive: %s\n",drive);
                   if (flags & DIRECTORY)
                      printf("\tdirectory: %s\n",dir);
                   if (flags & FILENAME)
                      printf("\tfile: %s\n",file);
                   if (flags & EXTENSION)
                      printf("\textension: %s\n",ext);
                   return 0;
               }

    fopen
──────────────────────────────────────────────────────────────
Функция        Открывает поток ввода-вывода.

Синтаксис      #include <stdio.h>
               FILE *fopen(const char *filename,
                           const char *mode);

Прототип в     stdio.h

Примечания     Открывает файл filename и связывает с ним поток
               ввода-вывода. Возвращает указатель, который мо-
               жет быть использован для идентификации потока в
               последующих операциях.
               Строка mode должна иметь одно из следующих зна-
               чений:
               ───────────────────────────────────────────────
               Mode Описание
               ───────────────────────────────────────────────
               r  Открыть для чтения.
               w
               Создать для  записи.  Если  файл с таким именем
               уже существует, он будет перезаписан.
               a
               Добавить; открывает для записи  в  конец  файла
               или создает для записи, если файла не существу-
               ет.
               r+
               Открыть существующий  файл  для   корректировки
               (чтения и записи).
               w+
               Создать новый  файл для корректировки (чтения и
               записи). Если файл с таким именем уже существу-
               ет, он будет перезаписан.
               a+
               Открыть для добавления; открывает для корректи-
               ровки (чтения и записи) в конец файла, или соз-
               дает, если файла не существует.
               ───────────────────────────────────────────────
               Чтобы указать,  что файл должен быть открыт или
               создан в текстовом режиме,  добавьте t к значе-
               нию строки mode (rt,  w+t и т.д.);  аналогично,
               для указания двоичного  режима,  добавьте  b  в
               строку mode (wb, a+b и т.д.).
               Если ни t, ни b не указаны в строке mode, режим
               определяется глобальной переменной _fmode. Если
               _fmode установлена в O_BINARY, файлы будут отк-
               рываться как двоичные.  Если _fmode установлена
               в O_TEXT,  файлы будут открываться как  тексто-
               вые. Эти O_... константы определены в fcntl.h.
               Когда файл  открывается  для  корректировки,  и
               ввод,  и  вывод  могут  осуществляться  в соот-
               ветствующем потоке.  Однако, вывод не может не-
               посредственно  следовать за вводом без промежу-
               точных обращений к fseek или rewind,  и ввод не
               может  непосредственно следовать за выводом без
               промежуточных обращений к fseek или rewind, или
               ввода, который обнаруживает конец файла.

Значение       При успешном завершении fopen возвращает указа-
               тель на вновь открытый поток.  При ошибке возв-
               ращается NULL.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она определена в Kernighan &
               Ritchie.

См. также      creat, dup, fclose, fdopen, ferror, _fmode(гло-
               бальная  переменная),  fread,  freopen,  fseek,
               fwrite, open, rewind, setbuf, setmode

Пример         /* Программа создает копию autoexec.bat */
               #include <stdio.h>
               int main(void)
               {  FILE *in, *out;
                if ((in = fopen("\\AUTOEXEC.BAT", "rt"))
                    == NULL)
                {fprintf(stderr,"Cannot open input file.\n");
                   return 1;
                }
                if ((out = fopen("\\AUTOEXEC.BAK", "wt"))
                    == NULL)
                {fprintf(stderr,"Cannot open output file.\n");
                   return 1;
                }
                while (!feof(in))
                   fputc(fgetc(in), out);
                fclose(in);
                fclose(out);
                return 0;
               }

      FP_OFF
──────────────────────────────────────────────────────────────
Функция        Получает смещение дальнего адреса.

Синтаксис      #include <dos.h>
               unsigned FP_OFF(void far *p);

Прототип в     dos.h

Примечания     FF_OFF - макро, которое может быть использовано
               для  получения или установки смещения для даль-
               него указателя *p.

Значение       Значение типа unsigned,  представляющее  смеще-
               ние.

Переносимость  Эта функция доступна только в DOS.

См. также      FP_SEG, MK_FP, movedata, segread

Пример         #include <dos.h>
               #include <stdio.h>
               int main(void)
               {  char *str = "fpoff.c";
                  printf("The offset of this string
                        in memory is: %Fp\n", FP_OFF(str));
                  return 0;
               }

               Вывод программы

               The offset of this string in memory is: FF02

      _fpreset
──────────────────────────────────────────────────────────────
Функция        Переустановка пакета работы с плавающей точкой.

Синтаксис      #include <float.h>
               void _fpreset(void);

Прототип в     float.h

Примечания     Эта функция   обычно   используется   вместе  с
               system, exec... или spawn... функциями.
               В среде DOS, если в программе используется соп-
               роцессор  80x87,  дочерний процесс (выполняемый
               посредством system,  exec... или spawn... функ-
               ций)  может  изменить состояние плавающей точки
               родительского процесса.
               При использовании  80x87  принимайте  следующие
               меры предосторожности:
               - Не  вызывайте  функции  system,  exec...  или
               spawn во время вычисления выражений с плавающей
               точкой.
               - Вызывайте _fpreset для переустановки  состоя-
               ния плавающей точки после использования функций
               system,  exec...  или spawn...,  если есть хоть
               малейшая вероятность того, что порожденный про-
               цесс производил операции с плавающей точкой  на
               сопроцессоре 80x87.

Значение       Нет.

Переносимость  Эта функция доступна только в DOS.

См. также      _clear87, _control87,    exec...,     spawn...,
               _status87, system

Пример         #include <stdio.h>
               #include <float.h>
               #include <setjmp.h>
               #include <signal.h>
               #include <process.h>
               #include <conio.h>
               jmp_buf reenter;
               /* определение обработчика для ошибок
                  с плавающей точкой */
               void float_trap(int sig)
               {  printf("Trapping floating point error,");
                  printf("signal is %d\n",sig);
                  printf("Press a key to continue\n");
                  getch();
               /* переустановка 8087 или эмулятора */
                  _fpreset();
               /* возврат в место ошибки */
                  longjmp(reenter, -1);
               }
               int main(void)
               {  float one = 3.14, two = 0.0;
                 if (signal(SIGFPE, float_trap) == SIG_ERR)
                 {printf("error installing signal handler\n");
                     exit(3);
                  }
                  printf("Generating a math error,");
                  printf("press a key\n");
                  getch();
                  if (setjmp(reenter) == 0)
                     one /= two;
                  printf("Returned from signal trap\n");
                  return 0;
               }

   fprintf
──────────────────────────────────────────────────────────────
Функция        Форматированный вывод в поток ввода-вывода.

Синтаксис      #include <stdio.h>
               int fprint(FILE *stream, const char *format
                          [, argument, ...]);

Прототип в     stdio.h

Примечания     fprintf принимает  последовательность  аргумен-
               тов,  форматирует каждый из них в  соответствии
               со спецификацией формата, передаваемой в строке
               формата, на которую указывает format, и выводит
               сформатированные  данные  в  поток.  Количество
               спецификаций формата должно совпадать  с  коли-
               чеством аргументов.

Значение       Возвращается число выведенных байтов.  В случае
               ошибки возвращается EOF.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie.

См. также      cprintf, fscanf, printf, putc, sprintf

Пример         #include <stdio.h>
               int main(void)
               {  FILE *stream;
                  int i = 100;
                  char c = 'C';
                  float f = 1.234;
                  /* открывает файл для корректировки */
                  stream = fopen("DUMMY.FIL", "w+");
                  /* пишет данные в файл */
                  fprintf(stream, "%d %c %f", i, c, f);
                  /* закрывает файл */
                  fclose(stream);
                  return 0;
               }

    FP_SEG
──────────────────────────────────────────────────────────────
Функция        Получает сегмент дальнего адреса.

Синтаксис      #include <dos.h>
               unsigned FP_SEG(void far *p);

Прототип в     dos.h

Примечания     FF_OFF - макро, которое может быть использовано
               для  получения или установки сегмента для даль-
               него указателя *p.

Значение       Значение типа unsigned, представляющее сегмент.

Переносимость  Эта функция доступна только в DOS.

См. также      FP_OFF, MK_FP, movedata, segread

Пример         #include <dos.h>
               #include <stdio.h>

               int main(void)
               {  char *filename = "fpseg.c";
                  printf("The offset of this string
                    in memory is: %Fp\n", FP_SEG(filename));
                  return(0);
               }

    fputc
──────────────────────────────────────────────────────────────
Функция        Выводит символ в поток ввода-вывода.

Синтаксис      #include <stdio.h>
               int fputc(int c, FILE *stream);

Прототип в     stdio.h

Примечания     Выводит символ c в указанный поток.

Значение       В случае  успешного  завершения возвращается c;
               при ошибке возвращается EOF.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      fgetc, putc

Пример         #include <stdio.h>
               int main(void)
               {  char msg[] = "Hello world";
                  int i = 0;
                  while (msg[i]) {
                     fputc(msg[i], stdout);
                     i++;
                  }
                  return 0;
               }

    fputchar
──────────────────────────────────────────────────────────────
Функция        Выводит символ на stdout.

Синтаксис      #include <stdio.h>
               int fputchar(int c);

Прототип в     stdio.h

Примечания     Выводит символ c на stdout. fputchar(c) - то же
               самое, что fputc(c, stdout).

Значение       В случае успешного завершения  возвращается  c;
               при ошибке возвращается EOF.

Переносимость  Эта функция доступна в системах UNIX.

См. также      fgetchar, putchar

Пример         #include <stdio.h>
               int main(void)
               {  char msg[] = "This is a test";
                  int i = 0;
                  while (msg[i]) {
                     fputchar(msg[i]);
                     i++;
                  }
                  return 0;
               }

   fputs
──────────────────────────────────────────────────────────────
Функция        Выводит  строку в поток ввода-вывода.

Синтаксис      #include <stdio.h>
               int fputs(const char *s, FILE *stream);

Прототип в     stdio.h

Примечания     Выводит строку s,  завершаемую нуль-символом, в
               данный выходной поток;  символ конца строки  не
               добавляется, и завершающий нуль-символ не копи-
               руется.

Значение       При успешном выполнении возвращается  последний
               записанный символ; в случае ошибки возвращается
               EOF.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie.

См. также      fgets, gets, puts

Пример         #include <stdio.h>
               int main(void)
               {  /* пишет строку на стандартный вывод */
                  fputs("Hello world\n", stdout);
                  return 0;
               }

   fread
──────────────────────────────────────────────────────────────
Функция        Читает данные из потока.

Синтаксис      #include <stdio.h>
               size_t fread(void *ptr, size_t size,
                            size_t n, FILE *stream);

Прототип в     stdio.h

Примечания     Читает n  элементов  данных по size байт каждый
               из заданного входного потока в блок,  указывае-
               мый ptr. Общее число читаемых байтов равно (n *
               size).

Значение       При успешном  завершении   возвращается   число
               действительно  считанных  элементов (не байт!).
               При ошибке или достижении конца файла возвраща-
               ется   усеченное  значение  счетчика  элементов
               (возможно, 0).

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      fopen, fwrite, printf, read

Пример         #include <string.h>
               #include <stdio.h>
               int main(void)
               {  FILE *stream;
                  char msg[] = "this is a test";
                  char buf[20];
                  if ((stream = fopen("DUMMY.FIL", "w+"))
                       == NULL)
                  {  fprintf(stderr,
                             "Cannot open output file.\n");
                     return 1;
                  }
                  /* пишет данные в файл */
                  fwrite(msg, strlen(msg)+1, 1, stream);
                  /* позиционирует в начало файла */
                  fseek(stream, SEEK_SET, 0);
                  /* читает и отображает данные */
                  fread(buf, strlen(msg)+1, 1, stream);
                  printf("%s\n", buf);
                  fclose(stream);
                  return 0;
               }

     free
──────────────────────────────────────────────────────────────
Функция        Освобождает ранее распределенный блок.

Синтаксис      #include <alloc.h>
               void free(void *block);

Прототип в     stdlib.h, alloc.h

Примечания     Освобождает блок  памяти,  распределенный пред-
               шествующим вызовом calloc, malloc или realloc.

Значение       Нет.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См. также      calloc, freemem, malloc, realloc, strdup

Пример         #include <string.h>
               #include <stdio.h>
               #include <alloc.h>
               int main(void)
               {  char *str;
                  /* распределяет память для строки */
                  str = malloc(10);
                  /* копирует "Hello" в строку */
                  strcpy(str, "Hello");
                  /* отображает строку */
                  printf("String is %s\n", str);
                  /* освобождает память */
                  free(str);
                  return 0;
               }

     freemem
──────────────────────────────────────────────────────────────
Функция        Освобождает ранее  распределенный  блок  памяти
               DOS.

Синтаксис      #include <dos.h>
               int freemem(unsigned segx);

Прототип в     dos.h

Примечания     Освобождает блок  памяти,  распределенный пред-
               шествующим вызовом allocmem.  segx - адрес сег-
               мента данного блока.

Значение       При успешном выполнении возвращается 0.  В слу-
               чае ошибки возвращается -1,  и глобальная пере-
               менная errno устанавливается в значение
                  ENOMEM  Недостаточно памяти

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См. также      allocmem, free

Пример         #include <dos.h>
               #include <alloc.h>
               #include <stdio.h>
               int main(void)
               {  unsigned int size, segp;
                  int stat;
                  size = 64; /* (64 x 16) = 1024 байта */
                  stat = allocmem(size, &segp);
                  if (stat == -1)
                     printf("Allocated memory at segment:
                            %x\n", segp);
                  else
                     printf("Failed: maximum number of
                            paragraphs available is %u\n",
                            stat);
                  freemem(segp);
                  return 0;
               }

   freopen
──────────────────────────────────────────────────────────────
Функция        Связывает новый файл с  открытым  потоком  вво-
               да-вывода.

Синтаксис      #include <stdio.h>
               FILE *freopen(const char *filename,
                             const char *mode, FILE *stream);

Прототип в     stdio.h

Примечания     Переназначает открытый поток на указанный файл.
               Предварительно поток закрывается.  Эта  функция
               полезна  для переопределения stdin,  stdout или
               stderr.
               Строка mode должна иметь одно из следующих зна-
               чений:
               r  Открыть для чтения.
               w
               Создать для записи.  Если файл с  таким  именем
               уже существует, он будет перезаписан.
               a
               Добавить; открывает  для  записи  в конец файла
               или создает для записи, если файла не существу-
               ет.
               r+
               Открыть существующий   файл  для  корректировки
               (чтения и записи).
               w+
               Создать новый файл для корректировки (чтения  и
               записи). Если файл с таким именем уже существу-
               ет, он будет перезаписан.
               a+
               Открыть для добавления; открывает для корректи-
               ровки (чтения и записи) в конец файла, или соз-
               дает, если файла не существует.
               Чтобы указать,  что файл должен быть открыт или
               создан в текстовом режиме,  добавьте t к значе-
               нию строки mode (rt,  w+t и т.д.);  аналогично,
               для указания двоичного  режима,  добавьте  b  в
               строку mode (wb, a+b и т.д.).
               Если ни t, ни b не указаны в строке mode, режим
               определяется глобальной переменной _fmode. Если
               _fmode установлена в O_BINARY, файлы будут отк-
               рываться как двоичные.  Если _fmode установлена
               в O_TEXT,  файлы будут открываться как  тексто-
               вые. Эти O_... константы определены в fcntl.h.
               Когда файл  открывается  для  корректировки,  и
               ввод,  и  вывод  могут  осуществляться  в соот-
               ветствующем потоке.  Однако, вывод не может не-
               посредственно  следовать за вводом без промежу-
               точных обращений к fseek или rewind,  и ввод не
               может  непосредственно следовать за выводом без
               промежуточных обращений к fseek или rewind, или
               ввода, который обнаруживает конец файла.

Значение       При успешном завершении freopen возвращает  ар-
               гумент stream. При ошибке возвращается NULL.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      fclose, fdopen, fopen, open, setmode

Пример         #include <stdio.h>
               int main(void)
               {  /* переназначает стандартный вывод в файл */
                  if (freopen("OUTPUT.FIL", "w", stdout)
                      == NULL)
                     fprintf(stderr, "error redirecting
                             stdout\n");
                  /* вывод в файл */
                  printf("This will go into a file.");
                  /* закрывает стандартный выходной поток */
                  fclose(stdout);
                  return 0;
               }

     frexp
──────────────────────────────────────────────────────────────
Функция        Разбивает число типа double на мантиссу и поря-
               док.

Синтаксис      #include <math.h>
               double frexp(double x, int *exponent);

Прототип в     math.h

Примечания     Вычисляет мантиссу m типа double ( 0.5 <=  m  <
               1)  и  целое n такие,  что x (исходное значение
               типа double) равно m * (2**n).  Записывает n по
               адресу, на который указывает exponent.
               Обработка ошибок  для  этой  функции может быть
               модифицирована посредством функции matherr.

Значение       Мантисса m.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      exp, ldexp

Пример         #include <math.h>
               #include <stdio.h>
               int main(void)
               {  double mantissa, number;
                  int exponent;
                  number = 8.0;
                  mantissa = frexp(number, &exponent);
                  printf("The number %lf is ", number);
                  printf("%lf times two to the ", mantissa);
                  printf("power of %d\n", exponent);
                  return 0;
               }

    fscanf
──────────────────────────────────────────────────────────────
Функция        Форматный ввод  из  потока ввода-вывода.

Синтаксис      #include <stdio.h>
               int fscanf(FILE *stream,
                          const char *format [, address,...]);

Прототип в     stdio.h

Замечания      fscanf посимвольно   читает  последовательность
               входных полей из  потока  ввода-вывода.  Каждое
               поле форматируется в соответствии со специфика-
               цией формата, передаваемой fscanf в строке фор-
               мата,  на  которую  указывает format.  Наконец,
               fscanf записывает форматированный ввод  по  ад-
               ресам, переданным в качестве аргументов, следу-
               ющих за format. Количество спецификаций формата
               и  адресов должно совпадать с количеством вход-
               ных полей.

               См. scanf для деталей о спецификаторах формата.
               scanf может прекратить обработку текущего  поля
               до достижения обычного символа конца поля (сим-
               вола-разделителя),  или вообще  завершиться  по
               различным причинам.

Значение       fscanf возвращает количество успешно  прочитан-
               ных,  преобразованных  и  записанных  в  память
               входных полей; возвращаемое значение не включа-
               ет прочитанные поля, которые не были записаны в
               память.
               Если scanf пытается  читать  за  концом  файла,
               возвращается EOF.
               Если ни одно поле не записано в память, возвра-
               щается 0.

Переносимость  Доступна в UNIX и совместима с ANSI C.

См. также      atof, cscanf,  fprintf, scanf, sscanf, vfscanf,
               vscanf, vsscanf

Пример         #include <stdlib.h>
               #include <stdio.h>
               int main(void)
               {  int i;
                  printf("Input an integer: ");
                  /* читает целое из стандартного
                     входного потока */
                  if (fscanf(stdin, "%d", &i))
                     printf("The integer read was: %i\n", i);
                  else {
                     fprintf(stderr, "Error reading an
                             integer from stdin.\n");
                     exit(1);
                  }
                  return 0;
               }

     fseek
──────────────────────────────────────────────────────────────
Функция        Перемещает указатель файла в потоке ввода-выво-
               да.

Синтаксис      #include <stdio.h>
               int fseek(FILE *stream,long offset,int whence);

Прототип в     stdio.h

Примечания     Устанавливает указатель файла, связанного с по-
               током   ввода-вывода  stream  в  новую  позицию
               (offset байтов от  позиции,  заданной  whence).
               Для потоков в  текстовом  режиме  offset  может
               быть 0 или значением, возвращаемым ftell.
               whence должно быть равно 0, 1 или 2; эти значе-
               ния  представлены тремя символическими констан-
               тами, определенными в stdio.h:
               ───────────────────────────────────────────────
                whence            Положение в файле
               ───────────────────────────────────────────────
                SEEK_SET   (0)    Начало файла
                SEEK_CUR   (1)    Текущая позиция
                SEEK_END   (2)    Конец файла
               ───────────────────────────────────────────────
               fseek игнорирует любой  символ,  вставленный  с
               помощью ungetc.
               fseek используется с потоковым  вводом-выводом;
               для ввода-вывода через обработчик файла исполь-
               зуйте lseek.
               Следующей после fseek операцией обработки файла
               может быть либо ввод либо вывод.

Значение       При успешном перемещении указателя возвращается
               0; при ошибке - ненулевое значение.
         !!!   fseek может вернуть 0, указывая на успешное пе-
               ремещение,  хотя в действительности это не так.
               Это происходит потому,  что DOS, которая факти-
               чески устанавливает указатель, не проверяет ре-
               зультат установки. fseek возвращает код ошибки,
               только если файл не открыт,  или устройство  не
               готово.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      fgetpos, fopen,  fsetpos, ftell, lseek, rewind,
               setbuf, tell

Пример         #include <stdio.h>
               long filesize(FILE *stream);
               int main(void)
               {  FILE *stream;
                  stream = fopen("MYFILE.TXT", "w+");
                  fprintf(stream, "This is a test");
                  printf("Filesize of MYFILE.TXT is
                         %ld bytes\n", filesize(stream));
                  return 0;
               }
               long filesize(FILE *stream)
               {  long curpos, length;
                  /* сохраняет текущую позицию файла */
                  curpos = ftell(stream);
                  /* ищет конец файла */
                  fseek(stream, 0L, SEEK_END);
                  /* получает текущее смещение в файле */
                  length = ftell(stream);
                  /* восстанавливает сохраненную позицию */
                  fseek(stream, curpos, SEEK_SET);
                  return length;
               }

      fsetpos
──────────────────────────────────────────────────────────────
Функция        Позиционирует указатель  файла  в  потоке  вво-
               да-вывода.

Синтаксис      #include <stdio.h>
               int fsetpos(FILE *stream, const fpos_t *pos);

Прототип в     stdio.h

Примечания     Устанавливает указатель файла,  связанный с по-
               током stream,  в новую позицию. Новая позиция -
               это значение,  полученное при предыдущем вызове
               fgetpos для этого потока. Она также очищает ин-
               дикатор конца файла и отменяет  все  изменения,
               произведенные   посредством  ungetc.  Следующей
               после вызова fsetpos операцией  на  этом  файле
               может быть ввод или вывод.

Значение       В случае  успеха  возвращается  0.  При  ошибке
               возвращается ненулевое значение,  и  глобальная
               переменная  errno также устанавливается в нену-
               левое значение.

Переносимость  Эта функция совместима с ANSI C.

См. также      fgetpos, fseek, ftell

Пример         #include <stdlib.h>
               #include <stdio.h>
               void showpos(FILE *stream);
               int main(void)
               {  FILE *stream;
                  fpos_t filepos;
                  /* открывает файл для корректировки */
                  stream = fopen("DUMMY.FIL", "w+");
                  /* сохраняет позицию указателя файла */
                  fgetpos(stream, &filepos);
                  /* пишет данные в файл */
                  fprintf(stream, "This is a test");
                  /* показывает текущую позицию */
                  showpos(stream);
                  /*устанавливает и отображает новую позицию*/
                  if (fsetpos(stream, &filepos) == 0)
                    showpos(stream);
                  else {
                     fprintf(stderr, "Error setting file
                             pointer.\n");
                     exit(1);
                  }
                  /* закрывает файл */
                  fclose(stream);
                  return 0;
               }
               void showpos(FILE *stream) {
                  fpos_t pos;
                  /* отображает текущую позицию в потоке */
                  fgetpos(stream, &pos);
                  printf("File position: %ld\n", pos);
               }

      fstat
──────────────────────────────────────────────────────────────
Функция        Получает информацию об открытом файле.

Синтаксис      #include <sys\stat.h>
               int fstat(int handle, struct stat *statbuf);

Прототип в     sys\stat.h

Примечания     Помещает в структуру stat информацию об  откры-
               том файле или справочнике, связанном с handle .
               statbuf указывает на структуру stat (определен-
               ную в sys\stat.h). Структура содержит следующие
               поля:
               st_mode   Битовая маска режима открытия файла.
               st_dev
               Номер диска,  содержащего файл, или номер обра-
               ботчика файла, если файл - это устройство
               st_rdev   То же, что и st_dev.
               st_nlink  Установлено в 1.
               st_size   Размер открытого файла в байтах.
               st_atime  Время последней модификации файла.
               st_mtime  То же, что и st_atime.
               st_ctime  То же, что и st_atime.
               Структура stat содержит еще три  не  упомянутых
               здесь поля.  Они содержат значения,  которые не
               имеют смысла в среде DOS.
               Битовая маска  режима  открытия  файла включает
               следующие поля:
               Один из следующих битов будет установлен:
               S_IFCHR  Если handle указывает на устройство.
               S_IFREG  Если handle указывает на обычный файл.
               Один или оба из следующие битов будут  установ-
               лены:
               S_IWRITE
               Если пользователю разрешена запись в файл.
               S_IREAD
               Если пользователю разрешено чтение из файла.
               Битовая маска включает  также  биты  чтения/за-
               писи;  они установлены в соответствии с режимом
               доступа к файлу.

Значение       При успешном  получении информации возвращается
               0. В случае ошибки (информацию получить не уда-
               лось) возвращается -1,  и глобальная переменная
               errno устанавливается в значение
                  EBADF  Неверный номер обработчика файла

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      access, chmod, stat

Пример         #include <sys\stat.h>
               #include <stdio.h>
               #include <time.h>
               int main(void)
               {  struct stat statbuf;
                  FILE *stream;
                  /* открывает файл для корректировки */
                  if ((stream = fopen("DUMMY.FIL", "w+"))
                      == NULL)
                  {  fprintf(stderr, "Cannot open output
                             file.\n");
                     return(1);
                  }
                  fprintf(stream, "This is a test");
                  fflush(stream);
                  /* получает информацию о файле */
                  fstat(fileno(stream), &statbuf);
                  fclose(stream);
                  /* выводит информацию */
                  if (statbuf.st_mode & S_IFCHR)
                     printf("Handle refers to a device.\n");
                  if (statbuf.st_mode & S_IFREG)
                     printf("Handle refers to an ordinary
                            file.\n");
                  if (statbuf.st_mode & S_IREAD)
                     printf("User has read permission on
                            file.\n");
                  if (statbuf.st_mode & S_IWRITE)
                     printf("User has write permission on
                             file.\n");
                  printf("Drive letter of file: %c\n",
                         'A'+statbuf.st_dev);
                  printf("Size of file in bytes: %ld\n",
                         statbuf.st_size);
                  printf("Time file last opened: %s\n",
                         ctime(&statbuf.st_ctime));
                  return 0;
               }

     _fstrcat
──────────────────────────────────────────────────────────────
     См. strcat.

     _fstrchr
──────────────────────────────────────────────────────────────
     См. strchr.

     _fstrcspn
──────────────────────────────────────────────────────────────
     См. strcspn.

     _fstrdup
──────────────────────────────────────────────────────────────
     См. strdup.

     _fstricmp
──────────────────────────────────────────────────────────────
     См. stricmp.

     _fstrlen
──────────────────────────────────────────────────────────────
     См. strlen.

     _fstrlwr
──────────────────────────────────────────────────────────────
     См. strlwr.

     _fstrncat
──────────────────────────────────────────────────────────────
     См. strncat.

     _fstrncmp
──────────────────────────────────────────────────────────────
     См. strncmp.

     _fstrncpy
──────────────────────────────────────────────────────────────
     См. strncpy.

     _fstrnicmp
──────────────────────────────────────────────────────────────
     См. strnicmp.

     _fstrnset
──────────────────────────────────────────────────────────────
     См. strnset.

     _fstrpbrk
──────────────────────────────────────────────────────────────
     См. strpbrk.

     _fstrrchr
──────────────────────────────────────────────────────────────
     См. strrchr.

     _fstrrev
──────────────────────────────────────────────────────────────
     См. strrev.

     _fstrset
──────────────────────────────────────────────────────────────
     См. strset.

     _fstrspn
──────────────────────────────────────────────────────────────
     См. strspn.

     _fstrstr
──────────────────────────────────────────────────────────────
     См. strstr.

     _fstrtok
──────────────────────────────────────────────────────────────
     См. strtok.

     _fstrupr
──────────────────────────────────────────────────────────────
     См. strupr.

    ftell
──────────────────────────────────────────────────────────────
Функция        Возвращает текущий указатель файла.

Синтаксис      #include <stdio.h>
               long int ftell(FILE *stream);

Прототип в     stdio.h

Примечания     ftell возвращает текущий  указатель  файла  для
               потока ввода-вывода stream.
               Смещение измеряется  в  байтах  от начала файла
               (если файл двоичный).
               Значение, возвращаемое    ftell,   может   быть
               использовано в последующем вызове fseek.

Значение       При успешном  выполнении  возвращается  текущая
               позиция указателя файла.  В случае ошибки возв-
               ращается  -1L,  и  глобальная  переменная errno
               устанавливается в положительное значение.

Переносимость  Эта функция доступна во всех  системах  UNIX  и
               определена в ANSI C.

См. также      fgetpos, fseek, fsetpos, lseek, rewind, tell

Пример         #include <stdio.h>
               int main(void)
               {  FILE *stream;
                  stream = fopen("MYFILE.TXT", "w+");
                  fprintf(stream, "This is a test");
                  printf("The file pointer is at byte
                         %ld\n", ftell(stream));
                  fclose(stream);
                  return 0;
               }

      ftime
──────────────────────────────────────────────────────────────
Функция        Помещает текущее время в структуру timeb.

Синтаксис      #include <sys\timeb.h>
               void ftime(struct timeb *buf);

Прототип в     sys\timeb.h

Примечания     Определяет текущее   время   и  заполняет  поля
               структуры timeb,  указываемой посредством  buf.
               timeb содержит 4 поля:  time, millitm, timezone
               и dstflag:
                  struct timeb {
                    long time;
                    short millitm;
                    short timezone;
                    short dstflag;
                  };
               - time - время в секундах с 00:00:00  1  января
               1970 года по Гринвичу(GMT).
               - millitm - миллисекунды.
               - timezone  -  разница  в  минутах  между GMT и
               местным временем; возрастает в западном направ-
               лении.  ftime  получает  это поле из глобальной
               переменной  timezone,  которая  устанавливается
               tzset.
               - dstflag используется для  указания  необходи-
               мости учета летнего времени.
         !!!   ftime вызывает tzset. Поэтому нет необходимости
               вызывать  tzset  явно,  когда  Вы   используете
               ftime.

Значение       Нет.

Переносимость  Эта функция доступна в системах UNIX System 5.

См. также      asctime, ctime, gmtime, localtime, stime, time,
               tzset

Пример         #include <stdio.h>
               #include <stdlib.h>
               #include <time.h>
               #include <sys\timeb.h>
               /* стандартное тихоокеанское время
                  с учетом летнего времени */
               char *tzstr = "TZ=PST8PDT";
               int main(void)
               {  struct timeb t;
                  putenv(tzstr);
                  tzset();
                  ftime(&t);
                  printf("Seconds since 1/1/1970 GMT: %ld\n",
                         t.time);
                  printf("Thousandths of a second: %d\n",
                         t.millltm);
                  printf("Difference between local time
                          and GMT: %d\n", t.timezone);
                  printf("Daylight savings in effect (1)
                          not (0): %d\n", t.dstflag);
                  return 0;
               }

       fwrite
──────────────────────────────────────────────────────────────
Функция        Пишет данные в поток.

Синтаксис      #include <stdio.h>
               size_t fwrite(const void *ptr, size_t size,
                             size_t n, FILE *stream);

Прототип в     stdio.h

Примечания     Добавляет n  элементов данных по size байт каж-
               дый в заданный выходной файл.  ptr указывает на
               записываемые данные.
               Общее количество  записываемых байтов n * size.
               ptr описан как указатель на любой объект.

Значение       При успешном   выполнении   возвращается  число
               действительно  записанных  элементов  (не  бай-
               тов!).  В  случае ошибки возвращается усеченное
               значение счетчика элементов.

Переносимость  Эта функция доступна во всех  системах  UNIX  и
               определена в ANSI C.

См. также      fopen, fread

Пример         #include <stdio.h>
               struct mystruct
               { int i;
                 char ch;
               };
               int main(void)
               {  FILE *stream;
                struct mystruct s;
                /* открывает файл TEST.$$$ */
                if ((stream=fopen("TEST.$$$", "wb"))==NULL)
                {fprintf(stderr,"Cannot open output file.\n");
                   return 1;
                }
                s.i = 0;
                s.ch = 'A';
                /* пишет структуру s в файл */
                fwrite(&s, sizeof(s), 1, stream);
                /* закрывает файл */
                fclose(stream);
                return 0;
               }
