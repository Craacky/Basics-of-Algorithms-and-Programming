                           ГЛАВА 8.
                        ВИДЕОФУНКЦИИ.

     Borland C++ поставляется с полной библиотекой графических
функций. Эта глава в начале кратко описывает видеорежимы и ок-
на, затем она объясняет как программировать в текстовом и гра-
фическом режимах.
     Видеофункции Borland C++ подобны соответствующим програм-
мам Turbo Pascal.  Если Вы не знакомы с управлением видеорежи-
мов компьютера,  или созданием и управлением окон,  познакомь-
тесь с этой главой.

                         Видеорежимы.

     IBM PC имеет несколько разновидностей видеоадаптеров. Это
может  быть MDA для работы только с текстом или он может рабо-
тать с графикой,  например CGA, EGA или Hercules. Каждый адап-
тер  может  работать  в  нескольких  режимах;  режим указывает
сколько колонок будет выводиться на экране - 80 или 40 (только
в  текстовом режиме),  разрешение экрана (только в графическом
режиме) и тип вывода (цветной или черно-белый).
     Видеорежимы определяются,  когда  Ваша программа вызывает
одну из функций определения режима  (textmode,  initgraph  или
setgraphmode).
     - В текстовом режиме экран делится на элементы (80 или 40
колонок в ширину и 25,  43 или 50 строк по вертикали).  Каждый
элемент содержит атрибут и символ.  Символ - это выводимый  на
экран символ ASCII, а атрибут указывает, как должен выводиться
символ (его цвет,  интенсивность и  т.д.).  Borland  C++  пре-
доставляет полный набор программ для манипуляции текстовым эк-
раном, вывода текста на экран и управления атрибутами.
     - В  графическом режиме экран делится на пикселы;  каждый
пиксел отображает одну точку на экране. Число пикселов (разре-
шение) зависит от типа видеоадаптера и текущего режима. Вы мо-
жете использовать функции графической библиотеки  Borland  C++
для  работы  в графическом режиме:  Вы можете рисовать линии и
фигуры, заполнять замкнутые области шаблонами и управлять цве-
том каждого пиксела.
     В текстовых режимах верхний левый угол экрана - это пози-
ция  (1,1)  с  х-координатой,  увеличивающейся слева направо и
y-координатой,  увеличивающейся сверху вниз. В графических ре-
жимах верхний левый угол экрана - это позиция (0,0), а коорди-
наты х и y изменяются аналогично текстовому режиму.

                        Окна и поля вывода.

     Borland C++ предоставляет функции для создания и управле-
ния  окнами  на экране в текстовом режиме (и полями вывода или
окнами в графическом режиме).  Если Вы не знакомы с  окнами  и
полями вывода, Вы должны прочитать этот краткий обзор. Функции
управления окнами и полями вывода Borland C++ объяснены в раз-
делах  "Программирование в текстовом режиме" и "Программирова-
ние в графическом режиме".

                       Что такое окно?

     Окно - это прямоугольная область экрана,  когда он  нахо-
дится  в  текстовом режиме.  Когда программа выводит на экран,
этот вывод ограничен активным окном.  Оставшаяся часть  экрана
(вне окна) остается неизменной.
     По умолчанию окно - это полный экран.  Ваша программа мо-
жет изменить это текстовое окно по умолчанию на текстовое окно
меньшего размера (вызвав функцию window). Эта функция указыва-
ет позицию окна в координатах экрана.

                    Что такое поле вывода?

     В графическом  режиме Вы можете так же определить прямоу-
гольную область на Вашем экране - это поле вывода.  Когда гра-
фическая  программа  делает  вывод  на  экран,  то поле вывода
действует как виртуальный экран.  Оставшаяся часть экрана (вне
поля вывода) остается нетронутой. Вы определяете поле вывода в
терминах координат экрана, вызывая функцию setviewport.

                         Координаты.

     За исключением функций определения окон и  полей  вывода,
все  координаты  в функциях в текстовом или графическом режиме
задаются в значениях относительно окна или поля вывода, а не в
абсолютных экранных координатах. Верхний левый угол текстового
окна имеет координаты (1,1), а графического (0,0).

             Программирование в текстовом режиме.

     В этом разделе мы кратко опишем функции текстового  режи-
ма.  Более детальную информацию об этих функциях Вы можете по-
лучить в главе 2 "Библиотека времени  выполнения"  Справочного
руководства по библиотеке.
     В Borland C++ пакет прямого В/В на экран (cprintf,  cputs
и т.д.) обеспечивает высокопроизводительный вывод текста,  уп-
равление окнами, позиционирование курсора и управление атрибу-
тами.   Эти  функции  являются  частью  стандартных  библиотек
Borland C++; они имеют прототипы в файле заголовка conio.h.

                   Функции В/В на консоль.

     Функции текстового режима Borland C++ работают в любом из
6  возможных  текстовых  режимов.  Режимы,  доступные на Вашем
компьютере, зависят от используемого видеоадаптера и монитора.
Вы задаете текущий текстовый режим,  вызывая textmode. Мы объ-
ясняем как использовать эту функцию позже в  этой  главе  и  в
разделе  textmode в главе 1 Справочного руководства по библио-
теке.
     Функции текстового режима делятся на 5 групп:
     - Вывод и манипуляция текстом.
     - Управление окнами и режимами.
     - Управление атрибутами.
     - Запрос состояния.
     - Вид курсора.
     Мы опишем эти группы функций в следующих разделах.

                 Вывод и манипуляция текстом.

     Список функций вывода и манипуляции текстом:
     Вывод и чтение текста:
      cprintf Посылает форматированный вывод на экран.
      cputs   Посылает строку на экран.
      getche  Читает символ и отображает его на экране.
      putch   Выводит символ на экран.
     Манипуляция текстом (и курсором):
      clreol   Очищает от курсора до конца строки.
      clrscr   Очищает текстовое окно.
      delline  Удаляет строку, на которой стоит курсор.
      gotoxy   Позиционирует курсор.
      insline  Вставляет пустую строку под строкой с курсором.
      movetext Копирует текст из одной области экрана  в  дру-
               гую.
     Пересылка блоков текста в память и из памяти:
      gettext   Копирует текст с экрана в память.
      puttext   Копирует текст из памяти на экран.
     Программа, работающая  с  экраном,  начинает  работать  с
текстовым окном на весь экран по умолчанию так,  что Вы можете
сразу читать,  писать и манипулировать текстом без любых пред-
варительных установок режима.  Вы можете писать текст на экран
функциями: cprintf, cputs и puth и читать функцией getche. Пе-
ренос текста управляется глобальной переменной _wscroll.  Если
_wscroll = 1,  текст переносится на следующую строку со скрол-
лингом,  если необходимо. Если _wscroll = 0, текст переносится
на ту же строку. _wscroll = 1 по умолчанию.
     Когда текст выведен на экран, Вы можете очистить активное
окно  с  помощью  clrscr,  часть строки с clreol,  удалить всю
строку с помощью delline и вставить пустую  строку  с  помощью
insline. Последние 3 функции работают относительно текущей по-
зиции курсора.  Вы переводите курсор на требуемое положение  с
помощью gotoxy. Вы так же можете скопировать целый блок текста
из одной части окна в другую с помощью movetext.
     Вы можете  скопировать прямоугольный блок текста в память
с помощью gettext и поместить текст обратно на экран (в  любое
место) с помощью puttext.

                Управление окнами и режимами.

     Это выполняется двумя функциями:
       textmode Переводит экран в текстовый режим.
       window   Определяет окно в текстовом режиме.
     Вы можете установить Ваш экран в любой текстовый режим  с
помощью textmode (ограничивается только типом монитора и адап-
тера).  Она инициализирует экран как  полноэкранное  текстовое
окно в заданный режим и удаляет любой текст с экрана.
     Когда Ваш экран в текстовом режиме, Вы можете выводить на
весь экран, или можете установить часть экрана - окно, которое
ограничивает вывод Вашей программы.  Для  создания  текстового
окна Вы вызываете window, указывая координаты окна.

                      Управление атрибутами.

     Список функций управления атрибутами в текстовом режиме:
     Установка цвета фона и символов:
       textattr  Устанавливает цвет фона и символов.
       textbackground Устанавливает цвет фона.
       textcolor Устанавливает цвет символов.
     Изменение интенсивности:
       highvideo Устанавливает текст в высокую интенсивность.
       lowvideo  Устанавливает текст в низкую интенсивность.
       normvideo Устанавливает текст в исходную интенсивность.
     Функции управления  текущим атрибутом устанавливают атри-
бут,  представленный  8-битным  значением:  4   младших   бита
представляют  цвет  символа,  следующие  3  бита - цвет фона и
старший бит - это бит блинкования (мигания).
     Последующий вывод  текста использует эти атрибуты.  С по-
мощью функций управления атрибутами Вы можете установить  цвет
фона и символа отдельно (textbackground и textcolor),  или од-
новременно с помощью textattr.  Вы можете так же указать,  что
символ будет блинковать. Большинство цветных мониторов в цвет-
ном режиме будут выводить правильные цвета. Нецветные мониторы
могут  преобразовывать  некоторые или все атрибуты в различной
интенсивности или с помощью других визуальных эффектов,  таких
как другой тип шрифта, подчеркивание и т.д.
     Вы можете управлять  Вашим  компьютером,  отображая  цвет
символов  высокой  интенсивности  в  цвет  символов низкой ин-
тенсивности с помощью  lowvideo  (выключает  бит  высокой  ин-
тенсивности  для  символов)  или Вы можете отобразить низкоин-
тенсивные цвета в высокую интенсивность  с  помощью  highvideo
(включает  бит высокой интенсивности).  Вы можете восстановить
первоначальную интенсивность символов с помощью normvideo.

                      Запрос состояния.

     Функции запроса состояния:
     gettextinfo Заполняет  структуру  text_info информацией о
текущем окне.
     wherex Возвращает х-координату курсора.
     wherey Возвращает y-координату курсора.
     Функции В/В  на консоль Borland C++ позволяют запрашивать
информацию о текстовом окне и текущей позиции  курсора  внутри
окна.
     Функция gettextinfo заполняет структуру text_info  (опре-
деленную в conio.h) информацией:
     - текущий видеорежим.
     - позиция окна в абсолютных координатах экрана.
     - размер окна.
     - текущий цвет фона и символа.
     - текущая позиция курсора.
     Иногда Вам  необходима  только  часть этой информации.  В
этом случае Вы можете получить только позицию курсора (относи-
тельно окна) с помощью wherex и wherey.

                        Форма курсора.

     Вы можете использовать функцию _setcursortype,  чтобы из-
менить форму курсора.  Значение  _NOCURSOR  выключает  курсор;
_SOLIDCURSOR устанавливает большой курсор; _NORMALCURSOR уста-
навливает обычный курсор.

                       Текстовые окна.

     По умолчанию текстовое окно занимает полный экран; Вы мо-
жете  изменить размер окна,  вызвав функцию window.  Текстовое
окно может содержать до 50 строк и до 80 колонок.
     Начало координат текстового окна - это левый верхний угол
окна (1,1).  Координаты нижнего правого  угла  полного  экрана
(80,25).

                           Пример.

     Предположим, что  Ваш компьютер находится в 80-колоночном
текстовом режиме и Вы хотите создать окно.  Верхний левый угол
окна   будет  занимать  координату  (10,8),  а  нижний  правый
(50,21). Чтобы сделать это вызовите:
     window(10, 8, 50, 21);
     После того,  как Вы создали текстовое окно, Вы хотите пе-
редвинуть курсор на позицию окна (5,8) и вывести в него текст.
     gotoxy(5, 8);
     cputs("Happy Birthday, Frank Borland");
     Следующий рисунок иллюстрирует это.

                          Рис. 8.1.
                Окно в текстовом режиме 80х25.
        экран
        колонка 1
           │
экран     ╔╪══════════════════════════════════════════════════════╗
строка 1 ─╫┘                                                      ║
          ║                                                       ║
          ║                                                       ║
окно      ║                                                       ║
строка 1 ─╫─────── ╔═══════════════════════════════╗              ║
          ║        ║                               ║              ║
          ║        ║                               ║              ║
          ║        ║                               ║              ║
          ║        ║ Happy Birthday, Franc Borland ║              ║
          ║        ║                               ║              ║
окно      ║        ║                               ║              ║
строка 14─╫─────── ╚═══════════════════════════════╝              ║
          ║        │                               │              ║
          ║        │                               │      экран   ║
          ║        │                               │    строка 25┌╫
          ╚════════╪═══════════════════════════════╪═════════════╪╝
                   │                               │             │
                 окно                             окно        экран
               колонка 1                      колонка 41 колонка 80

                          Тип text_modes.

     С помощью функции textmode Вы можете установить  1  из  7
текстовых режимов. Перечислимый тип text_modes, определенный в
conio.h,  позволяет Вам использовать символические  имена  для
аргумента mode функции textmode.  Однако,  если Вы используете
символические константы, Вы должны поместить в код
     #include <conio.h>
     text_modes определяет значение:
──────────────────────────────────────────────────────────────
символическая     числовое           текстовый режим
  константа       значение
──────────────────────────────────────────────────────────────
 LASTMODE           -1          Предыдущий текстовый режим.
 BW40                0          Черно-белый, 40 колонок
 C40                 1          16 цветов, 40 колонок
 BW80                2          Черно-белый, 80 колонок
 C80                 3          16 цветов, 80 колонок
 MONO                7          Монохромный, 80 колонок
 C4350              64          EGA, 80x43; VGA, 80x50
──────────────────────────────────────────────────────────────
     Например, следующие вызовы textmode переводят цветной мо-
нитор в режимы:
     textmode(0)      Черно-белый, 40 колонок.
     textmode(BW80)   Черно-белый, 80 колонок.
     textmode(C40)    16 цветов, 40 колонок.
     textmode(3)      16 цветов, 80 колонок.
     textmode(7)      Монохромный 80 колонок.
     textmode(C4350)  EGA, 80x43; VGA, 80x50
     Используйте settextinfo  для  определения  числа строк на
экране после вызова textmode(C4350).

                            Цвет.

     Детальное описание размещения атрибутов приведено в  раз-
деле textattr главы 2 Справочного руководства по библиотеке.
     Когда символ занимает ячейку,  то цвет символа называется
основным; цвет  оставшейся  области ячейки называется фоновым.
Цветные мониторы с цветными видеоадаптерами  могут  отображать
до  16  различных цветов;  монохромные мониторы заменяют цвета
различными визуальными атрибутами (подсвечивание,  подчеркива-
ние и т.д.).
     Включаемый файл conio.h  определяет  символические  имена
для  различных  цветов.  Если Вы используете эти символические
константы, Вы должны включить conio.h в исходный код.
     Следующая таблица  приводит эти символические константы и
соответствующие числовые значения.  Заметим, что первые 8 цве-
тов  могут  использоваться  для фона,  для цвета символа могут
использоваться все 16 цветов.

                          Таблица 8.
──────────────────────────────────────────────────────────────
символическая константа   число          символ или фон?
──────────────────────────────────────────────────────────────
BLACK                       0                оба
BLUE                        1                оба
GREEN                       2                оба
CYAN                        3                оба
RED                         4                оба
MAGENTA                     5                оба
BROWN                       6                оба
LIGHTGRAY                   7                оба
DARKGRAY                    8                только символ
LIGHTBLUE                   9                только символ
LIGHTGREEN                 10                только символ
LIGHTCYAN                  11                только символ
LIGHTRED                   12                только символ
LIGHTMAGENTA               13                только символ
YELLOW                     14                только символ
WHITE                      15                только символ
BLINK                     128                только символ
──────────────────────────────────────────────────────────────
     Вы можете добавить символическую константу BLINK к  аргу-
менту  основного  цвета,  если хотите,  чтобы символ блинковал
(мигал).

                Высокопроизводительный вывод.

     Пакет В/В  на  консоль  Borland  C++  включает переменную
directvideo.  Эта переменная управляет, будет ли программа вы-
водить  на  консоль прямо через видеопамять (directvideo = 1),
или через вызовы BIOS (directvideo = 0).
     Значение directvideo по умолчанию = 1. В общем случае вы-
вод через видеопамять гораздо быстрее,  но требует,  чтобы Ваш
компьютер  был 100%  совместим с IBM PC:  Ваша видеоаппаратура
должна быть идентичной  дисплейным  адаптерам  IBM.  Установка
directvideo = 0 позволяет работать на любой машине с совмести-
мой BIOS, но вывод на консоль будет медленнее.

            Программирование в графическом режиме.

     В этом разделе мы кратко опишем функции, которые Вы може-
те использовать в графическом режиме. Более детальная информа-
ция по этим функциям предоставлена в главе 2 Справочного руко-
водства по библиотеке.
     Borland C++ предоставляет отдельную  библиотеку  с  более
чем  70  функциями,  начиная  от  высокоуровневых  (таких  как
setviewport,  bar3d, drawpoly) до побитовых функций (таких как
gеtimage,  putimage). Графическая библиотека поддерживает мно-
гочисленные стили линий и заполнения, и предоставляет несколь-
ко текстовых шрифтов, которые Вы можете масштабировать, вырав-
нивать и ориентировать вертикально или горизонтально.
     Эти функции  находятся  в  библиотеке GRAPHICS.LIB,  а их
прототипы в файле заголовка graphics.h.  В дополнение  к  этим
двум  файлам,  графический пакет включает драйверы графических
устройств (файлы *.BGI) и  штриховые  шрифты  символов  (файлы
*.CHR); мы обсудим эти файлы в следующих разделах.
     Для того, чтобы использовать графические функции:
     - если  Вы используете интегрированную среду,  установите
Full Menus  в  On,  затем  установите  Options/Linker/Graphics
Library. Когда Вы собираете Вашу программу, редактор автомати-
чески подключает графическую библиотеку Borland C++.
     - если Вы используете компилятор командной строки ВCC.EXE
или ВССХ.ЕХЕ,  Вы должны задать GRAPHICS.LIB в командной стро-
ке. Например, если Ваша программа MYPROG.C использует графику,
задайте
     bcc myprog graphics.lib
     ВАЖНО! Поскольку  графические функции используют far ука-
затели, графика не поддерживается в модели памяти tiny.
     Существует только одна графическая библиотека без отдель-
ных  версий  для  каждой  модели  памяти.  Каждая  функция   в
GRAPHICS.LIB - это far функция,  и те графические функции, ко-
торые принимают указатели,  принимают far указатели. Чтобы эти
функции  работали  корректно  необходимо включить graphics.h в
каждом модуле, использующем графику.

                  Функции графической библиотеки.

     Графические функции Borland C++ делятся на 7 категорий:
     - управление графической системой.
     - рисование и заполнение.
     - манипуляция экраном и полями вывода.
     - вывод текста.
     - управление цветом.
     - обработка ошибок.
     - запрос состояния.

                 Управление графической системой.

     Функции управления графической системой:
     closegraph          закрывает графическую систему.
     detectgraph         проверяет аппаратуру   и  определяет,
                         какой графический  драйвер  использо-
                         вать, рекомендует режим.
     graphdefaults       устанавливает переменные  графической
                         системы в состояние по умолчанию.
     _graphfreemem       освобождает графическую память; необ-
                         ходима для определения Вашей програм-
                         мы.
     _graphgetmem        распределяет графическую память;  не-
                         обходима для определения Вашей  прог-
                         раммы.
     getgraphmode        возвращает текущий графический режим.
     getmoderange        возвращает минимальный и максимальный
                         допустимые режимы.
     initgraph           инициализирует графическую систему  и
                         переводит  аппаратуру  в  графический
                         режим.
     installuserdriver   инсталлирует драйвер   устройства   в
                         таблицу драйверов устройства ВGI.
     installuserfont     загружает  файл  штрихового  шрифта в
                         таблицу символьных файлов BGI.
     registerbgidriver   регистрирует встроенный или загружен-
                         ный пользователем драйвер для включе-
                         ния во время редактирования.
     restorecrtmode      восстанавливает первоначальный  режим
                         экрана (до initgraph).
     setgraphbufsize     задает размер внутреннего графического
                         буфера.
     setgraphmode        устанавливает заданный    графический
                         режим, очищает экран и восстанавлива-
                         ет все умолчания.
     Графический пакет Borland C++  предоставляет  графические
драйверы для следующих графических адаптеров (и полностью сов-
местимых с ними):
     - Color/Graphics Adapter (CGA);
     - Multi-Color Graphics Array (MCGA);
     - Enhanced Graphics Adapter (EGA);
     - Video Graphics Array (VGA);
     - Hercules Graphics Adapter;
     - AT&T 400-line Graphics Adapter;
     - 3270 PC Graphics Adapter;
     - IBM 8514 Graphics Adapter.
     Чтобы запустить графическую систему, Вы вызываете функцию
initgraph. initgraph загружает графический драйвер и переводит
систему в графический режим.
     Вы можете указать initgraph  использование  определенного
графического  драйвера  и  режима  или  задать автообнаружение
подключенного видеоадаптера и выбор соответствующего драйвера.
Если  Вы  задали  для  initgraph автообнаружение,  он вызывает
detectgraрh для выбора графического драйвера и режима. Если Вы
указали  использование  определенного  графического драйвера и
режима,  Вы должны быть уверены,  что этот адаптер установлен.
Если Вы задали использование адаптера,  который не установлен,
результат непредсказуем.
     После загрузки графического драйвера Вы можете определить
имя драйвера с помощью getdrivername и поддерживаемые режимы с
помощью  getmaxmode.  getgraphmode  возвращает  текущий графи-
ческий режим.  После определения номера режима Вы можете опре-
делить  имя  режима с помощью getmodename.  Вы можете изменить
графический режим с помощью setgraphmode и вернуться в  перво-
начальный  видеорежим  (до  инициализации  графики)  с помощью
restorecrtmode.  restorecrtmode возвращает экран  в  текстовый
режим,  но  не закрывает графическую систему (шрифты и драйвер
еще в памяти).
     graphdefaults устанавливает состояние графической системы
(размер поля вывода,  цвет,  шаблоны и т.д.) в  первоначальное
(по умолчанию) положение.
     installuserdriver и  installuserfont  позволяют  добавить
новые драйверы устройств и шрифты в графическую систему.
     Наконец, после использования графики вызовите  closegraph
для закрытия графической системы. closegraph выгружает драйвер
из памяти и восстанавливает первоначальный  видеорежим  (через
restorecrtmode).

                 Более детальное обсуждение.

     Предыдущее обсуждение  дало обзор initgraph.  В следующих
разделах  мы  более  детально  опишем   поведение   initgraph,
_graphgetmem и _graphfreemem.
     Программа initgraph загружает графический драйвер,  расп-
ределяя память под него, а затем загружая соответствующий .BGI
файл с диска. Как альтернатива этой схеме динамической загруз-
ки  Вы можете подредактировать файл графического драйвера (или
несколько из них) прямо в  выполнимую  программу.  Вы  делаете
это,  преобразуя  .BGI  файл  в  .OBJ  файл (используя утилиту
bgiobj),  а  затем  вызывая   registerbgidriver   (до   вызова
initgraph) для регистрации графических драйверов. Когда Вы ре-
дактируете Вашу программу, Вам необходимо подключить .OBJ фай-
лы для регистрируемых драйверов.
     После определения  используемого  графического   драйвера
(через  detectgraph)  initgraph проверяет,  зарегистрирован ли
необходимый драйвер. Если да, initgraph использует зарегистри-
рованный драйвер прямо из памяти. Иначе initgraph распределяет
память для драйвера и загружает .BGI файл с диска.
     Примечание: Не         рекомендуется        использование
registerbgidriver неопытными программистами.
     Во время  выполнения  графической  системе может потребо-
ваться распределить память под драйверы,  шрифты и  внутренние
буферы.  Когда  это необходимо,  она вызывает _graphgetmem для
распределения памяти и _graphfreemem для ее  освобождения.  По
умолчанию  эти  программы  просто вызывают malloc и free соот-
ветственно.
     Вы можете  изменить  это,  определив  собственные функции
_graphgetmem и _graphfreemem.  Таким образом, Вы можете управ-
лять распределением   графической  памяти.  Однако  Вы  должны
использовать те же имена для собственных версий этих  программ
распределения памяти: они перекроют функции по умолчанию с те-
ми же именами, находящиеся в стандартных библиотеках С.
     Примечание: Если   Вы   создадите   собственные    версии
_graphgetmem и _graphfreemem,  Вы можете получить предупрежде-
ние "duplicate symbols" (дублирование символов).  Просто игно-
рируйте это предупреждение.

                   Рисование и заполнение.

     Функции рисования и заполнения:
         Рисование:
  arc              Рисует дугу.
  circle           Рисует окружность.
  drawpoly         Рисует контур многоугольника.
  ellipse          Рисует эллиптическую дугу.
  getarccoords     Возвращает координаты последнего вызова
                   arc или ellipse.
  getaspectratio   Возвращает относительный аспект для
                   текущего графического режима.
  getlinesettings  Возвращает текущий стиль, шаблон и
                   толщину линии.
  line             Рисует линию от (x0, y0) до (x1, y1)
  linerel          Рисует линию на относительное расстояние
                   от текущей позиции (CP).
  lineto           Рисует линию от текущей позиции (СР) до
                   (x, y)
  moveto           Перемещает текущую позицию (СР) в (x, y)
  moverel          Перемещает текущую позицию (СР) на
                   относительное расстояние.
  rectangle        Рисует прямоугольник.
  setaspectratio   Изменяет относительный аспект.
  setlinestyle     Устанавливает текущую ширину и стиль линии

            Заполнение:

 bar               Рисует и заполняет полосу.
 bar3d             Рисует и заполняет 3-М полосу
 fillellipse       Рисует и заполняет эллипс.
 fillpoly          Рисует и заполняет многоугольник.
 floodfill         Заполняет ограниченную область.
 getfillpattern    Возвращает шаблон заполнения, определенный
                   пользователем.
 getfillsettings   Возвращает информацию о текущем шаблоне
                   заполнения и цвете.
 piesslice         Рисует и заполняет сектор.
 sector            Рисует и заполняет сектор эллипса.
 setfillpattern    Выбирает шаблон заполнения, определенный
                   пользователем.
 setfillstyle      Устанавливает шаблон и цвет заполнения.
     С помощью функций рисования Borland C++ Вы  можете  рисо-
вать цветные линии, дуги, окружности, эллипсы, прямоугольники,
сектора,  двух- и трехмерные полосы, многоугольники и регуляр-
ные  или нерегулярные формы,  основанные на их комбинации.  Вы
можете заполнять любую ограниченную форму (или любую  область,
окружающую  такую форму) одним из 11 предопределенных шаблонов
или собственным шаблоном.  Вы можете так же управлять толщиной
и стилем линии и положением текущей позиции (СР).
     Вы рисуете линии и незаполненные фигуры  с  помощью  arc,
circle,  drawpoly,  ellipse, linerel, line, lineto, rectangle.
Вы можете заполнять эти формы с помощью floodfill или комбини-
руя  рисование/заполнение с помощью bar,  bar3d,  fillellipse,
fillpoly,  pieslice и sector.  Вы используете setlinestyle для
указания  толщины линии (или границы для заполненных форм),  и
стиля линии.  Вы можете выбрать предопределенный шаблон запол-
нения  с  помощью setfillstyle и определить собственный шаблон
заполнения с помощью setfillpattern.  Вы можете переместить СР
в заданное положение с помощью moveto или на заданное смещение
с помощью moverel.
     Для определения  текущего  стиля и толщины линии вызовите
getlinesettings.  Для информации о текущем шаблоне и цвете за-
полнения вызовите getfillsettings;  Вы можете получить пользо-
вательский шаблон заполнения с помощью getfillpattern.
     Вы можете  получить  относительный аспект (масштабирующий
сомножитель, используемый графической системой для обеспечения
правильности  окружностей) с помощью getaspectratio и получить
координаты последней дуги или эллипса с помощью  getarccoords.
Если    окружность   рисуется   с   искажениями,   используйте
setaspectratio для корректировки.

             Манипуляция экраном и полями вывода.

     Список функций манипуляции экраном,  полями вывода, обра-
зами и пикселами:
     Манипуляция экраном:
 cleardevice     Очищает экран (активную страницу).
 setactivepage   Устанавливает активную страницу для вывода.
 setvisualpage   Устанавливает номер видимой страницы.

     Манипуляция полями вывода:
 clearviewport   Очищает текущее поле вывода.
 getviewsettings Возвращает информацию о текущем поле
                 вывода.
 setviewport     Устанавливает текущее поле вывода.

     Манипуляция образами:
 getimage        Сохраняет битовый образ заданной области
                 в памяти.
 umagesize       Возвращает число байт, требуемое для
                 хранения прямоугольной области экрана.
 putimage        Помещает предварительно сохраненный
                 битовый образ на экран.

     Манипуляция пикселами:
 getpixel        Получает цвет пиксела (x, y).
 putpixel        Рисует пиксел в (x, y).
     Кроме рисования  графическая   библиотека   предоставляет
несколько функций для манипуляции экраном,  полями вывода, об-
разами и пикселами.  Вы можете  очистить  весь  экран,  вызвав
cleardevice;  эта программа очищает весь экран и устанавливает
СР в начало поля вывода, но оставляет нетронутыми другие уста-
новки  графической системы (стили линий,  заполнения и текста;
палитру, поле вывода и т.д.).
     В зависимости  от Вашего графического адаптера Ваш компь-
ютер имеет от 1 до 4 экранных страниц,  которые сохраняют  от-
дельные  образы  экранов.  Вы  можете указать,  какая экранная
страница будет активной  (куда  графические  функции  помещают
свой  вывод)  и какая будет видимой (отображаемой на экране) с
помощью setactivepage и setvisualpage соответственно.
     Вы можете  определить  поле вывода (виртуальный экран) на
Вашем экране,  вызвав setviewport. Вы определяете позицию поля
вывода  в  терминах  абсолютных координат экрана и указываете,
включено отсечение или выключено.  Вы очищаете поле  вывода  с
clearviewport.  getviewsettings возвращает координаты и статус
отсечения текущего поля вывода.
     Вы можете  взять  часть образа экрана с помощью getimage,
imagesize вычисляет число байт,  требуемых для хранения  этого
образа в памяти,  а putimage помещает сохраненный образ на эк-
ран (в любое место).
     Координаты для  всех функций вывода (рисование,  заполне-
ние, текст и т.д.) указываются относительно поля вывода.
     Вы можете так же манипулировать цветом отдельных пикселов
с  помощью  getpixel  (возвращает  цвет  пиксела)  и  putpixel
(рисует пиксел заданного цвета).

                     Графический вывод текста.

     Функции вывода графического текста:
 gettextsettings  Возвращает текущий шрифт, направление
                  размер и выравнивание.
 outtext          Выводит строку в текущей позиции.
 outtextxy        Выводит строку в заданной позиции.
 registerbgifont  Регистрирует встроенный или загруженный
                  шрифт.
 settextjustify   Устанавливает выравнивание текста, используя
                  outtext и outtextxy.
 settextstyle     Устанавливает шрифт, стиль и коэффициент
                  увеличения символов.
 setusercharsize  Устанавливает коэффициенты высоты и ширины
                  для штрихового шрифта.
 texthight        Возвращает высоту строки в пикселах.
 textwidth        Возвращает ширину строки в пикселах.
     Графическая библиотека включает шрифт матрицы 8х8  бит  и
несколько штриховых шрифтов для вывода графического текста.
     - В  битовом  шрифте  каждый  символ  определен  матрицей
пикселов.
     - В штриховых шрифтах каждый символ определен серией век-
торов, из которых рисуется символ.
     Преимущество штриховых  шрифтов  проявляется  при  выводе
больших символов. Поскольку штриховой шрифт определен вектора-
ми,  при увеличении шрифта качество сохраняется. С другой сто-
роны, при увеличении битового шрифта матрица умножается на ко-
эффициент масштабирования;  чем больше увеличение,  тем больше
элементы  символа.  Для  небольших символов подходит побитовый
шрифт, но для большого текста лучше выбрать штриховой шрифт.
     Графический текст   выводится   с   помощью  outtext  или
outtextxy, settextjustify управляет выравниванием  текста.  Вы
выбираете шрифт,  направление и размер с помощью settextstyle.
gettextsetting возвращает текущие установки: шрифт, выравнива-
ние  и  направление в структуру textsettings.  setusercharsize
позволяет модифицировать ширину и высоту штрихового шрифта.
     Если отсечение включено,  все строки, выводимые outtext и
outtextxy,  отсекаются по границе поля вывода.  Если отсечение
выключено,  то  эти  функции не выводят побитовый шрифт,  если
строка выходит за границы экрана;  штриховой шрифт  отсекается
по границе экрана.
     Для определения  размера  текстовой  строки   используйте
textheight  (высота  строки  в  пикселах)  и textwidth (ширина
строки в пикселах).
     Побитовый шрифт  встроен  в  графический  пакет  и всегда
доступен во время выполнения.  Штриховые шрифты хранятся в от-
дельных .CHR файлах;  они могут быть загружены во время выпол-
нения или преобразованы в .OBJ файлы (утилитой bgiobj) и  под-
редактированы в Ваш .EXE файл.
     settextstyle загружает файл шрифта,  распределяя под него
память и загружая соответствующий .CHR файл с диска. Альтерна-
тивно можно использовать динамическую загрузку, при которой Вы
редактируете файл  шрифта  (или  несколько) прямо в выполнимую
программу.  Вы делаете это преобразованием .CHR файла  в  .OBJ
файл (используя  утилиту  BGIOBJ  - читайте о ней в UTIL.DOC),
затем регистрируя шрифт с помощью registerbgifont. При постро-
ении  Вашей  программы  Вам требуется редактировать .OBJ файлы
для регистрируемых шрифтов.
     Примечание: Программу    registerbgifont    рекомендуется
использовать только опытным программистам. Эта функция описана
в UTIL.DOC.

                        Управление цветом.

     Функции управления цветом:
     Получить информацию о цвете:
 getbkcolor          Возвращает текущий цвет фона.
 getcolor            Возвращает текущий цвет рисования.
 getdefaultpalette   Возвращает палитру по умолчанию.
 getmaxcolor         Возвращает максимальное допустимое
                     значение цвета в текущем режиме.
 getpalette          Возвращает текущую палитру и ее размер.
 getpalettesize      Возвращает размер таблицы палитры.

     Установить один или более цветов:
 setallpalette       Изменяет все цвета палитры.
 setbkcolor          Устанавливает текущий цвет фона.
 setcolor            Устанавливает текущий цвет рисования.
 setpalette          Изменяет один цвет палитры, как указано ее
                     аргументами.
     До описания  работы  функций  управления цветом мы опишем
процесс создания цветов на графическом экране.

                        Пикселы и палитры.

     Графический экран состоит  из  массива  пикселов.  Каждый
пиксел - это одна точка на экране.  Значение пиксела не указы-
вает цвет напрямую; это индекс в таблице цвета, называемой па-
литрой. Элемент палитры, связанный с данным значением пиксела,
содержит точную информацию о цвете для этого пиксела.
     Эта косвенная схема имеет ряд следствий.  Хотя аппаратура
может выводить много цветов,  только подмножество этих  цветов
будет отображаться в данный момент времени.  Число цветов, ко-
торое может отображаться в данный момент  времени равно  числу
элементов в палитре (размеру палитры). Например на EGA адаптер
может отображать 64 различных цвета, но только 16 из них - од-
новременно - размер палитры EGA равен 16.
     Размер палитры определяет диапазон значений,  который мо-
жет принимать пиксел от 0 до (размер - 1). Функция getmaxcolor
возвращает максимально допустимое значение пиксела  (размер  -
1) для текущего графического драйвера и режима.
     Когда мы обсуждаем графические функции  Borland  C++,  мы
часто  используем термин "цвет",  как например,  "текущий цвет
рисования",  "цвет заполнения", "цвет пиксела". В действитель-
ности этот цвет - значение пиксела - индекс в палитре.  Только
палитра определяет правильный цвет на экране.  Манипулируя па-
литрой, Вы можете изменять действительные цвета на экране, хо-
тя значения пикселов не будут изменяться.

                      Цвет рисования и фона.

     Цвет фона всегда соответствует значению пиксела 0.  Когда
какая-то  область очищается цветом фона,  эта область пикселов
просто устанавливается в 0.
     Цвет рисования - это значение,  в которое устанавливаются
пикселы при рисовании линии. Вы выбираете цвет рисования с по-
мощью setcolor(n), где n - это допустимое значение пиксела для
текущей палитры.

                     Управление цветом на CGA.

     Поскольку из-за различия адаптеров управление цветом пол-
ностью различается для CGA и EGA,  мы опишем их раздельно. Уп-
равление цветом для AT&T и MCGA в  низком  разрешении  подобно
управлению цветом на CGA.
     На CGA Вы можете выбрать режим отображения с низким  раз-
решением  (320х200)  и  4  цветами  или  с высоким разрешением
(640х200) и 2 цветами.

                  Низкое разрешение на CGA.

     В режимах с низким разрешением Вы можете выбрать одну  из
четырех предопределенных 4-цветных палитр. В любой из этих па-
литр Вы можете установить только первый элемент палитры;  эле-
менты 1,  2 и 3 фиксированы. Первый элемент палитры (цвет 0) -
это цвет фона.  Этот цвет фона может быть одним из 16 допусти-
мых цветов. (См. ниже таблицу цветов фона CGA.)
     Вы выбираете необходимую палитру,  выбирая режим  (CGAC0,
CGAC1,  CGAC2, CGAC3); эти режимы используют палитры цветов от
0 до 3 как описано ниже. Цвета CGA определены в graphics.h.
──────────────────────────────────────────────────────────────
                    Значение пиксела (номер цвета)
номер    ─────────────────────────────────────────────────────
палитры           1                  2                 3
──────────────────────────────────────────────────────────────
  0          CGA_LIGHTGREEN   CGA_LIGHTRED       CGA_YELLOW
  1          CGA_LIGHTCYAN    CGA_LIGHTMAGENTA   CGA_WHITE
  2          CGA_GREEN        CGA_RED            CGA_BROWN
  3          CGA_CYAN         CGA_MAGENTA        CGA_LIGHTGRAY
──────────────────────────────────────────────────────────────
     Чтобы выбрать  один  из этих цветов,  вызовите setcolor с
либо номером цвета,  либо именем соответствующей константы как
аргумент;  например,  если  Вы  используете палитру 3 и хотите
использовать светло-серый цвет для рисования:
     setcolor(3);
   или
     setcolor(CGA_LIGHTGRAY);
     Для CGA можно использовать следующие цвета фона,  опреде-
ленные в graphics.h:
──────────────────────────────────────────────────────────────
числовое      символическое     числовое      символическое
значение          имя           значение          имя
──────────────────────────────────────────────────────────────
   0           BLACK                8            DARKGRAY
   1           BLUE                 9            LIGHTBLUE
   2           GREEN               10            LIGHTGREEN
   3           CYAN                11            LIGHTCYAN
   4           RED                 12            LIGHTRED
   5           MAGENTA             13            LIGHTMAGENTA
   6           BROWN               14            YELLOW
   7           LIGHTGRAY           15            WHITE
─────────────────────────────────────────────────────────────
     Чтобы установить один из этих цветов цветом фона, исполь-
зуйте setbkcolor(n), где n - один из элементов предыдущей таб-
лицы.  Заметим, что для CGA этот цвет не значение пиксела (ин-
декс палитры);  он прямо указывает на действительный цвет пер-
вого элемента палитры.
     Примечание. Основные цвета CGA являются такими же,  что и
в этой таблице.

                   Высокое разрешение CGA.

     В режиме высокого разрешения (640х200) CGA выводит 2 цве-
та черный фон и цвет рисования. Пикселы могут принимать значе-
ния  0  или 1.  Из-за причудливости CGA цвет рисования - это в
действительности цвет,  о котором адаптер думает как  о  цвете
фона; Вы устанавливаете его программой setbkcolor (странно, но
факт).
     Допустимые основные цвета перечислены в предыдущей табли-
це. CGA использует эти цвета для вывода всех пикселов со  зна-
чением 1.
     Таким образом  ведут  себя  адаптеры  в  режимах   CGAHI,
MCGAMED, MCGAHI, ATT400MED, ATT400HI.

                    Программы палитры CGA.

     Поскольку палитра   CGA   предопределена,  Вы  не  должны
использовать setallpalette  для  CGA.  Вы  так  же  не  должны
использовать setpalette(index,  color), за исключением index =
0.  (Это альтернативный способ  установить  цвет  фона  CGA  в
color).

               Управление цветом для EGA и VGA.

     На EGA палитра содержит 16 элементов из 64 возможных цве-
тов и каждый элемент устанавливается пользователем.  Вы можете
получить текущую палитру функцией getpalette, которая заполня-
ет структуру размером палитры (16) и  массивом  действительных
элементов палитры (номерами аппаратных цветов,  хранимых в па-
литре).  Вы можете изменить отдельные элементы палитры  с  по-
мощью setpalette или всю палитру с помощью setallpalette.
     По умолчанию палитра EGA соответствует 16 цветам CGA, как
показано в предыдущей таблице:  черный - это запись 0, голубой
- запись 1, ..., белый - запись 15. Эти константы определены в
graphics.h и содержат соответствующие значения аппаратных цве-
тов: EGA_BLACK, EGA_WHITE и т.д. Вы можете получить эти значе-
ния функцией getpalette.
     Программа setbkcolor(color) ведет себя по-разному на  EGA
и CGA. На EGA setbkcolor копирует действительное значение цве-
та, которое хранится в элементе #color в элемент #0.
     VGA работает так же как EGA,  но имеет более высокое раз-
решение.

            Обработка ошибок в графическом режиме.

     Функции обработки ошибок в графическом режиме:
 grapherrormsg    Возвращает сообщение об ошибке для заданного
                  кода ошибки.
 graphresult      Возвращает  код  ошибки  для последней
                  графической операции.
     Если во время вызова графической функции произошла ошибка
(такая   как   не   найден   шрифт,   требуемый   при   вызове
settextstyle),  устанавливается  внутренний код ошибки.  Вызов
graphresult возвращает код ошибки  для  последней  графической
операции. Вызов grapherrormsg (graphresult()) возвращает стро-
ку ошибки из предыдущей таблицы.
     Код возврата  ошибки  изменяется только когда графическая
функция приводит к ошибке.  Код ошибки сбрасывается в 0 только
после успешного вызова initgraph или после вызова graphresult.
Следовательно,  если Вы хотите знать, какая графическая  функ-
ция  возвращает  какую  ошибку,  Вы  должны сохранить значение
graphresult во временной переменной и затем тестировать его.
     Определены следующие коды ошибок:
──────────────────────────────────────────────────────────────
код ошибки      константа                     ошибка
──────────────────────────────────────────────────────────────
  0       grOk                 Нет ошибки.
 -1       grNoInitGraph        Графика не инициализирована.
 -2       grNotDetected        Не найден графический адаптер.
 -3       grFileNotFound       Файл драйвера устройства не
                               найден.
 -4       grInvalidDriver      Неверный файл драйвера
                               устройства.
 -5       grNoLoadMem          Недостаточно памяти для
                               загрузки драйвера.
 -6       grNoScanMem          Выход за пределы памяти при
                               заполнении.
 -7       grNoFloodMem         Выход за пределы памяти при
                               заполнении.
 -8       grFontNotFound       Файл шрифта не найден.
 -9       grNoFontMem          Недостаточно памяти для
                               загрузки шрифта.
-10       grInvalidMode        Неверный режим для данного
                               драйвера.
-11       grError              Графическая ошибка.
-12       grIOerror            Графическая ошибка В/В.
-13       grInvalidFont        Неверный файл шрифта.
-14       grInvalidFontNum     Неверный номер шрифта.
-15       grInvalidDeviceNum   Неверный номер устройства.
-18       grInvalidVersion     Неверная версия файла.
─────────────────────────────────────────────────────────────

                         Запрос состояния.

     Функции запроса состояния в графическом режиме:

 getarcccords       Возвращает информацию о координатах
                    последнего вызова arc или ellipse.
 getaspectratio     Возвращает относительный аспект.
 getbkcolor         Возвращает текущий цвет фона.
 getcolor           Возвращает текущий цвет рисования.
 getdrivername      Возвращает имя текущего графического
                    драйвера.
 getfillpattern     Возвращает шаблон заполнения, определенный
                    пользователем.
 getfillsettings    Возвращает информацию о текущем шаблоне  и
                    цвете заполнения.
 getgraphmode       Возвращает текущий режим.
 getlinesettings    Возвращает текущий стиль, шаблон и толщину
                    линии.
 getmaxcolor        Возвращает максимально допустимое значение
                    пиксела.
 getmaxmode         Возвращает максимальный номер режима для
                    текущего драйвера.
 getmaxx            Возвращает разрешение по Х.
 getmaxy            Возвращает разрешение по Y.
 getmodename        Возвращает имя режима драйвера.
 getmoderange       Возвращает диапазон режимов для драйвера.
 getpalette         Возвращает текущую палитру и ее размер.
 getpixel           Возвращает цвет пиксела в (x, y).
 gettextsettings    Возвращает текущий шрифт, направление,
                    размер и выравнивание текста.
 getviewsettings    Возвращает информацию о текущем поле
                    вывода.
 getx               Возвращает Х-координату текущей позиции
                    (СР).
 gety               Возвращает Y-координату текущей позиции
                    (СР).

     В каждой категории графических функций Borland C++  есть,
по крайней мере,  одна функция запроса состояния.  Эти функции
приведены при обсуждении соответствующих категорий  и  так  же
собраны  здесь.  Каждая  функция запроса состояния Borland C++
названа getчто-либо (за исключением обработки ошибок). Некото-
рые  из них не имеют аргументов и возвращают единственное зна-
чение;  другие  указывают   на   структуру,   определенную   в
graphics.h, заполняют эту структуру соответствующей информаци-
ей и не возвращают значения.
     Функции запроса состояния для категории управления графи-
ческой системы: getgraphmode, getmaxmode, getmoderange. Первая
возвращает номер графического драйвера и режим, вторая возвра-
щает максимальный номер режима для данного драйвера  и  третья
возвращает диапазон режимов, поддерживаемый данным графическим
драйвером. getmaxx и getmaxy возвращают максимальные координа-
ты экрана x и y для текущего графического режима.
     getarccoords заполняет структуру координатами  последнего
вызова arc или ellipse;  getaspectratio возвращает относитель-
ный  аспект  текущего  режима,  который  графическая   система
использует     для    правильного    рисования    окружностей.
getfillpattern возвращает текущий шаблон  заполнения,  опреде-
ленный пользователем.  getfillsettings заполняет структуру те-
кущим шаблоном и цветом заполнения.  getlinesettings заполняет
структуру текущим стилем, толщиной и шаблоном линии.
     Когда Вы определили поле  вывода,  Вы  можете  найти  его
абсолютные  экранные координаты и состояние отсечения,  вызвав
getviewsettings, которая заполняет структуру этой информацией.
getx  и gety возвращают (относительно поля вывода) x и y коор-
динаты (СР). getpixel возвращает цвет заданного пиксела.
     Функция gettextsettings заполняет структуру информацией о
текущем шрифте,  направлении вывода текста, коэффициенте масш-
табирования м выравнивании текста.
     Функции управления  цветом  включают  3  функции  запроса
состояния. getbkcolor возвращает текущий цвет фона, а getcolor
- текущий цвет рисования.  getpalette заполняет структуру раз-
мером текущей палитры и ее содержимым.  getmaxcolor возвращает
максимальное допустимое значение пиксела для текущего драйвера
и режима.
     Наконец getmodename и getdrivername возвращают имя режима
и имя текущего графического драйвера.
