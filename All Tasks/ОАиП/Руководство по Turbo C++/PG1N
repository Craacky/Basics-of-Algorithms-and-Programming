                           ГЛАВА 1.

                   ЛЕКСИЧЕСКАЯ ГРАММАТИКА.

     Эта глава предоставляет а скорее  формальное  определение
лексической грамматики Borland C++.
     Лексика описывает  различные  категории  элементов   типа
слов, известных как лексемы, распознаваемых в языке. Граммати-
ка структуры фраз в главе 2 описывает допустимые способы груп-
пировки лексем в выражения, операторы и другие элементы.
     Лексемы в Borland C++ извлекаются из серии операций,  вы-
полняемых над Вашей программой компилятором и его препроцессо-
ром.
     Программа Borland  C++  представляет собой последователь-
ность символов ASCII,  которая создается текстовым  редактором
(таким  как редактор Borland C++).  Основной элемент программы
Borland C++ - это файл.  Обычно  он  соответствует  названному
файлу  DOS,  находящемуся  в  памяти  или  на диске и имеющему
расширение .C или .CPP.
     Препроцессор вначале сканирует текст программы для нахож-
дения директив  препроцессора,  например,  директива  #include
<файл>  добавляет  (или  включает)  содержимое  файла "файл" в
программу до фазы компиляции.  Препроцессор так  же  расширяет
любые макро, найденные в программе и включаемых файлах.

                         Разделители.

     На фазе  лексического анализа при компиляции исходный код
разбивается на лексемы и разделители.  Разделитель - это соби-
рательное имя для пробелов,  горизонтальной и вертикальной та-
буляции, символов начала новой строки и комментариев. Раздели-
тели указывают,  где начинаются и кончаются лексемы,  но кроме
этой функции,  любое  присутствие  разделителей  игнорируется,
например, две последовательности
     int    i; float f;
     и
     int i;
       float        f;
     лексически эквивалентны  и  при  интерпретации   дают   6
лексем:
     1. int
     2. i
     3. ;
     4. float
     5. f
     6 ;

     ASCII символы,  представляющие разделители,  могут встре-
чаться внутри литеральных строк. В этом случае они исключаются
из лексического разбора;  другими словами, они остаются частью
строки:
     char name[] = "Borland International";
     разбивается на  7  лексем,  включая  лексему  литеральной
строки "Borland International".

               Склеивание строки с помощью "\".

     В случае,  если  перед символом новой строки стоит символ
"\", символы "\" и новой строки игнорируются, позволяя интерп-
ретировать две отдельных строки текста как одно целое.
     "Borland \
     International"
     интерпретируется как "Borland International".

                         Комментарии.

     Комментарии - это часть текста,  используемые для аннота-
ции.  Комментарий  используется только программистом;  он отб-
расывается из исходного текста до лексического разбора.
     Существует 2  способа задания комментариев:  традиционный
метод С и метод С++.  Оба из них поддерживаются Borland C++, а
так  же  вложенные  комментарии.  Вы можете смешивать оба типа
комментариев в программах С и С++.

                        Комментарии С.

     Традиционный комментарий С - это произвольная  последова-
тельность символов,  помещенная после пары символов "/*". Ком-
ментарий завершается первым нахождением пары "*/".  Вся после-
довательность, включая 4 символа комментария, заменяется одним
пробелом после расширения макро. Заметим, что некоторые реали-
зации С удаляют комментарии без замещения пробелом.
     Borland C++ не поддерживает непереносимую стратегию скле-
ивания лексем,  используя "/**/".  Склеивание лексем в Borland
C++ производится с помощью определенной в ANSI пары ##:
     #define VAR(i,j) (i/**/j)  /* не работает */
     #define VAR(i,j) (i##j)  /* работает  в Borland C++ */
     #define VAR(i,j) (i ## j)  /* работает в Borland C++ */
     В Borland C++
      int /* объявление */ i /* счетчик */;
анализируется как
     int i ;
     давая 3 лексемы: int i;

                    Вложенные комментарии.

     ANSI C не разрешает вложенные комментарии. Попытка заком-
ментировать строку
     /* int /* объявление */ i /* счетчик */; */
     ошибочна, поскольку  первые /* закончится первым */.  Это
приведет к
     i ; */
что будет выдавать синтаксическую ошибку.
     По умолчанию Borland C++ не разрешает вложенные коммента-
рии, но Вы можете разрешить их с помощью опции компилятора. Вы
можете  включить вложенные комментарии опции -С или -с помощью
меню О/С/Source Options в интегрированной среде.

                       Комментарии С++.

     С++ разрешает комментарии на одной строке,  используя //.
Этот  комментарий  может  начинаться с любой позиции и продол-
жаться до начала новой строки:
     class X { //  это комментарий
     ... };
     Примечание. Можно использовать также // для создания ком-
ментариев в коде С. Это особенность Borland C++.

                  Комментарии и разделители.

     В некоторых случаях некоторые разделители до /* и  //,  и
после */ хотя синтаксически необязательны, будут предотвращать
проблемы при переносимости. Например код С++
     int i = j//* делить на k*/k;
     +m;
     анализируется как int i = j +m; а не как
     int i = j/k;
     +m;
     как ожидается в традиционном С. Более правильная форма
     int i = j/ /* делить на k*/ k;
     +m;
     предотвратит эту проблему.

                           Лексемы.

     Borland C++ распознает 6 классов лексем:  ключевые слова,
идентификаторы, константы, литеральные строки, операторы, зна-
ки  пунктуации (известные так же как разделители).  Формальное
определение лексем:
     Лексема:
       ключевое-слово
       идентификатор
       константа
       литеральная-строка
       оператор
       знак-пунктуации
     При лексическом разборе лексемы выбираются таким образом,
что из последовательности символов выбирается наиболее длинная
лексема. Например, external будет разбираться как один иденти-
фикатор, а не как ключевое слово extern и идентификатор al.

                       Ключевые слова.

     Ключевые слова - это слова,  зарезервированные для специ-
ального предназначения и  их  нельзя  использовать  как  имена
идентификаторов.  Следующие 2 таблицы приводят список ключевых
слов Borland C++.  Вы можете  использовать  опцию  компилятора
(или  опцию  в  среде)  для  выбора только ключевых слов ANSI,
только ключевых слов Unix и т.д.  См.  главу 2 "Ссылки меню  и
опций"  и главу 6 "Опции компилятора командной строки" в Руко-
водстве Пользователя для информации по этим опциям.

         Таблица 1.1. Все ключевые слова Borland C++.
─────────────────────────────────────────────────────────────
     asm         _ds          interrupt       short
     auto        else         _loadds         signed
     break       enum         long            sizeof
     case        _es          _near           _ss
     catch       _export      near            static
     _cdecl      extern       new             struct
     cdecl       _far         operator        switch
     char        far          _pascal         template
     class       float        pascal          this
     const       for          private         typedef
     continue    friend       protected       union
     _cs         goto         public          unsigned
     default     huge         register        virtual
     delete      if           return          void
     do          inline       _saveregs       volatile
     double      int          _seg            while
─────────────────────────────────────────────────────────────

   Таблица 1.2. Расширения Borland C++ относительно ANSI C.
─────────────────────────────────────────────────────────────
     _cdecl      _es          interrupt       pascal
     cdecl       _export      _loadds         _saveregs
     _cs         _far         near            _seg
     _ds         huge         _pascal         _ss
─────────────────────────────────────────────────────────────

     Таблица 1.3. Ключевые слова, специфические для С++.
─────────────────────────────────────────────────────────────
     catch       friend       operator        public
     class       inline       private         template
     delete      new          protected       this
                                              virtual
─────────────────────────────────────────────────────────────

    Таблица 1.4. Регистровые псевдопеременные Borland C++.
─────────────────────────────────────────────────────────────
     _AH         _BP          _CX           _DX
     _AL         _BX          _DH           _ES
     _AX         _CH          _DI           _FLAGS
     _BH         _CL          _DL           _SI
     _BL         _CS          _DS           _SP
                                            _SS
─────────────────────────────────────────────────────────────

                       Идентификаторы.

     Формальное определение идентификатора:

     идентификатор:
       не-цифра
       идентификатор не-цифра
       идентификатор цифра

     не-цифра: одна из
       a b c d e f g h i j k l m n o p q r s t u v w x y z _
       A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

     цифра: одна из
       0 1 2 3 4 5 6 7 8 9

                Ограничения на имена и длину.

     Идентификаторы - это произвольные имена любой  длины  для
классов,  объектов, функций, переменных, типов данных, опреде-
ленных пользователем и  т.д.  Идентификаторы  могут  содержать
буквы от A до Z и от a до z,  символ _ и цифры от 0 до 9.  Су-
ществует только 2 ограничения:
     1. Первый символ должен быть буквой или _.
     2. По умолчанию Borland C++ распознает только  первые  32
символа.  Число значащих символов может быть сокращено из меню
или с помощью опций командной строки,  но не может быть увели-
чено.   Используйте   опцию  командной  строке  -in  или  меню
O/C/S/Identifier Length в интегрированной среде, где N от 1 до
32.
     Примечание. В программах С++ имеют  смысл  идентификаторы
любой длины.

        Строчные и прописные буквы в идентификаторах.

     Borland C++  различает строчные и прописные буквы в иден-
тификаторах так, что Sum, sum и suM - это разные идентификато-
ры.
     Глобальные идентификаторы,  импортируемые из других моду-
лей,  используют те же правила именования, что и обычные иден-
тификаторы.  Однако Borland C++ предоставляет опцию, запрещаю-
щую  различать прописные и строчные буквы для обеспечения сов-
местимости при редактировании с языками,  не различающими про-
писные  и строчные буквы.  Вы можете отключить различение про-
писных и строчных букв в глобальных идентификаторах, используя
кнопку  Case-Sensitive  Link  в диалоговом окне Options/Linker
или опцию /с в TLINK. В этом случае глобальные Sum и sum будут
интерпретироваться  как  идентичные,  приводя к предупреждению
"Duplicate Symbol" (дублирование символа) во время  редактиро-
вания.
     Как исключение  из  этого  правила,  идентификаторы  типа
pascal всегда преобразуются в прописные буквы для последующего
редактирования.

                Уникальность и сфера действия.

     Хотя имена  идентификаторов   произвольны,   генерируется
ошибка, если то же самое имя используется для более, чем одно-
го идентификатора внутри одной сферы действия и разделяются  в
том же пространстве имени.  Дублирование имен всегда разрешено
для  различных  пространств  имен  вне  зависимости  от  сферы
действия. Эти правила обсуждаются в разделе "Сфера действия".

                          Константы.

     Лексемы "константа"  представляют числовые или символьные
значения. Borland C++ поддерживает 4 класса констант: с плава-
ющей точкой, целые, перечислимые и символьные.
     Тип данных константы различается компилятором с использо-
ванием числового значения и формата в исходном коде.  Формаль-
ное определение констант показано в следующей таблице:

        Таблица 1.5. Формальное определение констант.
──────────────────────────────────────────────────────────────
   Константа:
     константа-с-плавающей-точкой
     целая-константа
     перечислимая-константа
     символьная-константа

   Константа-с-плавающей-точкой:
    мантисса <экспонента> <суффикс-с-плавающей-точкой>
    последовательность-цифр экспонента <суффикс-с-плав-точкой>

   Мантисса:
     <последовательность-цифр>.последовательность-цифр
     последовательность-цифр.

   Экспонента:
     e <знак>последовательность-цифр
     Е <знак>последовательность-цифр

   Знак: один из
     + -

   Последовательность-цифр:
     цифра
     последовательность-цифр цифра

   Суффикс-с-плавающей-точкой: один из
     f l F L

   Целая-константа:
     десятичная-константа <целочисленный-суффикс>
     восьмеричная-константа <целочисленный-суффикс>
     шестнадцатиричная-константа <целочисленный-суффикс>

   Десятичная-константа:
     ненулевая-цифра
     десятичная-константа цифра

   Восьмеричная-константа:
     0
     восьмеричная-константа восьмеричная-цифра

   Шестнадцатиричная-константа:
     0х шестнадцатиричная-цифра
     0Х шестнадцатиричная-цифра
     шестнадцитиричная-константа шестнадцитиричная-цифра

   Ненулевая-цифра: одна из
     1 2 3 4 5 6 7 8 9

   Восьмеричная-цифра: одна из
     0 1 2 3 4 5 6 7

   Шестнадцитиричная-цифра: одна из
     0 1 2 3 4 5 6 7 8 9 А В С D E F a b c d e f

   Целочисленный-суффикс:
     беззнаковый-суффикс <длинный-суффикс>
     длинный-суффикс <беззнаковый-суффикс>

   Беззнаковый-суффикс: один из
     u U

   Длинный-суффикс: один из
     l L

   Перечислимая-константа:
     идентификатор

   Символьная-константа:
     символьная-последовательность

   Символьная-последовательность:
     символ
     символьная-последовательность символ

   Символ:
     (Любой символ,  за исключением ',  \ или символа
      новой строки) Esc-последовательность

   Esc-последовательность: одна из
     \"  \'  \?      \\
     \a  \b  \f      \n
     \o  \oo \ooo    \r
     \t  \v  \Xh...  \xh...

──────────────────────────────────────────────────────────────

                       Целые константы.

     Целые константы  могут  быть  десятичными (основание 10),
восьмеричными (основание 8) или 16-ричными (основание 16). При
отсутствии суффиксов,  тип данных целой константы определяется
из его значения,  как показано в таблице 1.6. Заметим, что эти
правила отличаются для десятичных и недесятичных констант.

                    Десятичные константы.

     Десятичные константы  могут  принимать  значения  от 0 до
4,294,967,295. Константы, превышающие этот предел будут приво-
дить к ошибке. Десятичные константы не должны использовать ли-
дирующий 0.  Целые константы,  которые имеют лидирующий 0, ин-
терпретируются как восьмеричные:
     int i = 10;  /* десятичное 10 */
     int i = 010;  /* десятичное 8 */
     int i = 0;  /* десятичное 0 = восьмеричному 0 */

                   Восьмеричные константы.

     Все константы с лидирующим 0,  интерпретируются как вось-
меричные.  Если восьмеричная константа содержит цифры 8 или 9,
генерируется  ошибка.  Восьмеричные   константы,   превышающие
037777777777 приводят к ошибке.

                     16-ричные константы.

     Все константы,  начинающиеся  с  0х (0Х) интерпретируются
как 16- ричные.  16-ричные константы,  превышающие 0хFFFFFFFF,
приводят к ошибке.

               Длинные и беззнаковые суффиксы.

     Суффикс L  (или  l),  присоединенный  к  любой константе,
заставляет интерпретировать ее как long. Аналогично, суффикс U
или u заставляет интерпретировать константу как unsigned.  Это
будет unsigned long, если значение константы больше, чем деся-
тичное 65,535,  вне зависимости от используемого основания. Вы
можете использовать оба суффикса U и L в одной константе  и  в
любом порядке: lu, ul, UL, и т.д.

     Таблица 1.6. Целые константы Borland C++ без L и U.

──────────────────────────────────────────────────────────────
     десятичные константы

     от 0 до 32,767                     int
     от 32,767 до 2,147,483,647         long
     от 2,147,483,648 до 4,294,967,295  unsigned long
     более 4294967295                   генерируется ошибка

     восьмеричные константы

     от 00 до 077777                    int
     от 0100000 до 0177777              unsigned int
     от 02000000 до 017777777777        long
     от 020000000000 до 037777777777    unsigned long
     более 037777777777                 генерируется ошибка

     шестнадцатиричные константы

     от 0х0000 до 0х7FFF                int
     от 0x8000 до 0xFFFF                unsigned int
     от 0x10000 до 0x7FFFFFFF           long
     от 0x80000000 до 0xFFFFFFFF        unsigned long
     более 0хFFFFFFFF                   генерируется ошибка
──────────────────────────────────────────────────────────────

     Тип данных константы в случае отсутствия любого  суффикса
(u, U, L, l) - это один из следующих соответствующих типов:

──────────────────────────────────────────────────────────────
     десятичный         int, long int, unsigned long int

     восьмеричный       int, unsigned int, long int,
                        unsigned long int

     шестнадцатиричный  int, unsigned int, long int,
                        unsigned long int
──────────────────────────────────────────────────────────────
     Если константа имеет суффикс U или u, ее тип будет первый
из unsigned int, unsigned long int, который может соответство-
вать ее значению.
     Если константа имеет суффикс L или l, ее тип будет первый
из long int,  unsigned long int, который может соответствовать
ее значению.
     Если константа имеет оба суффикса U и L  (ul,  uL,  UL  и
т.д.), ее тип данных будет unsigned long int.
     Таблица 1.6  подводит  итог  представления  целочисленных
констант на трех основаниях. Предполагается, что указанные ти-
пы данных не не игнорируют используемые суффиксы L и U.

                    Символьные константы.

     Символьная константа - это один или более символов,  зак-
люченные в апострофы, как например
     'A', '=', '\n'
     В Си одиночная символьная константа имеет тип данных int;
она хранится в 16 битах с нулевым старшим байтом.  В Си++ сим-
вольная константа имеет тип char. Константа из нескольких сим-
волов в Си и Си++ имеет тип данных int.

                   Esc последовательности.

     Символ \ используется для обозначения Esc  последователь-
ности,  позволяя  визуально  отобразить  некоторые графические
символы. Например константа \n используется для символа "новая
строка".
     \ используется с восьмеричными или 16-ричными числами для
представления  ASCII  символа  или  управляющего  кода,  соот-
ветствующего этому значению;  например,  '\03' для Ctrl-C  или
'\x3F' для ?.  Вы можете использовать до трех символов в вось-
меричной строке или любое число 16-ричных цифр в Esc  последо-
вательности,  обеспечивая,  что это значение лежит в диапазоне
для типа данных char (от 0 до 0xff для Borland  C++).  Большие
числа  выдают  ошибку  компиляции "Numeric constant too large"
(числовая константа слишком  велика).  Например,  восьмеричное
число \777 больше,  чем максимально допустимое значение \377 и
будет генерировать ошибку.  Первый невосьмеричный или  нешест-
надцатиричный символ, встреченный в восьмеричной или 16-ричной
Esc последовательности,  отмечает  конец  этой  последователь-
ности.
     Первоначально Turbo-C разрешал только 3 цифры в 16-ричной
Esc  последовательности.  Новое  правило  ANSI  С,  принятое в
версии Турбо-Си 2.0 и в Borland C++, может приводить к пробле-
мам для старого кода,  в котором принято,  что только 3 первых
символа будут преобразовываться.  Например, используя Турбо-Си
1.х  для  определения  строки  с  символом сигнала (ASCII 7) с
последующими числовыми символами, программист мог написать:
     printf ("\x0072.1A simple operating system");
     это интерпретируется как
     \x007 и "2.1A simple operating system"
     Однако Borland C++ и Turbo-C версии 2.0  компилирует  эту
строку  как  16-ричное  число  \x0072  и  строку  ".1A  simple
operating system".
     Чтобы предотвратить эту проблему, перепишите код
     printf ("\x007" "2.1A simple operating system");
     Неопределенность может так же возникать,  если за восьме-
ричной ESC последовательностью следует  невосьмеричная  цифра.
Например, поскольку 8 и 9 невосьмеричные цифры, константа \258
будет интерпретироваться как две символьные константы \25 и 8.
     Следующая таблица  показывает  допустимые  ESC последова-
тельности.

       Таблица 1.7. ESC последовательности Borland C++.
───────────────────────────────────────────────────────────
последова-   числовое    символьное    что делает
тельность   обозначение  обозначение
───────────────────────────────────────────────────────────
     \a       0x07        BEL          сигнал
     \b       0x08        BS           удаление предыдущего
                                       символа
     \f       0x0C        FF           перевод страницы
     \n       0x0A        LF           новая строка (пустая
                                       строка)
     \r       0x0D        CR           возврат каретки
     \t       0x09        HT           табуляция
                                       (горизонтальная)
     \v       0x0B        VT           табуляция
                                       (вертикальная)
     \\       0x5c        \            обратный \
     \'       0x27        '            одиночная кавычка
                                       (апостроф)
     \"       0x22        "            двойная кавычка
     \?       0x3F        ?            знак вопроса
     \O                   любой        O = строка до трех
                                       восьмеричных цифр
     \xH                  любой        H = строка
                                       шестнадцатиричных
                                       цифр
     \XH                  любой        H = строка
                                       шестнадцатиричных
                                       цифр
───────────────────────────────────────────────────────────
     Примечание: \\ должен  использоваться  для  представления
ASCII \, как например в пути DOS.

      Специальные двухсимвольные константы Borland C++.

     Borland C++  так же поддерживает двухсимвольные константы
(например 'An',  '\n\t' и '\007\007'). Эти константы представ-
ляются  как 16-битное значение int с первым символом в младшем
байте и со вторым - в старшем.  Эти константы  непереносимы  в
другие компиляторы Си.

                Знаковый и беззнаковый символ.

     В Си  односимвольная  константа,  такая  как 'A',  '\t' и
'\007' представляются как 16-битное значение int.  В этом слу-
чае младший байт знаково расширяется в старший байт; т.е. если
значение больше 127 (при основании 10),  старший байт устанав-
ливается  в  -1 (=0xff).  Это может быть запрещено объявлением
умалчиваемого типа char как unsigned (используя опцию -K  ком-
пилятора командной строки или выбрав unsigned character в меню
Options/Compiler/Code Generation), который устанавливает стар-
ший байт в 0 вне зависимости от значения младшего байта.

         Длинная символьная константа (только в Си).

     Символьная константа  с  предшествующим  L  - это длинный
символьный тип  данных  wchar_t  (целый  тип,  определенный  в
stddef.h). Например
     x = L'AB';

                Константы с плавающей точкой.

     Константа с плавающей точкой состоит из 6 чистей:
     - десятичная целая
     - десятичная точка
     - десятичная дробная
     - e или Е и знаковая целая экспонента (необязательная)
     - суффикс типа f, F, l, L (необязательный)
     Вы можете пропустить либо десятичную целую, либо десятич-
ную дробную часть (но не обе). Вы можете пропустить либо деся-
тичную точку, либо символ е (или Е) и знаковую целую экспонен-
ту  (но не обе).  Эти правила применимы для конвенциональной и
научной нотаций.
     Отрицательные константы с плавающей точкой представляются
как положительные с унарным оператором "-".
     Примеры:
──────────────────────────────────────────────────────────────
            константа                  значение
──────────────────────────────────────────────────────────────
           23.45е6                     23.45 х 10**6
           .0                          0
           0.                          0
           1.                          1.0 х 10*0 = 1.0
           -1.23                       -1.23
           2е-5                        2.0 х 10**-5
           3Е+10                       3.0 х 10**10
           0.9Е3                       0.09 х 10**34
──────────────────────────────────────────────────────────────

         Константы с плавающей точкой - типы данных.

     При отсутствии  любого  суффикса  принимается тип double.
Однако Вы можете задать  константу  с  плавающей  точкой  типа
float добавлением суффикса f или F. Аналогично суффикс l или L
задает константу типа long double.  Следующая таблица приводит
диапазоны значений типа float, double и long double.

         Таблица 1.8.  Размеры  и диапазоны констант
               с плавающей точкой Borland C++.
────────────────────────────────────────────────────────────
     тип        размер (в битах)        диапазон
────────────────────────────────────────────────────────────
     float           32     от 3.4*10**-38 до 3.4*10**-38
     double          64     от 1.7*10**-308 до 1.7*10**308
     long double     80     от 3.4*10**-4932 до 1.1*10**4932
────────────────────────────────────────────────────────────

                   Перечислимые константы.

     Перечислимые константы - это идентификаторы, определенные
в объявлении типа enum. Для удобства эти идентификаторы обычно
выбираются  мнемонически.  Перечислимые  константы - это целый
тип данных.  Они могут использоваться в любом  выражении,  где
допустимы целые константы. Идентификаторы должны быть уникаль-
ными внутри сферы  объявления  enum.  Разрешены  отрицательные
инициализаторы.
     Значения перечислимых констант зависят от формата  объяв-
ления перечислимого типа и присутствия возможных инициализато-
ров. Например
     enum team { giants, cubs, dodgers };
     giants, cubs и dodgers - это перечислимые константы  типа
team,  которые могут быть присвоены любой переменной типа team
или  любой  другой  переменной  целого  типа.  Значения   этих
констант
     giants = 0, cubs = 1, dodgers = 2
     при отсутствии явных инициализаторов. В следующем примере
     enum team { giants, cubs = 3, dodgers = giants + 1 };
     константы имеют значения
     giants = 0, cubs = 3, dodgers = 1
     Значения констант  необязательно должны быть уникальными.
     enum team { giants, cubs = 1, dodgers = cubs - 1 };

                     Литеральные строки.

     Литеральные строки,  так  же  известные   как   строковые
константы, используются для обработки фиксированных последова-
тельностей символов. Литеральные строки имеют тип данных array
of  char  и  класс памяти static и записываются как последова-
тельность любого числа символов внутри кавычек:
     "это литеральная строка"
     Пустая строка записывается "".
     Символы внутри  кавычек могут включать ESC последователь-
ности. Так код
     "\t\t\"name\"\\\taddress\n\n"
     выводится как:
     "name"\  address
     Перед "name" стоят 2 символа табуляции;  перед address  -
один символ табуляции.  После строки идут две новых строки. \"
вводит внутренние двойные кавычки.
     Литеральная строка  хранится  как заданная последователь-
ность символов плюс завершающий нулевой символ ('\0'). Нулевая
строка хранится как символ '\0'.
     Отдельные литеральные строки, разделенные только символа-
ми-разделителями,  объединяются во время лексического анализа.
В следующем примере
     #include <stdio.h>

     main()
     {
       char   *p;

       p = "Этот пример показывает как Borland C++"
           "производит\nавтоматическую конкатенацию очень"
           "длинной\nстроки и выводит результат.";
       printf(p);
     }

     программа выводит:
     Этот пример показывает как Borland C++ производит
     автоматическую конкатенацию очень длинной
     строки и выводит результат.
     Вы так  же  можете  использовать \ как символ продолжения
для разбиения символьной константы на несколько строк:
     puts("this is really \
     a one-line string");

            Константы и внутреннее представление.

     ANSI C устанавливает,  что размер и диапазон основных ти-
пов  данных определяется реализацией и обычно зависит от архи-
тектуры компьютера. Для Borland C++ реализация зависит от мик-
ропроцессора 80х86.  Следующая таблица приводит размеры и диа-
пазоны типов данных для  Borland  C++.  Рис.  1.1.  показывает
внутреннее представление этих типов.

        Таблица 1.9. Типы данных, размеры и диапазоны.
──────────────────────────────────────────────────────────────
     тип    размер      диапазон         Примеры применения
            (в битах)
──────────────────────────────────────────────────────────────
unsigned char  8    от 0 до 255          Небольшие числа     и
                                         полный набор символов
char           8    от -128 до 127       Маленькие числа     и
                                         символы ASCII
enum           16   от -32768 до 32767   Упорядоченные    мно-
                                         жества значений
unsigned int   16   от 0 до 65535        Большие числа и циклы
short int      16   от -32768 до 32767   Счет, небольшие числа
                                         и управление циклом
int            16   от -32768 до 32767   Счет, небольшие числа
                                         и управление циклом
unsigned long  32   от 0 до 4294967295   Астрономические
                                         расстояния
long           32   от -2147483648       Большие числа,
                    до 2147483647        совокупность
float          32   от 3.4*10**-38       Научные (разрешение
                    до 3.4*10**-38       в 7 цифр)
double         64   от 1.7*10**-308      Научные (разрешение
                    до 1.7*10**308       в 15 цифр)
long double    80   от 3.4*10**-4932     Научные (разрешение
                    до 1.1*10**4932      в 19 цифр)
near pointer   16   -                    Манипуляция адресами
                                         памяти
far pointer    32   -                    Манипуляция адресами
                                         памяти вне текущего
                                         сегмента
______________________________________________________________

       Рис.1.1. Внутреннее представление типов данных.
              ┌──┬───────────┐
              │  │           │
        int   │ з│ значение  │
              └──┴───────────┘
              16             0

              ┌──┬────────────────────┐
              │  │                    │
   long int   │ з│ значение           │
              └──┴────────────────────┘
              31                      0
                            i1
              ┌──┬────────────────────┐
              │  │экспонента│ мантисса│
      float   │ з│          │         │
              └──┴────────────────────┘
              31            22        0

                            i1
              ┌──┬──────────┬────────────────────┐
              │  │          │                    │
     double   │ з│экспонента│ мантисса           │
              └──┴──────────┴────────────────────┘
              63            51                   0

                                  i
              ┌──┬─────────────┬──┬────────────────────────┐
              │  │             │  │                        │
 long double  │ з│экспонента   │ 1│ мантисса               │
              └──┴─────────────┴──┴────────────────────────┘
              79              64  63                       0

     з - бит знака (0 = +, 1 = -)
     i = позиция явной двоичной точки
     1 = целый бит мантиссы:
         Хранится в long double
         Явный (всегда 1) в float, double
     Смещение экспоненты (нормализованные значения):
         float : 127 (7FH)
         double : 1023 (3FFH)
         long double : 16383 (3FFH)

                    Константные выражения.

     Константное выражение - это выражение, которое всегда вы-
числяется в константу (и должно вычисляться в константу, кото-
рая  находится  в  диапазоне допустимых значений для ее типа).
Константное выражение вычисляется так же,  как обычное выраже-
ние.  Вы можете использовать константное выражение везде,  где
допустимы константы. Синтаксис константных выражений.

     Константное-выражение:
       условное-выражение

     Константное выражение не может содержать любой из следую-
щих операторов,  если только эти операторы не находятся внутри
операнда оператора sizeof:
     - присваивание
     - уменьшение
     - вызовы функции
     - запятая

                     Описание оператора.

     Оператор - это лексема, которая переключает некоторые вы-
числения, когда применяется к переменной или к другому объекту
в выражении. Borland C++ представляет большой набор операторов
не только арифметических и логических, но так же для побитовых
манипуляций,  доступа  к  компонентам структур и объединений и
операций с указателями.
     С++ предоставляет  дополнительные операторы для доступа к
элементам класса и их объектам,  а так же механизм для  перег-
рузки  операторов.  Перегрузка  позволяет  Вам  переопределить
действие любого стандартного оператора,  когда  применяется  к
объекту данного класса.  В этом разделе мы обсудим стандартные
операторы Borland C++.
     После определения стандартных операторов, мы обсудим типы
данных и объявления и объясним,  как они  влияют  на  действие
каждого оператора. Мы так же объясним синтаксис для построения
выражений из операторов, знаков пунктуации и объектов.
     Операторы в Borland C++ определены:
     Оператор: один из
     []        ()        .        ->          ++          --
     &         *         +        -           ~           !
     sizeof    /         %        <<          >>          <
     >         <=        >=       ==          !=          ^
     |         &&        ||       ?:          =           *=
     /=        %=        +=       -=          <<=         >>=
     &=        ^=        |=       ,           #           ##
     Примечание: Оператор # и ## используются  только  препро-
цессором.
     Следующие операторы специфические для С++:
     ::   .*   ->*
     За исключением  [],  (),  ?:  многосимвольные   операторы
рассматриваются как одна лексема. Одна лексема оператора может
иметь более одной интерпретации,  в зависимости от  контекста.
Например
     a*b                 умножение
     *ptr                косвенная адресация

     A & B               побитовое И
     &A                  адресная операция
     int &               модификатор ссылки (С++)

     label:              оператор метки
     A ? X : Y           условный оператор

     void func(int n);   объявление функции
     A = (B+C)*D;        выражение в скобках

     A, B, C;            выражения через запятую
     func(a,b,c);        вызов функции

     a=~b;               побитовое отрицание
     ~func() {delete a;} дестрактор (С++)

                        Унарные операторы.

     &        адресный оператор
     *        оператор косвенной адресации
     +        унарный плюс
     -        унарный минус
     ~        побитовое отрицание
     !        логическое отрицание
     ++       префикс: предварительное увеличение;
              постфикс: последующее увеличение
     --       префикс: предварительное уменьшение;
              постфикс: последующее уменьшение

                        Бинарные операторы.
     Аддитивные операторы
     +         бинарный плюс
     -         бинарный минус

     Мультипликативные операторы
     *         умножение
     /         деление
     %         остаток

     Операторы сдвига
     <<        сдвиг влево
     >>        сдвиг вправо

     Побитовые операторы
     &         побитовое AND (И)
     ^         побитовое XOR (исключающее или)
     |         побитовое OR (ИЛИ)

     Логические операторы
     &&        логическое AND (И)
     ||        логическое OR (ИЛИ)

     Операторы присваивания
     =         присваивание
     *=        присвоить произведение
     /=        присвоить частное
     %=        присвоить остаток
     +=        присвоить сумму
     -=        присвоить разность
     <<=       присвоить левый сдвиг
     >>=       присвоить правый сдвиг
     &=        присвоить побитовое AND
     ^=        присвоить побитовое XOR
     |=        присвоить побитовое OR

     Операторы отношения
     <         меньше чем
     >         больше чем
     <=        меньше чем или равно
     >=        больше чем или равно

     Операторы эквивалентности
     ==        равно
     !=        не равно

     Операторы выбора компонент
     .         прямой селектор компоненты
     ->        непрямой селектор компоненты

     Операторы элемента класса
     ::        доступ/разрешение сферы действия
     .*        разименованный указатель на элемент класса
     ->*       разименованный указатель на элемент класса

     Условный оператор
     A ? X : Y "если А, то Х; иначе Y"

     Оператор ,
     ,         вычислить; например A,B,C; слева направо.

                      Знаки пунктуации.

     Знаки пунктуации, так же известные как разделители, опре-
делены в Borland C++:
     знак-пунктуации: один из
     [ ] ( ) { } , ; : ... * = #

                      Квадратные скобки.

     [] указывает список индексов одномерного или многомерного
массива:
     char ch, str[] = "stan";
     int mat[3][4];
     char = str[3];

                       Круглые скобки.

     () выделяет групповое  выражение,  условное  выражение  и
указывают на вызов функции и параметры функции:
     d = c*(a+b);    /* отвергает обычное старшинство */
     if (d==z) ++x;  /* применяется в условных выражениях */
     func();         /* вызов функции; без аргументов */
     int (*fptr)();  /* объявление указателя функции */
     fptr = func; /*отсутствие () означает указатель функции*/
     void func2(int n); /* объявление функции с аргументами */
     () рекомендуется в макроопределениях  для  предотвращения
потенциальных проблем во время расширения макро:
     #defined CUBE(x) ((x)*(x)*(x))
     () так же используется для предотвращения обычного поряд-
ка вычисления операторов.

                       Фигурные скобки.

     {} указывает на начало и конец составного оператора:
     if (d==z)
     {
       ++x;
       func();
     }
     Закрывающая } используется как конец составного  операто-
ра,  так  ";"  не  требуется после } за исключением объявления
структуры или класса. Часто ";" запрещена, как в
     if (оператор)
     {};
     else

                           Запятая.

     "," разделяет элементы списка аргументов функции;
     void func(int n, float f, char ch);
     "," так  же  используется как оператор в выражениях через
запятую.  Смешивание двух использований запятой разрешено,  но
Вы должны использовать () для их различения:
     func(i,j); /* вызов функции с двумя аргументами */
     func((exp1, exp2), (exp3, exp4, exp5)); /* также вызов
                   функции с двумя аргументами! */

                       Точка с запятой.

     ";" указывает на конец оператора.  Любое правильное выра-
жение  (включая  пустое  выражение) должно заканчиваться ";" и
интерпретируется как оператор,  известный как оператор выраже-
ния.  Это выражение вычисляется и его значение теряется.  Если
оператор выражения не имеет сторонних  эффектов,  Borland  C++
может игнорировать его.
     a+b;
     ++a;
     ;
     ";" часто используется для создания пустого оператора:
     for (i=0; i<n; i++)
     {
       ;
     }

                          Двоеточие.

     ":" указывает помеченный оператор.
     start:      x=0;
     ...
     goto start;
     ...
     switch (a) {
       case 1: puts("One");
               break;
       case 2: puts("Two");
               break;
     ...
     default:  puts("None of the above!");
               break;
     }

                         Многоточие.

     "..." используется в списке формальных аргументов  прото-
типа функции для указания переменного числа аргументов или ар-
гументов с изменяющимися типами:
     void func(int n, char ch, ...);
     Это объявление указывает, что func будет определена таким
образом,  что  вызовы должны иметь по крайней мере 2 аргумента
int и char, но могут иметь любое число дополнительных аргумен-
тов.
     Примечание: В С++  Вы  можете  пропустить  запятую  перед
"...".

                      Знак "звездочка".

     "*" в  объявлении переменной указывает на создание указа-
теля на тип:
     char *char_ptr;
     Указатель с несколькими уровнями ссылок может быть объяв-
лен заданием соответствующего числа звездочек:
     int **int_ptr;      /* указатель на указатель на int */
     double ***double_ptr;  /* указатель на указатель на
                             указатель на double */
     Вы можете  использовать  * как оператор для косвенной ад-
ресации или как оператор умножения:
     i = *int_ptr;
     a = b*3.14;

               Знак равенства (инициализатор).

     Знак равенства (инициализатор) разделяет объявление пере-
менной от списка инициализации:
     char array[5] = {1, 2, 3, 4, 5};
     int x = 5;
     В функциях до объявления переменных не может стоять  код.
В  С++  объявления  любого типа могут появляться (с некоторыми
ограничениями) в любой точке внутри кода.
     В списке  аргументов функции С++ знак равенства указывает
на значение параметра по умолчанию:
     int f(int i = 0) {...}
     Знак равенства так же используется как оператор  присваи-
вания в выражениях:
     a = b + c;
     ptr = farmalloc(sizeof(float) * 100);

                 Директива препроцессора (#).

     # указывает на директиву препроцессора, когда он встреча-
ется как первый символ (не разделитель) на строке.  Он опреде-
ляет действия компилятора,  не обязательно связанные с генера-
цией кода.
     # и  ## так же используются как операторы для замещения и
объединения лексем во время фазы препроцессора.

                         Объявления.

     Этот раздел кратко описывает концепции,  связанные с объ-
явлениями: объекты, типы, классы памяти, сферы действия, время
действия,  видимость и редактирование.  Общее представление  о
них необходимо до полного объяснения синтаксиса объявлений.
     Сфера действия,  время действия, видимость и редактирова-
ние  определяют  те  части программы,  которые могут выполнять
правильные ссылки на идентификатор для доступа к его объекту.

                           Объекты.

     Объект - это идентифицированная область  памяти,  которая
может содержать фиксированное или переменное значение (или на-
бор значений).  Это использование слова объект не следует  пу-
тать с более общим термином,  используемым в объектно-ориенти-
рованных языках - см. главу 4 в "Начале работы". Каждое значе-
ние имеет имя и тип (известный как тип данных).  Имя использу-
ется для доступа к объекту. Это имя может быть простым иденти-
фикатором или же сложным выражением, которое однозначно ссыла-
ется на объект. Тип используется
     - для определения корректного распределения памяти
     - для интерпретации данных,  найденных в объекте во время
последующих обращений
     - для проверок типов,  чтобы избежать неверных присваива-
ний.  Borland C++ поддерживает многие стандартные (предопреде-
ленные) и определенные пользователем типы данных, включая зна-
ковые и беззнаковые целые различных размеров,  числа с плаваю-
щей точкой различной точности, структуры, объединения, массивы
и классы.  Кроме того, указатели на большинство из этих объек-
тов могут использоваться в различных моделях памяти.
     Стандартные библиотеки Borland C++, Ваша программа и фай-
лы заголовков должны обеспечивать однозначные идентификаторы и
типы так,  чтобы Borland C++ мог правильно обращаться, интерп-
ретировать и (возможно) изменять данные в памяти соответствую-
щей каждому активному объекту Вашей программы.
     Объявление устанавливает необходимое  соответствие  между
идентификатором и объектом.  Каждое объявление связывает иден-
тификатор с типом данных.  Большинство  объявлений,  известные
как объявление определения, так же устанавливают создание (где
и когда) объекта,  т.е.  распределение физической памяти и  ее
возможную инициализацию. Другие объявления, известные как ссы-
лочные объявления, просто делают идентификаторы и типы извест-
ными компилятору.  Может существовать множество ссылочных объ-
явлений для одного идентификатора,  особенно  в  многофайловой
программе, но для каждого идентификатора разрешено только одно
объявление определения.
     Короче говоря,  идентификатор не может быть использован в
программе до точки его объявления в исходном тексте.  Исключе-
ния  из этого правила,  известные как "ссылка вперед" - метки,
имена структур и объединений и вызовы необъявленных функций.

                           Lvalue.

     Lvalue - это выражение,  указывающее на объект.  Примером
выражения  Lvalue  является *P,  где Р - любое выражение,  вы-
числяемое в ненулевой указатель.  Модифицируемое Lvalue -  это
идентификатор  или выражение,  которые относятся к объекту,  к
которому можно обращаться и изменять в памяти. const указатель
на константу, например, это немодифицируемое Lvalue. Указатель
на константу может быть изменен (но указываемое им значение не
может).
     L (left - левый), стоящее слева, означает, что Lvalue мо-
жет стоять в левой части оператора присваивания.  Только моди-
фицируемые Lvalue могут стоять в левой части оператора присва-
ивания.  Например,  если  a  и b - целочисленные неконстантные
идентификаторы с соответствующим  распределенным  хранением  в
памяти,  то  оба они являются модифицируемыми lvalue,  и такие
присваивания, как a = 1, b = a + b являются правильными.

                           Rvalue.

     Выражение A+B - это не Lvalue: A+B = A неверно, поскольку
выражение в левой части не ссылается на объект.  Такие выраже-
ния часто называются Rvalue (R - right - правый).

                    Типы и классы памяти.

     Связывание идентификатора с объектом требует,  чтобы каж-
дый идентификатор имел, по крайней мере, 2 атрибута: класс па-
мяти и тип.  Компилятор Borland C++ определяет эти атрибуты из
явных и неявных объявлений в исходном коде.
     Класс памяти указывает  положение  (сегмент  данных,  ре-
гистр,  куча  или  стек) объекта и продолжительность его жизни
(все время выполнения программы или выполнение некоторых  бло-
ков  кода).  Класс  памяти может быть установлен по синтаксису
объявления, его размещению в исходном коде или ими обоими.
     Тип, как объяснено ранее, определяет сколько памяти расп-
ределяется под объект,  и как программа будет интерпретировать
данные в памяти объекта.  Тип данных может быть рассмотрен как
набор значений (часто зависимый от реализации),  который может
принимать идентификатор этого типа, вместе с набором операций,
допустимых над этими значениями.  Специальный оператор времени
компиляции sizeof позволяет Вам определить размер в байтах лю-
бого стандартного или определенного пользователем типа.

                       Сфера действия.

     Сфера действия идентификатора - это  часть  программы,  в
которой  идентификатор  может использоваться для доступа к его
объекту.  Существует 5 категорий сфер действия:  блок (или ло-
кальный),  функция,  прототип  функции,  файл  и класс (только
С++). Это зависит от того, как и где объявлены идентификаторы.

                    Сфера действия блока.

     Сфера действия идентификатора со сферой  блока  (или  ло-
кальная) начинается с точки объявления и заканчивается в конце
блока,  содержащего объявления (такой блок называется включаю-
щим  блоком).  Объявления параметров в определении функции так
же имеют сферу блока,  ограниченной сферой действия блока, ко-
торый определяет функцию.

                   Сфера действия функции.

     Сферу действия - функция имеют только метки.  Имена меток
могут использоваться в операторах goto в любом месте  функции,
в котором определена метка.  Метка определяется неявно записью
"метка:" перед оператором. Имена меток должны быть уникальными
внутри функции.

              Сфера действия прототипа функции.

     Идентификаторы, объявленные  внутри списка объявления па-
раметров в прототипе функции (не в части определения функции),
имеют  сферу  действия - прототип функции.  Эта сфера действия
заканчивается на конце действия прототипа функции.

                    Сфера действия файла.

     Идентификаторы сферы действия файла,  так  же  называемые
глобальными,  объявлены  вне  всех блоков и классов;  их сфера
действия от точки объявления до конца исходного файла.

                 Сфера действия класса (С++).

     В данный момент думайте о классах как об именованной  со-
вокупности  элементов,  включающей структуры данных и функции,
обрабатывающие их.  Сфера класса применима с некоторыми исклю-
чениями  к именам элементов этого класса.  Классы и их объекты
имеют специальные правила доступа и сфер действия.

             Сферы действия и пространства имен.

     Пространство имени - это сфера действия,  внутри  которой
идентификатор  должен  быть  уникальным.  Существует  4 класса
идентификаторов в С:
     1. Имена  меток goto.  Они должны быть уникальными внутри
функций, в которых они объявлены.
     2. Структуры,  объединения и значения перечислимого типа.
Они должны быть уникальны внутри блока, в котором они объявле-
ны.  Значения перечислимых типов,  объявленные вне любой функ-
ции, должны быть уникальными среди всех значений перечислимого
типа, определенных как внешние.
     3. Имена элементов структур  и  объединений.  Они  должны
быть  уникальными внутри структуры или объединения,  в которых
они определены. Нет ограничений на тип или смещение элемента с
одинаковым именем элемента в различных структурах.
     4. Переменные,  typedefs и элементы  перечислимого  типа.
Они должны быть уникальными внутри сферы,  в которой они опре-
делены.  Идентификаторы,  объявленные как внешние, должны быть
уникальными среди переменных, объявленных как внешние.

                          Видимость.

     Видимость идентификатора  -  это  область  исходного кода
программы,  в которой может быть осуществлен доступ к объекту,
связанному с этим идентификатором.
     Сфера действия и видимость обычно совпадают, хотя сущест-
вуют различия для объектов,  которые становятся временно скры-
тыми из-за появления дублирующих идентификаторов:  объект  еще
существует, но первоначальный идентификатор не может использо-
ваться для доступа к нему,  пока не закончится сфера  действия
дублирующего идентификатора.
     Примечание: Видимость   не   может   превосходить   сферу
действия, но сфера действия может превосходить видимость.
     ...
     {
       int i; char ch;   // по умолчанию auto
       i = 3; // int i и char ch в области действия и видимы
     ...
       {
          double i;
          i = 3.0e3; // double i  в области действия и видима
                     // int i в области действия, но скрыта
          ch = 'A';  // char ch в области действия и видима
       }
                // double i вне области действия
       i += l;  // int i видима и = 4
     ... // char ch все еще в области действия, видима и = 'A'
     }
     ...        // int i и char ch вне области действия
     Примечание: Существуют специальные  правила  для  скрытых
имен  классов и имен элементов классов:  специальные операторы
С++ позволяют скрывать идентификаторы,  доступные при  опреде-
ленных условиях.

                       Время действия.

     Время действия, тесно связанное с классом памяти, опреде-
ляет период, во время которого объявленные идентификаторы име-
ют  реальные физические объекты,  распределенные в памяти.  Мы
так же различаем объекты времени компиляции и времени выполне-
ния.  Переменные, в отличие от typedef и типов, имеют реальное
распределение в памяти во время выполнения.  Существует 3 раз-
новидности времени действия:  статическое, локальное и динами-
ческое.

                 Статическое время действия.

     Объекты со статическим временем действия распределяются в
памяти  в  начальный момент выполнения программы и остаются до
тех пор,  пока не завершится выполнение программы. Статические
объекты  обычно размещаются в фиксированных сегментах данных в
соответствии с выбранной моделью памяти.  Все  функции  -  это
объекты  со  статическим временем действия.  Все переменные со
сферой действия файл имеют статическое время действия.  Другие
переменные  могут стать статическими с помощью явного указания
static или extern.
     Статические объекты  инициализируются  в  ноль  в  случае
отсутствия явного инициализатора или в С++ - констрактора.
     Статическое время   действия   нельзя  путать  со  сферой
действия файл или глобальный.  Объект может иметь  статическое
время действия и локальную сферу действия.


                  Локальное время действия.

     Объекты локального времени действия так же  известны  как
автоматические объекты. Они создаются в стеке (или в регистре)
при входе в блок или функцию.  Они удаляются,  когда программа
выходит из этого блока или функции. Объекты локального времени
действия должны быть явно инициализированы;  иначе их содержи-
мое непредсказуемо. Объекты локального времени действия должны
иметь сферу действия локальную или функции. При объявлении пе-
ременных  локального  времени действия может быть задан указа-
тель класса памяти auto,  но обычно он пропускается, поскольку
auto  принимается  по  умолчанию  для переменных,  объявленных
внутри блока.
     Примечание: Объект  локального времени действия имеет так
же локальную сферу действия,  поскольку он не  существует  вне
окружающего его блока. Обратное неверно; объект локальной сфе-
ры действия может иметь статическое время действия.
     Когда объявляется переменная (например int, char, float),
указатель класса памяти register так же подразумевает  auto  и
указывает  компилятору распределить по возможности этот объект
в регистр. Borland C++ может устанавливать в регистр локальную
целую  переменную или указатель,  если регистр свободен.  Если
нет свободного регистра,  переменная распределяется  как  auto
без выдачи предупреждений или ошибок.

                 Динамическое время действия.

     Объекты динамического времени действия создаются и разру-
шаются вызовами специальных функций во время работы программы.
Они распределяют память в специальной области памяти,  извест-
ной как куча (heap),  используя либо стандартную  библиотечную
функцию malock,  либо оператор С++ new. Соответствующее разру-
шение объекта выполняется с помощью free или delete.

                      Модули трансляции.

     Термин "модуль трансляции" используется для файла  исход-
ного  кода  вместе со всеми включаемыми файлами за исключением
исходных строк, пропущенных условными директивами препроцессо-
ра.  синтаксически  модуль трансляции определен как последова-
тельность внешних объявлений.

     модуль-трансляции:
       внешние-объявления
       модуль-трансляции внешние-объявления

     внешние-объявления:
       определение-функции
       объявление

     Слово "внешние" используется в  в  разных  контекстах  С;
здесь оно означает объявление, сделанное вне функций, и следо-
вательно имеющее сферу действия файл.  Любое объявление, кото-
рое так же резервирует память для объекта или функции, называ-
ется определением или объявлением определения.

                       Редактирование.

     Выполнимая программа   обычно    создается    компиляцией
нескольких независимых модулей трансляции,  а затем редактиро-
ванием полученных объектных файлов с существующими библиотека-
ми.  Проблема возникает,  когда один идентификатор определен в
различных сферах действия (например в различных  файлах),  или
объявлен  более  одного  раза в одной и той же сфере действия.
Редактирование - это процесс,  который позволяет  каждому  эк-
земпляру  идентификатора  корректно назначить отдельный объект
или функцию.  Все идентификаторы имеют один из трех  атрибутов
редактирования,  тесно связанных с их сферой действия: внешнее
редактирование,  внутреннее редактирование и  нередактируемый.
Эти  атрибуты определяются размещением и форматом Ваших объяв-
лений,  а так же явным (или неявным по умолчанию) используемым
указателем класса памяти static или extern.
     Каждый экземпляр идентификатора с внешним редактированием
представляет объект во всех файлах и библиотеках во время соз-
дания программы.  Каждый экземпляр идентификатора с внутренним
редактированием  представляет объект или функцию только внутри
одного файла. Нередактируемые идентификаторы представляют уни-
кальные элементы.
     Правила внутреннего и внешнего редактирования:
     1. Любой объект или идентификатор, имеющий сферу действия
файл,  является внутренне редактируемым,  если его  объявление
содержит указатель класса памяти static.
     В С++, если один и тот же идентификатор появляется в фай-
ле как с внешним и так с внутренним редактированием, идентифи-
катор будет с внешним редактированием;  а в С++  с  внутренним
редактированием.
     2. Если объявление объекта или идентификатора функции со-
держит указатель класса памяти extern, этот идентификатор име-
ет то же редактирование,  как любое видимое объявление иденти-
фикатора  со  сферой  действия файл.  Если нет такого видимого
объявления, идентификатор внешне редактируемый.
     3. Если функция объявлена без указателя класса памяти, ее
редактирование определяется, как если бы был указан extern.
     4. Если  идентификатор  объекта  со  сферой действия файл
объявлен без указателя класса памяти, то он внешне редактируе-
мый.
     Следующие идентификатора имеют атрибут нередактируемый:
     1. Все  идентификаторы,  отличные от объектов или функций
(например идентификатор typedef).
     2. Параметры функций.
     3. Идентификаторы сферы действия блок для объектов,  объ-
явленных без указателя класса памяти extern.

                       Сокращение имен.

     Когда компилируется  модуль  С++,  компилятор  генерирует
имена функций,  включающие шифровку типов аргументов  функций.
Это  называется сокращением имен.  Это дает возможность делать
функции оверлейными и помогает редактору поймать ошибки  вызо-
вов функций в других модулях.  Однако бывают случаи, когда Вам
не понадобится сокращение имен. При компиляции модуля С++, ко-
торый должен редактироваться с модулем, не имеющим сокращенные
имена, компилятору С++ нужно сказать о том, чтобы не сокращать
имена функций из другого модуля. Эта ситуация обычно возникает
при редактировании с библиотеками и объектными файлами, компи-
лированными компилятором С.
     Чтобы сказать компилятору С++ не сокращать имена функций,
просто объявите функцию как extern "C":
     extern "C" void Cfunc (int);
     Это объявление говорит компилятору, что ссылки на функцию
Cfunc не должны быть сокращены.
     Можно применить объявление extern "С" к блоку имен:
     extern "C" {
        void Cfunc1(int);
        void Cfunc2(int);
        void Cfunc3(int);
     };
     Как и в объявлении отдельной функции,  это объявление го-
ворит компилятору,  что ссылки на  функции  Cfunc1,  Cfunc2  и
Cfunc3 не должны быть сокращены.  Можно также использовать эту
форму объявления блока,  когда блок имен функций содержится  в
файле заголовков:
     extern "C" {
        #include "locallib.h"
     };

                    Синтаксис объявления.

     Все 6 атрибутов (класса памяти, типа, сферы действия, ви-
димости,  времени  действия  и  редактирования) определяются в
объявлениях.
     Объявление может быть объявлением определения (так же из-
вестным как определение) или ссылочным объявлением (иногда на-
зываемым как неопределяющее объявление).  Объявление определе-
ния, как следует из названия, производит как объявление, так и
определение; неопределяющее объявление требует дополнительного
определения где-либо в  программе.  Неопределяющее  объявление
просто  вводит  одно  или более имен в программу.  Определение
распределяет память под объект  и  связывает  идентификатор  с
этим объектом.

                 Предварительное определение.

     Стандарт ANSI  C  вводит новую концепцию "предварительное
определение".  Любое внешнее объявление данных  без  указателя
класса памяти и инициализатора,  рассматривается как предвари-
тельное определение. Если идентификатор появляется позже в оп-
ределении,  это  предварительное  определение рассматривается,
как если бы был указан класс памяти extern.  Другими  словами,
предварительное определение становится просто ссылочным объяв-
лением.
     Если до конца модуля трансляции определение идентификато-
ра не встретилось,  это предварительное определение становится
полным  определением  и  объект определен с распределенным под
него неинициализированным пространством. Например:
     int x;
     int x;  /* резервируется одна копия под х */

     int y;
     int y = 4;  /* y инициализируется в 4 */

     int z = 5;
     int z = 6;  /* неверно. оба имеют инициализацию */

                    Возможные объявления.

     Список объектов, которые можно объявить:
     - переменные
     - функции
     - классы и элементы классов (С++)
     - типы
     - структуры, объединения и перечисления
     - элементы структур
     - элементы объединений
     - массивы
     - перечислимые константы
     - метки
     - препроцессорные макро
     Полный синтаксис объявлений показан в следующих таблицах.
Рекурсивная  природа  объявлений допускает сложные объявления.
Мы поддерживаем использование typedefs для достижения удобочи-
таемости.

       Таблица 1.10. Синтаксис объявлений Borland C++.
──────────────────────────────────────────────────────────────
     объявление:
       <указатели-объявления> <список-объявлений>;
       объявление-asm
       объявление-функции
       указание-редактирования

     указатель-объявления:
       указатель-класса-памяти
       указатель-типа
       указатель-fct
       friend (С++)
       typedef

     указатели-объявления:
       <указатели-объявления> указатель-объявления

     указатель-класса-памяти:
       auto
       register
       static
       extern

     указатель-fct (С++):
       inline
       virtual

     указатель-типа:
       имя-простого-типа
       указатель-класса
       указатель-перечисления
       указатель-сложного-типа
       const
       volatile

     имя-простого-типа:
       имя-класса
       имя-typedef
       char
       short
       int
       long
       signed
       unsigned
       float
       double
       void

     указатель-сложного-типа:
       ключ-класса идентификатор
       ключ-класса имя-класса
       enum имя-перечисления

     ключ-класса: (С++)
       class
       struct
       union

     указатель-перечисления:
       enum <идентификатор>{<список-перечислений>}

     список-перечислений:
       перечислимое-значение
       список-перечислений, перечислимое-значение

     перечислимое-значение:
       идентификатор
       идентификатор=константное-выражение

     константное-выражение:
       условное-выражение

     указание-редактирования: (С++)
       extern строка {<список-объявления>}
       extern строка, объявление

     список-объявления:
       объявление
       список-объявления; объявление

──────────────────────────────────────────────────────────────
     Для следующей таблицы заметим, что существуют ограничения
на число и порядок модификаторов и квалификаторов. Также пере-
численные  модификаторы  являются  только  добавлением  к син-
таксису объявлений, которые не относятся к ANSI C или C++.

      Таблица 1.11. Модификаторы объявления Borland C++.
──────────────────────────────────────────────────────────────
     список-элементов-объявления:
       инициализатор
       список-элементов-объявления, инициализатор

     инициализатор:
       модификатор <инициализационное-значение>

     модификатор:
       d-имя
       список-модификаторов
       ptr-оператор элемент-объявления
       элемент-объявления (список-параметров-объявления)
        <список-cv-квалификаторов> (С++)
       элемент-объявления [<константное-выражение>]
       (элемент-объявления)

     список-модификаторов:
       модификатор
       список-модификаторов модификатор

     модификатор:
       cdecl
       pascal
       interrupt
       near
       far
       huge

     ptr-оператор:
       *<список-cv-квалификаторов>
       &<список-cv-квалификаторов> (С++)
       имя-класса::*<список-cv-квалификаторов> (С++)

     список-cv-квалификаторов:
       cv-квалификатор <список-cv-квалификаторов>

     cv-квалификатор:
       const
       volatile

     d-имя:
       имя
       имя-класса (С++)
       ~имя-класса (С++)
       имя-typedef

     имя-типа:
       указатель-типа <абстрактный-элемент-объявления>

     абстрактный-элемент-объявления:
       ptr-оператор <абстрактный-элемент-объявления>
       <абстрактный-элемент-объявления> (список-аргументов-
          объявления) <список-cv-квалификаторов>
       <абстрактный-элемент-объявления>
                               [<константное-выражение>]
       (абстрактный-элемент-объявления)

     список-аргументов-объявления:
       <список-arg-объявления>
       список-arg-объявления, ...
       <список-arg-объявления> ... (С++)

     список-arg-объявления:
       аргумент-объявления
       список-arg-объявления, аргумент-объявления

     аргумент-объявления:
       указатель-объявления элемент-объявления
       указатель-объявления элемент-объявления =
                                       выражение (С++)
       указатель-объявления <абстрактный-элемент-объявления>
       указатель-объявления <абстрактный-элемент-объявления> =
         выражение (С++)

     fct-определение:
     <указатель-объявления> элемент-объявления <инициализатор-
          ctor> тело-fct

     тело-fct:
       составной-оператор

     инициализационное-значение:
       =выражение
       ={список-инициализаторов}
       (список-выражений) (С++)

     список-инициализаторов:
       выражение
       список-инициализаторов, выражение
       {список-инициализаторов<,>}

──────────────────────────────────────────────────────────────

              Внешние объявления и определения.

     Указатели класса  памяти  auto  и register не могут появ-
ляться во внешних объявлениях.  Для каждого  идентификатора  в
модуле трансляции,  объявленного с внутренним редактированием,
не может быть более одного внешнего определения.
     Внешнее определение - это внешнее объявление, которое так
же определяет объект или функцию;  т.е.  распределяет  память.
Если  идентификатор,  объявленный  с  внешним редактированием,
используется в выражении (в другом, чем оператор sizeof), то в
программе  может  быть  только  одно внешнее определение этого
идентификатора.
     Borland С++ позволяет впоследствии переопределять внешние
имена такие,  как массивы,  структуры и объединения,  добавляя
информацию к ранним объявлениям. Например
     int a[];               // без размера
     struct mystruct;       // только имя типа без объявления
                            // элементов
     ...
     int a[3] = {1, 2, 3};  // устанавливается размер и
                            // инициализируется
     struct mystruct{
       int i, j;
     };                     // добавляет объявление элементов
     Следующая таблица приводит синтаксис объявления классов.

  Таблица 1.12. Объявления классов Borland C++ (только С++).
──────────────────────────────────────────────────────────────
     указатель-класса:
       заголовок-класса {<список-элементов>}

     заголовок-класса:
       ключ-класса <идентификатор> <основная-спецификация>
       ключ-класса имя-класса <основная-спецификация>

     список-элементов:
       объявление-элемента <список-элементов>
       указатели-доступа: <список-элементов>

     объявление-элемента:
       <указатель-объявления><список-объявления-элемента>;
       определение-функции <;>
       квалифицированное-имя;

     список-объявления-элемента:
       элемент-объявления-элемента
       список-объявления-элемента, элемент-объявления-элемента

     элемент-объявления-элемента:
       элемент-объявления <чистый-указатель>
       <идентификатор>:константное-выражение

     чистый-указатель:
       = 0

     основная-спецификация:
       :основной-список

     основной-список:
       основной-указатель
       основной-список, основной-указатель

     основной-указатель:
       имя-класса
       virtual <указатель-доступа> имя-класса
       указатель-доступа <virtual> имя-класса

     указатель-доступа:
       private
       protected
       public

     имя-функции-преобразования:
       указатель-типа <ptr-оператор>

     ctor-инициализатор:
       :список-mem-инициализаторов

     список-mem-инициализаторов:
       mem-инициализатор
       mem-инициализатор, список-mem-инициализаторов

     mem-инициализатор:
       класс имя (<список-аргументов>)
       идентификатор (<список-аргументов>)

     имя-функции-оператора:
       operator оператор

     оператор: один из
       new delete sizeof
       + - * / % ^
       & | ~ ! = <>
       += -= *= /= %= ^=
       &= |= << >> >>= <<=
       == != <= >= && ||
       С++ -- , ->* -> ()
       [] .*
──────────────────────────────────────────────────────────────

                       Указатель типа.

     Указатель типа  - это один или более необязательных моди-
фикаторов,  используемых для задания типа объявляемого иденти-
фикатора:
     int i;                    // объявляет i как знаковое
     unsigned char ch1, ch2;   // объявляет 2 беззнаковых char
     По традиции,  если указатель типа  пропущен,  принимается
тип signed int.  Однако в С++ существует ситуация,  когда про-
пуск указателя типа приводит к синтаксической неопределенности
так, что в практике С++ используется явное указание всех типов
int.

                     Классификация типов.

     Существует 4 основных категории типов: пустой, скалярный,
функция, сложный. Скалярный и сложный типы можно разделить:
     - скалярный: арифметический, перечислимый, указатели и, в
С++, ссылочный тип.
     - сложный: массив, структура, объединение и, в С++, класс.
     Типы так  же  можно  разделить на основные и производные.
Основные типы - это void,  char,  int, float и double вместе с
short,  long,  signed  и unsigned вариантами некоторых из них.
Производные типы включают указатели и ссылки на  другие  типы,
массивы других типов,  типы функции,  типы классы, структуры и
объединения.
     Объект класс, например, может содержать ряд объектов раз-
личных типов вместе с функциями для манипуляции этими объекта-
ми,  а так же механизм для управления доступом и наследованием
из других классов.
     С любым  непустым типом type (с некоторыми оговорками) Вы
можете определить производные типы:

               Таблица 1.13. Объявление типов.
──────────────────────────────────────────────────────────────
     type t;                       объект типа type
     type array[;]                 10 элементов типа type
     type *ptr;                    ptr - это указатель на type
     type &ref = t;                ref - это ссылка на type
                                   (С++)
     type func(void);              функция возвращает значение
                                   типа type
     void func1(type t);           func1 берет параметр
                                   типа type
     struct st{type t1; type t2};  структура st содержит
                                   2 type
──────────────────────────────────────────────────────────────
     Пример объявления производного типа в классе:
     class ct {  // класс ct хранит указатель на тип плюс
                 // функция, принимающая параметр type (С++)
       type *ptr;
       public
       void func(type*);
     }

                          Тип void.

     void - это специальный тип, указывающий на отсутствие лю-
бых значений. Он используется в следующих ситуациях:
     - При пустом списке параметров в объявлении функции:
       int func(void);
     - Когда объявляемая функция не возвращает значение:
       void func(int n);
     - Указатель на void - это указатель на что-либо:
       void *ptr;
     - В выражениях приведения типа:
       extern int rfunc();
       ...
       (void) rfunc();
     Примечание. С++ обрабатывает func() особым  образом.  См.
раздел "Объявления и прототипы".

                        Основные типы.

     Основные типы  объявляются  с помощью встроенных ключевых
     слов:  char    int    signed
            double  long   unsigned
            float   short
     Примечание: Модификаторы   signed  и  unsigned  применимы
только к целым типам.
     С помощью  этих  ключевых  слов Вы можете создавать целые
типы и типы с плавающей точкой, которые известны как арифмети-
ческие типы. Файл limits.h содержит диапазон допустимых значе-
ний для всех основных типов.

                         Целые типы.

     char, short, int, long вместе с их беззнаковыми варианта-
ми являются целыми типами данных. Список целых типов с синони-
мами, приведенными в одной строке:

                  Таблица 1.14. Целые типы.
─────────────────────────────────────────────────────────────
     char, signed char
     unsigned char
     char, unsigned char
     signed char
     int, signed int
     unsigned, unsigned int
     short, short int, signed short int
     unsigned short, unsigned short int
     long, long int, signed long int
     unsigned long, unsigned long int
─────────────────────────────────────────────────────────────
     signed и unsigned могут быть использованы с char,  short,
int или long.  Если используется просто signed  или  unsigned,
это означает signed int и unsigned int.
     При отсутствии unsigned обычно используется signed.  Иск-
лючение составляет char.  Borland C++ позволяет Вам установить
умолчание для  char  в  signed  или  unsigned.  (По  умолчанию
используется  signed).  Если умолчание установлено в unsigned,
то объявление char ch объявляет ch как unsigned.  Для перекры-
тия установки по умолчанию используйте signed char ch.  Подоб-
ным образом, с signed по умолчанию для char, Вам явно потребу-
ется unsigned char для объявления ch unsigned char.
     С int может  использоваться  long  или  short.  Отдельное
использование long и short означает long int и short int.
     ANSI C не устанавливает размера и внутреннего представле-
ния этих типов, за исключением того, что short <= int <= long.
Все 3 типа могут быть одинаковыми.  Это важно,  если Вы хотите
писать переносимую программу.
     В Borland C++ типы int и short эквивалентны - по 16  бит.
long  -  32-битовый объект.  Все знаковые множества хранятся в
формате,  использующем MSB (самый значащий бит) как бит знака:
0 для положительных, 1 для отрицательных (что объясняет диапа-
зоны в таблице  1.9).  Как  и  беззнаковые  версии,  все  биты
используются  для  задания диапазонов 0 - (2 в степени n - 1),
где n равно 8, 16 или 32.

                   Типы с плавающей точкой.

     Представление и набор значений для типа с плавающей  точ-
кой  зависит  от  реализации.  Borland C++ использует формат с
плавающей точкой IEEE.  (Приложение А дает дополнительную  ин-
формацию о вопросах, зависящих от реализации).
     float и double - это 32 и 64 битные типы данных с плаваю-
щей точкой.  long может использоваться с double для объявления
80-битного типа данных.

                 Стандартное преобразование.

     Когда Вы используете арифметическое выражение,  такое как
a+b,  где  a и b - различные арифметические типы,  Borland C++
производит определенные внутренние преобразования до  вычисле-
ния выражения. Эти стандартные преобразования включают продви-
жение от "низких" типов к "высоким" типам для обеспечения точ-
ности.
     Borland C++ выполняет следующие шаги  для  преобразования
операндов в арифметических выражениях :
     1. Все короткие целые типы преобразуются,  как показано в
таблице 1.15. После этого любые 2 значения, связанные с опера-
тором,  становятся  либо  int  (включая  модификаторы  long  и
unsigned), либо double, float или long double.
     2. Если один из операндов типа long double,  другой  опе-
ранд преобразуется в long double.
     3. Иначе, если один из операндов типа double, другой опе-
ранд преобразуется в double.
     4. Иначе,  если один из операндов типа float, другой опе-
ранд преобразуется в float.
     5. Иначе, если один из операндов типа unsigned long, дру-
гой операнд преобразуется в unsigned long.
     6. Иначе,  если один из операндов типа long,  другой опе-
ранд преобразуется в long.
     7. Иначе,  если один из операндов типа  unsigned,  другой
операнд преобразуется в unsigned.
     8. Иначе оба операнда типа int.
     Результат выражения  того же типа,  что и входящие в него
операнды.

                        Таблица 1.15.
        Методы,    используемые     в     стандартных
               арифметических преобразованиях.
─────────────────────────────────────────────────────────────
  тип          преобразуется в          метод
─────────────────────────────────────────────────────────────
  char             int            зануление или расширение
                                  знака
  unsigned char    int            зануление старшего байта
  signed char      int            расширение знака
  short            int            то же значение
  unsigned short   unsigned int   то же значение
  enum             int            то же значение
─────────────────────────────────────────────────────────────

         Специальное преобразование char, int и enum.

     Присвоение знакового  символьного объекта (такого как пе-
ременная) целому объекту приводит к автоматическому расширению
знака.  Объекты  типа signed char всегда используют расширение
знака; объекты типа unsigned char всегда устанавливают старший
байт в 0 при преобразовании в int.
     Преобразование более длинного целого типа в более  корот-
кий тип отсекает старшие биты и оставляет младшие неизмененны-
ми. Преобразование более короткого целого типа в более длинный
тип либо расширяет знак,  либо заполняет старшие биты нулями в
зависимости от  типа  более  короткого  целого  -  signed  или
unsigned соответственно.
     Примечание: Преобразования, описанные в этом разделе, яв-
ляются специфичными для Borland C++.

                        Инициализация.

     Инициализация устанавливает  начальные значения,  которые
сохраняются в объектах  (переменных,  массивах,  структурах  и
т.д.).  Если  Вы  не  инициализируете объект и он имеет стати-
ческое время действия, он инициализируется по умолчанию:
     - в 0, если он арифметического типа
     - в null, если он типа указатель.
     Примечание: Если объект автоматического времени действия,
его значение неопределено.
     Синтаксис для инициализации:

     инициализационное-значение:
       =выражение
       ={список-инициализаторов}
       (список-выражений) (С++)

     список-инициализаторов:
       выражение
       список-инициализаторов, выражение
       {список-инициализаторов<,>}

     Правила инициализации:
     1. Число инициализационных значений при инициализации  не
может быть больше числа инициализируемых значений.
     2. Инициализируемый элемент должен быть типом объекта или
массивом неизвестного размера.
     3. Все выражения должны быть константами,  если они появ-
ляются в одном из мест:
     а. При  инициализации  объекта  со  статическим  временем
действия (не требуется для С++).
     б. В списке инициализации массива,  структуры или объеди-
нения. (Так же разрешается использовать в выражении sizeof).
     4. Если  объявления  для   идентификатора   имеют   сферу
действия блок и идентификатор имеет внешнее или внутреннее ре-
дактирование, объявление не может содержать инициализацию.
     5. Если инициализационных значений меньше,  чем элементов
в структуре, остаток структуры неявно инициализируется так же,
как объекты со статическим временем действия.
     Скалярные типы инициализируются выражением, которое может
быть заключено в скобки. Начальное значение объекта - это зна-
чение выражения;  применяются те же правила для типов и те  же
преобразования, как и для присваивания.
     Для объединений инициализационное значение в скобках ини-
циализирует элементы, которые первыми появляются в списке объ-
явления объединения.  Для структур и объединений  с  автомати-
ческим  временем  действия  инициализационное  значение должно
быть:
     - списком инициализации,  как описано в следующем разделе
     - выражением, совместимым с типом структуры или объедине-
     ния.

              Массивы, структуры и объединения.

     Вы инициализируете массивы и структуры (во время объявле-
ния,  если хотите) с помощью списка инициализационных значений
для элементов.  Инициализационное значение приводится для пер-
вого элемента объединения. Например, Вы можете объявить массив
days, собираясь посчитать сколько раз каждый день недели появ-
ляется в месяце (и исходя,  что каждый день появляется хотя бы
однажды):
     int days[7]={1, 1, 1, 1, 1, 1, 1};
     Используйте эти  правила для инициализации массива симво-
лов:
     1. Вы можете инициализировать массив символов литеральной
строкой (можно заключить в {}).  Каждый символ в строке, вклю-
чая   завершающий  ноль,  инициализирует  последующий  элемент
массива. Например, Вы можете объявить:
     char name[]= {"unknown"};
     который устанавливает name[0] в 'u', name[1] в 'n' и т.д.
     2. Вы  можете  инициализировать  длинный  массив символов
(совместимый с wchar_t), используя длинную литеральную строку,
возможно  заключенную  в {}.  Как и в случае массива символов,
коды длинной литеральной строки последовательно инициализируют
элементы массива.
     Пример инициализации структуры:
     struct mystruct {
       int i;
       char str[21];
       double d;
     } s = {20, "Borland", 3.141};
     Сложные элементы структуры такие,  как массивы или струк-
туры, могут быть инициализированы соответствующими выражениями
внутри вложенных {}.  Вы можете опустить некоторые {},  но  Вы
должны соблюдать при этом определенные правила,  и это не луч-
шая практика.

                     Простые объявления.

     Простое объявление идентификатора переменной имеет вид:
     тип-данных var1 <=init1>, var2 <=init2>,...;
     где var1,  var2, ... последовательность идентификаторов с
необязательными инициализаторами. Каждое из объявленных значе-
ний будет типа тип-данных. Например
     int x = 1, y = 2;
     создает 2 целых переменных x и y и инициализирует их в  1
и 2 соответственно.
     Это объявление определения; оно распределяет память и мо-
жет использовать любые инициализаторы.
     Инициализатор для автоматического объекта может быть  лю-
бым выражением, которое вычисляется в совместимое значение для
этого типа переменной. Инициализаторы для статических объектов
должны быть константами или константными выражениями.
     Примечание: В С++ инициализатор для статических  объектов
может быть любым выражением,  включающим константы и предвари-
тельно объявленные переменные и функции.

                   Указатели класса памяти.

     В объявлении должен  присутствовать  спецификатор  класса
памяти,  или спецификатор типа.  Указатель класса памяти может
быть один из следующих:
     auto register typedef extern static

         Использование указателя класса памяти auto.

     Указатель класса памяти auto используется только при объ-
явлении переменных локальной сферы действия.  Он устанавливает
локальное  (автоматическое)  время  действия,  но поскольку он
устанавливается по умолчанию  для  всех  переменных  локальной
сферы действия, auto используется редко.

        Использование указателя класса памяти extern.

     Указатель класса  памяти  extern  может  использоваться с
функциями и переменными сферы действия файл  и  локальные  для
указания  на  внешнее  редактирование.  Для  переменных  сферы
действия файл этот указатель используется  по  умолчанию.  При
использовании  с переменными extern указывает,  что переменная
имеет статическое время действия. (Напомним, что функции всег-
да имеют статическое время действия.)

       Использование указателя класса памяти register.

     Указатель класса памяти register разрешен только при объ-
явлении локальных переменных и параметров функции.  Он эквива-
лентен auto с дополнительным указанием компилятору,  что пере-
менная по возможности должна  быть  распределена  на  регистр.
Распределение  на регистр может значительно сократить размер и
улучшить  производительность  программы.   Однако,   поскольку
Borland C++ старается разместить переменные в регистры при оп-
тимизации, редко возникает необходимость использовать ключевое
слово register.
     Borland C++ позволяет Вам указать регистровые  переменные
с       помощью       опции      из      диалогового      окна
Options/Compiler/Optimization.  Если Вы установите  Automatic,
Borland C++ будет пытаться распределять регистры, даже если Вы
не использовали указатель класса памяти register.

        Использование указателя класса памяти static.

     Указатель класса памяти static может  использоваться  при
объявлении  функции и переменных сферы действия файл и локаль-
ные для указания внутреннего  редактирования.  static  так  же
указывает,  что  переменная  имеет статическое время действия.
При отсутствии констрактора или явного инициализатора,  стати-
ческая переменная инициализируется в ноль или null.
     В С++ статические элементы класса имеют одно значение для
всех экземпляров класса. Статическая функция класса может быть
вызвана независимо из любого экземпляра класса.

        Использование указателя класса памяти typedef.

     Ключевое слово typedef указывает, что Вы определяете ука-
затель  нового  типа данных,  а не объявляете объект.  typedef
используется как указатель класса  памяти,  но  это  синтакси-
ческое, а не функциональное подобие.
     static long int biggi;
     typedef long int BIGGI;
     Первое объявление  создает  объект  статического  времени
действия  biggi.  Второе  объявление  определяет идентификатор
BIGGI как новый тип, но не создает объекта времени выполнения.
BIGGI может использоваться в последующих объявлениях, где раз-
решен указатель типа. Например
     extern BIGGI salary;
     что аналогично
     extern long int salary;
     Хотя тот же результат может быть достигнут через  #define
BIGGI long int,  typedef позволяет создавать более сложные ва-
рианты, чем это возможно с помощью текстуальной подстановки.
     ВАЖНО! typedef  не создает новых типов данных;  он скорее
создает мнемонические синонимы  для  существующих  типов.  Это
особенно удобно для упрощения сложных объявлений:
     typedef double (*PFD)();
     PFD array_pfd[10];
     Вы не можете использовать идентификатор typedef с другими
указателями типа данных:
     unsigned BIGGI pay;  /* неверно */

                        Модификаторы.

     В дополнение к указателям класса памяти объявление  может
использовать  модификаторы  для  изменения  некоторых аспектов
отображения  идентификатор/объект.  Модификаторы  Borland  C++
приведены в следующей таблице.

           Таблица 1.16. Модификаторы Borland C++.
─────────────────────────────────────────────────────────────
Модификатор   Используется с         Использование
─────────────────────────────────────────────────────────────
 const      только переменные   Предотвращает изменение
                                объекта.
 volatile   только переменные   Предотвращает регистровое
                                распределение и некоторую
                                оптимизацию. Указывает
                                компилятору, что объект
                                может изменяться извне во
                                время вычисления.

 Расширения Borland C++

 cdecl      функции             Задает соглашения о передаче
                                аргументов.
 cdecl      переменные          Устанавливает различие
                                прописных и строчных букв в
                                глобальных идентификаторах
                                и лидирующее "_".
 pascal     функции             Задает соглашения о передаче
                                аргументов Паскаль.
 pascal     переменные          Устанавливает не различать
                                прописные и строчные буквы в
                                глобальных идентификаторах
                                и без лидирующего "_".
 interrupt  функции             Функция компилируется с
                                дополнительным кодом,
                                сохраняющим регистры.
 near,      указатель           Перекрывает тип указателя
 far,                           по умолчанию, используемый
 huge                           с текущей моделью памяти.

 _cs,       указатель           Сегментные указатели.
 _ds,
 _es,
 _seg,
 _ss

 near,      функции             Перекрывает тип функции
 far,                           по умолчанию, используемый
 huge                           с текущей моделью памяти.

 near,      переменные          Управляет размещением
 far,                           объекта в памяти.

 _export    функции             Только для OS/2.
                                Игнорируется в Borland C++.
 _loadds    функции             Устанавливает DS на точку
                                в текущем сегменте данных.
 _saveregs  функции             Сохраняет все регистровые
                                значения (за исключением
                                возвращаемых) во время
                                выполнения функции.
─────────────────────────────────────────────────────────────

                      Модификатор const.

     Модификатор const предотвращает любое присваивание объек-
ту или любые сторонние эффекты,  такие как уменьшение и увели-
чение.  Указатель const не может быть изменен, хотя объект, на
который он указывает, может изменяться. Рассмотрим примеры:
     const float pi = 3.1415926;
     const       maxint = 32767;
     char *const str = "Hello, world";    // константный
                                          //указатель
     char const *str2 = "Hello, world";   // указатель
                                  //на константу типа char
     Для этих объявлений следующие операторы неверны:
     pi = 3.0;               // присваивает константе значение
     i = maxintС++;           // увеличивает константу
     str = "string";
     Примечание: Одиночный  модификатор   const   эквивалентен
const int.
     Заметим, однако,  что вызов  strcpy(str,"string")  верен,
поскольку  он  выполняет  посимвольное копирование литеральной
строки "string" в память str.
     В С++  const так же скрывает const объект и предотвращает
внешнее редактирование.  Вам  необходимо  использовать  extern
const.  Указатель на const не может быть назначен на указатель
не-const (в противном случае const значение может быть  назна-
чено на использование не-const указателя). Например
     char *str3 = str2   /* запрещено */

                Модификатор функций interrupt.

     Модификатор interrupt   специфичен   для   Borland   C++.
interrupt функции спроектированы для использования с векторами
прерываний 80х86.  Borland C++ будет  компилировать  interrupt
функцию с дополнительным кодом входа и выхода из функции, сох-
раняющим регистры AX,  BX,  CX, DX, SI, DI, ES, DS. Другие ре-
гистры (BP,  SP,  SS, CS, IP) сохраняются как часть вызывающей
последовательности или как часть обработки прерывания. Функция
будет использовать инструкцию iret для возврата так, что функ-
ция может быть использована для обработки аппаратных  и  прог-
раммных прерываний. Пример типичного определения interrupt:
     void interrupt myhandler()
     {
       ...
     }
     Вы должны объявить interrupt функцию типа  void.  Функция
может  быть объявлена в любой модели памяти.  Для всех моделей
памяти, кроме huge, DS установлен на сегмент данных программы.
Для модели huge DS установлен на сегмент данных модуля.

                    Модификатор volatile.

     Модификатор volatile указывает, что объект может быть мо-
дифицирован; причем не только Вами, но и чем-то извне програм-
мы,  например программой прерывания или портом В/В. Объявление
объекта как volatile указывает компилятору не делать предполо-
жений  относительно значения объекта во время вычисления выра-
жений,  содержащих его,  поскольку значение может измениться в
любой  момент.  Он так же предотвращает от распределения пере-
менной как регистровой.
     volatile int ticks;
     interrupt timer()
     {
       ticksС++;
     }
     wait(int interval)
     {
       ticks = 0;
       while(ticks < interval);     // ничего не делает
     }
     Эти программы  (предполагая,  что  timer - это обработчик
прерываний таймера) реализует ожидание числа квантов, заданных
аргументом interval. Оптимизирующий компилятор может не загру-
зить значение ticks внутри цикла while,  поскольку цикл не из-
меняет значение ticks.
     Примечание: В С++ volatile имеет специальное значение для
функций  класса.  Если Вы объявили volatile объект,  Вы можете
использовать только его volatile элементы-функции.

                 Модификаторы cdecl и pascal.

     Borland C++ позволяет Вашей программе легко вызвать  про-
цедуры,  написанные на других языках и наоборот. Когда Вы сме-
шиваете языки, Вам требуется учитывать 2 важных вопроса: иден-
тификаторы и передачу параметров.
     В Borland C++ все глобальные идентификаторы сохраняют  их
первоначальный вид (прописные,  строчные или смешанные) с "_",
стоящим перед идентификатором, если только Вы не укажете опцию
-u-   (Generate   Underbars...  отключена  в  диалоговом  окне
Options/Compiler/Code Generation).

                           pascal.

     В Паскале глобальные идентификаторы не сохраняют их  ори-
гинальный  вид  и записываются без "_".  Borland C++ позволяет
Вам объявлять любой идентификатор типа pascal;  этот идентифи-
катор  преобразуется в прописные и не предваряется "_".  (Если
идентификатор - функция,  он так же воздействует на соглашения
о передаче параметров).
     Модификатор pascal специфичен для Borland C++;  он введен
для функций и указателей на функции, которые используют согла-
шения о передаче параметров Паскаля. Так же функция, объявлен-
ная с типом pascal, может вызываться из процедур, так как про-
цедуры "видят", что эта функция типа pascal.
     pascal putnums(int i, int j, int k)
     {
       printf("and the answer are: %d, %d, and %d\n", i, j, k);
     }
     Функции типа pascal не могут иметь переменное число аргу-
ментов,  в отличие от функций типа printf.  По этой причине Вы
не можете использовать "..." в определении pascal функции.
     Примечание: Опция      компилятора      -p       (Calling
Convention...Pascal  в  диалоговом  окне Options/Compiler/Code
Generation) заставляет все функции (и указатели на  эти  функ-
ции) интерпретировать, как если бы они были типа pascal.

                            cdecl.

     Когда Вы указали опцию -p,  Вам может понадобиться, чтобы
некоторые идентификаторы сохранили свой первоначальный  вид  и
"_" перед ними,  особенно,  если это идентификаторы из другого
файла.  Вы можете сделать это, объявив их с cdecl. (Это так же
воздействует на передачу параметров в функции).
     Примечание: main  должна  быть   объявлена   как   cdecl;
поскольку  начальный код всегда пытается вызвать main с согла-
шениями о вызове.
     Как pascal,  cdecl специфичен для Borland C++. Он исполь-
зуется с функциями и указателями на  функции.  Он  перекрывает
директиву компилятора -p и позволяет вызвать функцию как обыч-
ную функцию.  Например, если Вы компилировали предыдущую прог-
рамму с опцией -p, но хотите использовать printf, Вы можете:
     extern cdecl printf();
     putnums(int i, int j, int k);

     cdecl main()
     {
       putnums(1, 4, 9);
     }

     putnums(int i, int j, int k)
     {
       printf("and the answer are: %d, %d, and %d\n", i, j, k);
     }
     Если Вы компилируете программу с опцией -p,  все функции,
используемые  из библиотеки времени выполнения необходимо объ-
явить с cdecl.  Если Вы посмотрите файлы заголовков (такие как
stdio.h)  Вы  увидите,  что  все  функции  явно определены как
cdecl.

                     Модификатор pointer.

     Borland C++ имеет 8 модификаторов,  которые  воздействуют
на операторы косвенной адресации(*);  т.е. модифицируют указа-
тели на данные: near, far, huge, _cs, _ds, _es, _seg, _ss.
      С позволяет   Вам   компилировать,   используя  одну  из
нескольких моделей памяти. Модель определяет (кроме всего про-
чего) внутренний формат указателей.  Например, если Вы исполь-
зуете модели tiny,  small или medium,  все указатели на данные
содержат  16-битное  смещение  от регистра сегмента данных DS.
Если Вы используете модели compact,  large или huge, использу-
ются 32-битные указатели (сегмент и смещение).
     Иногда при использовании одной модели данных Вам  необхо-
димо  объявить  указатель другого размера или формата,  чем по
умолчанию. В этом случае Вы используете модификатор указателя.

                  Модификаторы типа функции.

     Модификаторы типа near,  far и huge могут  использоваться
как модификаторы типа функции;  т.е.  они могут модифицировать
функцию или указатель на функцию так же, как указатель на дан-
ные.  Для  модификации функции Вы можете использовать _export,
_loadds, _saveregs.
     Модификаторы near,  far  и  huge можно объединить с cdecl
или pascal, но не с interrupt.
     Функции типа  huge  полезны при взаимодействии с кодом на
ассемблере,  который не использует то же распределение памяти,
что и Borland C++.
     Не-interrupt функции могут быть объявлены как  near,  far
или huge для перекрытия текущих установок для модели памяти.
     near функция использует near вызов;  функции far или huge
используют инструкции far call.
     В моделях памяти tiny,  small и compact функции имеют  по
умолчанию  тип  near.  В моделях памяти medium и large функции
имеют по умолчанию тип far.  В модели памяти huge по умолчанию
тип huge.
     Функция huge аналогична функции far за исключением  того,
что регистр DS устанавливается на адрес сегмента данных исход-
ного модуля при входе в функцию huge, а в функции far не уста-
навливается.
     Модификатор _export анализируется,  а затем игнорируется.
Он обеспечивает совместимость с исходным кодом, написанным для
OS/2. Этот модификатор не имеет действия для программ в DOS.
     Модификатор _loadds указывает, что функция должна устано-
вить регистр DS как функция huge.  Таким образом  _loadds  far
эквивалентно huge.
     Модификатор _saveregs заставляет  функцию  сохранять  все
значения  регистров  и  восстанавливать  их после возврата (за
исключением явного возврата значений через такие регистры  как
AX или DX).
     Модификаторы _loadds и _saveregs  полезны  для  написания
низкоуровневых интерфейсных программ, таких как программы под-
держки мышки.

          Сложные объявления и элементы объявления.

     Простые определения  используют  список  идентификаторов,
разделенных  запятыми,  следующий  за необязательными классами
памяти, типа и некоторых других.
     Сложные определения  используют список элементов объявле-
ния, разделенных запятыми, следующий за различными указателями
и  модификаторами.  Внутри  каждого  объявления  существует по
крайней мере один идентификатор.  Каждое объявление  в  списке
связано с соответствующим классом памяти и типом.
     Примечание: См. таблицу 1.9 для синтаксиса объявлений.
     Формат объявления  указывает  как интерпретировать объяв-
ленное d-имя в выражении.  Если type - это любой тип и  указа-
тель-класса-памяти - указатель любого класса памяти, а D1 и D2
- два любых идентификатора, то объявление
     указатель-класса-памяти type D1, D2;
     указывает, что появление D1 или D2 в выражении будет  ин-
терпретироваться  как  объект типа type и класса памяти указа-
тель-класса-памяти.  Способ объявления d-имя будет  влиять  на
его интерпретацию как "тип",  "указатель на тип",  "массив ти-
па", "функция, возвращающая тип" и т.д.
     Например в объявлениях
     int n, nao[], naf[3], *pn, *apn[], (*pan)[], &nr = n;
     int f(void), *fnp(void), (*pfn)(void);
     каждый из идентификаторов может использоваться как rvalue
(в некоторых случаях возможно как lvalue) а в выражениях,  где
допустим объект типа int.  Зависимость интерпретации идентифи-
каторов от их объявлений:

               Таблица 1.17 Сложные объявления.
───────────────────────────────────────────────────────────────
 Синтаксис    Подразумеваемый тип имени          Пример
───────────────────────────────────────────────────────────────
type имя;      type                            int count;
type имя[];    массив type                     int count[];
type имя[3];   массив из 3-х элементов,
               все типа type                   int count[3];
type *имя;     указатель на type               int *count;
type *имя[];   массив указателей на type       int *count[];
type *(имя[]); -"-                             int *(count[]);
type (*имя)[]; указатель на тип type          int (*count) [];
type &имя;     ссылка на type (С++)            int &count;
type имя();    функция возвращающая тип type   int count();
type *имя();   функция возвращающая указатель
               на тип type                     int *count();
type *(имя()); -"-                             int *(count());
type (*имя)(); указатель на функцию,
               возвращающую тип type           int *(count());
───────────────────────────────────────────────────────────────
     Заметим необходимость () в (*имя)[] и (*имя)(), поскольку
приоритет элемента объявления массива [] и элемента объявления
функции  () выше,  чем приоритет элемента объявления указателя
*. () в *(имя[]) необязательны.

                          Указатели.

     Указатели делятся на 2 больших  категории:  указатели  на
объекты и указатели на функции. Оба типа указателей - это спе-
циальные объекты для хранения адресов памяти.
     Два класса указателей имеют различные свойства,  назначе-
ние и правила обработки,  хотя обрабатываются одинаковыми опе-
раторами  Borland  C++.  Указатели на функции используются для
доступа к функциям и для передачи  функций  как  аргументов  в
другие функции;  выполнение арифметических действий над указа-
телями на функции недопустимо.  С другой стороны указатели  на
объекты  обычно  увеличиваются и уменьшаются так,  чтобы можно
было сканировать массивы и более сложные  структуры  данных  в
памяти.
     Хотя указатели содержат числа с обычными свойствами безз-
наковых целых, они имеют собственные правила и ограничения для
присваиваний преобразований и арифметических операций. Примеры
в следующих разделах иллюстрируют эти правила и ограничения.

                    Указатели на объекты.

     Указатель типа  "указатель  на объект типа type" содержит
адрес объекта типа type.  Поскольку сам указатель так же  объ-
ект,  Вы можете использовать указатель,  указывающий на указа-
тель (и т.д.).  Объекты,  для которых используются  указатели,
включают в себя массивы, структуры, объединения и классы.
     Размер указателя на объект зависит от  модели  памяти,  а
так же размера и положения Вашего сегмента данных и возможного
применения модификаторов указателя.

                    Указатели на функции.

     Указатель на функцию лучше всего представить  как  адрес,
обычно  в сегменте кода,  по которому находится выполнимый код
функции; это адрес, на который передается управление при вызо-
ве  функции.  Размер  и положение кодовых сегментов зависит от
модели памяти, которая устанавливает размер указателя на функ-
цию, требуемый для вызова Вашей функции.
     Указатель на функцию имеет  тип  "указатель  на  функцию,
возвращающую тип type".
     Примечание: В С++,  в котором используется более  строгая
проверка  типов,  указатель на функцию имеет тип "указатель на
функцию,  использующую аргументы типа type и возвращающую  тип
type". В действительности в функция, определенная с типами ар-
гументов так же имеет этот более строгий тип. Например:
     void (*func)();
     В С это указатель на функцию ничего  не  возвращающую.  В
С++ это указатель на функцию, не использующую аргументов и ни-
чего не возвращающую. В этом примере
     void (*func)(int);
     *func - это указатель на функцию,  использующую  аргумент
int и ничего не возвращающую.

                    Объявление указателей.

     Указатель должен быть объявлен как указывающий на опреде-
ленный тип даже, если это тип void (который в действительности
означает указатель на что-либо).  Однако после объявления ука-
затель может быть переназначен на объект другого типа. Borland
C++ позволяет Вам выполнять такое переназначение указателя без
приведения типа,  но компилятор будет выдавать предупреждение,
если  только Вы не объявите указатель типа void.  В С (но не в
С++) Вы можете назначить void* указатель  на  не-void*  указа-
тель.
     Если type - это любой предопределенный  или  определенный
пользователем тип, включая void, то объявление
     type *ptr;  /* осторожно, неинициализированный указатель */
     объявляет ptr типа "указатель на type". Все правила сферы
действия, времени действия и видимости применимы к объекту ptr
после объявления.
     ПРЕДУПРЕЖДЕНИЕ! Вам необходимо инициализировать указатель
до его использования.
     Значение указателя null - это адрес,  который гарантирует
различие от любого правильного указателя в программе. Присвое-
ние указателю целой константы 0 устанавливает его  в  значение
null.
     Мнемоническое NULL (определено в стандартном файле  заго-
ловка stdio.h) может быть использовано для улучшения читабель-
ности. Все указатели могут быть успешно проверены на равенство
или неравенство NULL.
     Указатель типа "указатель на void (пустой)" нельзя путать
со значением указателя null. Объявление
     void *vptr;
     объявляет vptr как указатель, которому может быть присво-
ено любое значение "указателя на type", включая null. Присвое-
ние  между  "указатель  на type1" и "указатель на type2",  где
type1 и typе2 - различные типы без соответствующего приведения
типа,  может привести к предупреждению или ошибке компилятора.
Если type1 - это  функция,  а  type2  -  нет  (или  наоборот),
присваивание  указателей  неверно.  Если  type1 - указатель на
void,  приведение типа не нужно.  Если type2  -  указатель  на
void, приведение типов в не требуется.
     Ограничения присваивания так же  применимы  к  указателям
различных  размеров  (near,  far и huge).  Вы можете присвоить
меньший указатель большему без ошибки, но Вы не можете присво-
ить больший указатель меньшему без использования явного приве-
дения типа. Например,
     char near *ncp;
     char far *fcp;
     char huge *hcp;
     fcp = ncp;               // верно
     hcp = fcp;               // верно
     fcp = hcp;               // неверно
     ncp = fcp;               // неверно
     ncp = (char near*)fcp;   // верно

                    Указатели и константы.

     Указатель или указываемый объект могут быть  объявлены  с
модификатором const.  Объектам, объявленным как const не может
быть присвоено значение.  Нельзя так же создать указатель, ко-
торый может нарушить неприсваиваемость объекта const. Рассмот-
рим примеры:
     int i;
     int * pi;                    // указатель на int
     int * const cp = &i      // константный указатель на int
     const int ci = 7;            // int константа
     const int * pci;          // указатель на int константу
     const int * const cpc = &ci; // константный указатель на
                                  //int  константу
     Следующие присваивания верны:
     i = ci;        // присваивает int константу в int
     *cp = ci;      // присваивает int константу в объект,
                    // указываемый константным указателем
     С++pci;         // увеличивает указатель на константу
     pci = cpc;     // присваивает константный указатель на
                    // константу указателю на константу
     Следующие присваивания неверны:
     ci = 0;     // нельзя присвоить константе
     ci--;       // нельзя изменить константу
     *pci = 3;   // нельзя присвоить объекту, указанному
                 // указателем на константу
     cp = &ci;   // нельзя присвоить константному указателю
     cpcС++;      // нельзя изменить константный указатель
     pi = pci;
     Подобные правила применимы к модификатору volatile. Заме-
тим,  что оба модификатора const и volatile могут быть исполь-
зованы с одним идентификатором.

            Арифметические действия с указателями.

     Арифметические действия с указателями ограничены сложени-
ем,  вычитанием и сравнением. Арифметические операции над ука-
зателями типа "указатель на type" автоматически учитывают раз-
мер type;  т.е.  числа байт, требуемых для запоминания объекта
типа type.
     Примечание: Внутренние арифметические действия, выполняе-
мые  над указателями,  зависят от модели памяти и используемых
модификаторов указателей.
     Когда выполняются арифметические операции над указателями
считается,  что указатель указывает на массив  объектов.  Так,
если указатель объявлен для указания на type, добавление цело-
го числа указателю передвигает  указатель  на  это  количество
объектов типа type.  Если type имеет размер 10 байт, то добав-
ление числа 5 к указателю на type передвигает указатель на  50
байт.  Разность  между  значениями двух указателей - это число
элементов массива, разделяющих эти 2 указателя. Например, если
ptr1 указывает на третий элемент массива, а ptr2 - на десятый,
то результат ptr2 - ptr1 равен 7.
     Когда целое значение прибавляется или вычитается из "ука-
зателя на type",  результат будет так же  типа  "указатель  на
type".  Если  type  не массив,  указатель интерпретируется как
если бы он указывал на первый элемент "массива типа type" дли-
ной sizeof(type).
     Не существует такого элемента,  как "указатель на следую-
щий  элемент  после последнего",  но указателю можно присвоить
такое значение. Если P указывает на последний элемент массива,
Р+1 разрешено, но Р+2 неопределено. Если Р указывает на следу-
ющий элемент после конца массива,  Р-1 разрешено,  указывая на
последний  элемент.  Однако  применение  оператора ссылки * на
"указатель на элемент после конца массива" имеет непредсказуе-
мое действие.
     Вы можете представлять Р+n как передвижение указателя  на
(n*sizeof(type)) байт до тех пор пока указатель остается внут-
ри допустимого диапазона.
     Вычитание двух указателей на элементы одного массива дает
целое  значение  типа  ptrdiff_t,  определенного  в   stddef.h
(signed long для huge и far указателей;  signed int - для дру-
гих).  Это значение дает разность между индексами двух элемен-
тов  в диапазоне ptrdiff_t.  В выражении P1-P2,  где Р1 и Р2 -
это указатели на type,  Р1 и Р2 должны указывать на существую-
щие  элементы  или  на  следующий элемент после конца массива.
Если Р1 указывает на i-тый элемент,  а Р2 - на j-тый  элемент,
Р1-Р2 имеет значение (i-j).

                  Преобразование указателей.

     Указатель одного типа может быть преобразован в указатель
другого типа, используя приведение типа:
     char *str;
     int *ip;
     str = (char *)ip;
     Приведение типа (type*) будет преобразовывать указатель в
тип "указатель на type".

                    Объявление ссылок С++.

     Тип ссылки в С++ тесно связан с типом указателя.  Ссылоч-
ный тип создает алиас для объектов и  позволяет  Вам  передать
аргументы  в функцию по ссылке.  Традиционный С передает аргу-
менты только по значению.  В С++ Вы можете передать  аргументы
по  значению  или по ссылке.  См.  раздел "Ссылки" для полного
описания.
