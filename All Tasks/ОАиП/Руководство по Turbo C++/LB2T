     tan
──────────────────────────────────────────────────────────────
Функция        Вычисляет тангенс.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>       #include <complex.h>
               double tan(double x);   complex tan(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                  complex.h

Примечания     tan вычисляет тангенс переданного значения. Уг-
               лы измеряются в радианах.
               Обработка ошибок  для  этой  функции может быть
               модифицирована посредством функции matherr.
               Тангенс комплексного аргумента определяется как
                  tan(z) = sin(z) / cos(z)

Значение       tan возвращает тангенс x,  sin(x) / cos(x).

Переносимость  Вещественная версия доступна в системах UNIX  и
               определена  в  ANSI C.  Комплексная версия этой
               функции требует С++ и, вероятно, не переносима.

См.также       acos, asin, atan, atan2, complex, cos, sin

Пример         #include <stdio.h>
               #include <math.h>
               int main(void)
               {  double result, x;
                  x = 0.5;
                  result = tan(x);
                  printf("The tan of %lf is %lf\n",
                          x, result);
                  return 0;
               }

     tanh
──────────────────────────────────────────────────────────────
Функция        Вычисляет гиперболический тангенс.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>      #include <complex.h>
               double tanh(double x); complex tanh(complex x);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:   КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                 complex.h

Примечания     tanh вычисляет     гиперболический     тангенс,
               sinh(x) / cosh(x).
               Обработка ошибок  для  этой  функции может быть
               модифицирована  посредством  функции   matherr.
               Гиперболический тангенс  комплексного аргумента
               определяется как
                  tanh(z) = sinh(z) / cosh(z)

Значение       tanh возвращает гиперболический тангенс x.

Переносимость  Вещественная версия доступна в системах UNIX  и
               определена  в  ANSI C.  Комплексная версия этой
               функции требует С++ и, вероятно, не переносима.

См.также       complex, cos, cosh, sin, sinh, tan

Пример         #include <stdio.h>
               #include <math.h>
               int main(void)
               {  double result, x;
                  x = 0.5;
                  result = tanh(x);
                  printf("The hyperbolic tangent of %lf "
                         "is %lf\n", x, result);
                  return 0;
               }

     tell
──────────────────────────────────────────────────────────────
Функция        Получает текущую позицию файлового указателя.

Синтаксис      #include <io.h>
               long tell(int handle);

Прототип в     io.h

Примечания     tell получает текущую позицию файлового  указа-
               теля, связанного с обработчиком handle, и выра-
               жает ее как число байтов от начала файла.

Значение       tell возвращает текущую позицию файлового  ука-
               зателя.  Значение -1 (типа long) означает ошиб-
               ку,  и глобальная переменная errno устанавлива-
               ется в значение
                 EBADF   Неверный номер (обработчика) файла

Переносимость  Эта функция доступна во всех системах UNIX.

См.также       fgetpos, fseek, ftell, lseek

Пример         #include <string.h>
               #include <stdio.h>
               #include <fcntl.h>
               #include <io.h>
               int main(void)
               {  int handle;
                  char msg[] = "Hello world";
                  if ((handle = open("TEST.$$$",
                       O_CREAT | O_TEXT | O_APPEND)) == -1)
                  {  perror("Error:");
                     return 1;
                  }
                  write(handle, msg, strlen(msg));
                  printf("The file pointer is at byte %ld\n",
                         tell(handle));
                  close(handle);
                  return 0;
               }

     textattr
──────────────────────────────────────────────────────────────
Функция        Устанавливает атрибуты текста.

Синтаксис      #include <conio.h>
               void textattr(int newattr);

Прототип в     conio.h

Примечания     textattr позволяет Вам установить как  основной
               цвет,  так и цвет фона посредством одного вызо-
               ва.  (Обычно для  этого  вызывают  textcolor  и
               textbackground).
               Эта функция  не  оказывает  влияния на символы,
               уже находящиеся  на  экране;  она  воздействует
               только  на  те символы,  которые изображаются с
               помощью функций (например, cprintf), работающих
               в  текстовом режиме и осуществляющих прямой вы-
               вод на экран ПОСЛЕ вызова функции textattr.
               Информация о  цвете  закодирована  в  параметре
               newattr следующим образом:
                        7   6   5   4 │ 3   2   1   0
                      ┌───┬───┬───┬───┼───┬───┬───┬───┐
                      │ B │ b │ b │ b │ f │ f │ f │ f │
                      └───┴───┴───┴───┼───┴───┴───┴───┘
               В этом 8-битовом параметре newattr:
                  ffff - 4-битовый основной цвет (от 0 до 15).
                  bbb  - 3-битовый фоновый цвет (от 0 до 7).
                  B    - бит мерцания.
               Если бит мерцания установлен, то символы мерца-
               ют.   Это  может  быть  достигнуто  добавлением
               константы BLINK к атрибуту.
               Если вы  используете  символьные  константы для
               обозначения цветов, определенные в conio.h, для
               создания текстовых атрибутов c textattr, запом-
               ните следующие ограничения на цвет фона:
               - Вы можете выбрать для  фона  только  один  из
                 первых восьми цветов.
               - Вы должны  сдвинуть  выбранный  фоновый  цвет
                 влево на 4 бита,  чтобы разместить его в пра-
                 вильных битовых позициях.
               В следующей таблице приведен список  символьных
               констант:
               ──────────────────────────────────────────────-
               Символьная         Числовое     Основной
               константа          значение     или фоновый?
               ──────────────────────────────────────────────-
                 BLACK                  0      Оба
                 (черный)
                 BLUE                   1      Оба
                 (синий)
                 GREEN                  2      Оба
                 (зеленый)
                 CYAN                   3      Оба
                 (бирюзовый)
                 RED                    4      Оба
                 (красный)
                 MAGENTA                5      Оба
                 (малиновый)
                 BROWN                  6      Оба
                 (коричневый)
                 LIGHTGRAY              7      Оба
                 (светло-серый)
                 DARKGRAY               8      Только основной
                 (темно-серый)
                 LIGHTBLUE              9      Только основной
                 (светло-синий)
                 LIGHTGREEN            10      Только основной
                 (светло-зеленый)
                 LIGHTCYAN             11      Только основной
                 (светло-бирюзовый)
                 LIGHTRED              12      Только основной
                 (светло-красный)
                 LIGHTMAGENTA          13      Только основной
                 (светло-малиновый)
                 YELLOW                14      Только основной
                 (желтый)
                 WHITE                 15      Только основной
                 (белый)
                 BLINK                128      Только основной
                 (мерцание)
               ──────────────────────────────────────────────-

Значение       Нет.

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми. Она не совместима с Windows.

См.также       gettextinfo, highvideo,  lowvideo,   normvideo,
               textbackground, textcolor

Пример         #include <conio.h>
               int main(void)
               {  int i;
                  clrscr();
                  for (i=0; i<9; i++)
                  {   textattr(i + ((i+1) << 4));
                      cprintf("This is a test\r\n");
                  }
                  return 0;
               }

     textbackground
──────────────────────────────────────────────────────────────
Функция        Выбирает новый цвет фона для текста.

Синтаксис      #include <conio.h>
               void textbackground(int newcolor);

Прототип в     conio.h

Примечания     textbackground выбирает фоновый цвет. Эта функ-
               ция предназначена для тех функций, которые осу-
               ществляют прямой вывод на экран в текстовом ре-
               жиме. В  newcolor  указывается новый цвет фона.
               Вы можете задать newcolor как целое число от  0
               до 7 или как символьную константу, определенную
               в  conio.h.  Если  вы  используете   символьную
               константу, вы должны включить conio.h.
               После того,     как    Вы    вызвали    функцию
               textbackground,  все последующие функции,  осу-
               ществляющие  прямой  вывод  на экран (например,
               cprintf), будут     использовать      newcolor.
               textbackground не влияет на символы,  уже нахо-
               дящиеся на экране.
               Следующая таблица содержит символьные константы
               и числовые значения допустимых цветов:
               ───────────────────────────────────────────────
               Символьная константа    Числовое значение
               ───────────────────────────────────────────────
                  BLACK                        0
                  (черный)
                  BLUE                         1
                  (синий)
                  GREEN                        2
                  (зеленый)
                  CYAN                         3
                  (бирюзовый)
                  RED                          4
                  (красный)
                  MAGENTA                      5
                  (малиновый)
                  BROWN                        6
                  (коричневый)
                  LIGHTGRAY                    7
                  (светло-серый)
               ───────────────────────────────────────────────

Значение       Нет.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Соответствующая функция имеется в
               Turbo Pascal. Она не совместима с Windows.

См.также       gettextinfo, textattr, textcolor

Пример         #include <conio.h>
               int main(void)
               {  int i, j;
                  clrscr();
                  for (i=0; i<9; i++)
                  {   for (j=0; j<80; j++)
                        cprintf("C");
                      cprintf("\r\n");
                      textcolor(i+1);
                      textbackground(i);
                  }
                  return 0;
               }

     textcolor
──────────────────────────────────────────────────────────────
Функция        Выбирает новый цвет символа в текстовом режиме.

Синтаксис      #include <conio.h>
               void textcolor(int newcolor);

Прототип в     conio.h

Примечания     textcolor выбирает основной цвет  (цвет  симво-
               лов).  Эта  функция предназначена для тех функ-
               ций, которые осуществляют прямой вывод на экран
               в текстовом режиме.  В newcolor указывается но-
               вый основной цвет.  Вы можете  задать  newcolor
               как  целое  число или как символьную константу,
               определенную в conio.h (см. таблицу ниже). Если
               вы используете символьную константу,  вы должны
               включить conio.h.
               После того,  как  Вы вызвали функцию textcolor,
               все последующие функции,  осуществляющие прямой
               вывод   на  экран  (например,  cprintf),  будут
               использовать newcolor.
               textcolor не влияет на символы, уже находящиеся
               на экране.
               Следующая таблица содержит символьные константы
               и числовые значения допустимых цветов:
               ───────────────────────────────────────────────
               Символьная константа    Числовое значение
               ───────────────────────────────────────────────
                  BLACK                         0
                  (черный)
                  BLUE                          1
                  (синий)
                  GREEN                         2
                  (зеленый)
                  CYAN                          3
                  (бирюзовый)
                  RED                           4
                  (красный)
                  MAGENTA                       5
                  (малиновый)
                  BROWN                         6
                  (коричневый)
                  LIGHTGRAY                     7
                  (светло-серый)
                  DARKGRAY                      8
                  (темно-серый)
                  LIGHTBLUE                     9
                  (светло-синий)
                  LIGHTGREEN                   10
                  (светло-зеленый)
                  LIGHTCYAN                    11
                  (светло-бирюзовый)
                  LIGHTRED                     12
                  (светло-красный)
                  LIGHTMAGENTA                 13
                  (светло-малиновый)
                  YELLOW                       14
                  (желтый)
                  WHITE                        15
                  (белый)
                  BLINK                       128
                  (мерцание)
               ───────────────────────────────────────────────
               Вы можете сделать символы  мерцающими,  добавив
               128 к основному цвету. Для этой цели существует
               предопределенная константа BLINK, например:
                  textcolor(CYAN + BLINK);
         !!!   Некоторые мониторы  не  распознают  сигнал  ин-
               тенсивности,  используемый  для создания восьми
               ярких ("light") цветов (от 8 до  15).  На  этих
               мониторах яркие цвета изображаются так же,  как
               и их темные ("dark") эквиваленты (от 0  до  7).
               Кроме того,  нецветные системы могут трактовать
               номера цветов как оттенки одного цвета,  специ-
               альные шаблоны или специальные атрибуты (такие,
               как подчеркивание, жирный или курсивный шрифт и
               т.п.).  То, что Вы на самом деле увидите на эк-
               ране, зависит от Вашей аппаратуры.

Значение       Нет.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Соответствующая функция имеется в
               Turbo Pascal. Она не совместима с Windows.

См.также       gettextinfo, highvideo,   lowvideo,  normvideo,
               textattr, textbackground

Пример         #include <conio.h>
               int main(void)
               {  int i;
                  for (i=0; i<15; i++) {
                      textcolor(i);
                      cprintf("Foreground Color\r\n");
                  }
                  return 0;
               }

     textheight
──────────────────────────────────────────────────────────────
Функция        Возвращает высоту строки в пикселах.

Синтаксис      #include <graphics.h>
               int far textheight(char far *textstring);

Прототип в     graphics.h

Примечания     Графическая функция textheight определяет высо-
               ту *textstring  в пикселах,  исходя из текущего
               размера шрифта и коэффициента  масштабирования.
               Эта  функция полезна для выбора интервала между
               строками, вычисления высоты поля вывода,  опре-
               деления  размера  заголовка,  чтобы он подходил
               для графика,  диаграммы  или  прямоугольника  и
               т.п.
               Например, для растрового шрифта 8*8 и коэффици-
               ента масштабирования 1 (установленных  функцией
               settextstyle),  строка "Turbo C++ " будет иметь
               высоту 8 пикселов.
         !!!   Используйте textheight для  определения  высоты
               строки вместо того, чтобы вычислять ее вручную.
               При использовании этой функции  не  потребуется
               модификации исходного кода при выборе различных
               шрифтов.

Значение       textheight возвращает высоту текста в пикселах.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       gettextsettings,       outtext,      outtextxy,
               settextstyle, textwidth

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int y = 0;
                  int i;
                  char msg[80];
                  /* инициализация графики
                     и локальных переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {  printf("Graphics error: %s\n",
                             grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  /* изобразить некоторый текст на экране */
                  for (i=1; i<11; i++)
                  {  /* выбрать стиль, направление и размер
                        текста */
                     settextstyle(TRIPLEX_FONT, HORIZ_DIR, i);
                     /* создать строку сообщения */
                     sprintf(msg, "Size: %d", i);
                     /* вывести сообщение */
                     outtextxy(1, y, msg);
                     /* перейти на следующую строку */
                     y += textheight(msg);
                  }
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     textmode
──────────────────────────────────────────────────────────────
Функция        Переводит экран в текстовый режим.

Синтаксис      #include <conio.h>
               void textmode(int newmode);

Прототип в     conio.h

Примечания     textmode выбирает указанный текстовый режим.
               Вы можете задать текстовый режим  (в  аргументе
               newmode),  используя символическую константу из
               перечислимого типа text_modes (определенного  в
               conio.h). Если Вы используете эти константы, Вы
               должны включить conio.h.
               В следующей таблице  приведены  константы  типа
               text_modes,  их числовые значения и режимы, ко-
               торые они определяют:
               ───────────────────────────────────────────────
               Символич.   Числовое      Текстовый
               константа   значение        режим
               ───────────────────────────────────────────────
                LASTMODE       -1   Предыдущий текстовый режим
                BW40            0   Черно-белый, 40 столбцов
                C40             1   Цветной, 40 столбцов
                BW80            2   Черно-белый, 80 столбцов
                C80             3   Цветной, 80 столбцов
                MONO            7   Монохромный, 80 столбцов
                C4350          64   Режимы EGA - 43 строки и
                                    VGA - 50 строк
               ───────────────────────────────────────────────
               После вызова   функции  textmode  текущее  окно
               устанавливается  в  полный  экран,  а   текущие
               текстовые  атрибуты  устанавливаются в нормаль-
               ные, соответствующие вызову normvideo.
               Задание режима LASTMODE вызывает установку пре-
               дыдущего использованного текстового режима.
               textmode должна  использоваться,  только  когда
               экран находится в текстовом режиме (желая пере-
               вести экран  в  другой  текстовый  режим).  Это
               единственный  контекст,  в  котором  может быть
               использована textmode.  Когда экран находится в
               графическом  режиме,  для временного возврата в
               текстовый     режим     используйте     функцию
               restorecrtmode.

Значение       Нет.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Соответствующая функция имеется в
               Turbo Pascal. Она не совместима с Windows.

См.также       gettextinfo, window

Пример         #include <conio.h>
               int main(void)
               {  textmode(BW40);
                  cprintf("ABC");
                  getch();
                  textmode(C40);
                  cprintf("ABC");
                  getch();
                  textmode(BW80);
                  cprintf("ABC");
                  getch();
                  textmode(C80);
                  cprintf("ABC");
                  getch();
                  textmode(MONO);
                  cprintf("ABC");
                  getch();
                  return 0;
               }

     textwidth
──────────────────────────────────────────────────────────────
Функция        Возвращает ширину строки в пикселах.

Синтаксис      #include <graphics.h>
               int far textwidth(char far *textstring);

Прототип в     graphics.h

Примечания     Графическая функция textwidth определяет ширину
               *textstring в пикселах, исходя из длины строки,
               текущего  размера шрифта и коэффициента масшта-
               бирования.
               Эта функция  полезна для вычисления высоты поля
               вывода, определения размера заголовка, чтобы он
               подходил для графика, диаграммы или прямоуголь-
               ника и т.п.
         !!!   Используйте textwidth  для  определения  высоты
               строки вместо того, чтобы вычислять ее вручную.
               При использовании этой функции  не  потребуется
               модификации исходного кода при выборе различных
               шрифтов.

Значение       textwidth возвращает ширину текста в пикселах.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       gettextsettings,       outtext,      outtextxy,
               settextstyle, textheight

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int x = 0, y = 0;
                  int i;
                  char msg[80];
                  /* инициализация графики
                     и локальных переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {  printf("Graphics error: %s\n",
                             grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  y = getmaxy() / 2;
                  settextjustify(LEFT_TEXT, CENTER_TEXT);
                  for (i=1; i<11; i++)
                  {  /* выбрать стиль, направление и размер
                        текста */
                     settextstyle(TRIPLEX_FONT, HORIZ_DIR, i);
                     /* создать строку сообщения */
                     sprintf(msg, "Size: %d", i);
                     /* вывести сообщение */
                     outtextxy(x, y, msg);
                     /* перейти в конец текста */
                     x += textwidth(msg);
                  }
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     time
──────────────────────────────────────────────────────────────
Функция        Получает время суток.

Синтаксис      #include <time.h>
               time_t time(time_t *timer);

Прототип в     time.h

Примечания     time определяет   текущее   время  в  секундах,
               отсчитываемое с  00:00:00  1 Января 1970 г.  по
               Гринвичу (GMT).  timer - указатель  на  область
               памяти, где сохраняется это значение (предпола-
               гается, что timer не есть NULL).

Значение       time возвращает  текущее время в секундах,  как
               описано выше.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См.также       asctime, ctime,   difftime,   ftime,   gettime,
               gmtime, localtime, settime, stime, tzset

Пример         #include <time.h>
               #include <stdio.h>
               #include <dos.h>
               int main(void)
               {  time_t t;
                  t = time(NULL);
                  printf("The number of seconds since "
                         "January 1, 1970 is %ld", t);
                  return 0;
               }

     tmpfile
──────────────────────────────────────────────────────────────
Функция        Открывает временный файл в двоичном режиме.

Синтаксис      #include <stdio.h>
               FILE *tmpfile(void);

Прототип в     stdio.h

Примечания     tmpfile создает временный двоичный файл и  отк-
               рывает его для обновления (w + b). Файл автома-
               тически удаляется при его закрытии или при  за-
               вершении программы.

Значение       tmpfile возвращает указатель на поток ввода-вы-
               вода,  связанный с созданным временным  файлом.
               Если файл не может быть создан, tmpfile возвра-
               щает NULL.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена в ANSI C.

См.также       fopen, tmpnam

Пример         #include <stdio.h>
               #include <process.h>
               int main(void)
               {  FILE *tempfp;
                  tempfp = tmpfile();
                  if (tempfp)
                     printf("Temporary file created\n");
                  else {
                     printf("Unable to create "
                            "temporary file\n");
                     exit(1);
                  }
                  return 0;
               }

     tmpnam
──────────────────────────────────────────────────────────────
Функция        Создает уникальное имя файла.

Синтаксис      #include <stdio.h>
               char *tmpnam(char *s);

Прототип в     stdio.h

Примечания     tmpnam создает  уникальное  имя,  которое может
               быть безопасно использовано как имя  временного
               файла.  tmpnam  генерирует различные строки при
               каждом вызове до TMP_MAX раз.
               TMP_MAX определено в stdio.h как 65535.
               Параметр s функции tmpnam - это либо NULL, либо
               указатель   на   массив,  содержащий  не  менее
               L_tmpnam  символов.   L_tmpnam   определено   в
               stdio.h.  Если  s  есть NULL,  tmpnam оставляет
               сгенерированное имя временного файла  во  внут-
               реннем  статическом объекте и возвращает указа-
               тель на этот объект.  Если s - не NULL,  tmpnam
               помещает свой результат в указанный массив, ко-
               торый должен иметь длину не менее L_tmpnam сим-
               волов, и возвращает s.
         !!!   Если Вы действительно создаете временный  файл,
               используя  функцию tmpnam,  то на Вас лежит от-
               ветственность  за   его   удаление   (например,
               посредством функции remove),  так как он не бу-
               дет удален автоматически (как это делает  функ-
               ция tmpfile).

Значение       Если s есть NULL,  tmpnam возвращает  указатель
               на  внутренний статический объект.  В противном
               случае tmpnam возвращает s.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См.также       tmpfile

Пример         #include <stdio.h>
               int main(void)
               {  char name[13];
                  tmpnam(name);
                  printf("Temporary name: %s\n", name);
                  return 0;
               }

     toascii
──────────────────────────────────────────────────────────────
Функция        Переводит символы в формат кода ASCII.

Синтаксис      #include <ctype.h>
               int toascii(int c);

Прототип в     ctype.h

Примечания     toascii -  макрос,  который  преобразует  целое
               число с в код ASCII, обнуляя все его биты, кро-
               ме 7 младших.  toascii выдает значение в диапа-
               зоне от 0 до 127.

Значение       toascii возвращает преобразованное значение с.

Переносимость  Эта функция доступна в системах UNIX.

Пример         #include <stdio.h>
               #include <cype.h>
               int main(void)
               {  int number, result;
                  number = 511;
                  result = toascii(number);
                  printf("%d %d\n", number, result);
                  return 0;
               }

     _tolower
──────────────────────────────────────────────────────────────
Функция        Преобразует прописные буквы в строчные.

Синтаксис      #include <ctype.h>
               int _tolower(int ch);

Прототип в     ctype.h

Примечания     _tolower - макрос,  который делает то же  самое
               преобразование, что и tolower, однако в отличие
               от последнего,  он должен использоваться только
               тогда,  когда  ch  заведомо  является прописной
               буквой (A - Z).
               Для использования _tolower Вы  должны  включить
               ctype.h.

Значение       Если ch  является  прописной  буквой,  _tolower
               возвращает преобразованное значение;  в против-
               ном случае результат не определен.

Переносимость  Эта функция доступна в системах UNIX.

Пример         #include <string.h>
               #include <stdio.h>
               #include <ctype.h>
               int main(void)
               {  int length, i;
                  char *string = "THIS IS A STRING";
                  /* необходимо проверить каждый символ,
                     чтобы убедиться, что это - прописная
                     буква, прежде, чем вызвать _tolower!
                     иначе результат не определен */
                  length = strlen(string);
                  for (i=0; i<length; i++) {
                     string[i] = _tolower(string[i]);
                  }
                  printf("%s\n",string);
                  return 0;
               }

     tolower
──────────────────────────────────────────────────────────────
Функция        Преобразует символы в строчные.

Синтаксис      #include <ctype.h>
               int tolower(int ch);

Прототип в     ctype.h

Примечания     tolower - функция,  которая  преобразует  целое
               число ch (в диапазоне от  EOF  до  255)  в  его
               строчное  значение  (от  a до z,  если это была
               прописная буква от A до Z).  Все другие символы
               остаются без изменения.

Значение       tolower возвращает преобразованное значение ch,
               если оно является прописной буквой; иначе возв-
               ращает его без изменения.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie.

Пример         #include <string.h>
               #include <stdio.h>
               #include <ctype.h>
               int main(void)
               {  int length, i;
                  char *string = "THIS IS A STRING";
                  length = strlen(string);
                  for (i=0; i<length; i++) {
                     string[i] = tolower(string[i]);
                  }
                  printf("%s\n",string);
                  return 0;
               }

     _toupper
──────────────────────────────────────────────────────────────
Функция        Преобразует строчные буквы в прописные.

Синтаксис      #include <ctype.h>
               int _toupper(int ch);

Прототип в     ctype.h

Примечания     _toupper - макрос,  который делает то же  самое
               преобразование, что и toupper, однако в отличие
               от последнего,  он должен использоваться только
               тогда, когда ch заведомо является строчной бук-
               вой (a - z).
               Для использования  _toupper  Вы должны включить
               ctype.h.

Значение       Если ch  является  строчной  буквой,   _toupper
               возвращает преобразованное значение;  в против-
               ном случае результат не определен.

Переносимость  Эта функция доступна в системах UNIX.

Пример         #include <string.h>
               #include <stdio.h>
               #include <ctype.h>
               int main(void)
               {  int length, i;
                  char *string = "this is a string";
                  /* необходимо проверить каждый символ,
                     чтобы убедиться, что это - строчная
                     буква, прежде, чем вызвать _toupper!
                     иначе результат не определен */
                  length = strlen(string);
                  for (i=0; i<length; i++) {
                     string[i] = _toupper(string[i]);
                  }
                  printf("%s\n",string);
                  return 0;
               }

     toupper
──────────────────────────────────────────────────────────────
Функция        Преобразует символы в прописные.

Синтаксис      #include <ctype.h>
               int toupper(int ch);

Прототип в     ctype.h

Примечания     toupper - функция,  которая  преобразует  целое
               число ch (в диапазоне от EOF до 255) в его про-
               писное  значение  (от  A  до  Z,  если это была
               строчная буква от a до z).  Все другие  символы
               остаются без изменения.

Значение       toupper возвращает преобразованное значение ch,
               если оно является строчной буквой;  иначе возв-
               ращает его без изменения.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie.

Пример         #include <string.h>
               #include <stdio.h>
               #include <ctype.h>

               int main(void)
               {  int length, i;
                  char *string = "this is a string";
                  length = strlen(string);
                  for (i=0; i<length; i++) {
                     string[i] = toupper(string[i]);
                  }
                  printf("%s\n",string);
                  return 0;
               }

     tzset
──────────────────────────────────────────────────────────────
Функция        Устанавливает значения  глобальных   переменных
               daylight, timezone, tzname.

Синтаксис      #include <time.h>
               void tzset(void);

Прототип в     time.h

Примечания     tzset устанавливает    глобальные    переменные
               daylight, timezone и tzname, исходя из значения
               переменной среды TZ. Библиотечные функции ftime
               и  localtime используют эти глобальные перемен-
               ные для корректировки значения времени по Грин-
               вичу  (GMT)  для любого часового пояса.  Формат
               переменной среды TZ:
                  TZ = zzz[+/-]d[d][lll]
               zzz -  это строка из трех символов,  содержащая
               наименование текущего часового пояса.  Все  три
               символа обязательны. Например, строка "PST" мо-
               жет быть использована для  представления  Стан-
               дартного Тихоокеанского Времени.
               [+/-]d[d] -  обязательное поле - число с необя-
               зательным знаком,  состоящее из одной или более
               цифр.  Это  число  есть  разница  в часах между
               местным поясным временем и временем по Гринвичу
               (GMT).  Положительные  числа соответствуют нап-
               равлению к западу  от  Гринвича,  отрицательные
               числа  -  к  востоку.  Например,  число 5 соот-
               ветствует Восточному Стандартному Времени(ESR),
               +8  - Тихоокеанскому Стандартному Времени(PST),
               а  -1  -  континентальной  Европе.  Это   число
               используется для вычисления глобальной перемен-
               ной timezone. timezone - это разница в секундах
               между GMT и местным поясным временем.
               lll -   необязательное   трехсимвольное   поле,
               представляющее  режим  летнего времени в данном
               часовом поясе.  Например,  строка  "PDT"  может
               представлять режим летнего времени для Тихооке-
               анского  (Pacific)  времени.  Если   это   поле
               присутствует, то глобальная переменная daylight
               будет иметь ненулевое значение.  Если это  поле
               отсутствует,  то  daylight  будет установлена в
               ноль.
               Если строка для переменной среды TZ отсутствует
               или имеет иной формат,  для инициализации  гло-
               бальных переменных daylight,  timezone,  tzname
               предполагается  значение  по  умолчанию:
                  TZ = "EST5EDT"
               Глобальная переменная  tzname[0]  указывает  на
               трехсимвольную строку с наименованием  часового
               пояса из строки окружения TZ.  tzname[1] указы-
               вает на трехсимвольную строку  с  наименованием
               режима летнего времени из строки TZ. Если режим
               летнего времени отсутствует, tzname[1] указыва-
               ет на пустую строку.

Значение       Нет.

Переносимость  Эта функция доступна в системах UNIX и XENIX.

См.также       asctime, ctime,   ftime,   gmtime,   localtime,
               stime, time

Пример         #include <time.h>
               #include <stdlib.h>
               #include <stdio.h>
               int main(void)
               {  time_t td;
                  putenv("TZ=PST8PDT");
                  tzset();
                  time(&td);
                  printf("Current time = %s\n",
                         asctime(localtime(&td)));
                  return 0;
               }

     ultoa
──────────────────────────────────────────────────────────────
Функция        Переводит значение типа unsigned long в строку.

Синтаксис      #include <stdlib.h>
               char *ultoa(unsigned long value, char *string,
                           int radix);

Прототип в     stdlib.h

Примечания     ultoa переводит  значение  аргумента  value   в
               строку,  завершаемую  нуль-символом и сохраняет
               результат в  *string.  Аргумент  value   должен
               иметь тип unsigned long.
               radix определяет  основание  системы счисления,
               которая будет использована при  преобразовании;
               его  значение  - число от 2 до 36 включительно.
               ultoa не осуществляет проверку переполнения,  и
               если  value  содержит  отрицательное  число,  а
               radix равно 10,  то знак минуса не устанавлива-
               ется.
         !!!   Область, отведенная  под  string,  должна  быть
               достаточно большой, чтобы разместить возвращае-
               мую  строку,  включая  завершающий  нуль-символ
               (\0). ultoa может возвратить до 33 байтов.

Значение       ultoa возвращает string.

Переносимость  Эта функция доступна только в DOS.

См.также       itoa, ltoa

Пример         #include <stdlib.h>
               #include <stdio.h>
               int main( void )
               {  unsigned long lnumber = 3123456789L;
                  char string[25];
                  ultoa(lnumber,string,10);
                  printf("string = %s  unsigned long = %lu\n",
                         string, lnumber);
                  return 0;
               }

     ungetc
──────────────────────────────────────────────────────────────
Функция        "Помещает" символ во входной поток.

Синтаксис      #include <stdio.h>
               int ungetc(int c, FILE *stream);

Прототип в     stdio.h

Примечания     ungetc "помещает" символ  с  во  входной  поток
               stream,  который должен быть открыт для чтения.
               Этот символ будет возвращен при следующем обра-
               щении к функциям getc или fread для этого пото-
               ка.  В любой ситуации в поток может быть "поме-
               щен"  только  один  символ.  Второе обращение к
               ungetc без вызова getc приведет к потере преды-
               дущего  символа.  Вызов функций fflush,  fseek,
               fsetpos или rewind уничтожает всю информацию  о
               "помещенных" в поток символах.

Значение       В случае успешного завершения ungetc возвращает
               "помещенный" в поток символ;  в случае  неудачи
               возвращает EOF.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См.также       fgetc, getc, getchar

Пример         #include <stdio.h>
               #include <ctype.h>
               int main( void )
               {  int i=0;
                  char ch;
                  puts("Input an integer "
                       "followed by a char:");
                  /* читать символ, пока не встретится
                     не-цифра или EOF */
                  while ((ch = getchar()) != EOF
                         && isdigit(ch))
                     /* перевести АSCII в целое значение */
                     i = 10 * i + ch - 48;
                  /* если была прочитана не цифра, поместить
                     символ обратно во входной буфер */
                  if (ch != EOF)
                     ungetc(ch, stdin);
                  printf("i = %d, next char in buffer = %c\n",
                         i, getchar());
                  return 0;
               }

     ungetch
──────────────────────────────────────────────────────────────
Функция        Помещает символ в буфер клавиатуры.

Синтаксис      #include <conio.h>
               int ungetch(int ch);

Прототип в     conio.h

Примечания     ungetch помещает символ сh на вход консоли, де-
               лая его следующим символом,  который будет про-
               читан.  Функция  ungetch  завершится с ошибкой,
               если будет вызвана более одного раза до  после-
               дующего чтения.

Значение       При успешном завершении ungetch возвращает сим-
               вол ch; в случае ошибки возвращает EOF.

Переносимость  Эта функция доступна в системах  UNIX.  Она  не
               совместима с Windows.

См.также       getch, getche

Пример         #include <stdio.h>
               #include <ctype.h>
               #include <conio.h>
               int main( void )
               {  int i=0;
                  char ch;
                  puts("Input an integer "
                       "followed by a char:");
                  /* читать символ, пока не встретится
                     не-цифра или EOF */
                  while ((ch = getche()) != EOF
                         && isdigit(ch))
                     /* перевести АSCII в целое значение */
                     i = 10 * i + ch - 48;
                  /* если была прочитана не цифра, поместить
                     символ обратно во входной буфер */
                  if (ch != EOF)
                     ungetch(ch, stdin);
                  printf("\n\ni = %d, next char "
                         "in buffer = %c\n", i, getch());
                  return 0;
               }

     unixtodos
──────────────────────────────────────────────────────────────
Функция        Переводит дату и время из формата UNIX в формат
               DOS.

Синтаксис      #include <dos.h>
               void unixtodos(long time, struct date *d,
                              struct time *t);

Прототип в     dos.h

Примечания     unixtodos переводит  время в формате UNIX,  за-
               данное в аргументе time,  в формат DOS. d и t -
               указатели  на структуры типов date и time соот-
               ветственно,  в  которые  помещаются  полученные
               значения.

Значение       Нет.

Переносимость  Эта функция доступна только в DOS.

См.также       dostounix

Пример         #include <stdio.h>
               #include <dos.h>
               char *month[] = {"---", "Jan", "Feb", "Mar",
                                       "Apr", "May", "Jun",
                                       "Jul", "Aug", "Sep",
                                       "Oct", "Nov", "Dec"};
               /* число секунд в сутках */
               #define SECONDS_PER_DAY 86400L
               struct date dt;
               struct time tm;
               int main(void)
               {  unsigned long val;
                  /* получить текущую дату и время */
                  getdate(&dt);
                  gettime(&tm);
                  printf("today is %d %s %d\n", dt.da_day,
                         month[dt.da_mon], dt.da_year);
                  /* перевести дату и время в формат unix
                     (число секунд с 1 января 1970) */
                  val = dostounix(&dt, &tm);
                  /* вычесть количество секунд,
                     составляющее 42 дня */
                  val -= (SECONDS_PER_DAY * 42);
                  /* перевести дату и время
                     обратно в формат DOS */
                  unixtodos(val, &dt, &tm);
                  printf("42 days ago it was %d %s %d\n",
                         dt.da_day, month[dt.da_mon],
                         dt.da_year);
                  return 0;
               }

     unlink
──────────────────────────────────────────────────────────────
Функция        Удаляет файл.

Синтаксис      #include <io.h>
               int unlink(const char *filename);

Прототип в     dos.h, io.h, stdio.h

Примечания     unlink удаляет файл,  указанный в *filename.  В
               качестве *filename   можно  использовать  любое
               устройство DOS,  путь,  или имя файла.  Символы
               шаблона не допускаются.
               Этой функцией нельзя удалить  файл  с атрибутом
               "только для чтения".  Чтобы удалить такой файл,
               необходимо сначала изменить его атрибут  с  по-
               мощью функции chmod или _chmod.
         !!!   Если файл открыт,  то перед удалением его необ-
               ходимо закрыть.

Значение       При успешном завершении unlink возвращает 0.  В
               случае ошибки возвращается -1, и глобальная пе-
               ременная errno устанавливается в одно из следу-
               ющих значений:
                 ENOENT  Файл или справочник не существует
                 EACCES  Доступ запрещен

Переносимость  Эта функция доступна в системах  UNIX.

См.также       chmod, remove

Пример         #include <stdio.h>
               #include <io.h>
               int main(void)
               {  FILE *fp = fopen("junk.jnk","w");
                  int status;
                  fprintf(fp,"junk");
                  status = access("junk.jnk",0);
                  if (status == 0)
                     printf("File exists\n");
                  else
                     printf("File doesn't exist\n");
                  fclose(fp);
                  unlink("junk.jnk");
                  status = access("junk.jnk",0);
                  if (status == 0)
                     printf("File exists\n");
                  else
                     printf("File doesn't exist\n");
                  return 0;
               }

     unlock
──────────────────────────────────────────────────────────────
Функция        Снимает блокировку с разделяемых файлов.

Синтаксис      #include <io.h>
               int unlock(int handle,
                          long offset, long length);

Прототип в     io.h

Примечания     unlock обеспечивает интерфейс с механизмом раз-
               деления файлов DOS 3.x.
               unlock снимает блокировку,  установленную ранее
               функцией lock.  Во избежании ошибки, все блоки-
               ровки должны быть сняты прежде,  чем файл будет
               закрыт.  Программа  должна снять все блокировки
               до завершения своей работы.

Значение       unlock возвращает 0 в случае успешного заверше-
               ния, и -1 - при ошибке.

Переносимость  Эта функция доступна только в  DOS  3.x.  Более
               ранние версии DOS не поддерживают эту функцию.

См.также       lock, sopen

Пример         #include <io.h>
               #include <fcntl.h>
               #include <sys\stat.h>
               #include <process.h>
               #include <share.h>
               #include <stdio.h>
               int main(void)
               {  int handle, status;
                  long length;
                  handle = sopen("c:\\autoexec.bat", O_RDONLY,
                                 SH_DENYNO,S_IREAD);
                  if (handle < 0) {
                      printf("sopen failed\n");
                      exit(1);
                  }
                  length = filelength(handle);
                  status = lock(handle,0L,length/2);
                  if (status == 0)
                     printf("lock succeeded\n");
                  else
                     printf("lock failed\n");
                  status = unlock(handle,0L,length/2);
                  if (status == 0)
                     printf("unlock succeeded\n");
                  else
                     printf("unlock failed\n");
                  close(handle);
                  return 0;
               }

     va_arg, va_end, va_start
──────────────────────────────────────────────────────────────
Функции        Реализуют список аргументов переменной длины.

Синтаксис      #include <stdarg.h>
               void va_start(va_list ap, lastfix);
               type va_arg(va_list ap, type);
               void va_end(va_list ap);

Прототип в     stdarg.h

Примечания     Некоторые функции   C,   например,   fprintf  и
               vprintf, принимают списки аргументов переменно-
               го  размера  в дополнение к фиксированному (из-
               вестному заранее) числу постоянных  параметров.
               Макросы va_arg,  va_end и va_start обеспечивают
               переносимый способ доступа к таким спискам  ар-
               гументов.  Они используются для пошагового про-
               хода по  списку  аргументов,  когда  вызываемая
               функции  не знает число и типы передаваемых ар-
               гументов.  Файл  заголовка  stdarg.h  объявляет
               один  тип(va_list)  и  три  макроса  (va_start,
               va_arg и va_end).
               va_list: Этот массив содержит информацию, необ-
               ходимую va_arg и va_end. Когда вызываемая функ-
               ция получает список аргументов переменного раз-
               мера, она объявляет переменную ap типа va_list.
               va_start: Эта процедура (реализованная как мак-
               рос) устанавливает ap как указатель  на  первый
               аргумент   из  списка,  передаваемого  функции.
               va_start должна бать  использована  до  первого
               обращения к va_arg или va_end.
               va_start принимает два параметра: ap и lastfix.
               Параметр ap рассмотрен выше;  lastfix - это имя
               последнего постоянного (не входящего  в  список
               переменной  длины)  параметра,  передаваемого в
               функцию).
               va_arg: Эта процедура (также реализованная  как
               макрос) расширяется в выражение,  которое имеет
               такой же тип и значение,  как следующий переда-
               ваемый  аргумент (один из списка аргументов пе-
               ременной длины).  Переменная ap в va_arg должна
               быть  той  же  самой,  которая была установлена
               посредством va_start.
               Из-за специфики  реализации   Вы   не   сможете
               использовать  такие  типы,  как char,  unsigned
               char или float с va_arg.
               При первом обращении к va_arg возвращается пер-
               вый аргумент из списка.  Каждое последующее об-
               ращение к va_arg возвращает следующий  аргумент
               из списка.  va_arg делает это, сперва производя
               разыменование ap,  а затем  наращивая  ap  так,
               чтобы  оно  указывало  на  следующий  аргумент.
               va_arg использует type как  при  разыменовании,
               так  и при определении места нахождения следую-
               щего аргумента. Каждый последующий вызов va_arg
               изменяет ap таким образом,  чтобы оно указывало
               на следующий аргумент из списка.
               va_end: Этот макрос помогает вызываемой функции
               осуществить  нормальный  возврат.  va_end может
               изменить ap таким образом,  что оно  не  сможет
               быть  использовано  без  повторного обращения к
               va_start.  va_end должна вызываться после того,
               как va_arg прочтет все аргументы;  неправильное
               использование va_end может быть причиной стран-
               ного,  неопределенного поведения вашей програм-
               мы.

Значение       va_start и va_end не возвращают никакого значе-
               ния;  va_arg  возвращает  очередной аргумент из
               списка (тот, на который указывает ap).

Переносимость  Эти функции доступны в системах  UNIX.

См.также       v...printf, v...scanf

Пример 1       #include <stdio.h>
               #include <stdarg.h>
               /* подсчитывает сумму строк в списке */
               void sum(char *msg, ...)
               {  int total = 0;
                  va_list ap;
                  int arg;
                  va_start(ap, msg);
                  while ((arg = va_arg(ap, int)) != 0) {
                     total += arg;
                  }
                  printf(msg, total);
               }
               int main(void) {
                  sum("The total of 1+2+3+4 is %d\n",
                      1,2,3,4,0);
               }

               Вывод программы:

               The total of 1+2+3+4 is 10

Пример 2       #include <stdio.h>
               #include <stdarg.h>
               void error(char *format, ...)
               {  va_list argptr;
                  printf("Error: ");
                  va_start(argptr, format);
                  vprintf(format, argptr);
                  va_end(argptr);
               }
               int main(void) {
                  int value = -1;
                  error("This is just an error message\n");
                  error("Invalid value %d encountered\n",
                        value);
                  return 0;
               }

               Вывод программы:

               Error: This is just an error message
               Error: Invalid value -1 encountered

     vfprintf
──────────────────────────────────────────────────────────────
Функция        Форматированный вывод в поток ввода-вывода.

Синтаксис      #include <stdio.h>
               int vfprintf(FILE *stream, const char *format,
                            va_list arglist);

Прототип в     stdio.h

Примечания     Функции типа v...printf являются альтернативны-
               ми точками входа для  функций  типа  ...printf.
               Эти функции  ведут  себя  точно  также,  как их
               ...printf-аналоги,  однако вместо списка  аргу-
               ментов они принимают указатель на этот список.
Детальное      vfprintf принимает указатель на список аргумен-
описание       тов,  применяет к каждому из  них  спецификатор
спецификаторов формата,  содержащийся в строке формата, на ко-
формата        торую указывает format,  и выводит  сформатиро-
см. printf     ванные  данные  в  поток.  Число спецификаторов
               формата и аргументов должно быть одинаковым.

Значение       vfprintf возвращает число байтов,  выведенных в
               поток. В случае ошибки возвращается EOF.

Переносимость  Эта функция доступна в системе UNIX System V  и
               совместима с ANSI C.

См.также       printf, va_arg, va_end, va_start

Пример         #include <stdio.h>
               #include <stdlib.h>
               #include <stdarg.h>
               FILE *fp;
               int vfpf(char *fmt, ...)
               {  va_list argptr;
                  int cnt;
                  va_start(argptr, fmt);
                  cnt = vfprintf(fp, fmt, argptr);
                  va_end(argptr);
                  return(cnt);
               }
               int main(void)
               {  int inumber = 30;
                  float fnumber = 90.0;
                  char string[4] = "abc";
                  fp = tmpfile();
                  if (fp == NULL) {
                     perror("tmpfile() call");
                     exit(1);
                  }
                  vfpf("%d %f %s", inumber, fnumber, string);
                  rewind(fp);
                  fscanf(fp,"%d %f %s", &inumber, &fnumber,
                         string);
                  printf("%d %f %s\n", inumber, fnumber,
                         string);
                  fclose(fp);
                  return 0;
               }

    vfscanf
──────────────────────────────────────────────────────────────
Функция        Форматный ввод из входного потока.

Синтаксис      #include <stdio.h>
               int vfscanf(FILE *stream, const char *format,
                           va_list arglist);

Прототип в     stdio.h

Примечания     Функции типа v...scanf являются альтернативными
               точками  входа  для функций типа ...scanf.  Эти
               функции  ведут  себя  точно   также,   как   их
               ...scanf-аналоги, однако вместо списка аргумен-
               тов они принимают  указатель  на  этот  список.
Детальное      vfscanf  посимвольно  читает последовательность
описание       входных полей из входного потока.  Каждое  поле
спецификаторов форматируется  в соответствии со спецификатором
формата        формата, передаваемым vfscanf в строке формата,
см. scanf      на которую указывает format.  Наконец,  vfscanf
               записывает форматированный ввод по адресам, пе-
               реданным  в  качестве аргументов,  следующих за
               format.  Количество спецификаций формата и  ад-
               ресов  должно  совпадать  с количеством входных
               полей.
               vfscanf может прекратить обработку текущего по-
               ля  до  достижения  обычного символа конца поля
               (символа-разделителя),  или вообще  завершиться
               по  различным  причинам.  Обсуждение  возможных
               случаев см. scanf.

Значение       vfscanf возвращает количество успешно прочитан-
               ных,  преобразованных  и  записанных  в  память
               входных полей; возвращаемое значение не включа-
               ет прочитанные поля, которые не были записаны в
               память.  Если ни одно поле не записано, возвра-
               щается 0.
               Если vfscanf обнаруживает конец файла,  возвра-
               щается EOF.

Переносимость  Эта функция доступна в системе UNIX System V.

См.также       fscanf, scanf, va_arg, va_end, va_start

Пример         #include <stdio.h>
               #include <stdlib.h>
               #include <stdarg.h>
               FILE *fp;
               int vfsf(char *fmt, ...)
               {  va_list  argptr;
                  int cnt;
                  va_start(argptr, fmt);
                  cnt = vfscanf(fp, fmt, argptr);
                  va_end(argptr);
                  return(cnt);
               }
               int main(void)
               {  int inumber = 30;
                  float fnumber = 90.0;
                  char string[4] = "abc";
                  fp = tmpfile();
                  if (fp == NULL) {
                     perror("tmpfile() call");
                     exit(1);
                  }
                  fprintf(fp, "%d %f %s\n", inumber, fnumber,
                          string);
                  rewind(fp);
                  vfsf("%d %f %s", &inumber, &fnumber,
                       string);
                  printf("%d %f %s\n", inumber, fnumber,
                         string);
                  fclose(fp);
                  return 0;
               }

     vprintf
──────────────────────────────────────────────────────────────
Функция        Форматированный вывод  в  стандартный  выходной
               поток (stdout).

Синтаксис      #include <stdarg.h>
               int vprintf(const char *format,
                           va_list arglist);

Прототип в     stdio.h

Примечания     Функции типа v...printf являются альтернативны-
               ми точками входа для  функций  типа  ...printf.
               Эти  функции  ведут  себя  точно также,  как их
               ...printf-аналоги,  однако вместо списка  аргу-
               ментов  они принимают указатель на этот список.
Детальное      vprintf принимает указатель на список  аргумен-
описание       тов,  применяет  к  каждому из них спецификатор
спецификаторов формата,  содержащийся в строке формата, на ко-
формата        торую  указывает format,  и выводит сформатиро-
см. printf     ванные данные  в stdout.  Число  спецификаторов
               формата и аргументов должно быть одинаковым.
         !!!   Если Вы используете флаг SS!=DS,  vprintf пред-
               полагает,  что  передаваемый  адрес относится к
               сегменту SS.

Значение       vprintf возвращает  число байтов,  выведенных в
               stdout. В случае ошибки возвращается EOF.

Переносимость  Эта функция  доступна в системе UNIX System V и
               совместима  с  ANSI  C.  Она  не  совместима  с
               Windows.

См.также       printf, va_arg, va_end, va_start

Пример         #include <stdio.h>
               #include <stdarg.h>
               int vpf(char *fmt, ...)
               {  va_list argptr;
                  int cnt;
                  va_start(argptr, format);
                  cnt = vprintf(fmt, argptr);
                  va_end(argptr);
                  return(cnt);
               }
               int main(void)
               {  int inumber = 30;
                  float fnumber = 90.0;
                  char *string = "abc";
                  vpf("%d %f %s\n", inumber, fnumber, string);
                  return 0;
               }

     vscanf
──────────────────────────────────────────────────────────────
Функция        Форматный ввод из стандартного входного  потока
               (stdin).

Синтаксис      #include <stdarg.h>
               int vscanf(const char *format,
                          va_list arglist);

Прототип в     stdio.h

Примечания     Функции типа v...scanf являются альтернативными
               точками  входа  для функций типа ...scanf.  Эти
               функции  ведут  себя  точно   также,   как   их
               ...scanf-аналоги, однако вместо списка аргумен-
               тов они принимают  указатель  на  этот  список.
Детальное      vscanf посимвольно   читает  последовательность
описание       входных полей из stdin.  Каждое поле форматиру-
спецификаторов ется  в соответствии со спецификатором формата,
формата        передаваемым vscanf в строке формата,  на кото-
см. scanf      рую указывает format. Наконец, vscanf записыва-
               ет форматированный ввод по адресам,  переданным
               в качестве аргументов, следующих за format. Ко-
               личество спецификаций формата и адресов  должно
               совпадать  с количеством входных полей.
               vscanf может прекратить обработку текущего поля
               до достижения обычного символа конца поля (сим-
               вола-разделителя),  или вообще  завершиться  по
               различным причинам. Обсуждение возможных случа-
               ев см. scanf.

Значение       vscanf возвращает  количество успешно прочитан-
               ных,  преобразованных  и  записанных  в  память
               входных полей; возвращаемое значение не включа-
               ет прочитанные поля, которые не были записаны в
               память.  Если ни одно поле не записано, возвра-
               щается 0.
               Если vscanf обнаруживает конец файла, возвраща-
               ется EOF.

Переносимость  Эта функция доступна в системе UNIX  System  V.
               Она не совместима с Windows.

См.также       fscanf, scanf, va_arg, va_end, va_start

Пример         #include <stdio.h>
               #include <conio.h>
               #include <stdarg.h>
               int vscnf(char *fmt, ...)
               {  va_list argptr;
                  int cnt;
                  printf("Enter an integer, a float, "
                         "and a string (e.g., i,f,s)\n");
                  va_start(argptr, fmt);
                  cnt = vscanf(fmt, argptr);
                  va_end(argptr);
                  return(cnt);
               }
               int main(void)
               {  int inumber;
                  float fnumber;
                  char string[80];
                  vscnf("%d, %f, %s", &inumber, &fnumber,
                        string);
                  printf("%d %f %s\n", inumber, fnumber,
                         string);
                  return 0;
               }

     vsprintf
──────────────────────────────────────────────────────────────
Функция        Форматированный вывод в строку.

Синтаксис      #include <stdarg.h>
               int vsprintf(char *buffer, const char *format,
                            va_list arglist);

Прототип в     stdio.h

Примечания     Функции типа v...printf являются альтернативны-
               ми точками входа для  функций  типа  ...printf.
               Эти  функции  ведут  себя  точно также,  как их
               ...printf-аналоги,  однако вместо списка  аргу-
               ментов  они принимают указатель на этот список.
Детальное      vsprintf принимает указатель на список аргумен-
описание       тов,  применяет  к  каждому из них спецификатор
спецификаторов формата,  содержащийся в строке формата, на ко-
формата        торую указывает format,  и помещает сформатиро-
см. printf     ванные данные в  строку.  Число  спецификаторов
               формата и аргументов должно быть одинаковым.

Значение       vsprintf возвращает число байтов,  помещенных в
               строку. В случае ошибки возвращается EOF.

Переносимость  Эта функция доступна в системе UNIX System V  и
               совместима с ANSI C.

См.также       printf, va_arg, va_end, va_start

Пример         #include <stdio.h>
               #include <conio.h>
               #include <stdarg.h>
               char buffer[80];
               int vspf(char *fmt, ...)
               {  va_list argptr;
                  int cnt;
                  va_start(argptr, fmt);
                  cnt = vsprintf(buffer, fmt, argptr);
                  va_end(argptr);
                  return(cnt);
               }
               int main(void)
               {  int inumber = 30;
                  float fnumber = 90.0;
                  char string[3] = "abc";
                  vspf("%d %f %s", inumber, fnumber, string);
                  printf("%s\n", buffer);
                  return 0;
               }

     vsscanf
──────────────────────────────────────────────────────────────
Функция        Форматный ввод из строки.

Синтаксис      #include <stdio.h>
               int vsscanf(const char *buffer,
                          const char *format [, address,...]);

Прототип в     stdio.h

Примечания     Функции типа v...scanf являются альтернативными
               точками  входа  для функций типа ...scanf.  Эти
               функции  ведут  себя  точно   также,   как   их
               ...scanf-аналоги, однако вместо списка аргумен-
               тов они принимают  указатель  на  этот  список.
Детальное      vsscanf посимвольно  читает  последовательность
описание       входных полей из строки. Каждое поле форматиру-
спецификаторов ется в соответствии со  спецификацией  формата,
формата        передаваемой vsscanf в строке формата, на кото-
см. scanf      рую указывает format.  Наконец, vsscanf записы-
               вает форматированный ввод по адресам,  передан-
               ным в качестве аргументов, следующих за format.
               Количество спецификаций формата и адресов долж-
               но совпадать с количеством входных полей.
               vsscanf может прекратить обработку текущего по-
               ля  до  достижения  обычного символа конца поля
               (символа-разделителя),  или вообще  завершиться
               по  различным  причинам.  Обсуждение  возможных
               случаев см. scanf.

Значение       vsscanf возвращает количество успешно прочитан-
               ных,  преобразованных  и  записанных  в  память
               входных полей; возвращаемое значение не включа-
               ет прочитанные поля, которые не были записаны в
               память.  Если ни одно поле не записано, возвра-
               щается 0.
               Если vsscanf обнаруживает символ конца  строки,
               возвращается EOF.

Переносимость  Эта функция доступна в системе UNIX System V.

См.также       fscanf, scanf,    sscanf,    va_arg,    va_end,
               va_start, vfscanf

Пример         #include <stdio.h>
               #include <conio.h>
               #include <stdarg.h>
               char buffer[80] = "30 90.0 abc";
               int vssf(char *fmt, ...)
               {  va_list  argptr;
                  int cnt;
                  fflush(stdin);
                  va_start(argptr, fmt);
                  cnt = vsscanf(buffer, fmt, argptr);
                  va_end(argptr);
                  return(cnt);
               }
               int main(void)
               {  int inumber;
                  float fnumber;
                  char string[80];
                  vssf("%d %f %s", &inumber, &fnumber,
                       string);
                  printf("%d %f %s\n", inumber, fnumber,
                         string);
                  return 0;
               }

     wherex
──────────────────────────────────────────────────────────────
Функция        Возвращает горизонтальную позицию курсора внут-
               ри окна.

Синтаксис      #include <conio.h>
               int wherex(void);

Прототип в     conio.h

Примечания     wherex возвращает х-координату текущей  позиции
               курсора (внутри текущего текстового окна).

Значение       wherex возвращает  целое число в диапазоне от 1
               до 80.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Соответствующая функция имеется в
               Turbo Pascal. Она не совместима с Windows.

См.также       gettextinfo, gotoxy, wherey

Пример         #include <conio.h>
               int main(void)
               {  clrscr();
                  gotoxy(10,10);
                  cprintf("Current location is X: %d  "
                          "Y: %d\r\n", wherex(), wherey());
                  getch();
                  return 0;
               }

     wherey
──────────────────────────────────────────────────────────────
Функция        Возвращает вертикальную  позицию курсора внутри
               окна.

Синтаксис      #include <conio.h>
               int wherey(void);

Прототип в     conio.h

Примечания     wherey возвращает  y-координату текущей позиции
               курсора (внутри текущего текстового окна).

Значение       wherey возвращает целое число в диапазоне от  1
               до 25, 43 или 50.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Соответствующая функция имеется в
               Turbo Pascal. Она не совместима с Windows.

См.также       gettextinfo, gotoxy, wherex

Пример         #include <conio.h>
               int main(void)
               {  clrscr();
                  gotoxy(10,10);
                  cprintf("Current location is X: %d  "
                          "Y: %d\r\n", wherex(), wherey());
                  getch();
                  return 0;
               }

     window
──────────────────────────────────────────────────────────────
Функция        Определяет активное окно в текстовом режиме.

Синтаксис      #include <conio.h>
               void window(int left,int top,
                           int right, int bottom);

Прототип в     conio.h

Примечания     window определяет  текстовое  окно  на  экране.
               Если задаются  неправильные  координаты,  вызов
               функции window игнорируется.
               left и top - экранные координаты левого верхне-
               го угла окна.
               right и bottom -  экранные  координаты  правого
               нижнего угла окна.
               Минимальный размер текстового окна: 1 столбец *
               1 строку.  Размер текстового окна,  принятый по
               умолчанию,  соответствует всему экрану с такими
               координатами:
                  1,1,80,25 - для режима экрана в 80 столбцов
                  1,1,40,25 - для режима экрана в 40 столбцов

Значение       Нет.

Переносимость  Эта функция работает только с  ПЭВМ  IBM  PC  и
               совместимыми. Соответствующая функция имеется в
               Turbo Pascal. Она не совместима с Windows.

См.также       clreol, clrscr,  delline,  gettextinfo, gotoxy,
               insline, puttext, textmode

Пример         #include <conio.h>
               int main(void)
               {  window(10,10,40,11);
                  textcolor(BLACK);
                  textbackground(WHITE);
                  cprintf("This is a test\r\n");
                  return 0;
               }

     _write
──────────────────────────────────────────────────────────────
Функция        Записывает данные в файл.

Синтаксис      #include <io.h>
               int _write(int handle, void *buf,
                          unsigned len);

Прототип в     io.h

Примечания     _write пытается записать  len байтов из  буфера
               *buf, в файл, связанный с обработчиком handle.
               Максимальное количество  байтов,  которое может
               записать функция _write, равно 65534, поскольку
               65535 (т.е.  0xFFFF) - это то же самое, что -1,
               т.е.  значение,  возвращаемое этой функцией при
               ошибке.
               _write не  преобразует  символ  перевода строки
               (LF) в пару символов CR/LF (возврат каретки/пе-
               ревод строки), поскольку эта функция работает с
               двоичными файлами.
               Если количество действительно записанных байтов
               окажется  меньшим,  чем  задано,   это   должно
               рассматриваться как ошибка, возможно, указываю-
               щая на переполнение диска.
               Для дисковых  файлов запись всегда начинается с
               текущей позиции указателя файла.  Для устройств
               байты   пересылаются   непосредственно  в  уст-
               ройство.
               Для файлов, открытых с опцией O_APPEND, функция
               _write  не позиционирует указатель файла на EOF
               перед записью данных.

Значение       _write возвращает количество записанных байтов.
               В случае ошибки _write возвращает -1 и устанав-
               ливает глобальную переменную errno  в  одно  из
               следующих значений:
                  EACCES  Доступ запрещен
                  EBADF   Неверный номер (обработчика) файла

Переносимость  Эта функция доступна только в DOS.

См.также       lseek, _read, write

Пример         #include <stdio.h>
               #include <io.h>
               #include <alloc.h>
               #include <fcntl.h>
               #include <process.h>
               #include <sys\stat.h>
               int main(void)
               {  void *buf;
                  int handle, bytes;
                  buf = malloc(200);
                  /* Создать файла TEST.$$$ в текущем
                     справочнике и записать в него 200
                     байтов. Если TEST.$$$ уже
                     существует, перезаписать его.  */
                  if ((handle = open("TEST.$$$",
                       O_CREAT | O_WRONLY | O_BINARY,
                       S_IWRITE | S_IREAD)) == -1)
                  {  printf("Error Opening File\n");
                     exit(1);
                  }
                  if ((bytes = _write(handle, buf, 200))
                      == -1)
                  {  printf("Write Failed.\n");
                     exit(1);
                  }
                  printf("_write: %d bytes written.\n",bytes);
                  return 0;
               }

     write
──────────────────────────────────────────────────────────────
Функция        Записывает данные в файл.

Синтаксис      #include <io.h>
               int write(int handle, void *buf, unsigned len);

Прототип в     io.h

Примечания     write записывает  буфер  данных  в  файл или на
               устройство,  связанные с handle.  handle -  это
               номер обработчика файла,  полученный при вызове
               creat, open, dup или dup2.
               write пытается  записать  len  байтов из буфера
               *buf,  в файл, связанный с обработчиком handle.
               За исключением случая, когда write используется
               для записи в  текстовый  файл,  количество  за-
               писанных байтов не будет превышать заданное ко-
               личество.
               Максимальное количество  байтов,  которое может
               записать функция _write, равно 65534, поскольку
               65535 (т.е.  0xFFFF) - это то же самое, что -1,
               т.е.  значение,  возвращаемое этой функцией при
               ошибке.
               В текстовых файлах write преобразует символ пе-
               ревода строки (LF) в пару символов CR/LF (возв-
               рат каретки/перевод строки).
               Если количество действительно записанных байтов
               окажется   меньшим,   чем  задано,  это  должно
               рассматриваться как ошибка, возможно, указываю-
               щая на переполнение диска.
               Для дисковых  файлов запись всегда начинается с
               текущей позиции указателя файла.  Для устройств
               байты   пересылаются   непосредственно  в  уст-
               ройство.
               Для файлов, открытых с опцией O_APPEND, функция
               write позиционирует указатель файла на EOF  пе-
               ред записью данных.

Значение       write возвращает  количество записанных байтов.
               При записи в текстовый файл  не  подсчитываются
               сгенерированные  символы  возврата  каретки.  В
               случае ошибки write возвращает -1 и  устанавли-
               вает глобальную переменную errno в одно из сле-
               дующих значений:
                  EACCES  Доступ запрещен
                  EBADF   Неверный номер (обработчика) файла

Переносимость  Эта функция доступна в системах UNIX.

См.также       creat, lseek, open, read, _write

Пример         #include <stdio.h>
               #include <stdlib.h>
               #include <fcntl.h>
               #include <sys\stat.h>
               #include <io.h>
               #include <string.h>
               int main(void)
               {  int handle;
                  char string[40];
                  int length, res;
                  /* Создать  файл TEST.$$$ в текущем
                     справочнике и записать в него
                     строку. Если TEST.$$$ уже
                     существует, перезаписать его. */
                  if ((handle = open("TEST.$$$",
                       O_WRONLY | O_CREAT | O_TRUNC,
                       S_IREAD | S_IWRITE)) == -1)
                  {  printf("Error opening file.\n");
                     exit(1);
                  }
                  strcpy(string, "Hello, world!\n");
                  length = strlen(string);
                  if ((res = write(handle, string, length))
                      != length)
                  {  printf("Error writing to the file.\n");
                     exit(1);
                  }
                  printf("Wrote %d bytes to the file.\n",
                         res);
                  close(handle);
                  return 0;
               }
