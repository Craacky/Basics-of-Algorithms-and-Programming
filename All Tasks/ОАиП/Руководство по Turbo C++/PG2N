                           ГЛАВА 2.
                  ГРАММАТИКА СТРУКТУРЫ ФРАЗ.

     Эта глава предоставляет формальное определение грамматики
структуры фраз Borland C++. Грамматика структуры фраз описыва-
ет правильные методы,  посредством которых лексемы могут груп-
пироваться для образования выражений, операторов и других зна-
чащих единиц языка.  В отличие от этой, лексическая грамматика
(описанная в главе 1) рассматривает различные  категории  еди-
ниц,  подобных словам,  известных как лексемы,  распознаваемых
языком.

                           Массивы.

     Объявление
     type элемент объявления [<константное-выражение>]
     объявляет массив,  состоящий  из  элементов  типа   type.
Массив  Си представляет собой последовательную область памяти,
достаточную для хранения всех элементов.
     Если при  объявлении массива используется выражение,  оно
должно вычисляться в положительную целую константу. Значение -
это  число  элементов в массиве.  Каждый элемент массива имеет
номер, начиная с 0 и до числа элементов массива -1.
     Многомерный массив  создается  объявлением  массива  типа
"массив".  Так двухмерный массив из 5 строк и 7 колонок объяв-
ляется
     type alpha [5] [7];
     В определенном  контексте  объявление  массива  может  не
использовать выражения внутри []. Такой массив имеет неопреде-
ленный размер. Это используется, когда нет необходимости знать
размер массива для резервирования памяти. Например extern объ-
явление массива не требует точных размеров массива,  то же са-
мое при использовании массива, как параметра функции. Как спе-
циальное  расширение  ANSI  C  Borland  C++  так  же позволяет
использовать массив  неопределенного  размера,  как  последний
элемент структуры.  Такие массивы не увеличивают размер струк-
туры за исключением того,  что массив может быть  выровнен  на
определенную границу. Такие структуры используются при динами-
ческом распределении и требуемый размер массива необходимо яв-
но  добавить к размеру структуры для правильного распределения
памяти.
     Выражение с  типом  "массив" преобразуется в указатель на
первый элемент массива,  за  исключением  случаев,  когда  тип
массива является операндом оператора sizeof или &.

                           Функции.

     Функции играют центральную роль при программировании на С
и C++. Такие языки, как Паскаль делают различия между процеду-
рами и функциями. Функции в Borland C++ играют обе роли.

                  Объявление и определение.

     Каждая программа  должна иметь единственную внешнюю функ-
цию с именем main,  указывающую на начальную точку  программы.
Функции обычно объявляются как прототипы в стандартных или оп-
ределенных пользователем файлах заголовков или  внутри  файлов
программы.  Функции  по умолчанию объявляются как external и к
ним можно обращаться из любого файла в  программе.  Это  может
быть ограничено использованием указателя класса памяти static.
     Функции определяются  в  исходных  файлах  или   делаются
доступными с помощью редактирования из библиотек.
     Функция может быть объявлена несколько раз  в  программе,
обеспечивая совместимость объявлений.  Неопределяемое объявле-
ние функции использует формат прототипа функции Borland C++  с
детальной информацией о параметрах,  что позволяет осуществить
контроль над числом аргументов, проверкой типов и преобразова-
нием типов.
     Примечание: В С++ Вы всегда должны использовать прототипы
функций. Мы так же рекомендуем делать это в С.
     Исключая перегрузку функции в С++,  допустимо только одно
определение каждой функции.  Объявления, если они есть, должны
соответствовать этому определению. (Существенное различие меж-
ду определением и объявлением в том, что определение имеет те-
ло функции).

                   Объявления и прототипы.

     В оригинальном стиле объявления Кернингана и Ритчи  функ-
ция  может  быть  объявлена неявно через ее появление в вызове
функции, или явно в виде:
     <type> func()    /* в С++ это объявление означает
                      <type> func(void) */
     где type  - это необязательный тип возвращаемого значения
(по умолчанию int).  Функция может быть объявлена возвращающей
значение любого типа, кроме массива или функции. Это не позво-
ляет компилятору проверять тип или число аргументов, использу-
емых при вызове функции.
     Эта проблема может быть решена  использованием  прототипа
функции:
     <type> func(список-параметров);
     Примечание: Вы  можете  разрешить  выдачу сообщения в IDE
или компилятором командной строки "function called  without  a
prototype" (функция вызвана без прототипа).
     В списке указывается тип каждого параметра функции.  Ком-
пилятор  использует  эту  информацию для проверки правильности
вызова функции.  Компилятор так же имеет возможность проверять
правильность типов аргументов. Предположим у Вас есть фрагмент
кода:
     long lmax(long v1, long v2); /* прототип */

     main()
     {
       int limit = 32;
       char ch = 'A';

       long mval;

       mval = lmax(limit, ch);   /* вызов функции */
     }
     Поскольку был  использован  прототип  функции  для  lmax,
программа преобразует limit и ch в long, используя стандартные
правила присваивания до помещения их в стеке при вызове  lmax.
Без прототипа функции limit и ch будут помещены в стек как це-
лое и символ соответственно;  в этом случае  стек,  переданный
lmax не будет соответствовать по размеру или содержимому тому,
что ожидает lmax, что приведет к проблемам. Классический стиль
объявления  не  позволяет осуществлять проверку типа или числа
параметров,  поэтому использование прототипов  функций  значи-
тельно облегчает программирование.
     Прототипы функции так же  помогают  документировать  код.
Например  функция strcpy имеет 2 параметра:  исходную строку и
строку назначения. Какая из них какая? Прототип функции
     char *strcpy(char *dest, char *source);
     делает это ясным.  Если файл заголовка содержит прототипы
функций,  Вы можете просмотреть этот файл для получения инфор-
мации при использовании этих функций.  Если Вы включаете иден-
тификатор в параметр прототипа, он используется только для вы-
дачи сообщений об ошибках, включающих этот параметр; и не име-
ет других применений.
     Объявление функции со словом void внутри () означает, что
функция не использует аргументы:
     func(void);
     Примечание: В С++ func() так же указывает, что функция не
имеет аргументов.
     Прототип функции  обычно объявляет функцию,  использующую
фиксированное число параметров. Для С функций, которые исполь-
зуют  переменное  число параметров (такие как printf) прототип
функции может заканчиваться "...", например
     f(int *count, long total, ...)
     Примечание: stdarg.h содержит макро,  который поможет Вам
определять функции с переменным числом параметров.
     При использовании этой формы прототипа фиксированные  па-
раметры проверяются во время компиляции, а переменные парамет-
ры передаются без проверки типов.
     Несколько примеров объявлений функций и прототипов:
     int f();  // в С функция возвращает int; информации   о
     //  параметрах нет
     int f();  // в С++ функция без аргументов
     int f(void); // функция без параметров
     int p(int, long); // функция, возвращающая int и с
                       // параметрами int и long
     int pascal q(void); // функция на Паскале, возвращающая
                         // int и без параметров
     char far *s(char *source, int kind); // функция,
     //возвращающая дальний указатель на char и
     //принимающая два параметра: char и int
     int printf(char *format, ...); // функция, возвращающая
     //int и использующая указатель на char как фиксированный
  // параметр и любое число дополнительных параметров без типа
     int (*fp)(int);  // указатель на функцию,  возвращающую int
     // и использующую int параметр

                         Определения.

     Ниже приведем синтаксис внешних определений функций:

          Таблица 2.1. Внешние определения функции.
──────────────────────────────────────────────────────────────
     файл:
       внешнее-определение
       файл внешнее-определение

     внешнее-определение:
       определение-функции
       объявление
       оператор-asm

     определение-функции:
      <указатели-объявления> идентификатор <список-объявления>
          составной-оператор
──────────────────────────────────────────────────────────────
     В общем случае определение функции состоит  из  следующих
разделов (грамматика позволяет более сложные варианты):
     1. Необязательный указатель  класса  памяти:  extern  или
static. По умолчанию extern.
     2. Возвращаемый тип, возможно void. По умолчанию int.
     3. Необязательные модификаторы: pascal, cdecl, interrupt,
near,  far,  huge.  Умолчание зависит от модели памяти и опций
компилятора.
     4. Имя функции.
     5. Список параметров,  возможно пустой, заключенный в ().
В С предпочтительно указывать пустой  список  как  func(void).
Старый стиль - func() разрешен в С, но может приводить к проб-
лемам. В С++ Вы получите сообщение.
     6. Тело функции,  содержащее код,  выполняемый при вызове
функции.
     Примечание: Вы можете смешивать элементы пп. 1 и 2.

              Объявление формальных параметров.

     Объявление формальных параметров имеет синтаксис, похожий
на обычные объявления идентификаторов. Несколько примеров:

     int func(void) {       // нет аргументов
     int func(Tl tl, T2 t2, T3 t3=l)  { // 3 простых параметра
                                          // один с аргументом
                                          // по умолчанию
     int func(Tl* ptr1l, T2& tref)  {   // указатель и ссылка
     int func(register int i)  {   // запрашивает регистр под
                                   // аргумент
     int func(char *str, ...)  {   // один строковый аргумент
                           // с переменным числом других
                           // аргументов или фиксированное
                           // число аргументов с различными
                           // типами
     В С++ Вы можете задать аргументы по умолчанию,  как пока-
зано  выше.  Параметры  со значениями по умолчанию должны быть
последними аргументами в списке  параметров.  Типы  аргументов
могут быть скалярами, структурами, объединениями, перечислени-
ями;  указателями или ссылками на структуры  или  объединения;
или указателями на функции или классы.
     "..." указывают, что функция будет вызываться с различным
набором аргументов.  "..." могут следовать после известных ар-
гументов.  Эта форма прототипа сокращает число проверок, кото-
рое может сделать компилятор.
     К объявленным параметрам применяется автоматическая сфера
действия и время действия для времени действия функции. Разре-
шен только указатель класса памяти register.
     Модификаторы const  и  volatile  могут  быть использованы
только с формальными аргументами.

          Вызов функций и преобразование аргументов.

     Функция вызывается с действительными  аргументами,  поме-
щенными  в  той  же последовательности,  что и соответствующие
формальные аргументы.  Действительные аргументы преобразуются,
как если бы они инициализировали формальные аргументы при объ-
явлении.
     Приведем правило,  которыми  руководствуется  Borland C++
при обработке модификаторов языка и формальных параметров  при
вызове функции, при использовании и отсутствии прототипов:
     1. Модификаторы  языка  для  определения  функции  должны
соответствовать модификаторам, используемых в объявлении функ-
ции, для всех вызовов функции.
     2. Функция  может  модифицировать  значения ее формальных
параметров,  но они не действуют на действительные аргументы в
вызывающей  программе,  за  исключением аргументов по ссылке в
С++.
     Когда не было предварительно объявленного прототипа функ-
ции,  Borland C++ преобразует целые аргументы при вызове функ-
ции в соответствии с правилами расширения, описанными в разде-
ле "Стандартные преобразования".  Когда прототип функции нахо-
дится в сфере действия, Borland C++ преобразует аргумент к ти-
пу объявленного параметра как в случае присвоения.
     Когда прототип функции включает "...", Borland C++ преоб-
разует все аргументы функции как в любом другом прототипе  (до
"...").  Компилятор  расширяет  любые аргументы,  идущие после
фиксированных параметров, согласно обычным правилам аргументов
функции без прототипов.
     Если прототип существует,  число аргументов должно  соот-
ветствовать  (если  в прототипе не используется "...").  Могут
использоваться только типы,  в которые может быть  произведено
преобразование при присваивании.  Вы можете использовать явное
приведение типа для  преобразования  аргументов  тип,  который
разрешен прототипом функции.
     ВАЖНО! Если прототип функции не соответствует определению
функции,  Borland C++ обнаруживает это,  тогда и только тогда,
когда это определение находится в том же самом модуле компиля-
ции,  что  и прототип.  Если Вы создаете библиотеку программ с
соответствующими файлами заголовков с  прототипами,  включайте
эти файлы заголовков при компиляции библиотеки,  чтобы выявить
различия между прототипами  и  действительными  определениями.
С++ обеспечивает надежное редактирование так, что отличия меж-
ду ожидаемыми и действительными параметрами могут быть выявле-
ны редактором.

                          Структуры.

     Структура обычно  представляет определенный пользователем
набор имен элементов (или компонент).  Элементы могут быть лю-
бого  типа  (с некоторыми ограничениями,  объясняемыми позже).
Дополнительно элемент структуры может быть полем битового  ти-
па, недопустимым больше нигде. Тип структур Borland C++ позво-
ляет Вам обрабатывать сложные структуры данных  почти  так  же
легко, как отдельные переменные.
     В С++ тип структура интерпретируется как тип класс (с не-
которыми  отличиями:  по умолчанию доступ общий и по умолчанию
для базового класса так же общий).  Это  позволяет  установить
более  сложный  контроль  над  доступом к элементам структуры,
используя указатели доступа С++:  public (общий) - по  умолча-
нию, private (личный) и protected (защищенный). За исключением
этого механизма доступа следующее обсуждение синтаксиса и пра-
вила использования структур одинаковы для С и С++.
     Структуры объявляются с  использованием  ключевого  слова
struct. Например
     struct mystruct  { ... };    // имя типа структуры
     ...
     struct mystruct s, *ps, arrs[10]; // s - структура;
                                // ps - указатель на структуру
                                // arrs - массив структур

             Нетипированные структуры и typedef.

     Если Вы пропускаете имя типа структуры, Вы получите нети-
пированную  структуру.  Вы  можете использовать нетипированные
структуры для объявления идентификаторов данного типа структу-
ры,  но  не  можете объявить дополнительные объекты этого типа
где-либо еще.
     struct { ... } s, *ps, arrs[10];
     Возможно создать typedef во время объявления структуры  с
именем типа структуры или без него:
     typedef staruct mystruct  { ... } MYSTRUCT;
     MYSTRUCT s, *ps, arrs[10];
     typedef struct  { ... } YRSTRUCT;
     YRSTRUCT y, *yp, arry[20];
     Обычно не требуется использовать имя типа и  typedef  од-
новременно: любой может быть использован в объявлении структу-
ры.
     Примечание. Нетипированная структура и элементы объедине-
ния игнорируются во время инициализации.

               Объявление элементов структуры.

     Список элементов  структуры  внутри  {}  объявляет типы и
имена элементов структуры,  используя синтаксис, приведенный в
таблице 1.11.
     Элемент структуры может быть любого типа с двумя исключе-
ниями:
     1. Тип элемента не может быть тот же, что и тип объявляе-
мой структуры:
     struct mystruct  { mystruct } s1, s2;  // неверно
     Примечание: В  С++  Вы  можете  опустить  ключевое  слово
struct.
     Элемент может быть указателем на объявляемую структуру:
     struct mystruct  { mystruct *ps } s1, s2;
     Так же структура может содержать предварительно объявлен-
ные типы структур при объявлении экземпляра объявленной струк-
туры.
     2. Исключение в С++: элемент не может иметь тип "функция,
возвращающая...",  но тип "указатель  на  функцию,  возвращаю-
щую..." разрешен. В С++ struct может иметь элементы-функции.

                     Структуры и функции.

     Функции могут  возвращать  тип структура или указатель на
тип структура:
     mystruct func1(void);   // возвращает структуру
     mystruct *func2(void);//возвращает указатель на структуру
     Структура может быть передана как аргумент в функцию сле-
дующими способами:
     void func1(mystruct s);     // прямо
     void func2(mystruct *sptr); // через указатель
     void func3(mystruct &sref); // как ссылка (только С++)

                 Доступ к элементу структуры.

     Доступ к  элементам структуры производится с помощью опе-
раторов "." и "->".  Предположим, что объект s - это структура
типа S,  а sptr - это указатель на S. Если m - это идентифика-
тор элемента типа M,  объявленный в  S,  то  выражения  s.m  и
sptr->m оба типа M и представляют элемент m в объекте s. Выра-
жение s->sptr - это удобный синоним для (*sptr).m.
     Оператор "." называется прямым селектором элемента.  Опе-
ратор -> называется косвенным (или указателем) селектором эле-
мента; например
     struct mystruct {
       int i;
       char str[21];
       double d;
     } s, *sptr=&s;
     ...
     s.i = 3;           // присваивает в i элемент структуры s
     sptr->d = 1.23;    // присваивает в i элемент структуры s
     Выражение s.m - это lvalue при условии, что s - не lvalue
и m не массив. Выражение sptr->m - это lvalue, если только m -
не массив.
     Если структура  B содержит поле типа структура А,  к эле-
ментам А можно обратиться с помощью двух селекторов элемента:
     struct A {
       int j;
       double x;
     };

     struct B {
       int i;
       struct A a;
       double d;
     } s, *sptr;
     ...
     s.i = 3;           // присваивает в i элемент B
     s.a.j = 2          // присваивает в j элемент A
     sptr->d = 1.23;    // присваивает в d элемент B
     (sptr->a).x = 3.14 // присваивает в x элемент A
     Каждое объявление структуры вводит уникальный тип  струк-
туры, так что в
     struct A {
       int i, j;
       double d;
     }; a, al;

     struct B {
       int i, j;
       double d;
     } b;
     объекты а и а1 - оба типа А, но объекты а и b - различных
структурных типов.  Структуры могут присваиваться только  если
источник и назначение имеют один тип:
     a = al;         // верно, один тип
     a = b;          // неверно, разные типы
     a.i = b.i; a.j = b.j; a.d = b.d // но Вы можете присвоить
                                     // элемент за элементом

                   Выравнивание структуры.

     Память распределяется под элементы структуры слева напра-
во, начиная с младших адресов к старшим. В примере
     struct mystruct {
       int i;
       char str[21];

       double d;
     } s;
     объект s занимает память под 2-байтовое целое,  21 - бай-
товую строку и 8-байтовый double. Формат этого объекта в памя-
ти  определяется  опцией  Borland  C++ выравнивания на границу
слова. Когда эта опция выключена (по умолчанию), под s распре-
деляется 31 последовательный байт.  Если Вы включите эту опцию
с  помощью  опции  компилятора  -а   (или   диалогового   окна
Options/Compiler/Code Generation) Borland C++ дополняет струк-
туру байтами так, чтобы структура была выровнена следующим об-
разом:
     1. Структура начиналась на границе слова (четный адрес).
     2. Любой  не-char  элемент имел четное смещение от начала
структуры.
     3. Добавляется последний байт (если необходимо) для того,
чтобы структура содержала четное число байт.
     Таким образом при включенном выравнивании на границу сло-
ва структура будет занимать  32  байта  вследствии  добавления
байта перед double.

                Пространство имени структуры.

     Имена структур разделяют то же пространство имен, что и в
объединениях и в перечислимых типах  (но  в  С++  enum  внутри
структуры имеют другое пространство имени).  Это означает, что
имена должны быть уникальными внутри одной сферы действия. Од-
нако  имена  не обязаны отличаться от имен меток,  элементов и
одиночных имен (которые состоят из переменных,  функций,  имен
typedef  и  значений перечислимых типов) в том же пространстве
имени.
     Имена элементов  внутри  данной структуры или объединения
должны быть уникальными,  но они могут использоваться в других
структурах или объединениях. Например
     goto s;
     ...
     s;
     struct s {   // верно, имя типа и метки имеют разные
                  // пространства
       int s;     // верно, имя типа, метки и элемента имеют
                  //разные пространства
       float s;   // неверно, дублирование имени элементов
     } s;         // верно, имя переменной имеет другое
                  // пространство. В Си++ это возможно только,
                  // если s не имеет констрактора

     union s {    // неверно, дублирование типов.
       int s;     // верно, элемент в новом пространстве
       float f;
     } f;         // верно, пространство имени переменной

     struct t {
       int s;     // верно, другое пространство элемента
       ...
     } s;         // неверно, дублирование имени переменной

                     Неполное объявление.

     Указатель на тип структуры А может появляться в  объявле-
нии другой структуры В до объявления структуры А:
     struct A;                 // неполное
     struct B { struct A *pa }
     struct A { struct B *pb }
     Первое появление  А  называется неполным потому,  что она
неопределена в этой точке.  Неполное  объявление  разрешено  в
этом случае, поскольку определение В не требует размера А.

                        Битовые поля.

     Вы можете объявить элементы signed или unsigned целые как
битовые поля с длиной от 1 до 16 бит.  Вы указываете длину би-
тового поля и необязательный идентификатор:
     указатель-типа <идентификатор-битового-поля>:длина;
     где указатель-типа  может быть char,  unsigned char,  int
или unsigned int.  Битовые поля распределяются  от  младших  к
старшим  битам  внутри  слова.  Выражение  "длина"  должно вы-
числяться в целую константу в диапазоне от 0 до 15.
     Примечание: Структура может содержать любую смесь битовых
и небитовых полей.
     Если идентификатор  битового  поля  пропущен,  число бит,
указанных в "длине" распределяется,  но к  полю  нельзя  обра-
титься. Это позволяет Вам определить шаблон бит, скажем, в ре-
гистрах аппаратного обеспечения, где некоторые биты не исполь-
зуются. Например
     struct mystruct {
       int      i : 2;
       unsigned j : 5;
       int        : 4;
       int      k : 1;
       unsigned m : 4;
     } a, b, c;
     Выполняет следующее распределение:
  ┌──┬──┬──┬──┬──┬──┬──┬──┬────┬──┬──┬──┬──┬──┬──┬──┐
  │15│14│13│12│11│10│ 9│ 8│ 7  │ 6│ 5│ 4│ 3│ 2│ 1│ 0│
  ├──┼──┼──┼──┼──┼──┼──┼──┼────┼──┼──┼──┼──┼──┼──┼──┤
  │ x│ x│ x│ x│ x│ x│ x│ x│ x  │ x│ x│ x│ x│ x│ x│ x│
  ├──┴──┴──┴──┼──┼──┴──┴──┴────┼──┴──┴──┴──┴──┼──┴──┤
  │<─────────>│<>│< ─ ─ ─ ─ ─ >│<────────────>│<───>│
  ├───────────┼──┼─────────────┼──────────────┼─────┤
  │     m     │ k│    не       │      j       │  i  │
  │           │  │используется │              │     │
  └───────────┴──┴─────────────┴──────────────┴─────┘
     Целые поля хранятся в дополнительном коде,  с самым левым
битом,  являющимся MSB (старшим битом).  С битовыми полями int
(signed,  например) MSB интерпретируется как знаковый бит. Би-
товое поле ширины 2, хранящее двоичное число 11, следовательно
будет интерпретироваться как 3, если unsigned, и -1, если int.
В  предыдущем  примере правильное присваивание а.i = 6 оставит
двоичное число 10 = -2 в a.i без сообщения об ошибке. Знаковое
int поле k ширины 1 может хранить только два значения: -1 и 0,
поскольку битовый образец 1 интерпретируется как -1.
     Примечание: Битовые  поля  могут  быть объявлены только в
структурах,  объединениях и классах.  К ним можно обратиться с
помощью тех же селекторов элементов (.  и ->), что и для неби-
товых полей.  Кроме того, битовые поля могут приводить к неко-
торым проблемам при написании переносимого кода, поскольку ор-
ганизация бит внутри байта и байт внутри слова зависит от  ма-
шины.
     Выражение &mystruct.x неверно, если х - идентификатор би-
тового поля,  поскольку нет гарантии,  что mystruct.x лежит на
байтовом адресе.

                         Объединения.

     Тип объединение во многом аналогичен  типу  структуры  по
синтаксическим и функциональным возможностям. Главное различие
в том,  что в каждый момент времени только один  из  элементов
объединения  "активен".  Размер  объединения  - это размер его
максимального элемента.  В каждый момент  времени  может  быть
сохранен  только  один  из элементов объединения.  В следующем
примере
     union myunion {     // имя типа myunion
       int i;
       double d;
       char ch;
     } mu, *muptr=&mu;
     идентификатор mu типа union myunion может быть  использо-
ван  для  хранения  2-байтового int или 8-байтового double или
однобайтового char, но только одного из них в один момент вре-
мени.
     Примечание: Объединения соответствуют типу запись с вари-
антами в Паскале и Модуле-2.
     sizeof(union myunion) и sizeof(mu) возвращают 8,  хотя  6
байт  не используются когда mu содержит объект int и 7 байт не
используются, когда mu хранит char. Вы обращаетесь к элементам
объединения с помощью селекторов объединения (.  и ->), но не-
обходимо соблюдать осторожность.
     mu.d = 4.016;
     printf("mu.d = %f\n", mu.d);   // выводит mu.d = 4.016
     printf("mu.i = %d\n", mu.i);   // выводит mu.i = 4.016
     mu.ch = 'A';
     printf("mu.ch = %c\n", mu.ch); // выводит mu.ch = A
     printf("mu.d = %f\n", mu.d);   // выводит mu.d = A
     muptr->i = 3;
     printf("mu.i = %d\n", mu.i);   // выводит mu.i = 3
     Второй printf верен,  поскольку mu.i целого типа.  Однако
битовый шаблон в mu.i соответствует части double предваритель-
но  сохраненному и не может быть правильно интерпретирован как
integer.
     При правильном  преобразовании  указатель  на объединение
указывает на каждый из его элементов и наоборот.

                   Объявление объединения.

     Синтаксис объявления  объединений  аналогичен  объявлению
структур. Существуют различия:
     1. Объединения могут содержать битовые  поля,  но  только
одно может быть активным. Эти поля начинаются с начала объеди-
нения (и помните, что, поскольку битовые поля зависят от маши-
ны, при написании переносимого кода могут возникнуть несколько
проблем).
     2. В отличие от структур С++,  объединение в С++ не может
использовать  указатели  доступа  класса:  public,  private  и
protected. Все поля объединения - типа public.
     3. Объединения могут быть инициализированы  только  через
их первый элемент:
     union local87 {
       int i;
       double d;
     } a = { 20 };
     4. Объединения не могут участвовать в  иерархии  классов.
Они не могут быть произведены из любого класса и не могут быть
базовым классом. Объединение может иметь констрактор.
     5. Анонимные  объединения не могут иметь элементы-функции
(С++).

                        Перечисления.

     Тип данных перечисление используется  для  предоставления
мнемонических идентификаторов для набора целых значений.  Нап-
ример следующее объявление
     enum days  { sun, mon, tues, wed, thur, fri, sat } anyday;
     создает целый тип enum days, переменную anyday этого типа
и набор перечислимых значений ( sun,  mon, ...) с константными
целыми значениями.
     Borland C++  сохраняет  перечисления в одном байте,  если
позволяет диапазон значений,  когда флаг -b выключен (по умол-
чанию включен, что означает, что enum хранится в int), но зна-
чение всегда представляется как int,  когда используется в вы-
ражениях.  Идентификаторы, используемые в списке перечисляемых
значений,  имеют неявный тип unsigned char или int  в  зависи-
мости  от перечислимых значений.  Если все значения могут быть
представлены в unsigned char, то это тип каждого перечислимого
значения.
     В Си переменной перечислимого типа может  быть  присвоено
любое  значение  типа  int - проверка типа не производится.  В
Си++ переменной перечислимого типа может быть присвоено только
одно из ее перечислимых значений. Например
     anyday = mon;  // верно
     anyday = l;    // неверно
     Идентификатор days  может  использоваться  в  последующих
объявлениях перечислимых переменных типа enum days:
     enum days payday, holiday;
     Примечание: В  С++  Вы  можете  пропустить ключевое слово
enum, если days уникально в данной сфере действия.
     Как и  в  объявлениях struct и union Вы можете пропустить
имя типа,  если переменные этого типа в дальнейшем не потребу-
ются:
     enum  { sun, mon, tues, wed, thur, fri, sat } anyday;
     Список перечислимых  значений  внутри {} так же известен,
как перечислимые константы. Каждой назначается целое значение.
При отсутствии явных инициализаторов первая константа устанав-
ливается в 0, вторая в 1 и т.д.
     Когда используются явные инициализаторы,  Вы можете уста-
новить одному или более перечислимому значению требуемое  зна-
чение.  Последующие  имена  без инициализаторов будут увеличи-
ваться на 1. Например
     // Выражения инициализации могут включать предварительно
     // объявленные перечисления
  enum coins { penny = 1, tuppence, nickel = penny + 4, dime =
       10, quarter = nickel * nickel } smallchange;
     tuppence = 2, nickel = 5 и quarter = 25.
     Инициализатор может быть любым выражением,  вычисляющимся
в целое положительное или отрицательное значение. Эти значения
обычно уникальны, но могут дублироваться.
     enum может появляться везде, где разрешен тип int.
     enum days { sun, mon, tues, wed, thur, fri, sat } anyday;
     enum days payday;
     typedef enum days DAYS;
     DAYS *daysptr;
     int i = tues;
     anyday = mon;       // верно
     *daysptr = anyday;  // верно
     mon = tues;         // неверно, mоn - константа
     Имена перечислимого типа  разделяют  то  же  пространство
имени,  что и имена типов структур и объединений. Перечислимые
значения разделяют то же  пространство  имен,  что  и  обычные
идентификаторы:
     int mon = 11;
     {
     enum days { sun, mon, tues, wed, thur, fri, sat } anyday;
         // mon скрывает объявление int mon
       struct days { int i, j;}; // неверно, дублирование days
       double sat;   // неверно, переопределение sat
     }
     mon = 12;
     В С++ перечисления,  объявленные внутри класса используют
ту же сферу действия, что и этот класс.

                          Выражения.

     Выражение - это последовательность операторов,  операндов
и разделителей.  Формальный синтаксис,  приведенный в  таблице
2.2 показывает,  что выражения определены рекурсивно: подвыра-
жения могут быть вложены без формальных  ограничений.  (Однако
компилятор  будет  выдавать  ошибку  выхода за пределы памяти,
если он не может откомпилировать слишком сложное выражение).
     Примечание. Таблица 2.2 показывает,  как идентификаторы и
операторы комбинируются в форме грамматически верных "фраз".
     Выражения вычисляются в соответствии с определенными пра-
вилами преобразований,  группировки,  ассоциативности и  стар-
шинства,  зависящими  от используемых операторов,  присутствия
скобок и типов данных операндов.  Метод,  с  помощью  которого
группируются  операнды  и подвыражения,  не обязательно задает
фактический порядок, которым они вычисляются Borland C++.
     Выражения могут  создавать  lvalue,  rvalue  и не задавть
значений вообще. Выражения могут привести к побочным эффектам,
в зависимости от того, создают они значение или нет.
     Грамматика в таблице 2.2 полностью определяет старшинство
и ассоциативность операторов. Это информация собрана в таблице
2.3. существуют 16 категорий старшинства, некоторые из которых
содержат только один оператор. Операторы одной категории имеют
равный приоритет. Если в таблице встречаются повторения опера-
торов, то первое вхождение первично, а второе вторично. Каждая
категория имеет правила  ассоциативности:  слева  направо  или
справа налево. При отсутствии круглых скобок эти правила реша-
ют группировку выражений с операторами равного приоритета.

              Таблица 2.2 Выражения Borland C++.
─────────────────────────────────────────────────────────────
  первичное-выражение:
    литерал
    псевдопеременная
    (выражение)
    this (С++)
    ::идентификатор (С++)
    ::имя-функции-оператора (С++)
    имя

  литерал:
    целая-константа
    символьная-константа
    константа-с-плавающей-точкой
    строка

  имя:
    идентификатор
    имя-функции-оператора (C++)
    имя-функции-преобразования (C++)
    квалифицированное-имя (C++)

  квалифицированное-имя: (C++)
    имя-класса::идентификатор
    имя-класса::имя-функции-оператора
    имя-класса::имя-функции-преобразования
    имя-класса::имя-класса
    имя-класса::~имя-класса

  постфиксное-выражение:
    первичное-выражение
    постфиксное-выражение [выражение]
    постфиксное-выражение(<список-выражения>)
    имя-простого-типа(<список-выражения>) (C++)
    постфиксное-выражение . имя
    постфиксное-выражение -> имя
    постфиксное-выражение ++
    постфиксное-выражение --

  список-выражения:
    выражение-присваивания
    список-выражения , выражение-присваивания

  унарное-выражение:
    постфиксное-выражение
    ++унарное-выражение
    --унарное-выражение
    унарный-оператор выражение-приведения-типа
    sizeof унарное-выражение
    sizeof(имя-типа)
    выражение-распределения (C++)
    выражение-освобождения (C++)

  унарный-оператор: один из
    & * + - ~ !

  выражение-распределения: (C++)
    <::>new<размещение> ограниченное-имя-типа<инициализатор>
    <::>new<размещение> (имя-типа)<инициализатор>

  размещение: (C++)
    (список-выражения)

  ограниченное-имя-типа: (C++)
    указатель-типа<ограниченный-элемент-объявления>

  ограниченный-элемент-объявления: (C++)
    ptr-оператор<ограниченный-элемент-объявления>
    ограниченный-элемент-объявления[<выражение>]

  выражение-освобождения: (C++)
    <::>delete выражение-приведения-типа
    <::>delete [выражение]выражение-приведения-типа

  выражение-приведения-типа:
    унарное-выражение
    (имя-типа)выражение-приведения-типа

  pm-выражение:
    выражение-приведения-типа
    pm-выражение .* выражение-приведения-типа (C++)
    pm-выражение ->* выражение-приведения-типа (C++)

  мультипликативное-выражение:
    pm-выражение
    мультипликативное-выражение * pm-выражение
    мультипликативное-выражение / pm-выражение
    мультипликативное-выражение % pm-выражение

  аддитивное-выражение:
    мультипликативное-выражение
    аддитивное-выражение + мультипликативное-выражение
    аддитивное-выражение - мультипликативное-выражение

  выражение-сдвига:
    аддитивное-выражение
    выражение-сдвига << аддитивное-выражение
    выражение-сдвига >> аддитивное-выражение

  выражение-отношения:
    выражение-сдвига
    выражение-отношения < выражение-сдвига
    выражение-отношения <= выражение-сдвига
    выражение-отношения > выражение-сдвига
    выражение-отношения >= выражение-сдвига

  выражение-равенства:
    условное-выражение
    выражение-равенства == условное-выражение
    выражение-равенства != условное-выражение

  АND-выражение:
    выражение-равенства
    АND-выражение & выражение-равенства

  исключающее-OR-выражение:
    AND-выражение
    исключающее-OR-выражение ^ AND-выражение

  OR-выражение:
    исключающее-OR-выражение
    OR-выражение | исключающее-OR-выражение

  логическое-AND-выражение:
    OR-выражение
    логическое-AND-выражение && OR-выражение

  логическое-OR-выражение:
    логическое-AND-выражение
    логическое-OR-выражение || логическое-AND-выражение

  условное-выражение:
    логическое-OR-выражение
    логическое-OR-выражение ? выражение : условное-выражение

  выражение-присваивания:
    условное-выражение
    унарное-выражение оператор-присваивания выражение-
      присваивания

  оператор-присваивания: один из
    =   *=   /=  %=  +=  -=
    <<=  >>=  &=  ^=  !=

  выражение:
    выражение-присваивания
    выражение , выражение-присваивания

  константное-выражение:
    условное-выражение
─────────────────────────────────────────────────────────────

     Таблица 2.3. Ассоциативность и приоритет операторов
                         Borland C++.
─────────────────────────────────────────────────────────────
 операторы                                   ассоциативность
─────────────────────────────────────────────────────────────
 () [] -> :: .                                  слева направо
 ! ~ + _ ++ -- & * (приведение типа) sizeof
   new delete                                   справа налево
 .* ->*                                         слева направо
 * / %                                          слева направо
 + -                                            слева направо
 << >>                                          слева направо
 < <= > >=                                      слева направо
 == !=                                          слева направо
 &                                              слева направо
 ^                                              слева направо
 |                                              слева направо
 &&                                             слева направо
 ||                                             слева направо
 ?:(условное выражение)                         справа налево
 = *= /= %= += -= &= ^= |= <<= >>=              справа налево
 ,                                              слева направо
─────────────────────────────────────────────────────────────
     Примечание. Приоритет каждой категории указывается поряд-
ком следования в этой таблице.  Первая категория (первая стро-
ка) имеет наивысший приоритет.

                       Выражения и C++.

     C++ позволяет перегрузить некоторые стандартные операторы
Си.   Перегрузка  определяет  новое  поведение  оператора  при
использовании классов в выражении.  Например, оператор отноше-
ния  == может быть определен в классе complex для проверки ра-
венства двух комплексных чисел без изменения  его  нормального
использования с другими типами данных. Перегруженные операторы
реализованы  как  функции;  функции  определяют  тип  операнда
lvalue и порядок вычисления,  которые используются при исполь-
зовании перегруженного оператора.  Однако перегрузка не  может
изменить приоритет оператора. Аналогично C++ позволяет пользо-
вателю определить преобразования между объектами типа  классов
и  основными типами.  Однако запомните,  что некоторые правила
для операторов и преобразований, описанные в этом разделе, мо-
гут быть неприменимы к выражениям C++.

                     Порядок вычисления.

     Порядок, в  котором  C++  вычисляет  операнды выражения -
обычный за исключением случаев,  где оператор специально уста-
новлен  по-другому.  Компилятор  будет пытаться реорганизовать
выражение для того,  чтобы улучшить качество генерируемого ко-
да.  Требуется осторожность с выражениями,  в которых значение
модифицируется более одного раза. В общем случае избегайте на-
писания выражений,  которые модифицируют и используют значение
одного объекта. Рассмотрим выражение:
     i = v[i++];   // i не определено
     Значение i зависит от того,  будет  i  увеличена  до  или
после присваивания. Аналогично
     int total = 0;
     sum = (total = 3) + (++total);  // sum = 4 или 7 ?
двусмысленно для sum и total.  Решение состоит в разбиении вы-
ражения с использованием временной переменной:
     int temp, total = 0;
     temp = ++total;
     sum = (total = 3) + temp;
     Там, где  синтаксис  позволяет  вычислять  последователь-
ность, можно использовать многократное вычисление:
     sum = (i = 3, i++, i++);   // sum = 4, i = 5
     Каждое подвыражение вычисляется слева направо,  а все вы-
ражение вычисляется в самое правое выражение.
     Borland C++ перегруппирует выражения, реорганизуя ассоци-
ативные  и  коммутативные операторы независимо от круглых ско-
бок,  для того, чтобы создать эффективно откомпилированное вы-
ражение. Реорганизация не воздействует на значение выражения.
     Вы можете использовать () для  установления  порядка  вы-
числения выражения. Например, если у Вас есть переменные a, b,
c,  f,  то в выражение f = a+(b+c),  b+c будет вычисляться  до
сложения с а.

                    Ошибки и переполнение.

     Во время  вычисления  выражения Borland C++ может обнару-
жить проблематичные ситуации такие, как деление на 0 или выход
за  диапазон  значения с плавающей точкой.  Переполнение целых
игнорируются,  но ошибки, обнаруженные математическими библио-
течными  функциями могут обрабатываться стандартными или поль-
зовательскими программами. См. matherr и signal в "Справочнике
по библиотеке".

                    Семантика операторов.

     Если операторы не были перегружены,  следующая информация
справедлива для С и C++.  В C++ Вы можете  перекрыть  все  эти
операторы,  кроме  "."  и  "?:" (Вы так же не можете перекрыть
операторы C++ "::" и ".*").
     Примечание: Операторы,  описанные здесь - это стандартные
операторы ANSI C.
   Таблица 2.2  описывает  синтаксис всех операторов и выраже-
ний.

             Постфиксные и префиксные операторы.

     6 постфиксных операторов [] () .  -> ++  --  используются
для  построения  постфиксных  выражений как показано в таблице
2.2 синтаксиса выражений.  Операторы увеличения  и  уменьшения
(++ --) используются так же, как префиксные и унарные операто-
ры.

                 Оператор индексации массива.

     В выражении
     постфиксное-выражение[выражение]
постфиксное-выражение должно быть типа массив; выражение долж-
но вычисляться в индекс элемента массива. Значение выражения -
это значение выбранного элемента;  оно будет  lvalue,  если  и
только если постфиксное-выражение - lvalue.
     В С,  но не обязательно в С++, выражение exp1[exp2] опре-
деляется как
     * ((exp1) + (exp2))
где или  exp1 является указателем,  а exp2 - целое число,  или
exp1 - целое,  а exp2 указатель.  (Знаки пунктуации [], *, и +
могут быть перезагружены в С++).

                   Оператор вызова функции.

     Выражение
     постфиксное-выражение (<список-аргументов>)
     вызывает функцию,    заданную   постфиксным   выражением.
Список-аргументов - это разделенный запятыми список  выражений
любого типа,  представляющий действительные аргументы функции.
Значение выражения вызова  функции,  если  есть,  определяется
оператором возврата в определение функции.

           Оператор элемента структуры/объединения.

     В выражении
     постфиксное-выражение.идентификатор
     постфиксное-выражение должно быть типа структура или объ-
единение;  идентификатор  должен  быть  именем  элемента  этой
структуры  или объединения.  Значение выражения - это значение
выбранного элемента;  оно будет lvalue,  если  и  только  если
постфиксное-выражение - lvalue.

         Оператор указателя на структуру/объединение.

     В выражении
     постфиксное-выражение->идентификатор
     постфиксное-выражение должно   быть   типа  указателя  на
структуру или объединение;  идентификатор должен  быть  именем
элемента этой структуры или объединения.  Значение выражения -
это значение выбранного элемента;  оно будет  lvalue,  если  и
только если постфиксное-выражение - lvalue.

                 Оператор постфиксного увеличения.

     В выражении
     постфиксное-выражение++
     постфиксное-выражение - это операнд; оно должно быть ска-
лярного типа (арифметический тип или указатель) и должно  быть
модифицируемым lvalue. Постфикс ++ так же известен, как опера-
тор постфиксного увеличения.  Значение всего выражения  -  это
значение постфиксного выражения ДО увеличения.  После вычисле-
ния постфиксного выражения операнд увеличивается на 1.
     Увеличение значения  соответствует типу операнда.  Указа-
тель изменяется соответственно правилам арифметики указателей.

              Оператор постфиксного уменьшения.

     Постфиксное уменьшение следует тем  же  правилам,  что  и
постфиксное увеличение,  за исключением того,  что из операнда
вычитается 1 ПОСЛЕ вычисления.

              Операторы увеличения и уменьшения.

     Первые 2 унарных оператора - это ++  и  --.  Они  так  же
постфиксные  и префиксные операторы.  Описание остальных шести
унарных операторов следует ниже.

               Оператор префиксного увеличения.

     В выражении
     ++унарное-выражение
     унарное-выражение - это операнд;  оно должно быть скаляр-
ного типа и должно быть модифицируемым lvalue.  Операнд увели-
чивается на 1 ДО вычисления выражения;  значение всего выраже-
ния - это увеличенное значение операнда.  1,  используемая для
увеличения, имеет соответствующее значение для этого типа опе-
ранда. Указатели используют правила арифметики указателей.

               Оператор префиксного уменьшения.

     Оператор префиксного уменьшения имеет синтаксис:
     --унарное-выражение
     оно следует правилам оператора префиксного увеличения, за
исключением того,  что операнд уменьшается на 1 до  вычисления
всего выражения.

                      Унарные операторы.

     Существует 6 унарных операторов (кроме ++ и --):  & * + -
~ !. Синтаксис:
     унарный-оператор выражение-приведения-типа

     выражение-приведения-типа:
       унарное-выражение
       (имя-типа)выражение-приведения-типа

                      Адресный оператор.

     Оператор &  и  оператор  *  работают вместе как операторы
ссылки и адресации. В выражении
     &выражение-приведения-типа
     выражение должно быть либо назначением функции, либо объ-
ектом lvalue,  который не является битовым полем и не объявлен
с указателем класса памяти register.  Если операнд типа  type,
то результат типа указатель на type.
     Примечание. Символ & также используется в С++ для задания
ссылочных типов.
     Заметим, что некоторые не  lvalue  идентификаторы,  такие
как имена функций и имена массивов автоматически преобразуются
в тип "указатель на Х",  когда появляются в определенном  кон-
тексте.  Оператор & может быть использован с такими объектами,
но такое использование лишнее и поэтому отвергается.
     Рассмотрим пример:
     type t1 = 1, t2 = 2;
     type *ptr = &t1;      // инициализированный указатель
     *ptr = t2;            // аналогично t1 = t2
     Заметим, что type *ptr = &t1 интерпретируется как
     T *ptr;
     ptr = &ti;
     так, что ptr,  а не *ptr будет присваиваться. После того,
как  ptr  будет инициализирован адресом &t1,  через него можно
ссылаться для получения lvalue *ptr.

                         Оператор *.

     В выражении
     *выражение-приведения-типа
     выражение должно быть типа "указатель-на-type",  где type
- любой тип. Результат ссылки - это тип type. Если операнд ти-
па "указатель на функцию",  результатом  будет  функция;  если
операнд  -  указатель на объект,  результатом будет lvalue.  В
следующих ситуациях результат будет неопределен:
     1. Выражение - это null указатель.
     2. Выражение - это адрес автоматической переменной и  вы-
полнение ее блока завершено.

                     Оператор унарный +.

     В выражении
     +выражение-приведения-типа
     выражение должно быть арифметического типа.

                     Оператор унарный -.

     В выражении
     -выражение-приведения-типа
     выражение должно быть арифметического типа.

                Оператор побитового отрицания.

     В выражении
     ~выражение-приведения-типа
     выражение должно быть целого типа.  Результат - побитовое
дополнение операнда. Каждый 0 бит устанавливается в 1 и каждый
1 бит устанавливается в 0.

               Оператор логического отрицания.

     В выражении
     !выражение-приведения-типа
     выражение должно  быть  скалярного типа.  Результат будет
типа int и логическим отрицанием операнда:  0, если операнд не
0; 1, если операнд 0. Выражение !Е эквивалентно (0==Е).

                       Оператор sizeof.

     Существует 2 использования оператора sizeof:
     sizeof унарное-выражение
     sizeof(имя-типа)
     В обоих случаях результат - это целая  константа,  дающая
размер памяти, занимаемой операндом в байтах (в зависимости от
типа,  с некоторыми исключениями). В первом случае тип выраже-
ния определяется без вычисления выражения (и следовательно без
сторонних эффектов).  Когда  операнд  типа  char  (signed  или
unsigned) sizeof дает результат 1.  Если операнд - не параметр
типа массив,  результат - это число байт  в  массиве  (другими
словами  имя массива не преобразуется в тип указателя).  Число
элементов в массиве равно sizeof array/sizeof array[0].
     Примечание: Размер каждого типа зависит от машины.
     Если операнд - это параметр,  объявленный как массив  или
функция,  sizeof  дает размер указателя.  При использовании со
структурами или объединениями sizeof дает  общее  число  байт,
включая байты для выравнивания.
     sizeof не может быть использован с выражениями типа функ-
ций,  неполными  типами,  именами  таких типов в скобках или с
lvalue, которые назначены на битовое поле.
     Целый тип  результата  sizeof - это size_t,  определенный
как unsigned int в stddef.h.
     Вы можете  использовать sizeof в препроцессорных директи-
вах; это особенность Borland C++.
     В C++  sizeof(тип-класса),  где  тип-класса наследован от
некоторого базового класса,  возвращает размер этого  базового
класса.

                 Мультипликативные операторы.

     Существует 3 мультипликативных оператора:  * / и %.  Син-
таксис мультипликативное-выражение:
       pm-выражение
       мультипликативное-выражение * pm-выражение
       мультипликативное-выражение / pm-выражение
       мультипликативное-выражение % pm-выражение
     Операнды для  *  (умножение)  и  /  (деление) должны быть
арифметического типа.  Операнд для % (остаток) должен быть це-
лого  типа.  Для  операндов выполняются обычные арифметические
преобразования.
     Результат (op1*op2)  -  это  произведение двух операндов.
Результат (op1/op2) и (op1%op2) это частное  и  остаток  соот-
ветственно, где op1 делится на op2 и op2 не равно 0. Использо-
вание / или %  со вторым операндом, равным 0, приводит к ошиб-
ке.
     Когда op1 и op2 целые и частное не целое,  результат сле-
дующий:
     1. Если op1 и op2 имеют одинаковый знак, то op1/op2 будет
наибольшее целое меньшее,  чем точное частное, и op1%op2 имеет
знак op1.
     2. Если  op1  и op2 имеют разные знаки,  то op1/op2 будет
наименьшее целое большее,  чем точное частное, и op1%op2 имеет
знак op1.

                    Аддитивные операторы.

     Существует 2 аддитивных оператора + и -. Синтаксис
     аддитивное-выражение:
       мультипликативное-выражение
       аддитивное-выражение + мультипликативное-выражение
       аддитивное-выражение - мультипликативное-выражение

                      Оператор сложения.

     Для op1+op2 разрешены типы операндов:
     1. op1 и op2 - арифметического типа.
     2. op1 - целый тип, а op2 - указатель на тип.
     3. op2 - целый тип, а op1 - указатель на тип.
     В первом  случае  применяются  стандартные арифметические
преобразования и результат - арифметическая  сумма  операндов.
Во  втором  и  третьем  случае используются правила арифметики
указателей.

                     Оператор вычитания.

     Для op1-op2 разрешены типы операндов:
     1. op1 и op2 - арифметического типа.
     2. op1 и op2 - указатели на  совместимые  типы  объектов.
(Примечание:  Неквалифицированный тип type считается совмести-
мым с квалифицированным типом  const  type,  volatile  type  и
const volatile type).
     3. op2 - целый тип, а op1 - указатель на тип.
     В первом  случае  применяются  стандартные арифметические
преобразования и результат - арифметическая  разность  операн-
дов. Во втором и третьем случае используются правила арифмети-
ки указателей.

                 Операторы побитового сдвига.

     Существует 2 оператора побитового сдвига <<  и  >>.  Син-
таксис
     выражение-сдвига:
       аддитивное-выражение
       выражение-сдвига << аддитивное-выражение
       выражение-сдвига >> аддитивное-выражение

              Оператор побитового сдвига влево.

     В выражениях Е1<<E2 и Е1>>E2 операнды Е1 и Е2 должны быть
целого типа.  Тип результата - это тип Е1.  Если Е2 -  отрица-
тельный или больше или равно, чем длина Е2, операция неопреде-
лена.
     Результат Е1<<Е2 - это значение Е1, сдвинутое влево на Е2
бит с правыми битами,  заполненными нулями,  если  необходимо.
Сдвиг  влево  unsigned  long  E1  эквивалентно умножению Е1 на
2**Е2 ограниченное ULONG_MAX+1;  а сдвиг влево unsigned int E1
эквивалентно  умножению  Е1  на 2**Е2 ограниченное UINT_MAX+1.
Если Е1 -  знаковое  целое,  результат  может  быть  неверным,
поскольку знаковый бит может измениться.
     Результат Е1>>Е2 - это значение Е1,  сдвинутое вправо  на
Е2 бит с левыми битами,  заполненными нулями, если необходимо.
Если Е1 типа signed,  заполнение слева использует бит знака (0
- для положительного,  1 - для отрицательного Е1).  Расширение
знака гарантирует,  что знак E1>>E2 тот же самый,  что и у Е1.
За  исключением  знаковых  типов,  значение Е1>>Е2 - это целая
часть частного Е1/(2**Е2).

                     Оператор отношения.

     Существует 4 оператора отношения:  < > <=  >=.  Синтаксис
для этих операторов:

     выражение-отношения:
       выражение-сдвига
       выражение-отношения < выражение-сдвига
       выражение-отношения <= выражение-сдвига
       выражение-отношения > выражение-сдвига
       выражение-отношения >= выражение-сдвига

                    Оператор меньше, чем.

     В выражении Е1<Е2 операнды должны соответствовать  одному
из условий:
     1. Е1 и Е2 - арифметического типа.
     2. Е1  и Е2 - указатели на квалифицированные или неквали-
фицированные совместимые типы.
     3. Е1  и Е2 - указатели на квалифицированные или неквали-
фицированные совместимые неполные типы.
     В случае 1 производятся обычные арифметические преобразо-
вания.  Результат Е1<Е2 типа int. Если значение Е1 меньше, чем
значение Е2 - результат 1 (true); иначе результат 0 (false).
     В случае 2 и 3,  когда Е1 и Е2 - указатели на совместимые
типы, результат Е1<Е2 зависит от относительного положения (ад-
ресов)  указываемых  объектов.  Когда  сравниваются   элементы
структуры внутри одной структуры, элементы, объявленные позже,
имеют больший указатель. Внутри массива больший указатель свя-
зан с большим индексом элемента. Все указатели на элементы од-
ного объединения равны.
     Обычно сравнение   указателей   на  различные  структуры,
массивы или объединения, или сравнение указателей вне диапазо-
на массива дает неопределенный результат. Исключение составля-
ет указатель на элемент после конца массива.  Если Р указывает
на элемент массива и Q указывает на последний элемент, выраже-
ние P<Q+1 разрешено, вычисляясь в 1 (true) несмотря на то, что
Q+1 не указывает на элемент массива.

                    Оператор больше, чем.

     Выражение Е1>E2  дает 1 (true),  если значение Е1 больше,
чем значение Е2;  иначе результат 0 (false),  используя те  же
правила  для сравнения арифметических типов и указателей,  как
определено для оператора меньше,  чем. Используются те же пра-
вила операндов и ограничения.

                  Оператор меньше или равно.

     Выражение Е1<=E2 дает 1 (true),  если значение Е1 меньше,
чем или равно Е2;  иначе результат 0 (false),  используя те же
правила  для сравнения арифметических типов и указателей,  как
определено для оператора меньше,  чем. Используются те же пра-
вила операндов и ограничения.

                  Оператор больше или равно.

     Выражение Е1>=E2 дает 1 (true),  если значение Е1 больше,
чем или равно значению Е2;  иначе результат 0 (false), исполь-
зуя  те же правила для сравнения арифметических типов и указа-
телей,  как определено для оператора меньше, чем. Используются
те же правила операндов и ограничения.

                     Операторы равенства.

     Существует 2 оператора равенства:  == и !=. Они проверяют
равенство и неравенство между арифметическими  значениями  или
значениями  указателей,  используя правила,  подобные правилам
операторов отношения.  Заметим,  что операторы равенства имеют
меньший приоритет, чем операторы отношения. Кроме того, опера-
торы равенства можно использовать с некоторыми типами указате-
лей, для которых операторы отношения не разрешены.
     Синтаксис:

     выражение-равенства:
       условное-выражение
       выражение-равенства == условное-выражение
       выражение-равенства != условное-выражение

                         Оператор ==.

     В выражении Е1==Е2 операнды должны соответствовать одному
из условий:
     1. Е1 и Е2 - арифметического типа.
     2. Е1 и Е2 - указатели на квалифицированные или  неквали-
фицированные совместимые типы.
     3. Один из Е1 и Е2 - указатель  на  объект  или  неполный
тип,  а другой - указатель на квалифицированный или неквалифи-
цированный void.
     4. Один  из  Е1 или Е2 - указатель,  а другой - константа
типа указатель со значением null.
     Если Е1 и Е2 имеют типы, разрешенные для операторов отно-
шения, действуют те же правила сравнения, что и для операторов
отношения.
     В случае 1,  например, выполняются обычные арифметические
преобразования,  а результат Е1==Е2 имеет тип int. Если значе-
ние Е1 равно значению Е2,  то результатом будет 1; в противном
случае 0.
     В случае 2,  Е1==Е2 дает 1 (true), если Е1 и Е2 указывают
на один объект,  или оба указывают на "одно прошлое последнего
элемента" одного объекта массива, или оба являются указателями
null.
     Если Е1 и Е2 указывают на тип функция,  то Е1==Е2 дает  1
(true)  если  они  оба являются null или оба указывают на одну
функцию.
     Обратно, если Е1==Е2 дает 1 (true), если или Е1 и Е2 ука-
зывают на одну функцию, или они оба null.
     В случае  4,  указатель  на  объект или несовместимый тип
преобразуется в тип другого операнда (указатель на  квалифици-
рованный или неквалифицированный void).

                         Оператор !=.

     Выражения Е1!=Е2 используют те же правила, что и операто-
ры равенства,  за исключением того, что результат 1, если опе-
ранды неравны и 0, если операнды равны.

                   Побитовый оператор AND.

     Синтаксис:

     АND-выражение:
       выражение-равенства
       АND-выражение & выражение-равенства

     В выражении  Е1&Е2  оба операнда должны быть целого типа.
Над Е1 и Е2 проводятся обычные арифметические  преобразования,
а результат - побитовый AND Е1 и Е2. Каждый бит результата оп-
ределен как показано в таблице 2.4.

               Таблица 2.4. Побитовые операции.
──────────────────────────────────────────────────────────────
 значение бита  значение бита
    в Е1           в Е2        Е1 & E2   E1 ^ E2     E1 | E2
──────────────────────────────────────────────────────────────
     0              0             0         0           0
     1              0             0         1           1
     0              1             0         1           1
     1              1             1         0           1
──────────────────────────────────────────────────────────────

              Побитовый оператор исключающее OR.

     Синтаксис:

     исключающее-OR-выражение:
       AND-выражение
       исключающее-OR-выражение ^ AND-выражение

     В выражении  Е1^Е2  оба операнда должны быть целого типа.
Над Е1 и Е2 проводятся обычные арифметические  преобразования,
а результат - побитовое исключающее OR Е1 и Е2. Каждый бит ре-
зультата определен, как показано в таблице 2.4.

                    Побитовый оператор OR.

     Синтаксис:

     OR-выражение:
       исключающее-OR-выражение
       OR-выражение | исключающее-OR-выражение

     В выражении Е1|Е2 оба операнда должны быть  целого  типа.
Над  Е1 и Е2 проводятся обычные арифметические преобразования,
а результат - побитовое OR Е1 и Е2.  Каждый бит результата оп-
ределен, как показано в таблице 2.4.

                   Оператор логический AND.

     Синтаксис:

     логическое-AND-выражение:
       OR-выражение
       логическое-AND-выражение && OR-выражение

     В выражении  Е1&&Е2  оба  операнда должны быть скалярного
типа.  Тип результата int,  значение результата 1 (true), если
значения Е1 и Е2 оба не равны 0; иначе результат 0 (false).
     В отличие от побитового оператора &, оператор && гаранти-
рует вычисление слева направо.  Е1 вычисляется первым; если Е1
- 0, Е1&&Е2 дает 0 (false) и Е2 не вычисляется.

                   Оператор логический OR.

     Синтаксис:

     логическое-OR-выражение:
       логическое-AND-выражение
       логическое-OR-выражение || логическое-AND-выражение

     В выражении Е1||Е2 оба операнда  должны  быть  скалярного
типа.  Тип результата int,  значение результата 1 (true), если
любое из значений Е1 и  Е2  не  равно  0;  иначе  результат  0
(false).
     В отличие от побитового оператора |, оператор || гаранти-
рует вычисление слева направо.  Е1 вычисляется первым; если Е1
не 0, Е1||Е2 дает 1 (true) и Е2 не вычисляется.

                      Условный оператор.

     Синтаксис:

     условное-выражение:
      логическое-OR-выражение
      логическое-OR-выражение ? выражение : условное-выражение

     В выражении Е1 ? Е2 : Е3 операнд Е1 должен быть скалярно-
го  типа.  Операнды  Е2  и Е3 должны соответствовать одному из
правил:
     1. Оба арифметического типа.
     2. Оба совместимые типы структур или объединений.
     3. Оба типа void.
     4. Оба типа указатели на квалифицированные или неквалифи-
цированные совместимые типы.
     5. Один операнд типа указатель, а другой - константа null
типа указатель.
     6. Один операнд типа указатель  на  объект  или  неполный
тип,  а другой - указатель на квалифицированный или неквалифи-
цированный void.
     Первым вычисляется Е1;  если его значение не 0 (true), то
Е2 вычисляется,  а Е3 игнорируется.  Если Е1 вычисляется  в  0
(false),  то  Е3  вычисляется,  а  Е2 игнорируется.  Результат
Е1?Е2:Е3 будет значение, в которое вычисляется Е2 или Е3.
     В первом  случае над Е2 и Е3 производятся обычные арифме-
тические преобразования и тип результата - это  результирующий
тип этих преобразований.
     Во втором случае тип результата - это тип  структуры  или
объединения из Е2 или Е3.
     В третьем случае тип результата void.
     В четвертом и пятом случае тип результата - это указатель
на тип, определяемый типом указываемых операндов.
     В шестом случае тип результата - это указатель на void.

                   Операторы присваивания.

     Существует 11  операторов  присваивания.  Оператор  = это
простой  оператор  присваивания;  остальные  10  известны  как
составные операторы присваивания.
     Синтаксис:

     выражение-присваивания:
       условное-выражение
       унарное-выражение оператор-присваивания выражение-
         присваивания

     оператор-присваивания: один из
       =   *=   /=  %=  +=  -=
       <<=  >>=  &=  ^=  !=

                Простой оператор присваивания.

     В выражении  Е1=Е2  Е1 должно быть модифицируемым lvalue.
Значение Е2 после преобразования к типу Е1 сохраняется в  объ-
екте, указываемом Е1 (замещает предыдущее значение Е1). Значе-
ние выражения присваивания - это значение Е1 после  присваива-
ния. Само выражение присваивания не является lvalue.
     Примечание. В С++ результатом будет lvalue.
     Операнды Е1 и Е2 должны быть одними из следующих:
     1. Е1 квалифицированный или неквалифицированный арифмети-
ческий тип, а Е2 арифметический тип.
     2. Е1 -  квалифицированный  или  неквалифицированный  тип
структуры или объединения, совместимый с типом Е2.
     3. Е1 и Е2 - это указатели на квалифицированные или  нек-
валифицированные совместимые типы и тип,  на который указывает
Е1,  должен иметь все квалификаторы типа, на который указывает
Е2.
     4. Е1 или Е2 - это указатель на объект или неполный  тип,
а  другой  - указатель на квалифицированный или неквалифициро-
ванный void.  Тип,  на который указывает Е1,  должен иметь все
квалификаторы типа, на который указывает Е2.
     5. Е1 - это указатель,  а Е2 - константа null типа указа-
тель.

              Составные операторы присваивания.

     Составной оператор  присваивания  op=,  где op может быть
одним из операторных символов * / %  + - << >> & ^ | интерпре-
тируются:
     Е1 op= Е2
     как в случае
     Е1 = Е1 op Е2
     за исключением того, что lvalue Е1 вычисляется только од-
нажды. Например Е1 += Е2 аналогично Е1 = Е1 + Е2.
     Правила для  составных  присваиваний описаны в предыдущем
разделе ("Простой оператор присваивания").

                      Оператор запятая.

     Синтаксис:

     выражение:
       выражение-присваивания
       выражение , выражение-присваивания

     В выражении
     Е1,Е2
     левый операнд Е1 вычисляется как  void  выражение,  затем
вычисляется Е2, определяя результат и тип выражения с запятой.
Рекурсивно в выражении
     Е1,Е2,...,Еn
     вычисляется слева направо каждое Еi,  а значение и тип Еn
определяет  результат всего выражения.  Во избежание неопреде-
ленности с запятыми,  используемыми  в  аргументах  функции  и
списках инициализаций необходимо использовать (). Например
     func(i,(j=1,j+4),k);
     вызывает func с тремя аргументами: i, 5, k.

                        Операторы С++.

     Операторами, специфичными для С++ являются :: .* ->*.
     Синтаксис для .* и -> имеет следующий вид:
     pm-выражение
       выражение_преобразования_типов
       pm-выражение .* выражение_преобразования_типов
       pm-выражение ->* выражение_преобразования_типов
     Оператор .*  разыменовывает указатели на элементы класса.
Он присваивает выражение_преобразования_типов,  которое должно
иметь тип "указатель на элемент типа класс", pm-выражению, ко-
торое должно быть типа класс или класс,  явно произведенный из
типа класс. Результатом будет объект или функция, имеющая тип,
заданный с помощью выражение_преобразования_типов.
     Оператор ->*  разыменовывает  указатели  на  указатели на
элементы класса (нет,  это не опечатка; он действительно разы-
меновывает  указатель  на  указатель).  Он присваивает выраже-
ние_преобразования_типов,  которое должно иметь тип "указатель
на элемент тип",  pm-выражению, которое должно быть типа "ука-
затель на тип", или типа "указатель на класс, явно произведен-
ный  из  из типа".  Результатом будет объект или функция типа,
заданного с помощью выражение_преобразования_типов.
     Если результатом любого из этих операторов является функ-
ция,  то результат можно использовать только как  операнд  для
оператора вызова функции (). Например,
     (ptr2object->*ptr2memberfunc) (10);
вызывает элемент-функцию, обозначенную ptr2memberfunc для объ-
екта, обозначенного ptr2object.

                   Операторы (утверждения).

     Операторы определяют процесс  выполнения  программы.  При
отсутствии  переходов и операторов выбора,  операторы выполня-
ются последовательно в порядке появления в исходном коде. Сле-
дующая таблица определяет синтаксис операторов:

      Таблица 2.5. Операторы (утверждения) Borland C++.
─────────────────────────────────────────────────────────────
     оператор:
       помеченный-оператор
       составной-оператор
       оператор-выражения
       оператор-выбора
       оператор-итерации
       оператор-перехода
       оператор-asm
       объявление (C++)

     asm-оператор:
       asm лексемы новая-строка
       asm лексемы;
       asm {лексемы;<лексемы;>=
            <лексемы;>
           }

     помеченный-оператор:
       идентификатор : оператор
       case константное-выражение : оператор
       умолчание : оператор

     составной-оператор:
       {<список-объявления><список-операторов>}

     список-объявления:
       объявление
       список-объявления объявление

     список-операторов:
       оператор
       список-операторов оператор

     оператор-выражения:
       <выражение>;

     оператор-выбора:
       if (выражение) оператор
       if (выражение) оператор else оператор
       switch (выражение) оператор

     оператор-итерации:
       while (выражение) оператор
       do оператор while (выражение);
       for (оператор-инициализации<выражение>;
                                <выражение>)оператор

     оператор-инициализации:
       оператор-выражения
       объявление (C++)

     оператор-перехода:
       goto идентификатор;
       continue;
       break;
       return<выражение>;
─────────────────────────────────────────────────────────────

                            Блоки.

     Составной оператор   или  блок  -  это  список  (возможно
пустой) операторов, заключенных в {}. Синтаксически блок может
рассматриваться  как  один  оператор  и  воздействует на сферу
действия идентификаторов.  Идентификатор,  объявленный  внутри
блока, имеет сферу действия, начиная с точки объявления и кон-
чая "}". Блоки могут быть вложены на любую глубину.

                    Помеченные операторы.

     Оператор может быть помечен следующими способами:
     1. идентификатор-метки : оператор
     Идентификатор-метки служит как назначение для безусловно-
го   оператора  goto.  Идентификатор-метки  имеет  собственное
пространство действия имени и имеет  сферу  действия  функции.
Заметим, что в C++ Вы можете пометить декларативные и недекла-
ративные операторы.
     2. case константное-выражение : оператор
        default : оператор
     Операторы, помеченные  как  case и default,  используются
только в операторах switch.

                     Оператор выражения.

     Любое выражение с последующей ";" образует оператор выра-
жения:
    <выражение>;
     Borland C++ выполняет оператор,  вычисляя выражение.  Все
сторонние эффекты при вычислении этого  выражения  завершаются
до выполнения следующего оператора. Большинство операторов вы-
ражения - это операторы присваивания или вызовы функций.
     Специальный случай - это пустой оператор, состоящий толь-
ко из ";".  Пустой оператор ничего не делает, он удобен в слу-
чаях,  когда синтаксис Borland C++ ожидает оператора, но прог-
рамме ничего не нужно делать.

                       Оператор выбора.

     Оператор выбора выбирает альтернативные варианты,  прове-
ряя определенное значение.  Существует 2 типа операторов выбо-
ра: if...else и switch.

                         Оператор if.

     Оператор if имеет вид:
     if (условное выражение) t-st <else f-st>
     Примечание: () вокруг условного выражения обязательны.
     Условное выражение должно быть скалярного типа.  Если вы-
ражение вычисляется в 0 (или null для указателя),  мы говорим,
что оно имеет значение false; иначе true.
     Если нет части else и выражение true,  t-st  выполняется;
иначе t-st игнорируется.
     Если else f-st присутствует и выражение true, t-st выпол-
няется; иначе t-st игнорируется и f-st выполняется.
     Примечание: В отличие от Паскаля,  Borland C++  не  имеет
специального типа boolean. Все выражения типа целые или указа-
тель могут использоваться как boolean в  условных  выражениях.
Выражения  отношения  (a>b)  (если  верно) вычисляется в int 1
(true) если (a>b),  и в int 0 (false),  если (a<=b). Указатель
преобразуется так,  что он всегда может быть правильно сравнен
с константным выражением,  вычисляемым в 0. Т.е. тест для null
указателя может быть записан if (!ptr)... или if (ptr==0)....
     Операторы f-st и t-st сами  могут  быть  операторами  if,
позволяя  выполнять серию проверок,  вложенных на произвольную
глубину.  Необходима осторожность при использовании  вложенных
if...else,  чтобы быть уверенным,  что выбраны правильные опе-
ранды. Не существует оператора endif: любая неопределенность с
else  разрешается  добавлением  соответствующего else к if без
else на том же уровне блока. Например
     if (x == 1)
       if (y == 1) puts(*x=1 и y=1*);
     else puts(*x != 1*);
     приводит к ошибке. еlse соответствует второму if несмотря
на отступ.  Правильное решение состоит в том, что х=1, а y!=1.
Используем эффект {}:
     if (x == 1)
     {
       if (y == 1) puts(*x=1 и y=1*);
     }
     else puts(*x != 1*);

                       Оператор switch.

     Оператор switch имеет формат:
     switch (sw-выражение) case-st
     Оператор switch  позволяет  Вам  передавать управление на
один из нескольких помеченных операторов в зависимости от зна-
чения sw-выражение. Оно должно быть целого типа (в C++ оно мо-
жет быть типа класс при условии,  что возможно недвусмысленное
преобразование в целый тип). Любой оператор в case-st (включая
пустой оператор) может быть помечен одной или более метками:
     case const-exp-i:case-st-i
     где каждая константа выбора const-exp-i - это константное
выражение  с уникальным целым значением (преобразованным в тип
управляющего выражения) внутри оператора switch.
     Примечание: Недопустимо  дублировать  константы  выбора в
одном операторе switch.
     Допускается так же одна метка default:
     default:default-st
     После вычисления sw-выражение ищется соответствие с одним
из const-exp-i.  Если соответствие найдено, управление переда-
ется на оператор case-st-i с соответствующей меткой.
     Если соответствие не найдено и есть метка default, управ-
ление передается на default-st. Если соответствие не найдено и
метки default нет,  ни один из операторов не  выполняется.  На
выполнение  программы  не влияет наличие case и меток default.
Управление просто передается, минуя метки, к следующему опера-
тору или переключателю.  Чтобы прервать выполнение группы опе-
раторов для соответствующего выбора, используйте break.

                     Операторы итерации.

     Операторы итерации позволяют Вам циклически выполнять на-
бор операторов. В Borland C++ имеются 3 формы итерации: while,
do, for.

                       Оператор while.

     Формат оператора:
     while (условное-выражение) t-st
     Примечание: () необходимы.
     Оператор цикла  t-st  будет выполняться до тех пор,  пока
условное-выражение не станет равным 0 (false).
     Вначале вычисляется   и  проверяется  условное-выражение.
Если его значение не 0 (true) t-st выполняется;  если нет опе-
раторов перехода, которые выходят из цикла, условное-выражение
вычисляется снова.  Этот цикл повторяется  до  тех  пор,  пока
условное-выражение не станет равным 0.
     Как и в операторе  if,  выражение  типа  указатель  можно
сравнить с null указателем и while (ptr)... эквивалентно
     while (ptr != NULL)...
     Цикл while полезен для сканирования строк и других струк-
тур данных, завершенных 0:
     char str[10]=*Borland*;
     char *ptr=&str[0];
     int count = 0;
     // ...
     while (*ptr++)
       count++;
     При отсутствии оператора перехода t-st должно воздейство-
вать на значение условного выражения  или  условное  выражение
должно  само  изменяться  во время вычисления для того,  чтобы
предотвратить бесконечный цикл.

                      Оператор do while.

     Формат оператора
     do do-st while (условное-выражение);
     Оператор do-st выполняется до тех пор,  пока условное-вы-
ражение не будет равно 0 (false). Главное отличие от оператора
while в том, что условное-выражение вычисляется после, а не до
каждого выполнения оператора цикла.  Таким образом,  do-st вы-
полняется по крайней мере 1 раз.  К условному выражению приме-
нимы те же правила, что и в случае while.

                        Оператор for.

     Формат оператора:
     for (<выражение-инициализации>;<условное-выражение>;
         <выражение-увеличения>)оператор
     Примечание: В C++ выражение-инициализации может быть  вы-
ражением или объявлением.
     Последовательность выполнения:
     1. Выполняется,  если есть,  выражение инициализации. Оно
обычно инициализирует один или  более  счетчиков  цикла,  син-
таксис  позволяет  любую  степень сложности выражения (включая
объявления в C++).  Любая С-программа может быть написана, как
единственный  цикл for.  (Не пытайтесь сделать это,  поскольку
это больше теоретическое, чем практическое утверждение).
     2. Условное  выражение  вычисляется по правилам для цикла
while. Если выражение не 0 (true), оператор цикла выполняется.
Если условное выражение пустое, это аналогично while (1), т.е.
всегда true. Если значение условного выражения 0 (false), цикл
for завершается.
     3. Выражение увеличения изменяет 1 или более счетчиков.
     4. Вычисляется выражение <оператор> (возможно пустой),  а
управление передается на шаг 2.
     Если любой из необязательных элементов пустой,  требуется
соответствующая ";":
     for(;;) {
     }
     Примечание: Правила  С  для  оператора  for применимы и в
C++.  Однако выражение инициализации в C++ может быть объявле-
нием.  Сфера  действия объявленного идентификатора расширяется
до конца оператора for. Например
     for (int i=1; i<j; ++i)
     {
       if (i...)...    // верно
     }
     if (i...)         // неверно, вне сферы действия i

                     Операторы перехода.

     Оператор перехода  производит безусловную передачу управ-
ления. Существует 4 оператора перехода: break, continue, goto,
return.

                       Оператор break.

     Синтаксис
     break;
     Оператор break  может использоваться только внутри опера-
тора итерации (while, do, for) и switch. Он заканчивает итера-
цию  или  switch.  Поскольку операторы итерации и switch могут
быть перемешаны и вложены на  любую  глубину,  убедитесь,  что
break производит выход для нужного цикла или switch. break за-
канчивает ближайший оператор итерации или switch.

                      Оператор continue.

     Синтаксис
     continue;
     Оператор continue может использоваться только внутри опе-
ратора итерации;  он передает управление на условное выражение
для циклов while и do и на условное выражение в цикле for.
     Для вложенных циклов оператор continue действует для бли-
жайшей итерации.

                        Оператор goto.

     Синтаксис
     goto метка;
     Оператор goto передает управление на оператор, помеченный
меткой, который должен быть в той же функции.
     Примечание: В C++  не  разрешается  обходить  объявление,
имеющее явный или неявный инициализатор, если только этот ини-
циализатор не находится во внутреннем блоке,  который  так  же
обходится.

                       Оператор return.

     Если тип возвращаемой функции не void, тело функции долж-
но содержать по крайней мере один оператор return:
     return возвращаемое-выражение;
     где возвращаемое-выражение должно быть типа type или  ти-
па, который преобразуется в type присваиванием. Значение возв-
ращаемоговыражения - это значение, которое возвращает функция.
Это значение rvalue, а не lvalue:
     t = func(arg);
     func(arg) = t; // неверно в Си; верно в C++, если функция
                      // возвращает ссылку.
     (func(arg))++; // неверно в Си; верно в C++, если функция
                      // возвращает ссылку.
     При достижении оператора return функция завершается; если
return не встречен,  выполнение заканчивается  при  достижении
последней } тела функции.
     Если возвращаемый тип - void,  оператор return может быть
записан
     {
       ...
       return;
     }
