                        ПРИЛОЖЕНИЕ А.

            ОСОБЕННОСТИ РЕАЛИЗАЦИИ СТАНДАРТА ANSI.

     Некоторые аспекты стандарта ANSI C не  определены  точно.
Вместо  этого каждый разработчик компилятора Си определяет эти
аспекты по-своему. Эта глава описывает, как фирма Borland реа-
лизует особенности стандарта,  зависящие от реализации.  Номер
разделов ссылается к проекту стандарта ANSI от  февраля  1990.
Заметим,  что существует отличие между Си и Си++; это приложе-
ние относится только к Си.

          2.1.1.3. Как идентифицировать диагностику.
     При выполнении с правильной комбинацией опций, любое, вы-
даваемое  компилятором  сообщение,  начинается  словами Fatal,
Error или Warning.  Опции требуются,  чтобы интерпретация была
следующей:

         Табл. А.1. Идентификация диагностики в С++.
──────────────────────────────────────────────────────────────
   опция                             действие
──────────────────────────────────────────────────────────────
     -A         Разрешены только ключевые слова ANSI
     -C-        Вложенные комментарии не разрешены
     -p-        Использовать соглашения о вызовах Си
     -i32       В идентификаторах 32 значащих символа
     -w-        Выключить все предупреждения, за исключением
                следующих
     -wbei      Включить предупреждение о несоответствующей
                инициализации
     -wdcl      Включить предупреждение об объявлениях без
                типа или класса памяти
     -wcpt      Включить   предупреждение   о  непереносимых
                сравнениях указателей
     -wdup      Включить предупреждение о дублированных
                неидентичных макроопределениях
     -wsus      Включить предупреждение о  подозрительных
                преобразованиях указателей
     -wrpt      Включить предупреждение о  непереносимых
                преобразованиях указателей
     -wvrt      Включить предупреждение о void функциях,
                возвращающих значения
     -wbig      Включить предупреждение о слишком больших
                константах
     -wucp      Включить предупреждение о смешении
                указателей на знаковые и беззнаковые char
     -wstu      Включить предупреждение о неопределенных
                структурах
     -wext      Включить предупреждение о переменных,
                объявленных и как внешних и как статических
     -wfdt      Включить  предупреждение  о  функциях,
                определенных   с использованием typedef
──────────────────────────────────────────────────────────────
     Ни одна из следующих опций не может использоваться:
     -ms!       SS должен быть тот же, что и DS для малых
                моделей данных
     -mm!       SS должен быть тот же, что и DS для малых
                моделей данных
     -mt!       SS должен быть тот же, что и DS для малых
                моделей данных
     -zGxx      Имя группы BSS нельзя изменить
     -zSxx      Имя группы данных нельзя изменить

     Другие опции,  не упомянутые здесь можно  установить  как
угодно.

             2.1.2.2.1. Семантика аргументов main
     Значение argv[0]  - это указатель на нулевой байт,  когда
программа выполняется под версиями DOS ниже  версии  3.0.  Для
версии DOS 3.0 и выше argv[0] указывает на имя программы.
     Остальные строки argv указывают на  компоненты  командной
строки  DOS.  Разделители  между  аргументами удалены и каждая
последовательность символов  не-разделителей  интерпретируется
как один аргумент.  Строки в "" обрабатываются корректно (т.е.
как строка, содержащая пробелы).

      2.1.2.3. Что назначается интерактивным устройствам
     Любое устройство, которое выглядит как консоль.

  2.2.1. Упорядоченная последовательность выполнимого набора
                          символов.
     Упорядоченная последовательность  выполнимого набора сим-
волов использует знаковое значение символа ASCII.

        2.2.1.1. Исходный и выполнимый набор символов
     Исходный и выполнимый набор символов  -  это  расширенный
набор ASCII,  поддерживаемый на IBM PC. Любой символ, отличный
от ^Z (Ctrl -Z) может появляться в литеральных  строках,  сим-
вольных константах или комментариях.

               2.2.1.2. Многобайтовые символы.
     Borland C++ не поддерживает многобайтовых символов.


                  2.2.2. Направление печати
     Слева направо - нормальное направление на PC.


  2.2.4.2. Число бит в символе в выполнимом наборе символов
     8 бит на символ в выполнимом наборе символов.

       3.1.2. Число значимых символов в идентификаторах
     В идентификаторах первые 32 символа  являются  значимыми.
Хотя  Вы  можете  использовать  опцию  -i  для изменения этого
числа. Внешние и внутренние идентификаторы используют одинако-
вое число значимых символов.  (Число значимых символов в иден-
тификаторах Си++ не ограничено).

    3.1.2. Различаются ли прописные и строчные во внешних
                       идентификаторах.
     По умолчанию компилятор различает  прописные  и  строчные
символы.  Вы  можете использовать опцию -l-c,  чтобы запретить
это различие.

     3.1.2.5. Представление и набор значений целых типов
─────────────────────────────────────────────────────────────
 Тип                           Минимальное      Максимальное
                                  значение          значение
─────────────────────────────────────────────────────────────
 Цифра со знаком                     -128               127
 Цифра без знака                        0               255
 Короткое целое со знаком         -32.768            32.767
 Короткое целое без знака               0            65.535
 Целое со знаком                  -32.768            32.767
 Целое без знака                        0            65.535
 Длинное целое со знаком   -2.147.483.648     2.147.483.647
 Длинное целое без знака                0     4.294.967.295
─────────────────────────────────────────────────────────────
     Все типы char используют 1 байт для хранения.
     Все типы short и int используют 2 байта.
     Все типы long используют 4 байта.
     Если требуется выравнивание (-a),  все не char целые типы
выравниваются на четные границы. Символьный тип никогда не вы-
равнивается.

           3.1.2.5. Представление и набор значений
            различных  типов  с  плавающей точкой.
     Для всех типов с плавающей точкой в Borland C++ использу-
ется IEEE формат с плавающей  точкой  Intel  8087.  Тип  float
использует 32- битный формат, double - 64-битный и long double
- 80-битный формат.

            3.1.3.4. Отображение между исходным и
                 выполнимым набором символов.
     Все символы в литеральных строках и символьных константах
остаются неизменными при выполнении программы.  Исходный и вы-
полнимый наборы символов совпадают.

                              3.1.3.4
     Значение целой  символьной  константы,  которая  содержит
символ или esc последовательность, не представленную в базовом
наборе выполнимых символов или расширенном наборе символов для
длинных символьных констант:
     Длинные символы  не поддерживаются.  Они интерпретируются
как обычные символы.  Все  правильные  esc  последовательности
отображаются в символы. Если 16-ричная или 8-ричная esc после-
довательность превышает диапазон  символа,  компилятор  выдает
сообщение.

                           3.1.3.4
     Текущее место действия,  используемое для  преобразования
многобайтовых символов  в  соответствующие длинные символы для
символьных констант:
     Длинные символьные константы распознаются, но обрабатыва-
ются как обычные символьные константы.  В этом  смысле,  место
действия является местом действия "С".

                           3.1.3.4
     Значение целой  константы,  которая содержит более одного
символа или длинную символьную константу, которая содержит бо-
лее одного многобайтового символа:
     Символьная константа  может  содержать  1  или 2 символа.
Если содержит 2  символа,  то  первый  занимает  младший  байт
константы, а второй - старший.

                           3.2.1.2
     Результат преобразования целого в более короткое знаковое
целое или результат преобразования беззнакового целого в  зна-
ковое  целое  с  равной  длиной,  если  значение не может быть
представлено:
     Эти преобразования выполняются простым отсечением старших
бит. Знаковые целые хранятся как значения из 2 частей, поэтому
результирующее число интерпретируется как значение. Если стар-
ший бит наименьшего целого не 0,  то значение интерпретируется
как отрицательное; иначе как положительное.

                           3.2.1.3
     Направление отсечения,  когда целое число преобразуется в
число с плавающей точкой,  которое не может точно  представить
оригинальное значение:
     Целое число округляется в  ближайшее  значение.  Например
long   значение  (2**31-1)  преобразуется  во  float  значение
(2**31).

                           3.2.1.4
     Направление отсечения или округления,  когда число с пла-
вающей точкой преобразуется в более короткое число с плавающей
точкой:
     Значение округляется до ближайшего значения.

                             3.3
     Результат побитовых операций над знаковыми целыми:
     Побитовые операторы применяются  к  знаковым  целым,  как
если  бы  они  были соответствующими беззнаковыми типами.  Бит
знака интерпретируется как обычный бит данных.

                           3.3.2.3
     Что происходит, когда к элементу объединения обращаются с
использованием элемента другого типа:
     Этот доступ  разрешен и просто будет производиться доступ
к битам,  хранящимся там. Вам необходимо понимание кодирования
битов значений  с  плавающей  точкой  для  того,  чтобы понять
доступ к элементам с плавающей точкой,  использующий различные
элементы. Если хранимый элемент короче, чем элемент, использу-
емый для доступа к значению,  то излишние биты имеют значения,
которые они имели перед запоминанием короткого элемента.

                           3.3.3.4
     Тип целого,  требуемый для хранения максимального размера
массива:
     Для нормального массива это тип unsigned int, для больших
массивов - это тип signed long.

                            3.3.4
     Результат приведения  типа  указателя к целому или наобо-
рот:
     При преобразовании между целыми и указателями одного раз-
мера биты не изменяются.  При преобразовании из более длинного
типа в более короткий, старшие биты отсекаются. При преобразо-
вании  из более короткого целого типа в более длинный тип ука-
зателя, целое вначале расширяется до целого типа, который того
же  размера,  что  и  тип указателя.  Так знаковые целые будут
использовать знаковые расширения для  заполнения  новых  байт.
Аналогично,  более  короткий  тип указателя будет преобразовы-
ваться в более длинный тип целого, расширяясь в тип указателя,
который имеет ту же длину, что и целый тип.

                            3.3.5
     Знак остатка при целом делении:
     Когда только один из операндов отрицателен - остаток  от-
рицателен.  Если  оба или ни один из операндов не отрицателен,
остаток положителен.

                            3.3.6
     Тип целого,  требуемый  для  хранения разницы между двумя
указателями на элементы одного массива, ptrdiff_t:
     Тип signed int, если указатели near, или тип signed long,
если  указатели far или huge.  Тип ptrdiff_t зависит от модели
памяти.  В малых моделях данных - это тип  int,  в  больших  -
long.

                            3.3.7
     Результат правого  сдвига отрицательного знакового целого
типа:
     Отрицательное знаковое значение знаково  расширяется  при
правом сдвиге.
                            3.5.1
     Объекты, которые  могут быть помещены в регистре при ука-
зании спецификатора класса памяти register:
     Объекты, объявленные как двухбайтовые целые или указатели
могут размещаться в регистрах.  Компилятор помещает в регистры
любые небольшие автоматические объекты,  но объекты, явно объ-
явленные как register, имеют приоритет. Доступно от 2 до 6 ре-
гистров.  Число регистров зависит от регистров,  требуемых для
хранения временных значений в функциях.

                           3.5.2.1
     Интерпретация битовых  полей  как  signed  int  или   как
unsigned int:
     int битовые поля интерпретируются как signed int  битовые
поля.

                           3.5.2.1
     Порядок распределения битовых полей внутри int:
     Битовые поля распределяются от младших бит к старшим.

                           3.5.2.1
     Дополнение и выравнивание элементов структур:
     По умолчанию дополнения  в  структурах  не  используются.
Если Вы используете опцию выравнивания -a,  структуры дополня-
ются до четного размера и элементы,  отличные  от  символов  и
символьных массивов, выравниваются на четное смещение.

                           3.5.2.1
     Могут ли битовые поля переходить границу элемента памяти:
     Когда выравнивание не требуется, битовые поля могут пере-
ходить границу слова, но никогда не занимают более 2 байт.

                           3.5.2.2
     Выбор целого типа для представления значений перечислимо-
го типа:
     Если перечислимые  значения  могут поместиться в unsigned
char, выбирается этот тип, иначе signed int.

                            3.5.3.

     Что назначает доступ к объектам,  имеющим изменяемый ква-
лифицированный тип:
     Любая ссылка на изменяемый объект дает доступ к  объекту.
Будут ли соседние ячейки памяти так же иметь доступ к объекту,
зависит от конструкции памяти в  аппаратном  обеспечении.  Для
специальной памяти устройства,  такой как видеопамять, это за-
висит от того, как сконструировано устройство. Для обычной па-
мяти PC  изменяемые  объекты  используются  только для памяти,
доступ к которой можно получить только с  помощью  асинхронных
прерываний, поэтому соседние объекты не имеют эффекта.

                            3.5.4
     Максимальное число  элементов  объявления,  которые могут
модифицировать арифметический тип, структуру или объединение:
     Число элементов объявления велико, но когда вложены внут-
ри набора блоков функции,  число  элементов  объявления  будет
сокращаться. Число, допустимое на уровне файла, по крайней ме-
ре 50.

                           3.6.4.2
     Максимальное число case в операторе switch:
     Нет определенного ограничения на число case в switch.  До
тех  пор,  пока  достаточно  памяти  для хранения информации о
case, компилятор будет обрабатывать их.

                            3.8.1.

     Соответствует ли   значение  односимвольной  константы  в
константном выражении,  управляющем условным включением значе-
нию такой  же символьной константы в выполняемом наборе симво-
лов. Может ли такая символьная константа  иметь  отрицательное
значение:
     Все символьные константы и даже константы в условных  ди-
рективах имеют одинаковые выполнимые наборы символов. Односим-
вольные константы могут быть отрицательными,  если  символьный
тип является знаковым (по умолчанию, a -K не запрашивается).

                            3.8.2
     Метод нахождения включаемых исходных файлов:
     Для имени  включаемого файла в <>,  если включаемые спра-
вочники заданы в командной строке,  то файл ищется в каждом из
включаемых  справочников.  Включаемые справочники просматрива-
ются в порядке:  вначале  справочники,  заданные  в  командной
строке, затем справочники, заданные в BORLANDC.CFG. Если вклю-
чаемые справочники не заданы,  поиск производится только в те-
кущем справочнике.

                            3.8.2
     Поддержка для имен в "" для включаемых исходных файлов:
     Если имя файла задано в "", файл вначале ищется в текущем
справочнике.  Если  он не найден,  Borland C++ ищет файл,  как
если бы он был задан в <>.

                            3.8.2
     Отображение последовательности  символов  исходных   имен
файлов:
     Обратные слэши во включенных именах файлов обрабатываются
как как отдельные символы,  а не как Esc символы. Различие ре-
гистров игнорируются.

                            3.8.8

     Определение для __DATE__ и __TIME__ когда они недоступны:
     Время и дата всегда доступны и используют  время  и  дату
DOS.

                            4.1.1
     Символ десятичной точки:
     Это "точка"

                            4.1.5
     Тип оператора sizeof size_t:
     Тип size-t - unsigned int

                            4.1.5
     Константа, в которую расширяется макро NULL:
     int или long 0 в зависимости от модели памяти.

                             4.2
     Диагностика, выводимая функцией утверждения,  и ее завер-
щение:
     Выводится диагностическое  сообщение:  "assertion failed:
expression, file filename, line nn": где expression - это оши-
бочное выражение, filename - имя исходного файла, nn - это но-
мер строки, где стоит утверждение.
     После вывода   такого   сообщения  немедленно  вызывается
abort.

                             4.3
     Проверка символов  и  отображение  прописных  и  строчных
букв:
     Ничего, кроме указанного в 4.3.1

                            4.3.1
     Набор символов,  проверяемый функциями isalnum,  isalpha,
iscntrl, islower, isprint, isupper:
     Первые 128 ASCII символов.

                            4.5.1
     Значение, возвращаемое   математическими  функциями,  при
ошибке:
     IEEE  NAN (не число)

                            4.5.1
     Устанавливают ли математические функции  целое  выражение
errno в значение макро ERANGE при ошибке нехватки точности:
     Нет. Только для других ошибок:  переполнении,  не число и
общей потери точности.

                           4.5.6.4
     Возникает ошибка не число или возвращается 0, когда функ-
ция fmod имеет второй аргумент 0:
     Нет. fmod(x, 0) возвращает 0.

                           4.7.1.1
     Набор сигналов для функции signal:
     SIGABRT, SIGFPE, SIGILL, SIGINT, SIGSEGV, SIGTERM

                           4.7.1.1
     Семантика для  каждого сигнала,  распознаваемого функцией
signal:
     См. описание signal в Справочном руководстве по библиоте-
ке.

                           4.7.1.1
     Обработка по  умолчанию и обработка начального кода прог-
раммы для каждого сигнала, распознаваемого функцией signal
     См. описание signal в Справочном руководстве по библиоте-
ке.

                           4.7.1.1
     Если эквивалент signal (sig,  SIG_DFL); не выполняется до
вызова обработчика сигналов, выполняется ли блокировка signal:
     Эквивалент signal  (sig,  SIG_DFL); всегда выполняется.

                           4.7.1.1
     Будет ли обработка по умолчанию переустанавливаться, если
сигнал   SIGILL  получен  обработчиком,  указанным  в  функции
signal:
     Нет.

                            4.9.2
     Будет ли последняя строка текста  требовать  завершающего
символа новой строки:
     Нет.

                            4.9.2
     Будет ли символ пробела, который записывается в текстовый
поток непосредственно перед символом новой строки,  появляться
при его чтении:
     Да

                            4.9.2
     Число NULL символов,  которые могут быть добавлены к дан-
ным, записываемым в двоичный поток:
     Ни одного.

                            4.9.3
     Будет ли индикатор позиции файла в режиме append первона-
чально позиционироваться в начало или конец файла:
     Индикатор позиции файла первоначально позиционируется  на
начало.  Он переустанавливается в конец файла перед каждой за-
писью.

                            4.9.3
     Приведет ли запись в текстовый поток к тому, что ассоции-
рованный файл отсекается до этой точки:
     Запись 0 байт может отсекать или не отсекать файл,  в за-
висимости от того, как буферизован файл.

                            4.9.3
     Характеристики буферизации файла:
     Файл может иметь полную буферизацию, построчную буфериза-
цию и быть небуферизован.  Если файл буферизован, по умолчанию
создается буфер длиной 512 байт.

                            4.9.3
     Будет ли  в  действительности  существовать  файл нулевой
длины:
     Да

                            4.9.3
     Может ли один и тот же файл открываться несколько раз:
     Да

                           4.9.4.1
     Действие функции remove на открытый файл:
     Для открытого файла не производится специальной проверки.
Ответственность лежит на программисте.

                           4.9.4.2
     Действие, если  файл  с новым именем существует до вызова
rename:
     rename возвращает -1 и errno устанавливается в EEXIST.

                           4.9.6.1
     Вывод для преобразования %p в fprintf:
     В ближних  моделях  данных  4  16-ричных цифры (ХХХХ),  в
дальних моделях -  4  16-ричных  цифры  :  4  16-ричных  цифры
(ХХХХ:ХХХХ).

                           4.9.6.2
     Вход для преобразования %p в fscanf:
     См. 4.9.6.1

                           4.9.6.2
     Интерпретация символа "-" когда он ни первый,  ни послед-
ний  символ  в  списке  сканирования  для  преобразования %[ в
fscanf:
     См. описание fscanf в Справочном руководстве по библиоте-
ке.

                           4.9.9.1
     Значение, в которое устанавливается макро errno, функция-
ми ftell и fgetpos при ошибке:
     EBADF - плохой номер файла

                           4.9.10.4
     Сообщение, выводимое perror:
─────────────────────────────────────────────────────────────
  Error 0                      Ошибка 0
  Invalid function number      Недействительный номер функции
  No such file or directory    Нет такого файла или справоч-
                               ника
  Path not found               Путь не найден
  Too many open files          Слишком много файлов
  Permission denied            Доступ запрещен
  Bad file number              Плохой номер файла
  Memory area trashed          Область памяти захламлена
  Not enough memory            Нет памяти
  Invalid memory block address Неправильные адреса блоков  па-
                               мяти
  Invalid environment          Неверная среда
  Invalid format               Неверный формат
  Invalid access code          Неверный код доступа
  Invalid data                 Неверные данные
  No such device               Нет такого устройства
  Attempted to remove current  Попытка удалить текущий спра-
      directory                вочник
  Not same device              Не такое устройство
  No more files                Нет больше файлов
  Invalid argument             Неверный аргумент
  Arg list too big             Список аргументов слишком
                               велик
  Exec format error            Ошибка формата выполнения
  Cross device link            Перекрестная связь между
                               устройствами
  Math argument                Математический аргумент
  Result too large             Результат слишком велик
  File already exists          Файл уже существует
─────────────────────────────────────────────────────────────
     См. perror в Справочном руководстве по библиотеке.

                            4.10.3
     Поведение calloc,  malloc и realloc,  если  запрашиваемый
размер 0:
     calloc и malloc игнорируют  запрос.  realloc  освобождает
блок.

                           4.10.4.1
     Поведение функции abort относительно открытия и временных
файлов:
     Буфера файлов не выталкиваются и файлы не закрываются.

                           4.10.4.3
     Статус, возвращаемый exit, если значение аргумента отлич-
но от 0, EXIT_SUCCESS, EXIT_FAILURE:
     Ничего специального.  Статус  возвращается  точно так же,
как передается. Статус представлен как signed char.

                           4.10.4.4
     Набор имен среды и метод изменения списка среды,  исполь-
зуемый в getenv:
     Строки среды определяются в DOS командой set.  putenv мо-
жет использоваться для изменения строк во время  работы  прог-
раммы,  но  для  постоянного  изменения  строки  среды  должна
использоваться команда DOS SET.

                           4.10.4.5
     Содержимое и режим выполнения строк системными функциями:
     Строка интерпретируется как команда DOS.  COMMAND.COM вы-
полняется и строка аргумента передается как команда для выпол-
нения.  Может выполняться любая встроенная команда DOS так же,
как .BAT файлы и выполнимые программы.

                           4.11.6.2
     Содержимое строки  сообщений  об  ошибках,   возвращаемое
strerror:
     См. 4.9.10.4

                            4.12.1
     Зона локального времени и Daylight Saving Time:
     Определяется, как локальная дата и время PC.

                           4.12.2.1
     Часы:
     Представляются как квант времени,  с началом, совпадающим
с началом выполнения программы.

                           4.12.3.5
     Формат даты и времени:
     Borland C++ реализует форматы ANSI.
