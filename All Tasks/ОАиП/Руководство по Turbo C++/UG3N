                           ГЛАВА 3.

                ПОСТРОЕНИЕ ПРИЛОЖЕНИЙ WINDOWS.

     Эта глава поясняет,  как  использовать  Borland  C++  для
построения  предложений Windows или динамических библиотек ре-
дактора (DLL).  Эта глава НЕ поясняет сложности проектирования
предложений  Windows и НЕ учит как программировать в Windows -
эти темы лежат далеко от  области,  которую  охватывает  глава
этой книги.

                      Основной процесс.

     Компиляция и редактирование модуля для Windows является в
основном таким же, как и для DOS. Вначале компилятор генериру-
ет объектный файл (который отличается от компиляции DOS прежде
всего особыми кодами оглавления и окончания Windows, что охва-
тывают  каждую функцию).  Используются различные варианты кода
оглавления и окончания,  в зависимости от того, какие установ-
лены опции компиляции Windows; эти опции описаны позднее.
     Чтобы создать модуль Windows для модели памяти, под кото-
рой  идет  компиляция,  редактор редактирует объектные файлы с
соответствующими начальным кодом Borland C++,  различными биб-
лиотеками и файлом определения модулей.
     Наконец, либо IDE,  либо Makefile, либо программист вызы-
вает Resource Compiler для связывания ресурсов в модуль. Рису-
нок 3.1 иллюстрирует весь процесс.

                         Рисунок 3.1
        Компиляция и редактирование программы Windows.
    ┌──────┐                         ┌──────┐
    │┌────┐│                         │┌────┐│
    ││.C  ││                         ││.ASM││
    │└────┘│                         │└────┘│   ┌────┐
    │┌────┐│     ┌─────┐   ┌─────┐   │┌────┐│   │ RT │
    ││.CPP│├────>│ TCC │   │TASM │<──┤│.INC││   └──┬─┘
    │└────┘│     └──┬──┘   └──┬──┘   │└────┘│      │
    │┌────┐│        │         │      └──────┘      │
    ││.H  ││     ┌──v───┐  ┌──v───┐            ┌───v──┐
    │└────┘│     │┌────┐│  │┌────┐│            │┌────┐│
    └──────┘     ││.OBJ││  ││.OBJ││            ││.RC ││
                 │└────┘│  │└────┘│            │└────┘│
                 └──┬───┘  └───┬──┘            └───┬──┘
                    └───┐  ┌───┘                   │
          ┌──────┐      │  │     ┌──────┐          │
          │┌────┐│   ┌──v──v─┐   │┌────┐│       ┌──v─┐
          ││.DEF│├──>│ TLINK │<──┤│.LIB││       │ RC │
          │└────┘│   └───┬───┘   │└────┘│       └──┬─┘
          └──────┘       │       └──────┘          │
                     ┌───v──┐                  ┌───v──┐
                     │┌────┐│                  │┌────┐│
                     ││.EXE││                  ││.RES││
                     │└────┘│                  │└────┘│
                     └───┬──┘                  └───┬──┘
                         └──────────┐  ┌───────────┘
                                    │  │
                                   ┌v──v┐
                                   │ RC │
                                   └──┬─┘
                                      │
                                  ┌───v──┐
                                  │┌────┐│
                                  ││.EXE││
                                  │└────┘│
                                  └──────┘
     Следующий раздел "Компиляция и редактирование с IDE" при-
водит пример того,  как  компилировать,  редактировать  и  за-
пускать  программу  Windows в Borland C++ IDE.  Если Вы обычно
компилируете  и  редактируете  из  командной  строки  или   из
Makefile, то Вы должны прочитать раздел "Компиляция и редакти-
рование из командной строки".

           Компиляция и редактирование внутри IDE.

     В качестве  примера  Вы  создадите   простое   приложение
Windows,  названное  WHELLO,  которое  создает  окно  и  пишет
текстовое сообщение в  это  окно.  Создается  файл  WHELLO.EXE
посредством компиляции и редактирования следующих трех файлов:
     - WHELLO.CPP, исходный файл С++
     - WHELLO.RC, файл ресурсов
     - WHELLO.DEF, файл определения модулей.
     Примечание. Полное  описание различных команд и опций IDE
можно найти в главе 2.

                  Понимание файлов ресурсов.

     Приложения Windows обычно используют ресурсы, которые мо-
гут быть изображениями, диалоговыми окнами, шрифтами, курсора-
ми и битовыми образами.  Эти ресурсы могут быть созданы с  по-
мощью Resource Toolkit и определяются в файле, называемом фай-
лом ресурсов.  Для данного приложения файлом ресурсов является
WHELLO.RC.
     Файлы ресурсов .RC являются исходными файлами,  также на-
зываемые журнальными файлами ресурсов.  Перед тем как файл .RC
может быть добавлен к выполнимому коду, он должен быть сначала
откомпилирован с Resource Compiler в двоичном формате;  компи-
ляция создает файл .RES.  Например, компиляция WHELLO.RC с по-
мощью Resource Compiler создает WHELLO.RES.  Resource Compiler
также используется для связывания файлов ресурсов .RES  в  вы-
полнимый файл.
     Чтобы построить  окончательное   приложение   Windows   с
ресурсами, необходимо вызвать Resource Compiler для того чтобы
связать файл
.RES в файл .EXE. Resource  Compiler выполняет три вещи:
     1. Компилирует файлы .RC в .RES.
     2. Связывает  файл  .RES в откомпилированный модуль (.EXE
или .DLL).
     3. Помечает .EXE и .DLL как совместимые с Windows.

             Понимание файлов определения модуля.

     Файл определения модуля WHELLO.DEF дает информацию компи-
лятору  о  содержании  и  системных  потребностях   приложения
Windows.  Поскольку TLINK и встроенный компилятор имеют другие
пути нахождения информации, содержащейся в определении модуля,
то  файлы  определения  модуля  не  требуются  для компилятора
Borland C++ при создании приложения Windows,  хотя один из них
включен здесь ради примера.

             Компиляция и редактирование WHELLO.

     Ниже показано  как  направить  эти три файла в приложение
Windows:
     1. Если  Вы  этого  еще не сделали,  войдите в справочник
\BORLANDC\EXAMPLES и запустите Borland  C++  IDE,  набрав  ВСХ
(версия  защищенного  режима)  или ВС из командной строки DOS.
Если  Вы  уже  находитесь  в  IDE,  измените   справочник   на
\BORLANDC\EXAMPLES с помощью команды File/Change Dir.
     2. Выберите Project/Open Project. В окне Project Name на-
берите  WHELLO.PRJ.  Нажмите  Enter или OK для открытия нового
проекта с именем WHELLO.
     3. Выберите  Project/Add  Item и наберите whello.* в окне
Name, так что Вы получите список всех файлов WHELLO.
     4. Добавьте три файла WHELLO.CPP,  WHELLO.RC,  WHELLO.DEF
для приложения.  Закройте диалоговое окно Project после добав-
ления этих трех файлов.
     5. Выберите Options/Application для открытия  диалогового
окна Set Application Options. Выберите Windows App. Информаци-
онная панель вверху диалогового окна изменилась. Каждая из че-
тырех  кнопок  внизу диалогового окна включена и устанавливает
несколько других опций в IDE.
     6. Выберите Compile/Build all для построения проекта.
     7. Выйдите из IDE, нажав Alt-X или выбрав File/Quit.
     8. Из командной строки DOS наберите
                   win whello
DOS загрузит Windows, который сам запустит приложение Windows.
     Все это нужно для построения и запуска приложения Windows
с Borland C++. Можно обобщить этот процесс:
     1. Создать проект.
     2. Добавить  исходные файлы,  файлы ресурсов,  библиотеки
импорта (если это нужно) и файл определения модулей (если нуж-
но) в проект.
     3. Установить среду компиляции и редактирования с помощью
диалогового окна Set Application Options или в другой комбина-
ции опций и установок.
     4. Сделать Build проекта.
     5. Запустить приложение под Windows.

         Установка опций компиляции и редактирования.

     Большая часть установок в этом примере  выполнена  с  по-
мощью   диалогового   окна  Set  Application  Options.  Кнопки
действия в этом диалоговом  окне  включают  или  устанавливают
другие  опции  в  других диалоговых окнах.  Borland C++ делает
легким изменение установок, управляющих компиляцией и редакти-
рованием программ,  так что Вы сами захотите освоить работу со
следующими диалоговыми окнами (все  они  полностью  описаны  в
главе 2):
     - Диалоговое окно Code Generation устанавливает такие ве-
щи, как модель памяти, говорит компилятору использовать отком-
пилированные заголовки, и т.д. Выберите Options/Compiler/Code,
чтобы посмотреть это окно.
     - Диалоговое окно Entry/Exit Code Generation устанавлива-
ет опции компилятора для генерации кода оглавления и окончания
Borland     C++      и      опции      экспорта.      Выберите
Options/Compiler/Entry/Exit Code и просмотрите содержание это-
го диалогового окна.
     - Диалоговое  окно  Make  (Options/Make).  Опции Generate
Import Library позволяют создать библиотеку импорта  для  DLL.
Библиотека импорта дает возможность объявить все функции в DLL
как импорт в другие модули без использования файла определения
модуля.
     - Диалоговое окно Linker  (Options/Linker)  устанавливает
опции для типа вывода,  который Вам требуется от компилятора -
такой,  как standard DOS.EXE,  overlaid DOS.EXE, Windows.EXE и
Windows.DLL - так же как и другие опции редактора.

       Компиляция и редактирование из командной строки.

     Если Вы  знаете,  как компилировать и редактировать прог-
рамму С или С++ из DOS, то Вы знаете почти все, что необходимо
для этого в Windows.  Вам нужно три файла для компиляции и ре-
дактирования примерного приложения:
     - WHELLO.CPP, исходный файл С++
     - WHELLO.RC, файл ресурсов
     - WHELLO.DEF, файл определения модулей.

               Компиляция из командной строки.

     Для компиляции и редактирования WHELLO.CPP для приложения
Windows наберите
     BCC -W whello.cpp
     Получив эту командную строку,  Borland  C++  скомпилирует
WHELLO.CPP в WHELLO.OBJ, затем отредактирует в корректных биб-
лиотеках и автоматически запустит код.  Чтобы запретить редак-
тирование,  добавьте опцию -с к командной строке.  Чтобы вклю-
чить отладочную информацию, добавьте опцию -v.
     Опция -W говорит компилятору командной строки, что Вы хо-
тите работать с приложением Windows.  Существуют другие  опции
Windows   (-Wxxx),  которые  дают  компилятору  больше  особых
инструкций о компиляции и генерации  кода  приложения  Windows
(например,  -WD для создания DLL). Подробные описания всех оп-
ций командной строки см. в главе 6.
     Как только  приложение WHELLO скомпилировано и отредакти-
ровано, единственное, что осталось сделать - добавить ресурсы.
Вначале, скомпилируем файл WHELLO.RC командой
     rc -r whello.rc
     Это создаст файл WHELLO.RES (-r говорит Resource Compiler
НЕ добавлять результат к выполнимому модулю с  таким  же  име-
нем).  Теперь вызовите Resource Compiler еще раз,  чтобы доба-
вить двоичный файл ресурсов к выполнимому файлу.
     rc whello.res whello.exe
     В действительности Resource Compiler  делает  это  легче,
чем мы здесь показали,  потому что он может компилировать файл
.RC в .RES и затем добавить его к выполнимому модулю  за  один
шаг.  Более  того,  если выполнимый модуль имеет такое же имя,
что и файл ресурсов,  то не нужно задавать выполнимый  файл  в
командной строке вообще.

             Редактирование из командной строки.

     Чтобы отредактировать  WHELLO.OBJ с правильными библиоте-
ками и начальным кодом,  вызовем TLINK со следующей  командной
строкой:
     TLINK /Tw /v /c /LC:\BorlandC\LIB c0ws whello, whello, ,
     import cwins cs, whello
     Командная строка TLINK состоит из опций и имен пяти  фай-
лов или групп имен файлов;  каждый файл или группа файлов раз-
деляются точкой с запятой.
     Опция /Tw  означает,  что редактирование для Windows,  /v
говорит TLINK включить отладочную информацию,  а /c приводит к
тому,  что  регистр был значимым в символах public и external.
/L, сопровождаемая именем пути, говорит TLINK, где искать биб-
лиотечные файлы и коды запуска .OBJ.
     Объектные файлы для редактирования  перечислены  далее  в
командной строке.  C0WS.OBJ - это модуль инициализации для не-
большой модели памяти,  а WHELLO.OBJ - это программный  модуль
для  этого  приложения.  Для  обоих этих файлов предполагается
расширение .OBJ.
     Следующий файл в командной строке, WHELLO, это имя, кото-
рое TLINK даст выполнимому модулю.  Когда Вы создаете приложе-
ние Windows, предполагается расширение .ЕХЕ; когда Вы создаете
приложение DLL,  то расширением будет .DLL. Если Вы хотите ра-
зобраться в том, как TLINK узнает, какое именно расширение Вам
требуется, прочитайте раздел "Опции редактора связей".
     Следующий файл в командной строке - это имя,  которое бу-
дет дано файлу .МАР.  Если имя не задано, как в нашем примере,
TLINK  дает  файлу  .МАР  имя  выполнимого  модуля и добавляет
расширение .МАР. После выполнения этой команды Вы найдете файл
WHELLO.МАР в справочнике с примером.
     После файла .МАР перечислены библиотечные файлы  для  ре-
дактирования.  CWINS.LIB  -  это библиотека времени выполнения
небольшой модели памяти для Windows, CS.LIB - это обычная биб-
лиотека  времени  выполнения,  а  IMPORT.LIB - это библиотека,
обеспечивающая доступ к встроенным функциям Windows.  Для всех
библиотечных файлов предполагается расширение .LIB.
     Последнее имя файла в командной строке TLINK -  это  файл
определения   модуля,  WHELLO.DEF  (предполагается  расширение
.DEF). Файлы определений модуля описаны в главе 7.

                   Использование Makefile.

     Поскольку вероятно Вы не захотите каждый раз при создании
приложения Windows набирать полную командную строку для компи-
лятора командной строки и TLINK,  то возникает  неплохая  идея
создать Makefile для своего приложения.
     Makefile для приложения WHELLO будет WHELLO.MAK. Заметим,
что    для    данного    примера    библиотеки   находятся   в
C:\BORLANDC\LIB,    а    включаемые    файлы    находятся    в
C:\BORLANDC\INCLUDE.  Следующий раздел поясняет каждое правило
в Makefile.
     Чтобы запустить МАКЕ по этому Makefile, наберите
     make -fwhello.mak
     Первое правило говорит MAKE,  как сделать завершающий вы-
полнимый код из WHELLO.EXE и WHELLO.RES и как сделать промежу-
точный  выполнимый код из объектного файла и файла определения
модулей.  (В конце этого раздела есть альтернативный Makefile,
представляющий  собой более общий подход к построению приложе-
ния Windows).
     whello.exe: whello.obj whello.def whello.res
        tlink /Tw /v /n /c C:\BORLANDC\LIB\c0ws whello,\
              whello,\
              ,\
              C:\BORLANDC\LIB\cwins C:\BORLANDC\LIB\cs
     C:\BORLANDC\LIB\import,\
              whello
        rc whello.res
     Следующее правило  говорит  МАКЕ,  как  сделать требуемые
файлы .OBJ из файлов .CPP с таким же именем. Опциями являются:
сделать  приложение  Windows (-W),  только компилировать (-c),
использовать небольшую модель памяти (-ms) и включить отладоч-
ную информацию (-v).
     .cpp.obj:
         BCC -c -ms -v -W $<
     Следующее правило говорит  МАКЕ,  как  сделать  требуемые
файлы  .RES (завершающие файлы ресурсов) из файлов .RC с таким
же именем.
     .rc.res:
         rc -r -iC:\BORLANDC\INCLUDE $<
     Опция -r  говорит  Resource Compiler только компилировать
ресурсы (вместо добавления к тому же их к выполнимому файлу  с
таким  же именем).  Опция -i определяет справочник,  в котором
следует искать файлы включения.

                 Другие Makefile для Windows.

     Следующий Makefile - это более общий Makefile, чем приве-
денный выше.  Его можно легко модифицировать путем переопреде-
ления макросов OBJS,  INCPATH и FLAGS.  TLINK не вызывается  в
отдельном  правиле;  вместо этого BCC вызывает TLINK автомати-
чески.
     OBJS = whello.obj
     INCPATH = C:\BORLANC\INCLUDE
     FLAGS = -W -v -I$(INCPATH)

     test.exe: $(OBJS) whello.def whello.res
         BCC $(FLAGS) -ewhello.exe @&&!
     $(OBJS)
     !
         rc whello.res
     .c.obj:
         BCC -c $(FLAGS) {$< }
     .cpp.obj:
         BCC -c $(FLAGS) {$< }
     .rc.res:
         rc -r -i$(INCPATH) $<

                  Начальный и конечный коды.

     При компиляции  модуля  для Windows компилятору требуется
знать,  какой вид начального и конечного  кода  создавать  для
каждой  функции модуля.  Созданием начального и конечного кода
управляют установки в IDE и опции  для  компилятора  командной
строки.  Начальный и конечный код выполняют несколько функций,
включая гарантию того,  что во время функций обратного  вызова
активен правильный сегмент данных и выполнения ближних и даль-
них структур стека для механизма перехода по стеку Windows.
     Необходимость в  начальном  и  конечном кодах не нова для
Windows;  они должны также генерироваться и для кода, предназ-
начаемого  для DOS.  Однако если программа предназначается для
Windows, то компилятор будет генерировать начальный и конечный
код, отличающийся от DOS.
     Начальный и конечный код генерируются автоматически  ком-
пилятором, хотя различные опции компилятора и опции IDE дикту-
ют точные инструкции, содержащиеся в коде.
     Следующий список  перечисляет  действие  различных  опций
Prolog/Epilog Code Generation и соответствующих им опций  ком-
пилятора в режиме командной строки. Чтобы установить эти опции
в IDE, выберите Options/Compiler/Entry/Exit Code.
     - Windows All Functions Exportable (-W). Эта опция созда-
ет  объектный  модуль  приложения  Windows  для  всех  дальних
экспортируемых функций.
     Это наиболее общий вид модуля  приложения  Windows,  хоть
может и не самый эффективный.  Компилятор генерирует начальный
и конечный код для каждой дальней функции,  что делает функцию
экспортируемой. Это не означает, что функции действительно бу-
дут экспортироваться,  на самом деле это только означает,  что
функции  могут быть экспортированы.  Для того,  чтобы действи-
тельно экспортировать одну из этих функций, нужно либо исполь-
зовать ключевое слово _Export,  либо добавить запись для имени
функции в разделе EXPORTS в файле определения модуля.
     - Windows  Explicit  Functions Exported (-WE).  Эта опция
создает объектный модуль только с функциями,  помеченными  как
_export (экспортируемыми).
     Поскольку в любом модуле приложения многие функции не бу-
дут  экспортироваться,  то  необязательно компилятору включать
специальные начальный и конечный коды для экспортируемых функ-
ций;  это можно делать только в том случае, если известно, что
конкретная  функция  будет  экспортироваться.  Ключевое  слово
_export в определении функции говорит компилятору использовать
специальные начальный и конечный коды, необходимые для экспор-
тируемых функций. Все функции, не помеченные _export, получают
сокращенные начальный и конечный коды, что приводит к меньшему
размеру объектного файла и более быстрому выполнению.
     Заметим, что опция Windows  Explicit  Functions  Exported
работает ТОЛЬКО вместе с ключевым словом _export. Эта опция не
экспортирует функции,  перечисленные в разделе EXPORTS в файле
определения модуля.  Фактически, Вы не можете использовать эту
опцию и предусмотреть имена экспортируемых функций  в  разделе
EXPORTS. Если Вы попытаетесь это сделать, компилятор будет ге-
нерировать начальный и конечный коды,  несовместимые с экспор-
тируемыми функциями;  результатом будет неправильное поведение
при вызове этих функций.
     - Windows Smart Callbacks (-WS). Эта опция создает объек-
тный модуль с функциями, использующими разумные обратные вызо-
вы.
     Эта форма начального и конечного кодов использует предпо-
ложение, что DS=SS; другими словами, сегмент данных по умолча-
нию такой же,  что и сегмент стека;  это показывает  необходи-
мость  специального кода Windows (называемого thunk),  который
создается для экспортируемых функций.  Эта форма начального  и
конечного  кода может улучшить производительность,  потому что
вызовы функций в модуле не будут перенаправлены через thunks.
     Здесь экспортируемым функциям не требуется ключевое слово
_export, их не нужно перечислять в разделе EXPORTS в файле оп-
ределения модуля,  потому что редактору связей не нужно созда-
вать экспортную запись для них в выполнимом модуле.
     При использовании функций, откомпилированных и отредакти-
рованных с обратными вызовами,  Вам не нужно перед ними делать
вызов  MakeProcInstance  (которая  переписывает  начальный код
функции таким способом,  который использует разумный  обратный
вызов).
     Из-за предположения,  что DS=SS,  нельзя использовать эту
функцию  для модулей в DLL (приложение - это прекрасно,  но не
для DLL).  Более того, не нужно явно изменять DS в своей прог-
рамме (не очень надежная практика под Windows во многих обсто-
ятельствах.
     - Windows  DLL All Functions Exportable (-WD).  Эта опция
создает объектный модуль DLL со всеми экспортируемыми функция-
ми.
     Эти начальный и конечный коды используются  для  функций,
которые  постоянно  находятся  в  DLL.  Они также поддерживают
экспортирование этих функций.  Эта опция подобна соответствую-
щей   опции   (не  DLL),  Object  Module  With  All  Functions
Exportable.
     - Windows DLL Explicit Functions Exported (-WDE). Эти на-
чальный и конечный  коды  используются  для  функций,  которые
постоянно находятся в DLL.  Однако, все функции, которые будут
экспортироваться,  должны точно задавать _export в определении
функции.  Эта  опция  подобна  соответствующей опции (не DLL),
Object Module только с точно предназначенными для  экспортиро-
вания функциями.

                   Ключевое слово _export.

     Ключевое слово _export в определении функции используется
для того,  чтобы сказать компилятору компилировать функцию как
экспортируемую. Также оно говорит редактору связей экспортиро-
вать функцию.  В объявлении функции _export  предшествует  не-
посредственно имени функции; например, LONG FAR PASCAL _export
MainWindowProc(HWND hWnd,unsigned iMessage,
                                       WORD wParam,LONG lParam)
     Можно также использовать _export  с  определением  класса
С++.

          Начальный, конечный коды и экспорт: итог.

     Для экспортирования функции существует два шага.  Во-пер-
вых, компилятор должен создать правильные начальный и конечный
коды для этой функции; если это сделано, то функция называется
экспортируемой.  Во-вторых, редактор должен создать запись для
каждой функции экспорта в разделе заголовка в выполнимом коде.
Все это происходит так,  что функцию во время выполнения будет
ограничивать правильный сегмент данных.
     Если функция помечена ключевым словом _export и использу-
ются какие-либо из опций компилятора Windows, то она будет от-
компилирована  как  экспортируемая   и   отредактирована   как
экспорт.
     Если функция НЕ  помечена  ключевым  словом  _export,  то
Borland C++ предпримет одно из следующих действий:
     - Если Вы откомпилируете с опцией -W или -WD (или с экви-
валентными опциями IDE),  то функция будет откомпилирована как
экспортируемая.
     Если функция  перечислена в разделе EXPORTS в файле опре-
деления модуля,  то функция будет отредактирована как экспорт.
Если  она  не  перечислена в файле определения модуля или файл
определения модуля не отредактирован, то она не будет отредак-
тирована как экспорт.
     - Если Вы откомпилировали с опцией -WE или -WDE (или  эк-
вивалентными опциями IDE), то функция НЕ будет откомпилирована
как экспортируемая.  Включение этой функции в раздел EXPORTS в
определении  модуля  приведет к тому,  что она будет считаться
экспортируемой,  но, поскольку начальный код неправилен, прог-
рамма будет работать некорректно. Вы можете получить сообщение
об ошибке Windows "Unrecoverable application error" (невосста-
новимая ошибка приложения).
     Следующая таблица  суммирует  действия  комбинации  опций
компилятора Windows и ключевого слова _export:

                         Таблица 3.1.
         Опции компилятора и ключевое слово _export.
______________________________________________________________
Функция помечена  Да    Да    Да   Да    Нет   Нет   Нет   Нет
словом _export?
Функция упомянута Да    Да    Нет  Нет   Да    Да    Нет   Нет
в EXPORTS?
Опция компиля-    -W    -WE   -W   -WE   -W    -WE   -W    -WE
тора:             или   или   или  или   или   или   или   или
                  -WD   -WDE  -WD  -WDE  -WD   -WDE  -WD  -WDE
Будет функция     Да    Да    Да   Да    Да    Нет   Да    Нет
экспортируемой?
Будет функция     Да    Да    Да   Да    Да    Да*   Нет** Нет
экспортироваться?
______________________________________________________________
     * - Функция будет экспортироваться  в  некотором  смысле,
но,  поскольку начальный и конечный коды неправильны,  функция
не будет работать как ожидалось.
     ** - Эта комбинация также получает некоторый смысл. Неэф-
фективно компилировать все функции как экспортируемые, если Вы
не собираетесь на самом деле экспортировать некоторые из них.

                        Модели памяти.

     С любым  типом  выполнимых модулей Windows,  включая DLL,
можно использовать небольшую,  среднюю, компактную и большую _
модели памяти.  Для всех выполнимых модулей Windows не исполь-
зуйте очень маленькую и огромную модели памяти. Borland C++ не
ограничивает Вас в установке очень маленькой и огромной модели
памяти как в командной строке,  так и в IDE,  но код,  который
генерируется  не  будет  работать  под Windows.  Для получения
большей информации обратитесь к разделу "Редактирование .OBJ и
.LIB файлов для DLL".

                 Редактирование для Windows.

     Вообще, Borland C++ должен брать объектные файлы,  отком-
пилированные с корректными опциями Windows, и затем редактиро-
вать их с надлежащим инициализационным кодом Windows,  библио-
теками времени выполнения, математическими библиотеками и фай-
лом  определения модуля.  Установка в диалоговом окне Linker в
IDE сделает это для Вас  автоматически;  если  Вы  используете
TLINK, Вы должны задать сами все опции и файлы.

                    Редактирование в IDE.

     С помощью  диалогового окна Linker в IDE можно установить
опции редактора связей для приложения Windows или DLL. Опции в
IDE перекрывают установки в файле определения модуля.  Это оз-
начает, что если Вы включили Windows EXE вместо Windows DLL, а
файл  определения  модуля имеет утверждение LIBRARY вместо ут-
верждения NAME,  то файл будет отредактирован  как  приложение
Windows, а не DLL.
     Редактор использует файл инициализации С0Wx.OBJ для  при-
ложений,  а  файл инициализации C0Dx.OBJ - для DLL,  где х за-
висит от модели памяти,  установленной в диалоговом окне  Code
Generation.  Для обеих опций Windows редактор использует теку-
щие  объектные  файлы  и   библиотеки   проекта,   IMPORT.LIB,
CWINx.LIB, MATHx.LIB и Cx.LIB.
     Borland C++ позволяет перекрывать установки по  умолчанию
для модели памяти, даже с неправильной моделью.

                   Редактирование с TLINK.

     TLINK рассматривается  в  главе 7 "Утилиты".  Этот раздел
рассматривает только те аспекты TLINK,  которые влияют на  ре-
дактирование выполнимого модуля Windows.
     Примечание. Начиная  с  этой  версии,  TLINK   становится
чувствительным к регистру своих опций.
     Чтобы предусмотреть способ редактирования файла определе-
ния модуля, новым синтаксисом командной строки TLINK стал:
     TLINK objfiles, exefile, mapfile, libfile, deffile
     Список сообщений TLINK (об ошибках и предупреждениях) см.
в главе 7.

                       Опции редактора.

     Существуют три опции,  которые Вы можете передать в TLINK
для  управления  редактированием  выполнимых модулей Windows и
DLL.
     - Используйте  опцию /Tw для создания Windows.EXE или DLL
в соответствии с установками файла определения модуля.  Если в
файле определения модуля стоит утверждение NAME,  то TLINK бу-
дет редактировать их как выполнимый  модель  Windows;  если  в
файле .DEF есть утверждение LIBRARY, то файлы будут редактиро-
ваться как DLL.
     Если в  командной  строке TLINK не задан файл определения
модуля,  то файлы будут редактироваться как  Windows.EXE.  Эта
опция не нужна,  если используется файл определения модуля,  в
котором утверждение EXETYPE задает WINDOWS.
     - Используйте  опцию  /Twe для задания выполнимого модуля
Windows. Это перекрывает установки в файле определения модуля.
Например,  даже  если  есть  утверждение LIBRARY во включенном
файле .DEF, TLINK будет редактировать файлы как .EXE.
     - Используйте опцию /Twd для задания Windows DLL. Это пе-
рекрывает установки в файле определения модуля.
     Когда Вы   редактируете  выполнимый  модуль  Windows,  НЕ
используйте опцию /о для оверлейных файлов и опцию /t или /Tdc
для создания файла .COM.

              Редактирование файлов .OBJ и .LIB.

     Список объектных   файлов   должен   начинаться  с  файла
С0Wx.OBJ или C0Dx.OBJ (для DLL), сопровождаемый именами других
объектных файлов для редактирования.  Пользовательские библио-
теки и IMPORT.LIB могут быть включены в  любом  месте  списка,
хотя, по соглашению, они перечисляются перед стандартными биб-
лиотеками.  Другие необходимые библиотеки должны располагаться
в следующем порядке:
      CWINx.LIB
      MATHx.LIB
      Cx.LIB
     ВАЖНО! НЕ  редактируйте  в EMU.LIB или FP87.LIB.  Borland
C++ сам заботится о математике с плавающей  точкой,  автомати-
чески.
     Чтобы создать выполнимый модуль  приложений  Windows,  Вы
должны использовать командный файл, названный WINRESP:
     /Tw /c \BORLANDC\LIB\C0WS winapp1 winapp2
     winapp
     winapp
     \BORLANDC\LIB\IMPORT \BORLANDC\LIB\CWINS \BORLANDC\LIB\CS
     winapp.def
     где
     - опция /Tw говорит TLINK генерировать приложение Windows
или DLL.  Если файл определения модуля не включен в редактиро-
вание,  то TLINK будет создавать приложение Windows. Если файл
определения модуля включается и содержит инструкции для созда-
ния DLL, то TLINK создаст DLL.
     - опция  /с говорит TLINK различать регистры во время ре-
дактирования.
     - \BORLANDC\LIB\C0WS - это стандартный файл инициализации
Windows, а WINAPP1 и WINAPP2 - это объектные файлы модулей.
     - WINAPP  - это имя выполнимого модуля Windows,  являюще-
гося целью.
     - TLINK будет называть файл .MAP - WINAPP.MAP.
     - \BORLANDC\LIB\CWINS - это библиотека времени выполнения
небольшой модели памяти для Windows, LIB\CS - это обычная биб-
лиотека времени выполнения,  а \BORLANDC\LIB\IMPORT - это биб-
лиотека,  которая  обеспечивает  доступ  к встроенным функциям
Windows.
     - WINAPP.DEF  является  файлом определения модуля Windows
для названных объектных файлов.
     - Чтобы  использовать  этот  командный  файл  в командной
строке TLINK, наберите
     TLINK @winresp
     Примечание. После редактирования приложения или DLL, НУЖ-
НО вызвать Resource Compiler, чтобы добавить ресурсы к образу.
Windows 3.x Resource Compiler также помечает  образ  как  сов-
местимый с Windows 3.х. Если даже у Вас нет ресурсов, Вы долж-
ны запустить Resource Compiler.

          Редактирование файлов .OBJ и .LIB для DLL.

     Редактирование файлов .LIB и .OBJ для DLL  отличается  от
редактирования  для приложения Windows.  Если редактор вызыва-
ется из IDE или из компилятора командной строки ВСС или  ВССХ,
то автоматически будут редактироваться правильные файлы .OBJ и
.LIB.  Если Вы вызываете явно TLINK, то Вам нужно знать, какие
файлы редактировать для DLL. Следующая таблица суммирует моде-
ли памяти, файлы запуска и библиотеки:

                         Таблица 3.2.
         Файлы запуска и библиотечные файлы для DLL.
______________________________________________________________
    Модель            Файл запуска         Библиотека
______________________________________________________________
  Небольшая          C0DS.OBJ              CWINC.LIB
  Компактная         C0DC.OBJ              CWINC.LIB
  Средняя            C0DM.OBJ              CWINL.LIB
  Большая            C0DL.OBJ              CWINL.LIB
______________________________________________________________
     Библиотека компактной модели памяти используется как  для
небольшой,  так и для компактной модели, поскольку она создает
дальние указатели данных и ближние указатели кода.  Библиотека
большой модели памяти используется как для средней,  так и для
большой модели, поскольку она создает дальние указатели данных
и дальние указатели кода.  DLL может иметь только дальние ука-
затели на данные; ближние указатели недопустимы.

          Построение проекта для программы Windows.

     Можно использовать менеджер проекта для построения прило-
жения Windows и DLL.  Построение программы Windows обычно тре-
бует  добавления  файла  определения  модуля  (.DEF)  и  файла
ресурсов (.RC или .RES) к проекту.
     Определение файла .RC подобно определению исходного файла
в проекте. Менеджер проекта вызовет один раз Rеsource Compiler
для компиляции его в файл .RES,  и второй раз  для  связывания
.RES с модулем и для того, чтобы пометить модуль как совмести-
мый с Windows. Определение файла .RES подобно определению объ-
ектного  файла.  Менеджер  проекта  вызовет  Rеsource Compiler
только для связывания его с модулем и  чтобы  пометить  модуль
как совместимый с Windows.
     Например, если Вы введете HELLO.CPP, HELLO.RC и HELLO.DEF
в проект, то менеджер проекта Borland C++ :
     - создаст HELLO.OBJ путем компиляции HELLO.CPP с  помощью
компилятора С++;
     - создаст HELLO.RES путем компиляции HELLO.RC  с  помощью
Resource Compiler;
     - создаст  HELLO.EXE  путем  редактирования  HELLO.OBJ  с
соответствующими библиотеками,  используя информацию, содержа-
щуюся в HELLO.DEF;
     - создаст  окончательный  HELLO.EXE  путем  использования
Resource Compiler  для  связывания  ресурсов,  содержащихся  в
HELLO.RES, в HELLO.EXE.
     Когда Вы добавляете файл .RC в проект,  менеджер  проекта
автоматически  назначает  транслятором  по  умолчанию Rеsource
Compiler.  Вдобавок,  именем  вывода  по  умолчанию   является
file.RES  (не  file.OBJ).  Наконец,  выбирается  "Exclude from
Link" (исключить редактирование),  потому что TLINK не  должен
редактировать результирующий файл .RES.
     Во время MAKE менеджер проекта перекомпилирует файл  .RC,
если он новее, чем файл .RES, таким же образом он перекомпили-
рует HELLO.C, если он новее HELLO.OBJ. Автозависимости не про-
веряются, поскольку информация недоступна.
     Во время  MAKE  менеджер   проекта   запускает   Resource
Compiler  после  любого  редактирования,  потому  что Resource
Compiler так же помечает образ как  совместимый  Windows  3.х.
Даже  если  у  Вас нет ресурсов,  Вы должны запустить Resource
Compiler.
     Менеджер проекта не будет компилировать файл с расширени-
ем .DEF.

                       Функция WinMain.

     Функция WinMain является основной точкой входа для прило-
жения Windows; Вы должны поставлять ее.
     В WinMain передаются следующие параметры:
     int PASCAL WinMain(HANDLE hInstance, HANDLE hPrevInstance,
                        LPSTR lpCmdLine, int nCmdShow)
     Типы HANDLE и LPSTR определяются в windows.h.
     HANDLE hInstance является обработкой образца  приложения.
Каждый образец приложения Windows будет иметь уникальный обра-
ботчик образца.  Этот обработчик используется как  аргумент  в
нескольких  функциях Windows и может быть использован для раз-
личения нескольких образцов данного приложения.
     HANDLE hPrevInstance  является обработкой предыдущего об-
разца этого приложения.  hPrevInstance является NULL, если это
первый образец.
     LPSTR, lpCmdLine является дальним указателем на командную
строку с null-завершением.  Это значение может быть задано при
вызове приложения из  менеджера  программы  или  из  вызова  к
WinExec.
     int nCmdShow является целым числом,  задающим как показы-
вать  окна  приложения.  Это  значение  должно быть передано в
ShowWindow.  Возможные значения nCmdShow см. в документации по
ShowWindow.
     Значение, возвращаемое из WinMain,  не используется сразу
в  Windows.  Однако  оно  может быть полезно во время отладки,
поскольку Turbo Debugger может показывать это значение по  за-
вершению Вашей программы.

           Resource Compiler (компилятор ресурсов).

     Resource Compiler делает три вещи:
     - компилирует журнальные файлы  ресурсов  (.RC)  и  файлы
ресурсов (.ICO, .CUR и так далее) в двоичный файл (.RES);
     - связывает откомпилированные ресурсы с откомпилированным
и отредактированным приложением;
     - помечает .ЕХЕ и .DLL как совместимые с Windows 3.х.
     Ресурсами Windows являются изображения,  диалоговые окна,
шрифты,  меню, курсоры и битовые образы. Эти ресурсы создаются
независимо  от  приложения  или  DLL.  Информацию  по созданию
ресурсов см. в Resource Toolkit.
     Из IDE  Resource  Compiler  вызывается менеджером проекта
при построении  проекта  Windows.  Любой  файл  .RC  (исходный
файл),  включенный в проект,  приводит к тому, что Borland C++
вызывает Resource Compiler для компиляции  его  в  файл  .RES.
После  того,  как  TLINK  отредактирует приложение проекта или
DLL, Resource Compiler пометит его и свяжет с ним ресурсы.
     Из командной   строки  Вы  можете  откомпилировать  файлы
ресурсов,  которые Вы хотите использовать в  своем  приложении
Windows,  с помощью Resource Compiler. Когда Вы готовы постро-
ить приложение,  используйте Resource Compiler для  связывания
файла .RES с .EXE или .DLL.
     В файле MAKE добавьте файл .RES к списку файлов  в  явном
правиле,  которое  описывает  построение  окончательного файла
.EXE.  В этом правиле добавьте  команду  для  вызова  Resource
Compiler с правильным файлом .RES. Можно также добавить прави-
ло для вызова Resource Compiler для файла .RES по дате.

                 Синтаксис Resource Compiler.

     Здесь показано как вызвать Resource Compiler из командной
строки:
     ***стр121
     Например, чтобы откомпилировать файл WHELLO.RC и добавить
его к WHELLO.EXE, задайте командную строку:
     rc whello
     Эта простейшая форма работает только в том  случае,  если
файл ресурса и выполнимый файл имеют одно имя.  Если WHELLO.RC
назвать WHELLORS.RC, Вы должны набрать:
     rc whellors whello
     Чтобы только откомпилировать файл ресурса WHELLO.RC (и не
добавлять   результирующий   файл  WHELLO.RES  в  WHELLO.EXE),
используйте опцию -R:
     rc -r whello
     Вы получите файл WHELLO.RES.  Чтобы добавить WHELLO.RES к
WHELLO.EXE, наберите
     rc whello.res
     Чтобы пометить  модуль  как совместимый с Windows,  но не
добавлять к нему ресурсы,  просто вызовите Resource Compiler с
именем  модуля  (заметим,  что  имя файла должно иметь одно из
расширений: .EXE, .DLL или .DRV). Например,
     rc whello.exe
     Следующая таблица описывает опции Resource Compiler.  За-
метим, что опции Resource Compiler не чувствительны к регистру
(-е и -Е - одно и то же).  Так же можно  комбинировать  опции,
которые  не  имеют  аргументов (например,  действительна опция
-kpr).

                         Таблица 3.3.
                   Опции Resource Compiler.
______________________________________________________________
  Опция                       Что она делает
______________________________________________________________
-?          Выдает справочную информацию по опциям
            Resource Compiler (подобно -H).
-dSymbol    Определяет Symbol для препроцессора.
-e          Изменяет положение  глобальной памяти для DLL выше
            ЕМS.
-feFileName Переименовывает файл .EXE на FileName.
-foFileName Переименовывает файл .RES на FileName.
-h          Выдает справочную информацию по опциям
            Resource Compiler (подобно -?).
-iPath      После поиска текущего справочника для файлов вклю-
            чения и файлов ресурсов, RC ищет справочник с име-
            нем Path. Опцию -i можно повторить, если Вы хотите
            задать более одного пути  для  поиска.  См.  также
            описание опции -х.
-k          Включает оптимизацию  загрузки  для  сегментов   и
            ресурсов.  (Обычно Resource Compiler перезагружает
            все сегменты данных,  несбрасываемые сегменты кода
            и сегмент кода точки входа,  даже если сегменты не
            были помечены как PRELOAD в файле определения  мо-
            дуля.  Вдобавок, Resource Compiler обычно помещает
            все перезагружаемые сегменты в прилегающую область
            в выполнимом файле).
-l          Информирует Windows,  что приложение будет исполь-
            зовать expanded память, в соответствии со специфи-
            кацией LIM 3.2.
-lim32      Подобно опции -l.
-m          Назначает каждый образец задания различным  банкам
            EMS, если expanded память под Windows была сконфи-
            гурирована под EMS 4.0.
-mulinst    Подобно опции -m.
-p          Делает DLL закрытым ради одного или более образцов
            единственного приложения, что должно улучшить про-
            изводительность.
-r          Компилирует файл .RC в файл .RES,  но не добавляет
            его к .EXE.
-t          Создает приложение,   которое   будет  выполняться
            только в стандартном режиме или улучшенном  режиме
            386  (защищенном режиме).  Если пользователь пыта-
            ется работать в действительном режиме, будет выда-
            но сообщение.
-v          Показывает все сообщения компилятора (многословная
            компиляция).
-x          Исключает поиск в справочниках,  названных в пере-
            менной среды INCLUDE. Также см. описание опции -i.
______________________________________________________________

              Динамические библиотеки редактора.

     Динамическая библиотека  редактора (DLL) - это библиотека
функций,  которые может вызвать модуль Windows для  выполнения
задания. Если Вы уже писали приложения Windows, то использова-
ли DLL. Файлами DLL, а не приложения (что подразумевает расши-
рение .ЕХЕ) являются KERNEL.EXE, USER.EXE и GDI.EXE. Ссылки на
функции API, которые Вы вызываете из этих модулей, решаются во
время выполнения (динамическое редактирование), вместо времени
редактирования (статическое редактирование).

         Компиляция и редактирование DLL внутри IDE.

     Чтобы компилировать и редактировать DLL внутри  IDE,  вы-
полните следующие шаги:
     1. Создайте исходные файлы DLL.  Можно (но необязательно)
создать файл ресурсов и файл определения модуля.
     2. Выберите Project/Open для начала нового проекта.
     3. Выберите  Project/Add  item и добавьте исходный и файл
ресурсов для DLL.
     4. Если  Вы  создали файл определения модуля для DLL,  то
добавьте его к проекту. (Заметим, что Borland C++ может редак-
тировать и без него).
     5. Выберите Options/Application/Windows dynamic  library.
Чтобы  редактировать без файла определения модуля для DLL,  Вы
должны пометить каждую функцию как экспортируемую в DLL с  по-
мощью ключевого слова _export.  (Ключевое слово _export должно
непосредственно предшествовать имени функции). Вдобавок, выбе-
рите  Options/Compiler/Entry/Exit  Code/Windows  DLL  Explicit
Functions Exportable.
     6. Выберите Compile/Build All.

     Компиляция и редактирование DLL из командной строки.

     Чтобы компилировать и редактировать DLL,  составленный из
исходного файла LIBXAMP.CPP, наберите
         BCC -WD lixamp.cpp
     Компилятор командной строки сам займется  редактированием
с правильными кодом запуска и библиотеками.  Опция -WD говорит
компилятору строить Windows DLL со всеми экспортируемыми функ-
циями.  Чтобы компилировать и редактировать с явными экспорти-
руемыми функциями,  Вы должны использовать опцию -WDE и ключе-
вое  слово  _export для функций экспорта.  Чтобы редактировать
DLL с редактором командной строки TLINK,  Вы можете  использо-
вать командную строку:
TLINK /Twd /v /c /LC:\BORLANDC\LIB c0ds libxamp,libxamp, , cwinc cs
import,libxamp
     Опция /Twd  указывает  на  Windows DLL,  /v говорит TLINK
включать отладочную информацию,  /c приводит к различению  ре-
гистра в символах public и external.  Опция /L задает путь по-
иска библиотеки и файла запуска.

                  Файлы определения модуля.

     Файл определения  модуля не является таким уж необходимым
для редактирования приложения Windows или DLL.
     Есть два способа сказать компилятору о функциях экспорта:
     - Чтобы редактировать с файлом определения  модуля,  соз-
дайте раздел EXPORTS в файлу определения модуля, который пере-
числит все функции,  которые будут использоваться другими при-
ложениями (Сделать это Вам поможет утилита IMPDEF).
     - Чтобы редактировать без файла  определения  модуля,  Вы
должны  пометить  каждую экспортируемую функцию в DLL ключевым
словом _export.  Вдобавок,  когда Вы строите или  редактируете
DLL, Вы должны выбратьOptions/Compiler/Entry/Exit Code/Windows
DLL Explicit Functions Exportable.
     Перед тем,  как  функция  будет  импортироваться в другие
приложения DLL, она должна экспортироваться из DLL.

                     Библиотеки импорта.

     Если модуль приложения Windows или какой-либо другой  мо-
дуль  DLL использует функции из DLL,  то есть два способа ска-
зать компилятору об этом:
     - Можно добавить раздел IMPORTS к файлу определения моду-
ля и перечислить все функции из DLL,  которые будет  использо-
вать этот модуль.
     - Или можно включить библиотеку импорта для DLL  при  ре-
дактировании модуля.  (Библиотеку импорта для одного или более
DLL создает утилита, называемая IMPLIB).

                        Создание DLL.

     Следующие разделы дают информацию по специфике  написания
DLL.

                        LibMain и WEP.

     Функция LibMain  -  это  основная точка входа для Windows
DLL; Вы должны поставлять ее сами.
     Windows вызывает  LibMain  один  раз  при первой загрузке
библиотеки.  LibMain выполняет инициализацию для DLL. Эта ини-
циализация почти полностью зависит от функции конкретного DLL,
но может включать следующие задания:
     - Разблокирование  сегмента  данных с помощью UnlockData,
если он был объявлен как MOVEABLE.
     - Установка  глобальных  переменных  для  DLL,  если  они
используются.
     - Регистрация Windows для DLL.
     Примечание. Начальный код DLL C0Dx.OBJ инициализирует ло-
кальную  кучу  автоматически;  Вам  не  нужно  включать  код в
LibMain для этого.
     Эта функция  вызывается  Windows  (фактически библиотекой
времени выполнения) при инициализации DLL. Вы должны предоста-
вить  его  при построении DLL.  В LibMain передаются следующие
параметры:
     int PASCAL LibMain(HANDLE hInstance, WORD wDataSeg,
                        WORD cbHeapSize, LPSTR lpCmdLine)
     HANDLE, WORD и LPSTR определяются в windows.h.
     HANDLE hInstans - это обработчик образца DLL.
     WORD wDataSeg  -  это  значение  регистра сегмента данных
                       (DS).
     WORD cbHeapSize  - это размер локальной кучи,  заданный в
                        файле определения модуля для DLL.
     LPSTR lpCmdLine  -  это  дальний  указатель  на командную
строку,  заданную при загрузке DLL.  Это  почти  всегда  NULL,
поскольку DLL обычно загружается автоматически без параметров.
Однако можно предложить командную строку DLL,  когда он загру-
жается явно.
     Значение, возвращаемое для LibMain - это или 1  (успешная
инициализация),  или 0 (неудачная инициализация). Если возвра-
щается 0, Windows выгрузит DLL из памяти.
     Точкой завершения DLL является функция WEP (которая стоит
в качестве процедуры выхода Windows).  Эта функция не является
необходимой  в  DLL  (поскольку  библиотеки времени выполнения
Borland C++ предоставляют ее по умолчанию), но может быть пре-
доставлена  программистом,  пишущим DLL,  для чистки DLL перед
его выгрузкой из памяти.  Windows будет вызывать процедуру WEP
перед самой выгрузкой DLL.
     WEP должен выполнять все чистки,  необходимые для DLL.  В
Borland   C++   необязательно  объявлять  WEP  экспортируемой.
Borland C++ определяет свою собственную функцию  WEP,  которая
вызовет Вашу WEP,  а затем выполнит системную чистку. Прототи-
пом для WEP является:
     int FAR PASCAL WEP (int n Parameter)
     int nParameter   -   это    или    WEP_SYSTEMEXIT,    или
WET_FREE_DLL.  Первый  означает,  что все в Windows прекращает
работу, а второй указывает, что этот DLL будет выгружаться.
     WEP должен  вернуть 1 в случае успеха.  Windows не делает
ничего при возвращении этого значения.

                     Указатели и память.

     Функции в  DLL  не  редактируются  прямо   в   приложении
Windows,  но вызываются во время выполнения. Это означает, что
вызовы DLL функций будут дальними вызовами,  поскольку DLL бу-
дет  иметь сегмент кода,  отличающийся от приложения.  Данные,
используемые вызываемыми функциями DLL также должны быть даль-
ними.
     Предположим, что имеется  приложение  Windows,  названное
APP1,  DLL определяется с помощью LSOURCE1.C, а файл заголовка
для этого DLL называется lsource1.h.  Функция f1, которая опе-
рирует со строками, вызывается этим приложением.
     Если Вы хотите,  чтобы функция работала корректно,  неза-
висимо  от  модели  памяти,  под которой будет компилироваться
DLL,  Вы должны явно сделать функции и их данные  дальними.  В
файле заголовка прототип функции примет следующую форму:
     extern FAR f(char FAR *dstring);
     В DLL реализация функции примет следующую форму:
     far f1(char FAR *dstring)
     {
       ...
     }
     Для функции,  которая будет  использоваться  приложением,
она  также  должна быть откомпилирована как экспортируемая,  а
затем экспортироваться.  Для этого можно или компилировать DLL
со всеми экспортируемыми функциями (-WD) и занести f1 в раздел
EXPORTS файла определения модуля,  или пометить функцию ключе-
вым словом _export, как в примере:
     far _export f1(char far *dstring)
     {
       ...
     }
     Если Вы компилируете DLL  под  большой  моделью  (дальние
данные,  дальний код), то Вам не нужно явно определять функции
и их данные как дальние в DLL.  В файле заголовка прототип все
еще будет иметь такую форму:
     extern FAR f(char FAR *dstring);
     поскольку прототип  нуждается в корректировке для модуля,
откомпилированного с меньшей моделью памяти. В DLL функция мо-
жет быть задана следующим образом:
     _export f1(char *dstring)
     {
       ...
     }

                     Статические данные.

     Все приложения, использующие DLL, имеют доступ к глобаль-
ным данным этого DLL через функции DLL. Конкретная функция бу-
дет  иметь  те же данные независимо от приложения,  которое ее
вызывает. Если Вы хотите, чтобы глобальные данные DLL были за-
щищены для использования одним приложением, Вы должны написать
эту защиту сами.  Сам DLL не имеет механизма для  того,  чтобы
сделать  глобальные  данные  доступными для одного приложения.
Если Вам нужно сделать данные личными для программ, вызывающих
DLL,  то Вы должны динамически разместить данные и вручную уп-
равлять доступом к этим данным. Статические данные в DLL явля-
ются глобальными для всех программ, вызывающих DLL.

                   Классы и указатели С++.

     Классы С++, которые используются только вне DLL, не нужно
объявлять как дальние. Если класс будет использоваться из дру-
гого  DLL  как приложение Windows,  то это требует специальной
обработки.
     Все элементы   данных   и  элементы-функции  разделяемого
класса должны быть дальними.  Это можно сделать путем объявле-
ния  элементов  класса как far или компиляцией DLL под большой
моделью памяти.  Классы должны быть экспортируемыми, что может
быть сделано двумя способами:
     - или включить  имена  всех  элементов  класса  в  раздел
EXPORTS в файле определения модуля,  а затем компилировать DLL
с опцией компилятора,  которая делает все функции экспортируе-
мыми (-WD);
     - или пометить целый класс ключевым словом  _export,  от-
компилировать  DLL  с опцией компилятора,  которая делает явно
все функции экспортируемыми (-WDЕ).
     Классы С++  используют  указатели  виртуальных  таблиц  и
включают спрятанный указатель this.  Оба этих указателя  также
должны быть дальними. Есть два основных способа сделать это.
     Один из способов - просто компилировать модули DLL и при-
ложение, используя DLL с опцией Far C++ Virtual Table Pointers
(Options/Compiler/C++ options в IDE или -Vf из командной стро-
ки). Это приводит к тому, что все указатели виртуальной табли-
цы и параметры This становятся полными 32-битовыми  указателя-
ми.  Преимущество этого заключается в том, что не требуется ни
каких изменений исходного кода.  Хотя это может быть менее эф-
фективно;  все классы, разделяемые или нет, допускают 32-бито-
вые указатели.
     Более эффективным  способом является объявление разделяе-
мых классов как  huge  вместо  far.  Это  говорит  компилятору
использовать  полные  32-битовые  указатели  только  для  этих
классов.  Заметим,  что huge класс может наследовать только от
других  huge  классов.  Ниже  приведен пример определения huge
класса:
     class   huge   DLLclass
     {
       ...
     }
     Для класса,  который задан в DLL как используемый из при-
ложения Windows,  его не-inline  элементы-функции  и  элементы
статических  данных нужно сделать доступными,  сделав их имена
экспортируемыми.  Это может быть сделано путем  добавления  их
public  имен (укороченных) в разделе EXPORTS в файле определе-
ния модуля DLL, но это может быть утомительно.
     Есть более легкая альтернатива:  объявить классы, которые
будут экспортироваться, как _export. Как только класс объявлен
как  _export,  Borland  C++ будет обрабатывать его как huge (с
32-битовыми указателями) и автоматически экспортирует все  его
не-inline элементы-функции и элементы статических данных. Если
Вы объявите класс как _export,  Вы не можете уже объявить  его
как far или huge.  (_export подразумевает huge, что подразуме-
вает far).
     Если Вы объявите класс в файле включения, который включа-
ется как исходными файлами DLL, так и исходными файлами прило-
жения,  использующего DLL, то такой класс должен быть объявлен
как _export при компиляции DLL, и просто как huge при компиля-
ции приложения. Чтобы сделать это, Вы можете использовать мак-
рос __DLL__,  который определяется компилятором во время пост-
роения  DLL.  Следующий код может быть частью файла включения,
который задает разделяемый класс:
     #ifdef __DLL__
     #define EXPORT _export
     #else
     #define EXPORT   huge
     #endif

     class   EXPORT   DLLclass
     {
       ...
     }
     Заметим, что  компилятор  кодирует  (в укороченном имени)
информацию,  какой  элемент  класса  является  элементом  huge
класса. Это гарантирует, что при компиляции программы, исполь-
зующей huge и не-huge классы все несоответствия будут  пойманы
редактором связей.
