                           ГЛАВА 6.

            КОМПИЛЯТОР В РЕЖИМЕ КОМАНДНОЙ СТРОКИ.

     В дополнение  к  использованию  интегрированной   усовер-
шенствованной  среды можно компилировать и запускать программы
Borland C++ с интерфейсом командной строки, на который позднее
ссылаются как компилятор в режиме командной строки. Компилятор
командной строки делает больше,  чем простая компиляция  Ваших
файлов.  Это фактически версия командной строки IDE. Почти все
что можно сделать внутри IDE,  можно также сделать,  использую
компилятор  командной строки.  Можно установить или отказаться
от выдачи сообщения,  использовать EMS или нет,  выполняться в
действительном или защищенном режиме,  вызывать TASM (или дру-
гой Ассемблер) для ассемблирования исходных файлов .ASM и т.д.
Фактически, чтобы ТОЛЬКО компилировать, Вы должны использовать
опцию -с в командной строке.
     Примечание. Компилятор в режиме командной строки позволя-
ет вызывать все функции компилятора IDE  из  командной  строки
DOS.
     Эта глава разделена на две части. Первая часть описывает,
как  использовать  компилятор командной строки и предоставляет
таблицу всех опций.  Вторая часть представляет опции, разбитые
по функциональным группам.
     Итоговая таблица 6.1 представляет все  опции  компилятора
командной строки.

         Использование компилятора командной строки.

     Можно запустить  компилятор  командной  строки в действи-
тельном или защищенном режиме.  Можно использовать  защищенный
режим,  если  у  Вас есть 286,  386 или i486 с по крайней мере
640К обычной RAM и по крайней мере 576К extended или симулиро-
ванной  expanded  памяти;  возможно  Вы предпочтете работать в
этом режиме. В противном случае используйте действительный ре-
жим.
     Эаметим, что хотя Вы можете запускать Borland C++ в защи-
щенном режиме, Вы все еще генерируете приложения для запуска в
действительном режиме.  Огромное преимущество в  использовании
Borland C++ в защищенном режиме заключается в том,  что компи-
лятор  имеет  ГОРАЗДО  больше  места  для  выполнения,  чем  в
действительном  режиме,  в  то время как Ваше приложение имеет
больше памяти в действительном режиме.

             Выполнение в действительном режиме.

     Для вызова Borland C++ из командной строки в действитель-
ном режиме наберите BCC в ответ на подсказку DOS, а за ней на-
бор параметров командной  строки.  Параметры  командной  сроки
включают  опции компилятора и редактора связей,  а также имена
файлов. Общий формат командной строки выглядит следующим обра-
зом:
     bcc [option [option...]] filename [filename...]
     За двумя  исключениями,  впереди  каждой  опции командной
строки идет дефис (-), и она отделяется от команды ВСС, других
опций  и  следующих  за  ней имен файлов по крайней мере одним
пробелом.
     Примечание.Можно также  использовать  файл конфигурации.

               Выполнение  в защищенном режиме.

     Выполнение Borland C++ в защищенном режиме вызывает взаи-
модействие  между  тремя   файлами:   BCCX.EXE,   BCCX.OVY   и
TKERNEL.EXE.  BCCX.EXE  загружает TKERNEL и BCCX.OVY,  которые
являются  версией  защищенного  режима  компилятора  командной
строки.  Хотя BCCX.EXE загружает эти файлы автоматически,  так
что Вам самим не надо касаться их вызова, но нужно проследить,
чтобы  они  оба  находились  на пути или в справочнике запуска
BCCX.EXE так, чтобы он мог их найти.
     Как только Вы проверили,  что пути установлены правильно,
выполнение Borland C++ в защищенном режиме становится таким же
простым, как и в действительном режиме; синтаксис идентичен за
исключением того, что вместо BCC используется BCCX:
     bccх [option [option...]] filename [filename...]
     Опции и имена файлов идентичные ВСС;  более того далее  в
этой  главе при упоминании компилятора командной строки мы бу-
дем иметь в виду как ВСС,  так и ВССХ (если это не будет отме-
чено особо).
     Примечание. ВССХ.EXE загружает TKERNEL каждый раз при вы-
зове  BCCX.  Можно сэкономить много времени путем перезагрузки
TKERNEL; перед запуском BCCX наберите:
     TKERNEL hi=yes
     в командной строке DOS.  Когда Вы завершите сеанс  работы
Borland C++, наберите:
     TKERNEL rem
для удаления TKERNEL.
     Если Вы используете компилятор командной строки в  соеди-
нении с Windows, то Вы должны набрать:
     TKERNEL hi=yes kilos=1024
и вызвать Windows, используя опцию /s (стандартный режим).

                     Использование опций.

     Опции разделяются на три основных типа:
     - опции компилятора;
     - опции редактора связей;
     - опции среды.
     Примечание. Опции  компилятора в свою очередь разделяются
на десять групп.
     Чтобы посмотреть на экране список большинства опций,  на-
берите ВСС или ВССХ (без опций или имен  файлов)  в  ответ  на
подсказку DOS, а затем нажмите Enter.
     Для того чтобы выбрать опции  командной  строки,  введите
дефис (-),  а за ним сразу букву опции (например,  -l).  Чтобы
выключить опцию,  добавьте второй дефис после буквы опции. Это
правильно для опций переключения (тех, которые переключаются с
On на Off): дефис после опции отключает опцию, а знак плюс (+)
или отсутствие знака включает ее.  Таким образом, например, -С
и -С+ обе включают вложенные комментарии,  в то время как  -С-
отключает опцию для вложенных комментариев.
     Примечание. Используйте это свойство для перекрытия уста-
новок в файлах конфигурации.

                  Правила старшинства опций.

     Правила старшинства опций просты;  опции командной строки
вычисляются слева направо с применением следующих правил:
     - Для любой опции, НЕ являющейся опцией -l или -L, повто-
рение справа перекрывает такую же опцию слева. (Таким образом,
опция Off справа отменяет опцию On слева).
     - Опции -l и -L слева,  однако,  имеют старшинство  перед
такой же опцией справа.

                         Таблица 6.1.
                Обзор опций командной строки.
______________________________________________________________

Опция                            Функция
_______________________________________________________________
@filename       Дает компилятору командной строки имя
                командного файла
+filename       Говорит компилятору командной строки использо-
                вать альтернативный файл конфигурации filename
-1              Генерирует инструкции 80186
-1-             Генерирует инструкции 8088/8086
-2              Генерирует совместимые инструкции в защищенном
                режиме 80286
-А              Использование только ключевых слов ANSI
-A или -АТ      Использование ключевых слов Borland C++
                (по умолчанию)
-АК             Использование только ключевых слов Kernighan и
                Ritchie
-AU             Использование только ключевых слов UNIX
-а              Выравнивание по словам
-а-             Выравнивание по байтам (по умолчанию)
-В              Компиляция и вызов Ассемблера для обработки
                inline ассемблерного кода
-b              Делает вычисления размером в слово (по умолча-
                нию)
-b-             Делает вычисления со знаком или без
-С              Разрешаются вложенные комментарии
-С-             Запрещаются вложенные комментарии (по  умолча-
                нию)
-с              Компиляция в .OBJ, но без редактирования связей
-Dname          Определение name со строкой,  состоящей из ну-
                левого символа
-Dname=string   Определение name в string
-d              Слияние одинаковых строк установлено в On
-d-             Слияние одинаковых строк установлено в Off
                (по умолчанию)
-Еfilename      Использовать filename, как Ассемблер для
                использования
-efilename      Редактирование связей для создания filename.EXE
-Fc             Генерирует COMDEF
-Ff             Создает автоматически дальние переменные
-Ff=size        Создает автоматически дальние переменные;
                устанавливает предел
-Fm             Делает допустимыми опции -Fc, -Ff и -Fs
-Fs             Предполагается, что DS=SS во всех моделях
                памяти
-f              Эмуляция чисел  с плавающей точкой (по умолча-
                нию)
-f-             Не выполнять вычисления с плавающей точкой
-ff             Быстрые вычисления с плавающей точкой
                (по умолчанию)
-ff-            Строгие вычисления с плавающей точкой ANSI
-f87            Использование инструкций аппаратного обеспече-
                ния 8087
-f287           Использование инструкций аппаратного обеспече-
                ния 80287
-G              Оптимизация скорости
-G-             Оптимизация размера (по умолчанию)
-gn             Предупреждения: остановиться после n сообщений
-H              Компилятор генерирует и использует
                откомпилированные заголовки
-H-             Отключает генерацию и использование
                откомпилированных заголовков (по умолчанию)
-Hu             Компилятор использует, но не генерирует
                откомпилированные заголовки
-H=filename     Устанавливает имя файла для откомпилированных
                заголовков
-h              Использовать быструю арифметику Huge указателей
-Ipathname      Справочники для включаемых файлов
-in             Длина значащих символов идентификатора равна n
-jn             Ошибки: остановиться после n сообщений
-K              По умолчанию символьный тип unsigned
-K-             По умолчанию символьный тип signed (задано по
                умолчанию)
-k              Стандартная структура стека включена (по умол-
                чанию)
-Lpathname      Справочники для библиотек
-lx             Передача опции х редактору связей (можно
                использовать более одного х)
-l-x            Подавление опции х для редактора связей
-M              Инструкция редактору связей создать файл .MAP
-mc             Компиляция с  использованием   модели   памяти
                compact
-mh             Компиляция с использованием модели памяти huge
-ml             Компиляция с   использованием   модели  памяти
                large
-mm             Компиляция с  использованием   модели   памяти
                medium
-mm!            Компиляция с   использованием   модели  памяти
                medium; предполагается DS!=SS
-ms             Компиляция с использованием модели памяти small
                (по умолчанию)
-ms!            Компиляция с использованием модели памяти small;
                предполагается DS!=SS
-mt             Компиляция с использованием модели памяти tiny
-mt!            Компиляция с использованием модели памяти tiny;
                предполагается DS!=SS
-N              Проверка переполнения стека
-npath          Справочник вывода
-O              Оптимизация команд перехода
-O-             Нет оптимизации (по умолчанию)
-ofilename      Компиляция исходного файла в filename.OBJ
-P              Выполняет компиляцию  С++ независимо от расши-
                рения исходного файла
-Pext           Выполняет компиляцию   С++   и   устанавливает
                расширение по умолчанию ext
-Р-             Выполняет компиляцию С или С++ в зависимости от
                расширения файла (по умолчанию)
-Р-ext          Выполняет компиляцию С или С++ в зависимости от
                расширения файла; устанавливает расширение
                по умолчанию ext
-р              Использование соглашений вызова Паскаль
-р-             Использование соглашений вызова Си (по умолча-
                нию)
-Qe             Инструкция компилятору     использовать    всю
                доступную память EMS (по умолчанию)
-Qe-            Инструкция компилятору  не использовать память
                EMS
-Qx             Инструкция компилятору     использовать    всю
                доступную память extended
-Qx=nnnn        Инструкция компилятору зарезервировать nnnn Кб
                памяти extended для других программ, а всю
                оставшуюся использовать
-Qx=nnnn,yyyy   Инструкция компилятору зарезервировать nnnn Кб
                памяти extended для других программ и yyyy для
                себя
-Qx=,yyyy       Инструкция компилятору зарезервировать уууу Кб
                памяти extended для себя
-Qx-            Инструкция компилятору не использовать память
                extended
-r              Использование регистровых переменных (по умол-
                чанию)
-r-             Подавляет использование регистровых переменных
-rd             Позволяет хранить в регистрах только объявлен-
                ные регистровые переменные
-S              Создает файл вывода .ASM
-Tstring        Передает string как опцию в TASM или ассемблер,
                заданный с -Е
-Т-             Удаляет все предыдущие ассемблерные опции
-Uname          Отменяет все предыдущие определения name
-u              Генерация подчеркиваний включена (по умолчанию)
-u-             Генерация подчеркиваний отключена
-V              Разумные виртуальные таблицы С++
-Vs             Локальные виртуальные таблицы С++
-VО,-V1         External и Public  виртуальные таблицы С++
-Vf             Дальние виртуальные таблицы С++
-v, -v-         Отладка исходного кода включена
-vi, -vi-       Управляет расширением inline функций
-W              Создает .OBJ для Windows со всеми экспортируе-
                мыми функциями
-WS             Создает .OBJ для Windows, использующий обратные
                вызовы
-w              Показ предупреждений включен
-wxxx           Делает возможным сообщение-предупреждение ххх
-w-xxx          Делает невозможным сообщение-предупреждение ххх
-X              Делает невозможным вывод автозависимости
                компилятора
-Y              Делает возможной генерацию оверлейного кода
-Yo             Делает оверлейными откомпилированные файлы
-y              Номера строк включены
-Z              Делает возможной оптимизацию использования ре-
                гистра
-zAname         Класс кода
-zBname         Класс BSS
-zCname         Сегмент кода
-zDname         Сегмент BSS
-zEname         Дальний сегмент
-zFname         Дальний класс
-zGname         Группа BSS
-zHname         Дальняя группа
-zPname         Группа кода
-zRname         Сегмент данных
-zSname         Группа данных
-zTname         Класс данных
-zX*            Использование имени по умолчанию для Х
                (по умолчанию)
_____________________________________________________________

                  Синтаксис и имена файлов.

     Borland C++ компилирует файлы в соответствии со следующим
набором правил:
     filename.asm   Вызвать TASM для ассемблирования в .OBJ
     filename.obj   Включить как объект во время
                    редактирования
     filename.lib   Включить как библиотеку во время
                    редактирования
     filename       Компилировать FILENAME.CPP
     filename.c     Компилировать FILENAME.C
     filename.cpp   Компилировать FILENAME.CPP
     filename.xyz   Компилировать FILENAME.XYZ
     Примечание. Файлы Си++ имеют расширение .СРР.
     Например, следующая командная строка
    BCC -a -f -C -O -Z -emyexe oldfile1 oldfile2 nextfile
     приведет к   тому,   что   Borland    C++    скомпилирует
OLDFILE1.CPP, OLDFILE2.CPP и NEXTFILE.CPP в .OBJ, а редактиро-
вание связей  создаст  выполнимый  файл  программы,  названный
MYEXE.EXE, с выбранными опциями: выравниванием слов (-а), эму-
ляцией чисел с плавающей точкой (-f), вложенными комментариями
(-С),  оптимизацией  (-O)  и с оптимизированным использованием
регистра (-Z).
     Borland C++  вызовет  TASM,  если Вы зададите файл .ASM в
командной строке или если файл .С  или  .СРР  содержит  inline
ассемблерный код. Опциями, которые компилятор командной строки
передаст в TASM, являются:
        /D_ _MODEL_ _ /D_ _lang_ _ /ml /floatopt
     где MODEL - это или TINY,  или  SMALL,  или  MEDIUM,  или
COMPACT,  или LARGE или HUGE. Переключатель /ml приводит к то-
му,  что TASM ассемблирует с различением прописных и  строчных
букв.  lang - это CDECL или PASCAL; floatoptp - это r, если Вы
задали -f87 или -f287; в противном случае e.

                       Командные файлы.

     Если Вы хотите задать много опций и/или файлов в  команд-
ной строке, Вы можете поместить их в текстовый файл ASCII, на-
зываемый командным файлом.  Чтобы компилятор командной  строки
читал  командную  строку  из этого файла,  надо включить соот-
ветствующее имя файла с префиксом @ в командную строку.  Можно
задать  любое  количество таких файлов и свободно смешать их с
другими опциями и/или именами файлов.
     Например, предположим, что файл MOON.RSP содержит STARS.C
и RAIN.C.  Следующая  команда  приведет  к  компиляции  файлов
SUN.C, STARS.C, RAIN.C и ANYONE.C:
     BCC SUN.C @MOON.RSP ANYONE.C
     Любые опции,  включенные  в  командный файл,  вычисляются
точно также, как если бы они были набраны в командной строке.


                     Файлы конфигурации.

     Если Вы обнаружили, что снова и снова используете опреде-
ленный набор опций,  то можете перечислить их в файле конфигу-
рации, названный TURBOC.CFG по умолчанию. Если у Вас есть файл
конфигурации TURBOC.CFG,  то  не  нужно  беспокоиться  об  его
использовании.  Когда Вы запускаете ВСС (или ВССХ), он автома-
тически ищет TURBOC.CFG в текущем справочнике.  Если он не на-
ходит  его  там И Вы работаете под управлением DOS 3.х и выше,
то Borland C++ затем продолжит  поиск  в  справочнике  запуска
(где находятся файлы ВСС.ЕХЕ или ВССХ.ЕХЕ).
     Можно создать более  одного  файла  конфигурации;  каждый
должен иметь уникальное имя.  Чтобы задать уникальное имя аль-
тернативного файла конфигурации,  включите это  имя  файла  со
стоящим  перед  ним  + в любом месте командной строки ВСС (или
ВССХ).
     Например, чтобы   прочитать   установку  опций  из  файла
D:\ALT.CFG, Вы можете использовать следующую командную строку:
     ВCC +D:\ALT.CFG ......
     Ваш файл конфигурации может использоваться  вдобавок  или
вместо опций,  введенных в командной строке. Если Вы не хотите
использовать конкретные опции,  перечисленные  в  Вашем  файле
конфигурации,  то  Вы  можете  перекрыть  их опциями командной
строки.
     Можно создать  файл  TURBOC.CFG (или любой альтернативный
конфигурационный файл),  используя любой стандартный  редактор
ASCII  или процессор слов,  такой как интегрированный редактор
Borland C++. Вы можете перечислить опции (разделенные пробела-
ми) в одной строке или перечислить их на разных строках.

                  Правила старшинства опций.

     Опции, заданные в командной строке, перекрывают те же са-
мые опции,  заданные в файле конфигурации. Это свойство перек-
рытия  опций файла конфигурации опциями командной строки явля-
ется важным свойством.  Если,  например, Ваш файл конфигурации
содержит несколько опций,  включая опцию -а (которую Вы хотите
отключить),  Вы можете использовать файл конфигурации,  но пе-
рекрыть  опцию -а посредством перечисления опции -а- в команд-
ной строке.
     К приведенным выше правилам старшинства опций добавляются
еще два правила:
     1. Когда  опции из файла конфигурации комбинируются с оп-
циями командной строки,  опции -l и -L из  файла  конфигурации
добавляются в правую часть командной строки. Это означает, что
справочники включенных файлов и библиотек,  заданные в команд-
ной строке,  являются первыми справочниками, в которых Borland
C++ ищет включенные файлы и файлы библиотек (что дает справоч-
никам  -L  и  -l  в командной строке приоритет над такими же в
файле конфигурации).
     2. Остальные  опции  файла конфигурации вставляются слева
списка опций командной  строки  сразу  за  командой  ВCC  (или
ВССХ).  Это дает опциям командной строки приоритет над опциями
файла конфигурации.

                      Опции компилятора.

     Опции компилятора в режиме командной строки  Borland  C++
разделяются на десять групп:
     1. ОПЦИИ МОДЕЛИ ПАМЯТИ позволяют задать,  под  какой  мо-
делью памяти Borland C++ будет компилировать Вашу программу.
     2. МАКРО-ОПРЕДЕЛЕНИЯ позволяют задать и отменить макро  в
командной строке.
     3. ОПЦИИ ГЕНЕРАЦИИ КОДА управляют такими характеристиками
генерации кода, как опция чисел с плавающей точкой, соглашение
вызова, символьный тип или инструкции CPU.
     4. ОПЦИИ ОПТИМИЗАЦИИ позволяют задать способ, которым оп-
тимизируется объектный код;  с оптимизацией размера  или  ско-
рости,  с или без использования регистровых переменных,  с или
без предположений о псевдоименах.
     5. ОПЦИИ  ИСХОДНОГО КОДА приводят к тому,  что компилятор
распознает или игнорирует определенные свойства исходного  ко-
да:   ключевые   слова,   определенные  реализацией  (не-ANSI,
не-Kernighan и Ritchie,  и не-UNIX),  вложенные комментарии  и
длина идентификаторов.
     6. ОПЦИИ СООБЩЕНИЯ ОБ ОШИБКАХ позволяют Вам сделать наст-
ройку, какие сообщения об ошибках будет выдавать компилятор, и
максимальное число предупреждений и ошибок, которое может про-
изойти до остановки компиляции.
     9. ОПЦИИ ПАМЯТИ EMS И EXTENDED позволяют управлять  коли-
чеством памяти expanded и extended, которую будет использовать
Borland C++.
    10. ОПЦИИ  ВИРТУАЛЬНЫХ ТАБЛИЦ С++ позволяют управлять тем,
как будут обрабатываться виртуальные таблицы.

                        Модель памяти.

     Опции модели памяти позволяют сказать Borland C++,  какую
модель памяти использовать при компиляции Вашей программы. Су-
ществуют  следующие  модели  памяти:  tiny,   small,   medium,
compact,  large и huge (очень маленькая,  небольшая,  средняя,
компактная,  большая и огромная).
-mc  Компиляция с использованием модели памяти compact
-mh  Компиляция с использованием модели памяти huge
-ml  Компиляция с использованием модели памяти large
-mm  Компиляция  с  использованием модели памяти medium
-mm! Компиляция с использованием модели памяти medium;
     предполагается DS!=SS
-ms  Компиляция с использованием модели памяти small
     (по умолчанию)
-ms! Компиляция с использованием модели памяти small;
     предполагается DS!=SS
-mt  Компиляция с использованием модели памяти tiny
-mt! Компиляция с использованием модели памяти tiny;
     предполагается DS!=SS
     Примечание. Информацию о моделях памяти  (что  они  собой
представляют,  как  используются)  см.  в  главе 6 руководства
программиста.
     Конечный эффект новых опций -mt!,  -ms!  и -mm!  на самом
деле очень невелик.  Если Вы возьмете адрес  переменной  стека
(авто  или параметр),  то по умолчанию (DS==SS) результирующим
указателем станет ближний указатель (относительно DS).  В этом
случае  он  просто назначает адрес на указатель с умалчиваемым
размером в этих моделях без проблем.  Когда DS!=SS,  то созда-
ется  тип  указателя,  когда Вы берете адрес переменной стека,
являющейся указателем _ss.  Это означает,  что указатель может
быть  свободно  назначен или передан в дальний указатель или в
указатель _ss.  Но для искусственных моделей памяти назначение
адреса  ближнему указателю или указателю с умалчиваемым разме-
ром приведет к появлению  предупреждения  "Suspicious  pointer
conversion"   (Подозрительное  преобразование  указателя).  Вы
должны рассматривать этот вид предупреждений,  как  будто  это
ошибка.

                    Определения макросов.

     Определения макросов  позволяют  задать или отменить мак-
росы (также называемые manifest или symbolic константы) в  ко-
мандной  строке.  Определением  по  умолчанию является нулевая
строка. Макросы, заданные в командной строке, перекрывают мак-
росы в исходном файле.
-Dname          Задает идентификатор name строке, состоящей из
                нулевого  символа
-Dname=string   Задает идентификатор name для строки string
                после знака равенства. string не должна
                содержать никаких пробелов или табуляции
-Uname          Отменяет все предыдущие определения
                идентификатора name
     Borland C++  позволяет  выполнять  многочисленные  записи
#define в командной строке одним из следующих способов:
     - Можно  включить многочисленные записи после одной опции
-D,  разделяя записи точкой с запятой (так называемые "группо-
вые" опции);
         ВСС -Dxxx;yyy=1;zzz=NO myfile.c
     - Можно  поместить более одной опции -D в командной стро-
ке:
         ВСС -Dxxx -Dyyy=1 -Dzzz=NO myfile.c
     - Можно смешивать групповые и многократные списки -D:
         ВСС -Dxxx -Dyyy=1;zzz=NO myfile.c

                    Опции генерации кода.

     Эти опции управляют такими характеристиками генерации ко-
да,  как опция чисел с плавающей  точкой,  соглашение  вызова,
символьный тип или инструкции CPU.
-1     Приводит к тому, что Borland C++ генерирует расширенные
       инструкции 80186.  Эта опция также генерирует программы
       80286, выполняющиеся в реальном режиме, как с IBM PC/AT
       под управлением DOS.
-1-    Приводит к тому,  что Borland C++ генерирует инструкции
       8088/8086.
-2     Приводит к тому,  что Borland C++ генерирует инструкции
       80286, совместимые с защищенным режимом.
-a     Приводит к  выравниванию размеров целых чисел и больших
       элементов  по  границе  машинного  слова.  В  структуру
       вставляются  экстра-байты  для  выравнивания элементов.
       Автоматические  глобальные   переменные   выравниваются
       должным образом. Переменные char и unsigned char и поля
       могут быть размещены по любому  адресу;  все  остальные
       будут  размещены  по четным адресам (по умолчанию уста-
       новлено Off, допуская побайтное выравнивание).
-b     Эта опция (установленная по умолчанию) приводит к тому,
       что компилятор всегда размещает целое слово  для  пере-
       числимых типов.  (Это также способ, которым Turbo C 2.0
       обрабатывает перечисления).
-b-    Эта опция  говорит  компилятору  размещать  знаковый  и
       беззнаковый байт,  если минимальное и максимальное зна-
       чения  перечисления  находятся  в диапазоне от 0 до 255
       или от -128 до 127 соответственно.
-d     Сливает строки  литер,  когда одна строка соответствует
       другой;  это приводит к созданию программ меньшего раз-
       мера По умолчанию отключена (-d-).
-f     Эмулирует вызовы 8087 во время выполнения, если система
       времени  выполнения не имеет 8087;  если она его имеет,
       то вызывает 8087 для выполнения вычислений с  плавающей
       точкой (по умолчанию).
-Fc    Эта опция генерирует общие переменные (COMDEF) для гло-
       бальных  переменных "С",  которые не инициализируются и
       не объявляются  как  static  или  extern.  Преимущество
       использования  этой опции заключается в том,  что файлы
       заголовков,  которые включаются  в  несколько  исходных
       файлов,  могут содержать объявления глобальных перемен-
       ных. При условии, что данная переменная не требует ини-
       циализации в ненулевое значение,  Вам не нужно включать
       определение для нее ни в один из исходных файлов. Можно
       использовать  эту  опцию при перенесении кода,  который
       имеет подобные свойства с другой реализацией.
       В моделях памяти tiny, small и medium переменные COMDEF
       будут  генерироваться  как ближние;  в моделях compact,
       large и huge они будут дальними.
-Ff    При использовании  этой  опции  глобальные  переменные,
       большие  или равные предельному размеру,  автоматически
       делаются компилятором дальними.  Предельный  размер  по
       умолчанию равен 32767; можно изменить его с помощью оп-
       ции -Ff=size. Эта опция полезна для кода, не использую-
       щего модель памяти huge,  но объявляет достаточно боль-
       шие глобальные переменные,  общий размер которых превы-
       шает (или близок) 64К.
-Ff=   Используйте эту опцию для изменения предельного  разме-
size   ра, используемого опцией -Ff.
-Fm    Эта опция делает допустимыми все другие опции -F  (-Fc,
       -Ff  и  -Fs).  Можно использовать ее как сокращение при
       перенесении кода из других компиляторов.
-Fs    Эта опция говорит компилятору,  что DS равен SS во всех
       моделях памяти;  можно использовать ее при  перенесении
       кода,  написанного для реализации, которая делает часть
       стека сегментом данных. При задании этой опции компиля-
       тор будет редактировать в альтернативном модуле запуска
       (C0Fx.OBJ), который помещает стек в сегмент данных.
-f     Эта опция  говорит компилятору эмулировать вызовы 80х87
       во время выполнения, если система времени выполнения не
       имеет  80х87;  если  есть,  то  компилятор вызывает чип
       80х87 для вычислений с плавающей точкой (по умолчанию).
-f-    Определяет, что программа не содержит вычислений с пла-
       вающей точкой,  поэтому библиотеки вычислений с плаваю-
       щей точкой на шаге редактирования связей не будут подк-
       лючены редактором.
-ff    Быстрое вычисление с плавающей точкой. Компилятор опти-
       мизирует операции с плавающей точкой независимо от  яв-
       ного или неявного преобразования типов. Ответ можно по-
       лучить быстрее,  чем при режиме операций под ANSI.  До-
       полнительную  информацию  см.  в главе 7 "Математика" в
       Руководстве программиста.
-ff-   Отключает опцию быстрого вычисления с плавающей точкой.
       Компилятор точно следует правилам ANSI в соответствии с
       преобразованиями чисел с плавающей точкой.
-f87   Генерирует операции над  числами  с  плавающей  точкой,
       используя inline инструкции 80х87, а не вызовы программ
       эмуляции библиотек 80х87.  Устанавливает, что математи-
       ческий  сопроцессор будет доступен во время выполнения;
       программы,  откомпилированные с этой опцией,  не  будут
       запускаться на машине,  не имеющей математического соп-
       роцессора.
-f287  Подобно -f87, но использует только те инструкции, кото-
       рые доступны с чипом 80287 (высшим).
-h     Эта опция  предлагает  альтернативный способ вычисления
       выражений с huge указателем;  этот  способ  значительно
       быстрей,  но  пользоваться  им нужно с большой осторож-
       ностью. При использовании этой опции указатели нормали-
       зуются только тогда, когда циклический возврат от нача-
       ла к концу сегментов происходит в части  смещения.  Это
       может  привести к возникновению проблем для huge масси-
       вов,  если какие-то элементы массива пересекают границу
       сегмента. Эта опция по умолчанию отключена.
       Обычно Borland  C++  нормализует  huge указатель всякий
       раз при добавлении к или при вычитании из него. Это га-
       рантирует,  что,  например,  если  имеется huge массив,
       состоящий из struct,  который больше 64К, то индексиро-
       вание массива и выбор поля struct всегда будет работать
       со struct любого размера. Borland C++ выполняет это пу-
       тем постоянной нормализации результатов операций с huge
       указателем,  так что часть смещения содержит число,  не
       превышающее 15.  При этом способе никогда не происходит
       циклический возврат от начала к концу сегмента  с  huge
       указателями. Недостаток этого метода заключается в том,
       что он значительно снижает скорость выполнения.
-K     Приводит к тому,  что компилятор рассматривает все объ-
       явления char как тип unsigned char. Это допускается для
       совместимости с другими компиляторами, которые рассмат-
       ривают объявления char как unsigned.  По умолчанию объ-
       явления char являются signed (-К-).
-k     Генерирует стандартную структуру стека, которая полезна
       для отладчика при трассировке назад по стеку  вызванных
       подпрограмм. По умолчанию эта опция включена.
-N     Генерирует логическую схему переполнения стека на входе
       каждой  функции,  что  приводит к появлению сообщения о
       переполнении стека при его обнаружении.  Это отражается
       как на размере программы,  так и на скорости, но тем не
       менее полезно,  так как переполнение стека очень трудно
       обнаружить. Если обнаруживается переполнение стека, пе-
       чатается сообщение  "Stack  overflow!"  (стек  перепол-
       нен!), а программа завершается с кодом завершения, рав-
       ным 1.
-p     Заставляет компилятор  генерировать все вызовы подпрог-
       рамм и функции с использованием последовательности  пе-
       редачи параметров Паскаль.  Результирующие вызовы функ-
       ции становятся меньше и быстрее.  Функции  должны  кор-
       ректно  передавать число и типы параметров,  не как при
       обычном использовании Си,  который допускает переменное
       число параметров функций.  Можно использовать утвержде-
       ние cdecl для перекрытия этой опции и  особо  объявлять
       функции, чтобы они были типа Си. По умолчанию эта опция
       отключена (-р-).
-u     Когда эта опция указана,  то при объявлении идентифика-
       тора Borland C++ автоматически помещает знак  подчерки-
       вания  (_)  перед  идентификатором при его сохранении в
       объектном модуле.  Borland C++ обрабатывает идентифика-
       торы  типа  Паскаль  (модифицированные  ключевым словом
       pascal) иначе - они изображаются прописными  буквами  и
       НЕ имеют префикс в виде знака подчеркивания.
       Подчеркивания для идентификаторов Си необязательны,  но
       эта опция задана по умолчанию. Ее можно отключить с по-
       мощью -u-. Однако при использовании стандартных библио-
       тек Borland C++ Вы столкнетесь  с  множеством  проблем,
       если  не  сделаете заново построение библиотек.  (Чтобы
       сделать это,  Вам нужно иметь исходные коды  библиотеки
       времени выполнения Borland C++;  для получения дополни-
       тельной информации обратитесь к фирме Borland).
       Примечание. Если  Вы неопытный программист,  не исполь-
       зуйте опцию -u-.  Дополнительную информацию о подчерки-
       ваниях см.  в главе 9 "Интерфейс с языком Ассемблера" в
       руководстве программиста.
-X     Делает невозможной генерацию  информации  об  автомати-
       ческой зависимости в файле вывода. Модули, откомпилиро-
       ванные с этой опцией,  не смогут использовать  свойство
       автоматической  зависимости  интегрированной  среды или
       MAKE.  Обычно эта опция используется только для файлов,
       которые должны быть помещены в файлы .LIB (для экономии
       пространства на диске).
-Y     Генерирует код,  совместимый с оверлеем.  Каждый файл в
       оверлейной программе должен быть откомпилирован с  этой
       опцией;  дополнительную  информацию  об оверлеях см.  в
       главе 6 "Управление  памятью"  в  Руководстве  програм-
       миста.  Примечание. Нельзя использовать эту опцию, если
       Вы используете любую из опций -W (приложения  Windows),
       и наоборот.
-Yo    Делает оверлейным компилируемый файл(ы);  см. главу 6 в
       Руководстве  программиста  для получения дополнительной
       информации.
-y     Включает номера  строк в объектный файл для использова-
       ния символическим отладчиком, таким как Turbo Debugger.
       Это  увеличивает размер объектного файла,  но не влияет
       на размер и скорость выполнимой  программы.  Эта  опция
       полезна только для символического отладчика, использую-
       щего эту информацию.  Вообще, для Turbo Debugger полез-
       ней опция -v.
-v     Компилятор включает отладочную информацию в  файл  .OBJ
       так,  что файлы, откомпилированные с этой опцией, можно
       отлаживать как в интегрированном отладчике Borland C++,
       так и в автономном Turbo Debugger. Компилятор также пе-
       редает эту опцию редактору  связей,  поэтому  он  может
       включать отладочную информацию в файл .EXE.
       Для облегчения  отладки  этот  переключатель приводит к
       тому,  что inline функции Си++ обрабатываются как обыч-
       ные функции. Если Вы хотите избежать этого, используйте
       -vi.
       Примечание. Turbo   Debugger  является  отладчиком  как
       исходного уровня (символическим),  так и  ассемблерного
       уровня.
-vi    inline функции Си++ будут расширены.
       Примечание: Для того, чтобы управлять расширением функ-
       ций inline,  действие опции -v для  Си++  незначительно
       отличается.  Когда расширение функции inline недопусти-
       мо, функция будет генерироваться и вызываться как любая
       другая  функция.  Отладка  с наличием inline расширения
       будет существенно  отличаться,  поэтому  мы  предлагаем
       следующие опции:
         -v        Отладка  включается, а  inline   расширение
                   отключается.
         -v-       Отладка отключается, а  inline   расширение
                   включается.
         -vi       inline расширение переключается на On.
         -vi-      inline расширение переключается в Off.
             Поэтому, например,   если   Вы   хотите  включить
             одновременно отладку  и  inline  расширение,   вы
             должны использовать два переключателя: -v -vi

                         Опции оптимизации.

     Опции оптимизации позволяют задать способ,  которым опти-
мизируется объектный код; с оптимизацией размера или скорости,
с или без использования  регистровых  переменных,  с  или  без
предположений о псевдоименах.
-G     Приводит к тому,  что компилятор влияет на оптимизацию,
       отдавая предпочтение скорости в ущерб размеру.
-G-    Приводит к тому,  что компилятор влияет на оптимизацию,
       отдавая предпочтение размеру в ущерб скорости (установ-
       лена по умолчанию).
-O     Включает оптимизацию.  Эта оптимизация устраняет излиш-
       ние переходы (такие,  как переход в переход) и излишние
       копии идентичного кода, которые попадают на то же место
       (слияние). Так же подавляется излишняя загрузка регист-
       ров.  Когда опция -Z отключена, то эта опция не изменит
       режима работы Вашей программы (конечно,  за исключением
       того, что код станет более эффективным).
-O-    Оптимизация отключена. Компилирует быстро, создавая код
       низкого уровня.
-r     Разрешает использование   регистровых   переменных  (по
       умолчанию).
-r-    Подавляет использование   регистровых  переменных.  При
       использовании опции -r-,  компилятор не использует  ре-
       гистровые  переменные  и не сохраняет регистровые пере-
       менные (SI, DI) из любого вызова. По этой причине нель-
       зя иметь код,  использующий регистровые переменные, для
       вызова кода, откомпилированного с опцией -r-.
       С другой стороны,  если есть интерфейс  с  существующим
       ассемблерным кодом, не сохраняющим SI, DI, то опция -r-
       позволяет вызвать этот код из Borland C++.
       Примечание. Если Вы не являетесь опытным программистом,
       не используйте -r-.
-rd    Разрешает хранение в регистрах только  объявленных  ре-
       гистровых переменных.
-Z     Эта опция позволяет компилятору предполагать, что пере-
       менные  недоступны  как прямо,  так и через указатель в
       той же функции.  Эта опция  оказывает  действие  только
       вместе с опцией -O.
       Компилятор хранит таблицу, которая отражает текущее со-
       держание регистров.  Если переменная была загружена  из
       памяти  в  регистр,  то компилятор помнит,  что регистр
       сейчас  содержит  копию  переменной.  Если   переменная
       используется  снова,  то  компилятор использует копию в
       регистре, а не переменную в памяти.
       Опция -Z определяет, как компилятор обрабатывает непря-
       мые назначения (т.е.,  назначения через  указатели  или
       назначения через ссылки в C++). Обычно он предполагает,
       что это назначение может изменить любую переменную. Бо-
       лее  того,  он должен забыть о всех копиях переменных в
       регистрах (т.е., очистить таблицу). -Z говорит компиля-
       тору,  что непрямые назначения не изменят переменных, и
       более того, они являются безопасными для сохранения ко-
       пий.
       Последнее утверждение говорит о том, что если Вы имеете
       доступ  к  переменной (или прямой,  или через указатель
       внутри одной и той же функции),  то установка -Z  МОЖЕТ
       сгенерировать неправильный код и,  следовательно, небе-
       зопасна для использования.  С другой стороны, она БУДЕТ
       создавать более быстрый код.
       Примечание. Будьте осторожны, когда используете эту оп-
       цию.  Компилятор не может обнаружить,  что регистр стал
       недействительным посредством непрямого  назначения  или
       через указатель.

                    Опции исходного кода.

     Опции исходного  кода  приводят  к  тому,  что компилятор
распознает или игнорирует определенные свойства исходного  ко-
да:   ключевые   слова,   определенные  реализацией  (не-ANSI,
не-Kernighan и Ritchie,  и не-UNIX),  вложенные комментарии  и
длина идентификаторов.  Эти опции имеют большое значение, если
Вы собираетесь передать код в другие системы.
-A     Компилирует код, совместимый с ANSI: любые из расширен-
       ных ключевых слов Borland C++ игнорируются и могут быть
       использованы как обычные идентификаторы.  Этими словами
       являются:
          _cs     _ss      far        near      _loadds
          _ds     asm      huge       pascal
          _es     cdecl    interrupt  _export
       и регистровые псевдопеременные, такие как _AX, _BX, _SI
       и так далее.
       Примечание. Полный список ключевых слов Borland C++ со-
       держится  в  главе  1  "Лексическая грамматика" в Руко-
       водстве программиста.
-A-    Использовать ключевые слова Borland C++.  -AT  является
       альтернативной версией этой опции.
-AK    Использовать только ключевые слова Kernighan и Ritchie.
-AU    Использовать только ключевые слова UNIX.
-C     Допускается вложенность комментариев.  Обычно коммента-
       рии вкладывать нельзя.
-in    Приводит к тому,  что компилятор распознает только пер-
       вые n символов идентификатора.  Все идентификаторы: пе-
       ременные, имена макросов препроцессора, имена элементов
       структуры и т.д.  воспринимаются как различные,  только
       если отличаюся первые n символов.
       По умолчанию,  Borland C++ использует  32  символа  для
       идентификатора.  Другие системы, включая некоторые ком-
       пиляторы UNIX,  игнорируют  все  символы  после  первых
       восьми.  Если Вы вошли в другую среду, Вы можете отком-
       пилировать свой код с меньшим числом значащих символов.
       Компиляция таким образом поможет Вам увидеть,  могут ли
       быть какие-нибудь конфликты имен в длинных  идентифика-
       торах,  если  они  отсекаются до меньшей длины значащих
       символов.

                 Опции сообщения об ошибках.

     Опции сообщения об ошибках позволяют Вам сделать настрой-
ку,  какие  сообщения об ошибках будет выдавать компилятор,  и
максимальное число предупреждений и ошибок, которое может про-
изойти до остановки компиляции.
     Знак звездочка (*) указывает, что опция включена по умол-
чанию. Все остальные опции по умолчанию отключены.
-gn    Останавливает компиляцию  после n сообщений (и об ошиб-
       ках, и предупреждений).
-jn    Останавливает компиляцию после n сообщений об ошибке.
-w     Эта опция приводит к тому,  что  компилятор  показывает
       сообщения-предупреждения.  Ее можно отключить с помощью
       -w-.  Можно разрешить или запретить особые предупрежде-
       ния с помощью -wxxx, описанной ниже.
-wxxx  Делает возможным предупредительное сообщение, указанное
       ххх.  Опция  -w-xxx подавляет предупредительное сообще-
       ние,  указанное ххх.  Подробное объяснение  предупреди-
       тельных сообщений см. в главе 10 "Сообщения об ошибках"
       в Руководстве программиста. Здесь перечисляются возмож-
       ные опции для -wxxx,  которые разделяются на четыре ка-
       тегории:  нарушения ANSI, частые ошибки, предупреждения
       переносимости   и   предупреждения  Си++.  Также  можно
       использовать pragma warn в своем исходном коде для  уп-
       равления  этими опциями.  См.  главу 4 "Препроцессор" в
       Руководстве программиста.

                       Нарушения ANSI.

-wbbf    Битовые поля должны быть signed или unsigned int.
-wbfs*   Нетипированное битовое поле предполагает signed int.
-wbig*   Шестнадцатиричное значение содержит более трех цифр.
-wdcl*   Объявление не задает признак или идентификатор.
-wdpu*   Объявление function до использования в прототипе.
-wdup*   Переопределение macro не идентично.
-weas    Присвоение integer_val переменной типа enumeration.
-wext*   Identifier объявлен и как внешний, и как статический.
-wpin    Эта инициализация заключена в скобки только частично.
-wret*   Используются возврат с и без значения.
-wstu*   Неопределенная структура structure.
-wsus*   Подозрительное преобразование указателя.
-wvoi*   void функции не могут возвращать значение.
-wzdi*   Деление на ноль.

                        Частые ошибки.

-wamb    Двусмысленные операторы нуждаются в скобках.
-wamp    Избыток & с функцией или массивом.
-wasc*   Повторная компиляция с использованием Ассемблера.
-wasm    Неизвестная инструкция Ассемблера.
-waus*   identifier    назначается  значению,  которое  никогда
         не используется.
-wdef    Возможное использование identifier перед определением.
-weff*   Код не имеет выполнения.
-wfdt*   Определение функции не может быть объявлением typedef.
-will    Неверно сформированная pragma.
-wnod    Нет объявления для функции function.
-wpar*   Параметр parameter никогда не используется.
-wpia*   Возможно неправильное присваивание.
-wpro    Вызов функции, не имеющей прототипа.
-wrch*   Недостижимый код.
-wrvl*   Функция должна возвращать значение.
-wstv    Структура передается значением.
-wuse    identifier объявляется, но никогда не используется.

                Предупреждения переносимости.

-wcln    Длинная константа.
-wcpt*   Сравнивание непереносимого указателя.
-wrng*   Константа выходит за диапазон при сравнении.
-wrpt*   Преобразование непереносимого указателя.
-wsig    Преобразование может потерять значащие цифры.
-wucp    Смешивание указателей на signed и unsigned char.

                     Предупреждения С++.

-watt*   Присваивание this является устарелым; используйте
         вместо него X::operator new.
-wbei*   Инициализация с неподходящим типом.
-whid*   Function1 скрывает виртуальную функцию function2.
-winl*   Функции, содержащие identifier, не являются inline
         расширенными.
-wlin*   Временно используется для инициализации identifier.
-wlvc*   Временно используется для параметра в вызове к
         identifier.
-wncf    Неконстантная функция function вызывает константный
         объект.
-wnci*   Константный элемент identifier не инициализирован.
-wobi*   Инициализация базы без имени класса теперь устарела.
-wofp*   Этот стиль определения функции теперь устарел.
-womf*   Устаревший синтаксис, используйте вместо него ::.
-wovl*   Использование перезагрузки сейчас не является
         необходимым и устарело.
-wscp*   identifier, являющийся и признаком, и именем
         структуры, сейчас устарел.

             Управление наименованием сегментов.

     Опции управления наименованием сегментов позволяют переи-
меновывать сегменты и переприсваивать их группы и классы.
-zAname  Изменяет имя класса сегмента кода на name. По умолча-
         нию сегмент кода присваивается классу CODE.
-zBname  Изменяет имя  неинициализированного  класса  сегмента
         данных на  name.  По  умолчанию  неинициализированные
         сегменты данных присваиваются классу BSS.
         Примечание. Не используйте эти опции,  если не имеете
         хорошего понимания  сегментации  процессора  8086.  В
         нормальных обстоятельствах Вам не понадобится задание
         имен сегментов.
-zCname  Изменяет имя кодового сегмента на name.  По умолчанию
         кодовый   сегмент  называется  _TEXT,  кроме  medium,
         large,  huge  моделей  памяти,  где  именем  является
         filename_TEXT.   (filename   здесь  представляет  имя
         исходного файла).
-zDname  Изменяет имя неинициализированного сегмента данных на
         name. По умолчанию, неинициализированный сегмент дан-
         ных  называется  _BSS,  за  исключением модели памяти
         huge,  где неинициализированный сегмент данных не ге-
         нерируется.
-zEname  Изменяет имя сегмента, где дальние объекты помещены в
         name.  По  умолчанию,  именем  сегмента  является имя
         дальнего объекта,  сопровождаемое _FAR. Имя, начинаю-
         щееся  со  знака звездочки (*) указывает,  что должна
         быть использована строка по умолчанию.
         Примечание. Дополнительную информацию о дальних  объ-
         ектах  см.  в  главе  6  "Управление памятью" в Руко-
         водстве программиста.
-zFname  Изменяет имя класса для дальних объектов на name. Имя
         по умолчанию - FAR_DATA.  Имя,  начинающееся со знака
         звездочки (*) указывает, что должна быть использована
         строка по умолчанию.
-zGname  Изменяет имя  неинициализированной  группы   сегмента
         данных на name. По умолчанию группа данных называется
         DGROUP,  за исключением модели памяти huge,  где  нет
         групп данных.
-zHname  Приводит к тому,  что дальние  объекты  помещаются  в
         группу name.  По умолчанию дальние объекты не помеща-
         ются в группу.  Имя,  начинающееся со знака звездочки
         (*) указывает, что должна быть использована строка по
         умолчанию.
-zPname  Приводит к тому,  что файлы вывода генерируются с ко-
         довой группой для сегмента кода, названного name.
-zRname  Устанавливает имя инициализированного сегмента данных
         в name.  По умолчанию инициализированный сегмент дан-
         ных называется _DATA, за исключением модели huge, где
         сегмент называется filename_DATA.
-zSname  Изменяет имя  инициализированной группы сегмента дан-
         ных на name.  По умолчанию группа  данных  называется
         DGROUP,  за  исключением  модели huge,  в которой нет
         групп данных.
-zTname  Устанавливает имя инициализированного класса сегмента
         данных в name.  По умолчанию инициализированный класс
         сегмента данных называется DATA.
-zX*     Использует имя по умолчанию  для  Х.  Например,  -zA*
         присваивает имя класса по умолчанию CODE сегменту ко-
         да.

                Опции управления компиляцией.

     Опции управления компиляцией позволяют направить компиля-
тор на компиляцию исходных файлов, будет ли Ваш код компилиро-
ваться как Си или Си++,  будут или нет использоваться откомпи-
лированные заголовки и какой вид выполнимых файлов Windows бу-
дет  создаваться.  Подробную  информацию о создании приложения
Windows см. в главе 3.
-B         Компилирует и  вызывает  Ассемблер  для   обработки
           inline ассемблерного кода.
-c         Компилирует и  ассемблирует  файлы,  названные  .C,
           .CPP и .ASM, но не выполняет команду редактирования
           связей.
-Ename     Использует name  как  имя используемого Ассемблера.
           По умолчанию используется TASM.
-H         Приводит к   тому,   что  компилятор  генерирует  и
           использует откомпилированные заголовки.
-Н-        Приводит к тому,  что компилятор не генерирует и не
           использует откомпилированные заголовки.
-Hu        Приводит к тому,  что компилятор не генерирует,  но
           использует откомпилированные заголовки.
-H=name    Эта опция  устанавливает имя файла для откомпилиро-
           ванных  заголовков.  По  умолчанию  устанавливается
           TCDEF.SYM  (находящийся  в  справочнике запуска BCC
           или BCCX).  Эта опция также  включает  генерацию  и
           использование   откомпилированных  заголовков;  она
           имеет такое же действие, что и -H.
           Примечание. Информацию об  откомпилированных  заго-
           ловках см. в приложении А.
-ofilename Компилирует названные файлы в заданный filename.obj.
-P         Компилирует исходный файл как программу Си++  неза-
           висимо от его расширения.  Компилятор будет предпо-
           лагать,  что все файлы с расширением .СРР,  а не  с
           другим расширением, заданы с кодом.
           Примечание. Эта  опция  отличается  от  опции  -P в
           Turbo C++ 1.x.
-Pext      Компилятор компилирует все файлы как С++;  он изме-
           няет расширение по умолчанию на то,  которое задано
           с помощью ext. Эта опция доступна, потому что неко-
           торые  программисты используют .С и другие расшире-
           ния как свои расширения по умолчанию для кода С++.
-P-        Эта опция  говорит  компилятору  компилировать файл
           как С или С++  в  зависимости  от  его  расширения.
           Расширением  по  умолчанию является точка СРР.  Эта
           опция установлена по умолчанию.
           Примечание. Если Вы хотите использовать  свой  код,
           написанный  в  Turbo  C  или Turbo C++,  не думая о
           расширениях имен файлов,  используйте или -Р-,  или
           -Р-С.
-P-ext     Эта опция  также  говорит компилятору компилировать
           код в зависимости от расширения (.СРР как код  С++,
           а все другие расширения имен файлов как код .С).  В
           дальнейшем он задает, какое расширение по умолчанию
           будет установлено.
-S         Компилирует названные исходные файлы и создает фай-
           лы вывода на языке Ассемблер (.ASM),  но не ассемб-
           лирует. Когда Вы используете эту опцию, Borland C++
           включает  исходные строки Си как комментарии в соз-
           даваемый файл .ASM.
-Tstring   Передает string  как  опцию в TASM (или как опции к
           Ассемблеру, заданной с -Е).
-T-        Удаляет все ранее заданные опции Ассемблера.
-W         Эта опция создает наиболее  общий  вид  выполнимого
           кода Windows,  может быть и не самого эффективного.
           Компилятор генерирует информацию экспорта для  каж-
           дой дальней функции. Это не означает, что все даль-
           ние функции действительно  будут  экспортироваться,
           это  означает  только  то,  что  для каждой дальней
           функции будет генерироваться  информация  экспорта.
           Для  того,  чтобы действительно экспортировать одну
           из этих функций,  нужно или  использовать  ключевое
           слово _export,  или добавить запись для имени функ-
           ции в разделе EXPORTS файла определения модуля.
-WD        Эта опция создает модуль для использования в DLL со
           всеми экспортируемыми функциями.
-WDE       Эта опция  создает  модуль  для использования в DLL
           только с точно экспортируемыми функциями.
-WE        Эта опция создает объектный модуль только с функци-
           ями,  явно  обозначенными  с  помощью  _export  как
           экспортируемыми.
-WS        Эта опция создает .OBJ с  функциями,  использующими
           разумные  обратные  вызовы.  Рекомендуем эту опцию,
           если Вы пишете приложения  Windows  (а  не  DLL)  в
           предположении,  что DS=SS. Эта опция упрощает прог-
           раммирование Windows;  например,  используя ее, Вам
           больше    не   понадобится   MakeProcInstance   или
           FreeProcInstance и  не  нужно  экспортировать  свою
           WndProc;  вместо  этого  вы  можете  прямо  вызвать
           WndProc.  Включение этой  опции  приводит  к  более
           быстрому выполнению Windows.
           Примечание. Не  используйте  эту опцию для модулей,
           которые будут компилироваться с huge моделью  памя-
           ти.
Примечание. Эти пять опций (-W,  -WD,  -WDE,  -WE и  -WS)  от-
носятся  к  созданию приложений Windows.  Заметим,  что нельзя
использовать любую из этих опций,  если Вы  используете  опцию
-Y.

                 Опции EMS и extended памяти.

     Если у  Вас есть extended или expanded память и Вы не за-
пускаете компилятор командной строки в защищенном  режиме,  то
компилятор может использовать всю доступную память.  Для этого
можно использовать следующие опции.
-Qe      Компилятор использует всю память EMS,  которую  может
         найти.  Это задается по умолчанию для версии действи-
         тельного режима компилятора командной  строки  (ВСС).
         Эта  опция увеличивает скорость компиляции,  особенно
         для больших исходных файлов.
-Qe=yyyy Компилятор использует  yyyy страниц (размером по 16К)
         EMS памяти для себя.
-Qe-     Компилятор не использует памяти EMS вообще.
-Qx      Компилятор использует всю  память  extended,  которую
         может найти. Как и -Qe, это увеличивает скорость ком-
         пиляции больших исходных файлов. Однако, в отличие от
         -Qe,  эту опцию нужно использовать с большой осторож-
         ностью, потому что другие программы могут уже исполь-
         зовать  память  extended  и  быть нераспознанными при
         этом.
         Например, использование устройства диска RAM VDISK  с
         этой  опцией безопасно,  в то время как использование
         некоторых программ кэш-памяти диска безопасным не яв-
         ляется.
         Примечание. Если Вы не уверены в  своих  знаниях  при
         использовании extended памяти, не используйте эту оп-
         цию.  Также не  используйте  эту  опцию  при  запуске
         ВССX.EXE.
-Qx=nnnn Компилятор резервирует  nnnn  Кб  памяти extended для
         других программ и использует сам всю  оставшуюся  па-
         мять.  Чтобы  вычислить,  сколько памяти зарезервиро-
         вать,  Вы должны сложить память,  используемую на дне
         памяти extended резидентными программами такими,  как
         RAM-диски. Например, если Вы используете кэш-диск, Вы
         можете  установить его так,  что он использует первые
         512 Кб памяти extended.  Чтобы компилятор использовал
         оставшуюся память,  задайте опцию -Qx=512. Если Вы не
         уверены в том,  сколько памяти extended  используется
         резидентными  утилитами,  такими  как  RAM-диски  или
         кэш-диски, лучше не использовать эту опцию.
-Qx=nnnn,yyyy
         Компилятор резервирует  nnnn  Кб  extended памяти для
         других программ и yyyy Кб extended памяти для себя.
-Qx=,yyyy
         Компилятор резервирует yyyy Кб  extended  памяти  для
         себя. Запятая обязательна.
-Qx-     Компилятор не использует память extended вообще.  Эта
         опция задается по умолчанию.

                   Виртуальные таблицы С++.

     Опция -V управляет виртуальными таблицами С++. Существуют
пять вариаций опции -V:
         -V    Smart C++ виртуальные таблицы
         -Vs   Local C++ виртуальные таблицы
         -V0   External C++ виртуальные таблицы
         -V1   Public C++ виртуальные таблицы
         -Vf   Far C++ виртуальные таблицы
-V   Используйте эту опцию, если хотите генерировать виртуаль-
     ные таблицы С++ (и inline функции, не расширенные inline)
     так,  что  только один образец данной виртуальной таблицы
     или inline функции будет включен в программу. Это создает
     наименьший  по  размеру и наиболее эффективный выполнимый
     код,  но использует расширения .OBJ  и  .ASM,  допустимые
     только с TLINK 3.0 и TASM 2.0 (и выше).
-Vs  Используйте эту опцию, если хотите, чтобы Borland C++ ге-
     нерировал  локальные  виртуальные  таблицы  С++ (и inline
     функции,  не расширенные inline) так,  что каждый  модуль
     получит  личный  образец  данной виртуальной таблицы (или
     inline функции), которую он использует. Эта опция исполь-
     зует  только  стандартные  конструкции .OBJ (и .ASM),  но
     создает большие по размеру выполнимые коды.
-V0, Эти опции  работают вместе для создания глобальных вирту-
-V1  альных таблиц. Если Вы не хотите использовать опции Smart
     или Local (-V или -Vs),  Вы можете использовать -V0 и -V1
     для создания и ссылки на глобальные виртуальные  таблицы.
     -V0  генерирует  external (внешние) ссылки на виртуальные
     таблицы;  -V1 создает Public определения для  виртуальных
     таблиц  (общие).  При  использовании  двух  этих опций по
     крайней мере один из модулей в программе должен быть ком-
     пилирован с опцией -V1, чтобы дать определения для вирту-
     альных таблиц. Все другие модули должны быть откомпилиро-
     ваны  с опцией -V0 для ссылки к этой Public копии (общей)
     виртуальных таблиц.
-Vf  Можно использовать  эту опцию независимо или в соединении
     с любыми другими опциями виртуальной таблицы.  Это приво-
     дит к тому,  что виртуальные таблицы создаются в сегменте
     кода вместо сегмента данных и делает указатели  виртуаль-
     ной  таблицы  полными  32-битовыми указателями (последнее
     делается автоматически,  если Вы используете huge  модель
     памяти).
     Есть две  основные  причины для использования этой опции:
     удалить виртуальные таблицы из сегмента  данных,  который
     может переполнится, и иметь возможность разделять объекты
     (классов с виртуальными функциями) между модулями,  кото-
     рые используют различные сегменты данных (например, DLL и
     выполнимый код,  использующий этот DLL). Вы должны компи-
     лировать все модули, которые могут разделять объекты либо
     полностью с этой опцией,  либо все без этой опции.  Можно
     достигнуть  того же эффекта,  используя модификаторы huge
     или _export на основе класс-за-классом.

                          Опции редактора связей.

-efilename Получает имя  выполнимой программы путем добавления
           к filename расширения .EXE  (имя  программы  станет
           filename.EXE).  filename  должно сразу же следовать
           за -е, без пробелов. Без этой опции редактор связей
           извлекает имя файла .EXE из имени первого исходного
           или объектного файла в списке имен файлов. Расшире-
           нием по умолчанию становится .DLL при использовании
           -WD или -WDE.
-lx        Передает опцию  х  редактору связей.  Переключатель
           -l-x подавляет опцию х.  После -l  может  появиться
           более одной опции.
-M         Заставляет редактор связей создавать  полную  карту
           редактора.  По  умолчанию карта редактора связей не
           создается.
           Примечание. Список опций  редактора  связей  см.  в
           разделе по TLINK в главе 7 этого руководства.

                         Опции среды.

     При работе  с  опциями  среды  помните,  что  Borland C++
распознает  два   типа   библиотечных   файлов:   implicit   и
user-specified (известные также как explicit библиотечные фай-
лы).
-ldirectory  Ищет directory,  спецификатор устройства или  имя
             пути  подсправочника,  для включаемых файлов (до-
             бавление к поиску в стандартных месторасположени-
             ях).  Спецификатор устройства является единствен-
             ной строчной или прописной буквой, сопровождаемой
             двоеточием   (:).   Справочник   является   любым
             действительным справочником или путем  справочни-
             ка. Можно использовать более одной опции справоч-
             ника -l.  Этой опции  в  верхнем  регистре  соот-
             ветствует I.
-Ldirectory  Заставляет редактор  связей  получить   объектный
             файл  начального  кода  C0x.OBJ и файлы библиотек
             Borland C++ (Cx.LIB,  CPx.LIB, MATHx.LIB, EMU.LIB
             и FP87.LIB) из названного справочника. По умолча-
             нию редактор связей ищет их в текущем  справочни-
             ке.
-nxxx        Помещает все файлы .OBJ и .ASM,  созданные компи-
             лятором,  в справочник или на устройство, указан-
             ные путем ххх.

           Поиск включаемых и библиотечных файлов.

     Borland C++  может осуществлять поиск нескольких справоч-
ников для включенных файлов и файлов библиотек.  Это означает,
что  синтаксис для опций командной строки справочников библио-
тек (-L) и справочников включенных файлов (-l),  как и #define
опция  (-D),  допускает многочисленные перечисления данной оп-
ции.
     Ниже приведен синтаксис этих опций:
     Library directories:    -Ldirname[;dirname;...]
     Include directories:    -Idirname[;dirname;...]
     Параметр dirname,  используемый с опциями -L и -l,  может
быть любым справочником или путем справочника.
     Можно ввести эти многочисленные справочники  в  командной
строке следующими способами:
     - Можно "группировать" многочисленные записи с одной  оп-
цией -L или -l, разделяя группируемые записи точкой с запятой,
подобно:
BCC -Ldirname1;dirname2;dirname3 -Iinc1;inc2;inc3 myfile.c
     - Можно поместить в командной строке  более  одной  опции
одного вида, например:
BCC -Ldirname1 -Ldirname2 -Ldirname3 -Iinc1 -Iinc2 -Iinc3 myfile.c
     - Можно  смешивать  сгруппированные  и многократные пере-
числения, например:
BCC -Ldirname1;dirname2 -Ldirname3 -Iinc1;inc2 -Iinc3 myfile.c
     Если Вы многократно включите опции -L или -l в  командную
строку,  результат будет совокупным: компилятор ищет все пере-
численные справочники или определяет заданные константы в  по-
рядке слева направо.
     Примечание. Интегрированная среда также поддерживает мно-
гочисленные справочники библиотек.

                   Алгоритмы поиска файлов.

     Алгоритмы поиска  включенных  файлов Borland C++ осущест-
вляют поиск файлов #include,  перечисленных в  Вашем  исходном
коде, одним из следующих способов:
     - Если Вы поместили утверждение #include  <somefile.h>  в
своем исходном коде, Borland C++ будет искать somefile.h толь-
ко в заданных справочниках включаемых файлов.
     - Если,   с  другой  стороны,  Вы  поместили  утверждение
#include "somefile.h" в своем коде,  Borland C++ будет  искать
somefile.h  сначала в текущем справочнике;  если он не находит
здесь файла заголовка,  он начинает поиск во включенных  спра-
вочниках, заданных в командной строке.
     Алгоритмы поиска библиотечных файлов  подобны  алгоритмам
поиска включенных файлов:
     - ЯВНЫЕ БИБЛИОТЕКИ:  Borland C++  ищет  явные  библиотеки
только в заданных справочниках библиотек; это подобно алгорит-
му поиска для #include <somefile.h>. [Явные библиотечные файлы
-  это файлы,  в которых Borland C++ автоматически редактирует
связи.  Ими являются Cx.LIB,  CWINx.LIB, EMU.LIB или FP87.LIB,
MATHx.LIB, IMPORT.LIB, OVERLAY.LIB и объектные файлы начально-
го кода (C0x.OBJ, C0Wx.OBJ или C0Dx.OBJ)].
     - НЕЯВНЫЕ БИБЛИОТЕКИ:  где Borland C++ будет искать неяв-
ные (определенные пользователем) библиотеки,  зависит частично
от того,  как Вы внесли в список имя библиотечного файла. (Оп-
ределенные пользователем библиотечные файлы - это файлы, кото-
рые Вы перечислили в командной строке или проектном файле; ими
являются имена файлов с расширением .LIB).
   - Если Вы внесли в список имя файла  неявной  библиотеки
     без устройства  или справочника (например, mylib.lib),
     Borland C++  ищет эту  библиотеку  сначала  в  текущем
     справочнике. Затем (если поиск был неуспешным) он ищет
     в заданных   справочниках   библиотек.   Это   подобно
     алгоритму поиска для #include "somefile.h".
   - Если  Вы  внесли  в  список определенную пользователем
     библиотеку с   информацией   об    устройстве    и/или
     справочнике      (например:      c:mystuff\mylib.lib),
     Borland C++ ищет ТОЛЬКО  в  том  месте,  которое  явно
     указано как  часть  имени  пути  библиотеки,  а  не  в
     заданных справочниках библиотек.
     Примечание. Ваш  код,  написанный  в любой версии Turbo С
или Turbo C++, будет работать без проблем в Borland C++.

                    Пример с замечаниями.

     Здесь приведен  пример  использования  командной   строки
Borland C++ в действительном режиме,  которая объединяет опции
многочисленных справочников библиотек и  справочников  включе-
ний.
     1. Текущим устройством является С:;  текущим справочником
является С:\TURBOC, где находится BCC.EXE. Вашей текущей пози-
цией на устройстве А является A:\ASTROLIB.
     2. Ваши включаемые файлы (.H или файлы "заголовка") нахо-
дятся в C:\TURBOC\INCLUDE.
     3. Ваши  файлы  начального кода (C0T.OBJ,  C0S.OBJ,  ...,
C0H.OBJ) находятся в C:\TURBOC.
     4. Ваши   стандартные   библиотечные  файлы  Borland  C++
(CS.LIB,  CM.LIB,  ...,  MATHS.LIB,  MATHM.LIB,  ..., EMU.LIB,
FP87.LIB и так далее) находятся в C:\TURBOC\LIB.
     5. Ваши библиотечные файлы настройки для систем star (ко-
торые  Вы создаете и которыми управляете с помощью TLIB) нахо-
дятся в C:\TURBOC\STARLIB.  Одной из этих  библиотек  является
PARX.LIB.
     6. Ваши библиотечные файлы для квазаров находятся на уст-
ройстве  А  в  \ASTROLIB.  Одной  из  этих  библиотек является
WARP.LIB.
     С этой конфигурацией Вы вводите следующую командную стро-
ку:  bcc -mm -Llib;starlib -Iinclude orion.c  umaj.c  parx.lib
a:\astrolib\warp.lib
     Borland C++ откомпилирует ORION.C и UMAJ.C в файлы .OBJ.
     Компилятор ищет  C:TURBOC\INCLUDE  для  включаемых файлов
Вашего исходного кода,  затем редактирует их с начальным кодом
модели  medium (C0M.OBJ),  библиотеками модели medium (CM.LIB,
MATHM.LIB), стандартной библиотекой эмуляции чисел с плавающей
точкой  (EMU.LIB)  и  определенными пользователем библиотеками
(PARX.LIB и WARP.LIB),  создавая  выполнимый  файл,  названный
ORION.EXE.
     Он ищет код запуска в C:\TURBOC (затем прекращает  поиск,
потому что он там находится); он ищет стандартные библиотеки в
C:\TURBOC\LIB (поиск заканчивается,  потому что они  находятся
там).
     Когда он  ищет  определенную   пользователем   библиотеку
PARX.LIB,  компилятор  сначала  ищет  в  текущем  справочнике,
C:\TURBOC.  Не найдя здесь библиотеку,  компилятор затем  осу-
ществляет  поиск  справочников  библиотек  в порядке:  сначала
C:\TURBOC\LIB,   затем   C:\TURBOC\STARLIB   (где    находится
PARX.LIB).
     Так как  для  библиотеки   WARP.LIB   задан   явно   путь
(A:\ASTROLIB\WARP.LIB), компилятор ищет только там.
