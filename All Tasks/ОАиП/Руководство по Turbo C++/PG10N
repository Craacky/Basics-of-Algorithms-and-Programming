                          ГЛАВА 10.
                    СООБЩЕНИЯ ОБ ОШИБКАХ.

     Borland C++ имеет 2 категории ошибок:  ошибки времени вы-
полнения и времени компиляции.  Ошибки времени компиляции  де-
лятся на 3 класса: фатальные ошибки, нефатальные ошибки и пре-
дупреждения. В сообщениях об ошибках появляются некоторые име-
на и значения.  Когда Вы получаете сообщение об ошибке,  соот-
ветствующее имя или значение подставляется.
──────────────────────────────────────────────────────────────
   в руководстве                          на экране
──────────────────────────────────────────────────────────────
     argument           Аргумент командной строки или другой
                        аргумент.
     class              Имя класса.
     field              Ссылка на поле.
     filename           Имя файла.
     group              Имя группы.
     identifier         Идентификатор.
     language           Язык программирования.
     member             Имя элемента данных или
                        элемента-функции.
     message            Строка сообщения.
     module             Имя модуля.
     number             Действительное число.
     option             Опция командной строки или
                        другая опция.
     parameter          Имя параметра.
     segment            Имя сегмента.
     specifier          Спецификатор типа.
     symbol             Имя символа.
     XXXXh              Четырехзначное 16-ричное число,
                        сопровождаемое h.
──────────────────────────────────────────────────────────────
     Сообщения об ошибках приведены в алфавитном ASCII  поряд-
ке; сообщения, начинающиеся с символов (, = [] и т.д.), обычно
стоят первыми. Поскольку сообщения, которые начинаются с одной
из  переменных,  нельзя  расставить в алфавитном порядке,  эти
сообщения помещены в начало.
     Например, если Вы используете функцию goforit,  Вы можете
получить сообщение:
     goforit must be declared with no arguments
     Для того,  чтобы посмотреть это сообщение об ошибке,  Вам
необходимо найти
     function must be declared with no arguments
в начале списка сообщений об ошибках.
     Если переменная встречается позднее в тексте сообщения об
ошибке (например,           "Incoorrect           command-line
argument:<argument>", то Вы должны искать сообщение в алфавит-
ном порядке; в данном случае, под буквой I.

                  Ошибки времени выполнения.

     Borland C++ имеет небольшое число ошибок времени выполне-
ния.  Эти ошибки возникают  после  того,  как  программа  была
успешно откомпилирована и выполняется.

     Abnormal program termination
     Неправильное завершение программы

     Это сообщение может выдаваться, если для выполнения прог-
раммы недостаточно памяти. Это сообщение обсуждается более де-
тально в конце раздела ошибок с плавающей точкой.  Вызов abort
активизирует это сообщение.
     Примечание: Эта ошибка может возникать, если портится па-
мять.

     Divide error
     Ошибка деления

     Это сообщение  выдается  при  делении  целого числа на 0.
Например,
     int n = 0;
     n = 2 / n;
     Оно может быть перехвачено функцией signal. Иначе вызыва-
ется abort и программа завершается.

     Floating point error: Divide by 0
     Floating point error: Domain
     Floating point error: Overflow

     Эти фатальные  ошибки  выдаются  для операций с плавающей
точкой, для которых не определен результат.
     - "Divide  by  0" означает,  что результат плюс бесконеч-
ность или минус бесконечность, как для 1.0/0.0
     - "Domain" означает, что результат NAN (не число) как для
0.0/0.0
     - "Overflow" означает, что результат - плюс бесконечность
или минус бесконечность с полной  потерей  точности,  как  при
присваивании 1Е20 * 1Е20 в double.

     Floating point error: Partial loss of precision
                           (частичная потеря точности)
     Floating point error: Underflow (нехватка точности)

     Эти ошибки  по  умолчанию  замаскированы  и  сообщения об
ошибках не появляются.  Нехватка точности преобразуется в 0, а
частичная  потеря  точности  игнорируется.  Их можно включить,
вызвав _control87.

     Floating point error: Stack fault (ошибка стека)

     Это сообщение указывает, что стек плавающей точки был пе-
рекрыт.  Обычно  эта  ошибка  не встречается и может возникать
из-за того,  что ассемблерный код использует слишком много ре-
гистров или переобъявление функции с плавающей точкой.
     Эта ошибка с плавающей точкой может быть предотвращена  с
помощью  маскирования  или  перехватом  с помощью signal.  См.
функции _control87 и signal (в Справочном руководстве по биби-
лиотеке).
     В каждом из перечисленных выше случаев  программа  выдает
сообщение об ошибке и затем вызывает abort, который печатает
     Abnormal program termination
и вызывает _exit(3). См. abort и _exit.

     Null pointer assigment
     Присваивание неинициализированному указателю.

     При выходе из программы с моделью памяти small или medium
проверяется  содержимое первых нескольких байт внутри сегмента
данных программы.  Эти байты никогда не изменяются при  работе
программы.  Если они изменены,  выдается данное сообщение, что
означает,  что было присвоено  значение  неинициализированному
указателю.  Программа в остальном может казаться правильно ра-
ботающей; однако это серьезная ошибка, которая должна быть не-
медленно исправлена. Неинициализированный указатель может при-
вести к непредсказуемым результатам (включая зависание  компь-
ютера для моделей памяти large,  compact, huge). Можно исполь-
зовать интегрированный отладчик для отслеживания нулевых  ука-
зателей.

     Stack overflow
     Переполнение стека

     По умолчанию стек для программ Borland C++ -  4096  байт.
Этого достаточно для большинства программ, которые не выполня-
ют рекурсивных функций и не сохраняют большого количества  ло-
кальных данных. Вы получите это сообщение только если включена
проверка стека.  Если Вы получили это сообщение, Вы можете по-
пытаться  перейти на большую модель памяти,  увеличивая размер
стека, или уменьшить зависимость Вашей программы от стека. См.
главу  3  "Глобальные  переменные" в Справочном руководстве по
библиотеке для информации по изменению стека  с  помощью  гло-
бальной переменной _stklen. Чтобы уменьшить количество локаль-
ной памяти,  используемой функциями, см. пример ниже. Перемен-
ная buffer, объявленная как static, не использует пространство
стека как list.
   void func(void)
   {
   static int buffer[2000];  // размещается в сегменте данных
   int list[2000];    // размещается в стеке
   }
     Есть два недостатка объявления локальных  переменных  как
статических:
     1. Они сокращают пространство,  используемое  глобальными
переменными и кучей. Обычно это минимальный недостаток.
     2. Функции могут стать повторно используемыми.  Это озна-
чает,  что если функция вызывается рекурсивно или асинхронно и
необходимо,  чтобы каждый вызов функции имел уникальную  копию
переменной, Вы не можете сделать ее статической. Это связано с
тем,  что при каждом вызове функции,  она  будет  использовать
точно то же пространство памяти для переменной, а не распреде-
лять новое пространство при каждом вызове. У Вас будут пробле-
мы, если функция вызывается из самой себя (рекурсивно) или од-
новременно (асинхронно). Если Вы не пишете рекурсивных функций
или многозадачных программ,  не беспокойтесь. В противном слу-
чае, используйте это объяснение.

              Сообщения об ошибках компилятора.

     Диагностические сообщения компилятора Borland C++ делятся
на 3 класса: фатальные ошибки, ошибки и предупреждения.
     Фатальные ошибки редки.  Некоторые из  них  указывают  на
внутреннюю ошибку компилятора. Когда возникает фатальная ошиб-
ка, компиляция немедленно останавливается. Вы должны выполнить
соответствующие действия и перезапустить компиляцию.
     Ошибки указывают на синтаксические  ошибки  в  программе,
ошибки  доступа  к диску или памяти и ошибки командной строки.
Компилятор завершит текущую фазу компиляции  и  затем  остано-
вится. Компилятор пытается найти как можно больше действитель-
ных ошибок в исходной программе во время текущей фазы компиля-
ции (препроцессорная обработка,  лексический разбор, оптимиза-
ция и генерация кода).
     Предупреждения не мешают окончанию компиляции. Они указы-
вают на условия,  которые могут быть подозрительными, но кото-
рые законны как часть языка.  Компилятор так же выдает предуп-
реждение, если Вы используете в исходном файле машинно-зависи-
мые конструкции.
     Компилятор вначале печатает класс  сообщения,  затем  имя
исходного файла и номер строки, в которой компилятор обнаружил
это условие и, наконец, само сообщение.
     Сообщения приведены  в  алфавитном  порядке внутри класса
сообщений.
     Вы должны  обратить  внимание на одну деталь относительно
номеров строк в сообщениях об ошибках:  компилятор  генерирует
сообщения по мере их обнаружения. Поскольку С  не устанавлива-
ет ограничений на размещение операторов в строке, действитель-
ная  причина  ошибки  может находиться на одну или более строк
выше указываемой строки.  В следующих сообщениях мы укажем  на
сообщения, для которых компилятор может указывать строку после
реальной ошибки.

     constructor is not a base class of class
     Констрактор не базового класса class

     Констрактор C++ класса class пытается вызвать констрактор
constructor базового класса,  или Вы пытаетесь изменить  права
доступа  class::constructor.constructor,  который  не является
базовым классом для класса class. Проверьте Ваши объявления.

     function1 cannot be distinguished from function2
     Нельзя отличить function1 от function2

     Списки параметров  в объявлениях этих двух функций не от-
личаются в достаточной степени.  Попробуйте  изменить  порядок
параметров или тип параметра в одном из объявлений.

     function cannot return a value
     Функция не может возвращать значение

     Функция с типом возврата void содержит  оператор  return,
которое возвращает значение; например, int.

     function must be declared with no arguments
     function должна быть объявлена без аргументов

     Функция оператор C++ некорректно объявлена с аргументами.

     function must be declared with one argument
     function должна быть объявлена с одним аргументом.

     Функция оператор  C++ некорректно объявлена с более,  чем
одним аргументом.

     function must be declared with two arguments
     function должна быть объявлена с двумя аргументами.

     Функция оператор  C++ некорректно объявлена с более,  чем
двумя аргументами.

     function was previously declared without static
     function была предварительно объявлена без static

     Функция объявлена здесь как static,  но ранее была объяв-
лена как extern (или глобальная).  ANSI C не разрешает  смеши-
вать эти объявления.

   function was previously declared with the language language
   function была предварительно объявлена с языком language

     Для данной функции можно использовать только один язык  с
extern. Эта функция была объявлена с различными языками в раз-
ных местах одного модуля.

Предупреждение
     function1 hides virtual function function2
     function1 скрывает виртуальную функцию function2

     Виртуальная функция в базовом классе обычно перекрывается
объявлением в производном классе.  В этом случае объявление  с
тем же именем, но с другими типами аргументов делает виртуаль-
ные функции недоступными в производных классах.

    identifier cannot be declared in an anonymous union
    identifier не может быть объявлен в анонимном объединении

     Компилятор обнаружил объявление функции элемента или ста-
тического элемента в анонимном объединении.  Такие объединения
могут содержать только элементы-данные.

     identifier cannot be used in a static member function
     identifier не может использоваться в
     статических функциях-элементах.

     Статическая функция-элемент   может  использовать  только
статический элемент своего класса,  хотя  имеет  полные  права
доступа.  Эта ошибка возникает в результате использования эле-
мента, который требует указателя this.

Предупреждение
     identifier declared but never used
     Идентификатор объявлен, но никогда не используется

     Была объявлена  переменная как часть блока,  но эта пере-
менная не использовалась.  Предупреждение выдается, когда ком-
пилятор встречает } соответствующего блока или функции.

Предупреждение
     identifier is assigned a value that is never used
     identifier присваивается значение, которое нигде не
     используется

     Переменная появляется в присваивании,  но больше нигде не
используется  в  функции.  Предупреждение  выдается только при
достижении }.

Предупреждение
   identifier is both a structure tag and a name, now obsolete
   Идентификатор используется и как имя структуры, и как тип
   структуры - это устарело

     В  С  совершенно  правильно  использовать идентификатор и
как имя структуры и как имя переменной или имя typedef, как в
     struct s { int i, j; } s;
или
     typedef struct s { int i, j; } s;
Это недопустимо в C++.

Предупреждение
     identifier is declared as both external and static
     identifier объявлен и как внешний и как статический

     Этот идентификатор появляется в объявлении,  где явно или
неявно помечен как глобальный или внешний, а так же в объявле-
нии как статический.  Идентификатор считается статическим.  Вы
должны просмотреть все объявления этого идентификатора.

     identifier is inaccessible because also in class
     identifier не доступен, поскольку так же присутствует
     в class

     Нельзя использовать   класс  одновременно  как  прямой  и
косвенный базовый класс, поскольку поля становятся неоднознач-
ными.  Попытайтесь  сделать  базовый класс виртуальным в обоих
местах.

     identifier is not a data member and can't be initialized
     here
     identifier не  данные-элемент  и не может быть
     инициализирован здесь

     Элементы-данные могут  инициализироваться в инициализато-
рах констрактора.  Это сообщение означает, что список содержит
статический элемент или функцию-элемент.

     identifier is not a member of class
     identifier не элемент структуры

     Вы пытаетесь  обратиться  к  identifier  как  к  элементу
struct, но это не элемент структуры. Проверьте объявления.

     identifier is not a parameter
     identifier не параметр

     В секции "объявления параметров" определений функции ста-
рого стиля,  identifier объявлен, но не приведен как параметр.
Либо удалите объявление,  либо добавьте identifier  как  пара-
метр.

     identifier is not legal here
     identifier не разрешен здесь

     Спецификатор типа identifier не разрешен, поскольку конф-
ликтует или дублирует другой спецификатор типа в этом объявле-
нии,  или поскольку identifier используется как  имя  typedef,
когда он не является именем typedef в этой сфере действия.

     identifier must be a member function
     identifier должен быть функцией-элементом

     Большинство функций операторов C++ могут быть  элементами
класса или обычными функциями, но некоторые из них должны быть
элементами класса. Это operator = , operator ->, operator () и
преобразования типов. Эта функция оператор не функция-элемент,
хотя должна быть функцией-элементом.

     identifier must be a member function or have an  argument
     of  class  type
     identifier должна быть функцией-элементом или иметь аргу-
     мент типа класс

     Большинство функций  операторов C++ имеют явный или неяв-
ный аргумент типа класс.  Эта функция оператор была  объявлена
вне класса и не имеет явного аргумента типа класс.

     identifier must be a previously defined class or struct
     identifier должен   быть   предварительно    определенным
     классом или структурой

     Вы пытаетесь объявить identifier как базовый класс, но он
либо не класс, либо еще не полностью определен. Скорректируйте
имя или реорганизуйте объявления.

     identifier must be a previously defined enumeration tag
     identifier должен быть предварительно определенным  пере-
     числением

     Это объявление ссылается к identifier как к типу enum, но
он не был объявлен таким образом. Скорректируйте имя или реор-
ганизуйте объявления.

     identifier must be a previously defined structure tag
     identifier должен быть предварительно определенной струк-
     турой

     Это объявление  ссылается к identifier как к типу struct,
но он не был объявлен таким образом.  Скорректируйте  имя  или
реорганизуйте объявления.

     identifier is only allowed in C++
     indentifier допустим только в С++

     В программе С  использовалась  конструкция  С++,  которая
здесь недопустима.  Это  могут быть такие специальные символы,
как :: или .* или ->*, или объявление параметра или переменной
ссылки.

     identifier specifies multiple or duplicate access
     identifier указан с несколькими или с дублированными пра-
     вами доступа

     Базовый класс может быть объявлен как public или private,
но не одновременно с двумя.  Этот спецификатор  доступа  может
появляться для базового класса не более одного раза.

     member is not accessible
     Недоступен member

     Вы пытаетесь обратиться к элементу класса member,  но  он
private или protected и к нему нельзя обратиться из этой функ-
ции.  Иногда это происходит при попытке вызвать  перегруженную
функцию-элемент (или констрактор),  но аргументы соответствуют
недоступной функции. Проверка перегруженного разрешения всегда
производится до проверки доступности. В таком случае попробуй-
те явно привести тип одного или более параметров выбора  необ-
ходимой доступной функции.

     specifier has already been included
     specifier уже был включен

     Этот спецификатор был указан в  данном  объявлении  более
одного раза. Удалите или измените одно из его появлений.

     = expected
     Ожидается =

     Ожидается оператор присваивания для  инициализации  пере-
менной.

     , expected
     Ожидается ,

     "," ожидается в списке объявлений,  инициализаций или па-
раметров.

     { expected
     Ожидается {

     Вначале блока или инициализации ожидается левая  фигурная
скобка.

     ( expected
     Ожидается (

     Перед списком параметров ожидается левая круглая скобка.

     } expected
     Ожидается }

     В конце блока или инициализации ожидается правая фигурная
скобка.

     ) expected
     Ожидается )

     В конце  списка параметров ожидается правая круглая скоб-
ка.

     : expected after private/protected/public
     После private/protected/public ожидается ":"

     В секции private/protected/public класса C++ эти резерви-
рованные слова должны сопровождаться ":".

     ::requires a preceding identifier in this context
     В этом контексте :: требует предшествующего идентификато-
     ра

     :: встретилось в объявлении без имени класса.  Неквалифи-
цированное  ::  может  использоваться  только в выражениях для
указания глобальной сферы действия, а не в объявлении.

     .* operands do not match
     Несоответствие операндов .*

     Вы не  объявили  правую часть оператора C++ .* как указа-
тель на элемент класса, указанного в левой части оператора.

     #operator not followed by macro argument name
     За оператором # не следует имя аргумента макро

     В макроопределении  # может использоваться для преобразо-
вания макроаргумента в строку.  За # должно следовать имя мак-
роаргумента.

     Access can only be changed to public or protected
     Доступ может быть изменен только на public или protected

     Производный класс C++ может модифицировать права  доступа
элемента базового  класса,  но только на public или protected.
Элемент базового класса не может быть private.

     Access declarations cannot grant or reduce access
     Объявления доступа не могут увеличить или уменьшить доступ

     Порожденные классы С++ могут модифицировать права доступа
базового элемента класса, но только восстанавливая права базо-
вого класса. Он не может увеличивать или уменьшать права.

     Access specifier specifier found in union
     Спецификатор доступа specifier найден в объединении

     Спецификатор доступа  C++  (public,  private,  protected)
нельзя использовать в объединении.

     Ambiguity between function1 and function2
     Неоднозначность между function1 и function2

     Обе перегруженные функции могут быть использованы  с  за-
данными параметрами. Эта неоднозначность неразрешима.

     Ambiguous conversion functions: type1 and type2
     Неоднозначность функций преобразования: type1 и type2

     Компилятор нашел  более  одного  способа   преобразования
исходного типа в требуемый тип. Эта неоднозначность неразреши-
ма.

Предупреждение
     Ambiguous operators need parentheses
     Неопределенные операторы, требуются скобки

     Это предупреждение выдается,  когда  2  оператора  сдвига
(условных  или  побитовых)  используются без скобок.  Оператор
сложения или вычитания,  используемый без () вместе с операто-
ром  сдвига  так  же приводит к этому сообщению.  Программисты
часто путают приоритет этих операторов.

     Array bounds missing ]
     Пропущена ] для границ массива

     В объявлении массива границы массива не заканчиваются ].

     Array must have at least one element
     Массив должен иметь по крайней мере один элемент

     ANSI C и C++ требуют, чтобы массив был определен по край-
ней мере с одним элементом (объекты нулевого размера не разре-
шены).  Старый программистский трюк объявлял массив структур с
нулевым  размером,  а затем распределял память,  действительно
необходимую, с помощью malloc. Вы можете использовать эту хит-
рость,  но  должны объявить массив элементов с по крайней мере
одним элементом. Объявления (в противоположность определениям)
массивов неизвестной длины конечно разрешена. Например,
 char ray[];  // определение неизвестного размера - неверно
 char ray[0]; // определение нулевого размера - неверно
 extern char ray[];  // объявление неизвестного размера - верно

     Array of references is not allowed
     Массив ссылок не разрешен

     Недопустимо создавать массив ссылок,  поскольку указатели
на ссылки не разрешены.

     Array size too large
     Размер массива слишком велик

     Объявленный массив больше 64К.

     Assembler statement too long
     Слишком длинный ассемблерный оператор

     Встроенный ассемблерный оператор не  может  быть  длиннее
480 байт.

Предупреждение
     Assigning type to enumeration
     Назначение type в enumeration

     Присваивается целое  значение типу enum.  Это ошибка,  но
выдается предупреждение, чтобы программа могла работать.

Предупреждение
   Assignment to this is obsolete, use X::operator new instead
   Присваивание устарело, используйте Х::operator new

     В ранних версиях C++ существовал только способ управления
распределением объектов класса с помощью присваивания парамет-
ров this внутри констрактора. Эта практика сейчас не использу-
ется,  поскольку лучше,  надежнее и более общей техникой явля-
ется определение функции-элемента operator new.

     Attempting to return a reference to local name identifier
     Попытка возвратить ссылку на локальное имя identifier

     Эта функция возвращает ссылочный тип и Вы пытаетесь возв-
ратить ссылку на локальную (auto) переменную.  Это не разреше-
но,  поскольку  эта переменная пропадает после выхода из функ-
ции.  Вы можете вернуть ссылку на любую статическую  или  гло-
бальную переменную,  или изменить функцию так, чтобы она возв-
ращала значение.

     Attempting to return a reference to a temporary object
     Попытка возвратить ссылку на временный объект

     В функции, возвращающей ссылочный тип, Вы пытаетесь возв-
ратить ссылку  на   временный   объект   (возможно   результат
констрактора или вызова функции).  Поскольку этот объект будет
пропадать при возврате функции, то ссылка будет неправильной.

Фатальная ошибка
     Bad call of inline function
     Неверный вызов inline функции

     Вы используете  inline функцию,  взятую из макроопределе-
ния,  и некорректно вызываете ее.  inline функция в С  одна из
тех, которая начинается и заканчивается со знака двойного под-
черкивания "__".

     Bad file name format in include directive
     Неверный формат файла в директиве include

     Имя включаемого файла должно быть заключено в "" или  <>.
Для имени  файла  пропущена  открывающая " или угловая скобка.
Если было использовано макро,  результирующий текст расширения
некорректен; т.е. не заключен в одиночные кавычки.

     Bad ifdef directive syntax
     Неверный синтаксис директивы ifdef

     Директива #ifdef должна содержать отдельный идентификатор
(и ничего более) как тело директивы.

     Bad ifndef directive syntax
     Неверный синтаксис директивы ifndef

     Директива #ifndef должна содержать отдельный  идентифика-
тор (и ничего более) как тело директивы.

     Bad return type for a type conversion operator
     Неверный возвращаемый тип для оператора преобразования
     типа

     Функция-элемент преобразования типа указывает тип возвра-
та, отличный от ее типа. Объявление для функции преобразования
operator T может не указывать возвращаемого типа.

     Bad syntax for pure function definition
     Ошибочный синтаксис для определения "чистой" функции

     "Чистая" виртуальная функция указывается добавлением "=0"
в объявлении. Вы написали что-то подобное, но не то же самое.

     Bad undef directive syntax
     Неверный синтаксис директивы undef

     Директива #undef должна содержать отдельный идентификатор
(и ничего более) как тело директивы.

     Base class class is included more than once
     Базовый класс class включен более одного раза

     Класс C++ может быть производным от любого числа  базовых
классов,  но может быть производным от данного класса напрямую
только однажды.

     Base class class is initialized more than once
     Базовый класс class инициализирован более одного раза

     В констракторе класса C++ список инициализаций, следующий
за заголовком констрактора, включает базовый класс class более
одного раза.

     Base class cannot be declared protected
     Базовый класс нельзя объявить как protected

     Базовый класс C++ можно объявить как public или  private,
но не как protected.

     Base inialization without a class name is now obsolete
     Базовая инициализация без имени класса устарела

     В ранних  версиях C++ предоставлялась инициализация базо-
вого класса с заголовком констрактора вместе со списком  пара-
метров. Сейчас рекомендуется включать имя базового класса.
     Это делает  код  более ясным и требуется при многократных
базовых классах.
Старый способ:
     derived::derived(int i):(i, 10) {...}
Новый способ:
     derived::derived(int i): base(i, 10) {...}

     Bit field cannot be static
     Базовое поле не может быть статическим

     Только обычные  элементы  данных  класса в C++ можно объ-
явить как static, но не битовые поля.

     Bit fields must be signed or unsigned int
     Битовые поля должны быть signed или unsigned int

     Битовое поле   должно   быть  объявлено  как  signed  или
unsigned целый тип.  В ANSI C битовое поле может  быть  только
signed или unsigned int (но не char или long например).

     Bit fields must contain at least one bit
     Битовое поле должно содержать по крайней мере 1 бит.

     Нельзя объявить именованное битовое поле  с  0  бит  (или
меньше,  чем 0). Вы можете объявить неименованное битовое поле
с длиной 0 бит,  это соглашение используется для  выравнивания
следующего  битового поля на границу байта (или границу слова,
если использована опция -a).

     Bit field too large
     Слишком длинное битовое поле

     Эта ошибка  выдается,  если  задано битовое поле с длиной
более 16 бит.

     Body already defined for this function
     Тело этой функции уже определено

     Для функции  с  этим  именем и типом было определено тело
функции.

Предупреждение
     Both return and return with a value used
     Используется и return и return со значением.

     Текущая функция содержит операторы return со и без значе-
ний.  Это разрешено в  С,  но почти всегда ошибочно.  Возможно
оператор return был пропущен в конце функции.

     Call of non-function
     Вызов не функции

     Имя, использованное в вызове,  не объявлено как  функция.
Обычно это вызвано некорректным объявлением функции или невер-
ным написанием имени функции.

Предупреждение
     Call to function with no prototype
     Вызов функции без прототипа

     Это сообщение   выдается,   если   сообщение  "Prototypes
required" (требуются прототипы) включено и Вы вызываете  функ-
цию, не имеющую прототипов.

Предупреждение
     Call to function <function> with no prototype
     Вызов функции function без прототипа

     Это сообщение  выдается,   если   сообщение   "Prototypes
required"  (требуются прототипы) включено и Вы вызываете функ-
цию <function>, не имеющую прототипов.

     Cannot add or subtract relocatable symbols
     Нельзя добавлять или вычитать перераспределяемые имена

     Единственными арифметическими операциями,  которые  могут
выполняться над   перераспределяемыми   именами   в  операндах
Ассемблера, являются сложение и вычитание  констант.  Перемен-
ные, процедуры,  функции  и метки являются перераспределяемыми
именами. В предположении,  что Var - это переменная, а Const -
это константа, то инструкции
     MOV AX,Const+Const
и
     MOV AX, Var+Const
являются правильными, а MOV AX,Var+Var неправильно.

     Cannot assign identifier1 to identifier2
     Нельзя присвоить identifier1 в identifier2

     Обе стороны оператора присваивания = (или составного опе-
ратора присваивания, такого как +=) должны быть совместимыми и
не должны быть массивами.  Правая сторона  этого  присваивания
имеет  тип identifier1 и не может быть присвоена объекту в ле-
вой части, который имеет тип identifier2.

     Cannot call 'main' from within the program
     Нельзя вызвать main изнутри программы

     C++ не позволяет рекурсивно вызывать main

     Cannot cast from identifier1 to identifier2
     Нельзя выполнить  приведение  типа   из   identifier1   в
identifier2
     Приведение типа из типа identifier1 в тип identifier2  не
разрешено.  В  Си  указатель может быть приведен к целому типу
или к другому указателю. Целый тип может быть приведен к любо-
му  целому,  с плавающей точкой или типу указателя.  Плавающий
тип может быть приведен к целому или плавающему  типу.  Нельзя
выполнить  приведение типа для структур и массивов.  Обычно Вы
не можете выполнить приведение типа из типа void.
     В C++   преобразования,   определенные  пользователем,  и
констракторы проверяются и,  если они не найдены,  применяются
предыдущие  правила  (за  исключением  указателей  на элементы
класса).  Для целых типов только константа 0 может быть приве-
дена  к указателю на элемент.  Указатель на элемент может быть
приведен к целому типу или к подобному указателю  на  элемент.
Подобный  указатель  на  элемент  ссылается на элемент данных,
если есть оригинал,  или функцию-элемент,  если есть оригинал;
квалифицирующий класс приведения типа должен быть тот же самый
или базового класса оригинала.

     Cannot create a variable for abstract class class
     Нельзя создать переменную для абстрактного класса class

     Абстрактные классы - те, которые имеют "чистые" виртуаль-
ные функции - нельзя использовать прямо,  а только производные
от них.

     Cannot define a pointer or reference to a reference
     Нельзя определить указатель или ссылку на ссылку

     Неверно определять указатель  на  ссылку  или  ссылку  на
ссылку.

     Cannot find class::class(class&) to copy a vector
     Нельзя найти class::class(class&), чтобы копировать вектор

     Когда класс  class1  содержит  вектор  (массив)   классов
class2  и Вы хотите создать объект типа class1 из другого объ-
екта     типа     class1,     должен     быть      констрактор
class2::class2(class2&), который создает элементы этого векто-
ра.  Этот констрактор использует только один параметр  (ссылку
на его класс) и называется констрактором ссылки.
     Обычно компилятор создает  констрактор  ссылки  автомати-
чески.  Однако,  если  Вы  определяете  констрактор для класса
class2,  который имеет параметр типа class2& и  дополнительные
параметры  со  значениями по умолчанию,  констрактор ссылки не
может  существовать  и  не  может  быть  создан  компилятором.
(Поскольку    нельзя   различить   class2::class2(class2&)   и
class2::class2(class2&,  int = 1).) Вы  должны  переопределить
этот  констрактор  так,  чтобы  параметры были без значений по
умолчанию.  Затем Вы можете определить констрактор ссылки  или
позволить компилятору сделать это.

     Cannot find   identifier::identifier()  to  initialize  a
     vector
     Нельзя найти identifier::identifier() для инициализации
вектора.

     Когда класс  class1  содержит  вектор  (массив)   классов
class2 и Вы хотите создать объект типа class1 но не из другого
объекта типа class1, должен быть констрактор class2::class2(),
который  создает  элементы  этого  вектора.  Этот  констрактор
используется без  параметров  и  называется  констрактором  по
умолчанию. Компилятор создает констрактор по умолчанию автома-
тически,  если Вы не определили констрактор для класса class2.
В  этом случае компилятор не использует констрактор по умолча-
нию - Вы должны определить констрактор.

     Cannot find class::class() to initialize base class
     Не может  найти class::class() для инициализации базового
класса.

     Когда C++ создает производный класс class2,  вначале дол-
жен быть создан каждый базовый класс class1.  Если констрактор
для class2 не задает констрактора для class1 (как часть  заго-
ловка  class2),  должен  быть констрактор class1::class1() для
базового класса.  Этот констрактор без  параметров  называется
констрактором по умолчанию.  Компилятор создает констрактор по
умолчанию  автоматически,  если  только   Вы   не   определите
констрактор  для  класса  class1.  В этом случае компилятор не
использует констрактор по умолчанию  -  Вы  должны  определить
констрактор.


     Cannot find class::class() to initialize field identifier
     Нельзя найти   class::class()   для   инициализации  поля
identifier

     Когда класс class1 содержит элемент класса  class2  и  Вы
хотите  создать  объект типа class1,  но не из другого объекта
типа class1, должен быть констрактор class2::class2(), который
создает этот элемент.  Этот констрактор используется без пара-
метров и называется  констрактором  по  умолчанию.  Компилятор
создает констрактор по умолчанию автоматически, если Вы не оп-
ределили констрактор для класса class2. В этом случае компиля-
тор не использует констрактор по умолчанию - Вы должны опреде-
лить констрактор.

     Cannot find  class:operator=(class&)  to  copy  a  vector
     Нельзя найти  class:operator=(class&),  чтобы скопировать
вектор.

     Когда класс  class1  содержит  вектор  (массив)   классов
class2  и  Вы хотите создать копию класса типа class1,  должен
быть оператор присваивания class2::operator=(class2&), который
копирует элементы этого вектора.
     Обычно компилятор создает такой  оператор  автоматически.
Однако,  если Вы определили operator= для класса class2, но не
тот,  который использует параметр типа class2&,  компилятор не
создает его автоматически - Вы должны определить его.

     Cannot have a near member in a far class
     Не может быть ближний элемент в дальнем классе

     Все элементы far класса должны быть дальними.  Этот  эле-
мент класса был объявлен (или по умолчанию) near.

     Cannot initialize a field
     Нельзя инициализировать поле

     Отдельные поля struct, union или class нельзя инициализи-
ровать. struct и union можно инициализировать целиком, исполь-
зуя инициализаторы внутри {}.  class  в  C++  инициализируется
только констрактором.

     Cannot initialize type1 with type2
     Нельзя инициализировать тип type1 типом type2

     Вы пытаетесь инициализировать объект типа type1 значением
типа type2,  что недопустимо.  Правила для инициализации те же
самые, что и для присваивания.

     Cannot modify a const object
     Нельзя модифицировать const объект

     Это сообщение  указывает  на неверную операцию над объек-
том,  объявленным с const, такую как присваивание этому объек-
ту.

     Cannot overload 'main'
     Нельзя перегрузить main

     main - это единственная функция,  которая не  может  быть
перегружена.

     Cannot specify  base  classes  except  when  defining the
class
     Нельзя указывать базовые классы, за исключением определе-
ния класса.

     Базовые классы,  из которых создается класс,  могут  быть
указаны только в точке определения класса. Когда Вы объявляете
класс, как в class c; , Вы не можете указывать базовые классы.

     Cannot use tiny or huge model with Windows.
     Нельзя использовать   модели   памяти  Tiny  или  Huge  с
Windows.

     Это сообщение вполне объяснимо.

     Case bypasses initialization of a local variable
     Не инициализирована локальная переменная.

     В С++ нельзя оставить локальную переменную не инициализи-
рованной. В этом случае есть метка,  которой передается управ-
ление после этой локальной переменной.

     Case constant is out of range of the selector.
     Выход константы селектора за диапазон.

     Константа метки case вышла из диапазона возможных  значе-
ний выражения переключателя, и эта метка case никогда не будет
выбрана. Например выражение switch имеет тип Int, а метка case
имеет значение,  большее,  чем  наибольшее  возможное значение
Int.

     Case outside of switch
     Case вне switch

     Компилятор встретил  оператор  case вне оператора switch.
Скорее всего пропущены {}.

     Case statement missing:
     В операторе case пропущено ":"

     Оператор case  должен  содержать  константное выражение с
последующим ":". В выражении оператора case либо было пропуще-
но ":", либо перед ":" лишние символы.

     Character constant too long
     Слишком длинная символьная константа

     Символьная константа может содержать только 1 или 2  сим-
вола.

     Classes cannot be initialized with {}
     Классы нельзя инициализировать с {}

     Обычные структуры Си могут быть инициализированы  набором
значений  внутри  {}.  Классы  C++ могут быть инициализированы
только констракторами,  если класс имеет констракторы, private
элементы, функции или виртуальные базовые классы.

     Class member member declared outside its class
     Элемент класса member объявлен вне класса

     Функции-элементы класса могут быть объявлены только внут-
ри объявления класса.  В отличие от функций не элементов,  они
не могут быть объявлены несколько раз или в других местах.

Предупреждение:
     Code has no effect
     Код не имеет эффекта

     Это предупреждение  выдается,  когда компилятор встречает
оператор, который не имеет действия. Например
     a+b
     не воздействует ни на одну переменную.  Этот оператор  не
нужен и, вероятно, указывает на ошибку.

Фатальная ошибка:
     Compiler table limit exceeded
     Превышение предела таблицы компилятора

     Это сообщение возникает в результате  переполнения  внут-
ренних таблиц компилятора. Обычно это означает, что компилиру-
емый модуль содержит слишком много объявлений класса  С++  или
слишком много функций или слишком много других элементов. Если
Вы сделаете больше доступной памяти для компилятора,  это  Вас
не спасет;  единственный  выход  - это упростить компилируемый
файл.

     Compound statement missing }
     Пропущена }

     Компилятор достиг  конца  исходного  файла  и не нашел }.
Обычно это связано с несбалансированными {}.

     Conflicting type modifiers
     Конфликтующие модификаторы типа

     Это происходит,  когда объявление включает, например, оба
ключевых слова near и far для одного  указателя.  Только  один
модификатор  адреса  можно использовать для одного указателя и
только один модификатор языка (cdecl, pascal, interrupt) можно
использовать для функции.

     Constant expression required
     Требуется константное выражение

     Массивы должны быть объявлены с постоянным размером.  Эта
ошибка обычно возникает из-за неправильного написания констан-
ты в #define.

Предупреждение:
     Constant too long
     Длинная константа

     Компилятор встретил либо  десятичную  константу,  большую
чем  32767,  либо 8-ричную (или 16-ричную) большую,  чем 65535
без символа l или L после нее.  Константа интерпретируется как
long.

Предупреждение:
     Constant member member is not initialized
     Константный элемент member не инициализирован

     Этот класс  содержит константный элемент member,  который
не инициализирован.  Заметим,  что константные элементы  могут
быть только инициализированы, но им нельзя ничего присвоить.

Предупреждение:
     Constant out of range in comparision
     Выход константы за диапазон при сравнении

     Исходный файл содержит сравнение,  включающее константное
подвыражение,  которое  выходит  за предел,  разрешенный типом
другого подвыражения. Например, сравнение unsigned целого с -1
бессмысленно.  Чтобы получить unsigned константу, большую, чем
32767 Вы должны либо привести константу к  unsigned  (например
(unsigned)65535),  либо  добавить  символ  u или U к константе
(например 65535u).
     Когда это сообщение выдается,  компилятор генерирует  код
для сравнения.

     Constructor cannot have a return type specification
     Констрактор не может иметь спецификации типа возврата

     Констракторы C++ имеют неявный возвращаемый тип,  исполь-
зуемый компилятором, но Вы не можете объявить тип возврата или
вернуть значение.

Предупреждение:
     Conversion may lose significant digits
     Сравнение может потерять значащие цифры

     Для оператора присваивания или какого-то  другого  требу-
ется  преобразование  из  long  или  unsigned  long  в int или
unsigned int.  Поскольку переменные типа int  и  long  разного
размера,  это преобразование может изменить поведение програм-
мы.

     Conversion of near pointer not allowed
     Преобразование ближнего указателя не допускается

     Ближний указатель  нельзя  преобразовать в дальний в окне
вычисления выражения, когда программа не выполняется, посколь-
ку преобразование требует текущего значения DS в программе.

     Could not find a match for argument(s)
     Нельзя найти соответствие для argument

     Не может быть найдена функция C++  с  параметрами,  соот-
ветствующими заданным аргументам.

     Could not find file filename
     Нельзя найти файл filename

     Компилятор не может  найти  файл,  заданный  в  командной
строке.

     Declaration does not specify a tag or an identifier
     Объявление не указывает имя типа или идентификатор

     Это объявление ничего не объявляет. Это может быть struct
или  union без имени типа или переменной.  C++ требует,  чтобы
что-то было объявлено.

     Declaration is not allowed here
     Объявление здесь не разрешено.

     Объявление не  может использоваться как оператор управле-
ния для while, for, do, if или switch.

     Declaration missing ;
     В объявлении пропущена ";"

     Объявление поля  struct  или union не содержит после себя
";".

     Declaration syntax error
     Синтаксическая ошибка объявления

     Это объявление  содержит  либо  некоторые лишние символы,
либо в нем пропущены символы.

     Declaration terminated incorrectly
     Неверное завершение объявления

     Объявление содержит  лишние  или некорректные символы за-
вершения,  такие как ";", помещенная после тела функции. Функ-
ция или элемент C++, объявленная в классе с ";" между заголов-
ком и {, так же приводит к этой ошибке.

     Declaration was expected
     Ожидается объявление

     Здесь ожидалось,  но  не  найдено объявление.  Обычно это
происходит из-за отсутствия разделителя такого, как , ; ( {

Предупреждение:
     Declare function prior to use in prototype
     Объявление function до использования в прототипе

     Когда прототип функции ссылается к структурному типу, ко-
торый не был объявлен, объявление внутри прототипа не совпада-
ет с объявлением вне прототипа. Например:
     int func(struct s *ps);
     struct s { /* ... */ };
     Поскольку нет  структуры s в сфере действия прототипа для
func,  тип параметра ps  -  это  указатель  на  неопределенную
структуру s и не тот же самый, как структура s, которая объяв-
лена позже.  В результате выдаются предупреждения и  ошибки  о
несовместимости  типов.  Для устранения проблемы,  переместите
объявление структуры s до любых прототипов,  которые ссылаются
на  нее  или добавьте неполное объявление struct s;  до любого
прототипа, который ссылается на s. Если параметр функции - это
struct, а не указатель на struct, неполное объявление не имеет
значения; Вы должны поместить объявление структуры до функции.

     Declare operator delete (void*) or (void*, size_t)
     Объявлен оператор delete (void*) или (void*, size_t)

     Объявлен оператор  delete с одним параметром void* или со
вторым параметром типа size_t.  Если Вы используете второй ва-
риант,  он будет использоваться вместо первой версии. Глобаль-
ный оператор delete уже объявлен с двумя параметрами так,  что
будьте внимательны, если Вы хотите перекрыть это объявление.

     Default outside of switch
     Default вне switch

     Компилятор встретил  оператор   default   вне   оператора
switch.
     Обычно это связано с несбалансированными {}.

     Default value missing
     Пропущено значение по умолчанию

     Когда функция C++  объявляет  параметр  со  значением  по
умолчанию,  все последующие параметры так же должны иметь зна-
чения по умолчанию. В этом объявлении параметр со значением по
умолчанию  содержит после себя параметры без значения по умол-
чанию.

     Define directive needs an identifier
     Директива define требует идентификатора

     Первый символ  не  разделитель  после #define должен быть
идентификатором. Компилятор обнаружил какой-то другой символ.

     Destructor cannot have a return type sppecification
     Дестрактор не может иметь спецификации возвращаемого типа

     Дестракторы C++  никогда  не  возвращают значения и Вы не
можете объявить возвращаемый тип или вернуть значение.

     Destructor for class is not accessible
     Дестрактор для class недоступен

     Дестрактор для  этого класса - protected или private и не
может быть доступен здесь для разрушения класса. Если дестрак-
тор класса - private,  класс не может быть разрушен и следова-
тельно  не  может  быть  использован.  Вероятно,  это  ошибка.
protected дестрактор может быть доступен только из производных
классов. Это полезный способ убедиться, что не создано экземп-
ляров базового класса, а только от классов, производных от ба-
зового.

     Destructor for class required in conditional expression
     В условном выражении требуется дестрактор для class

     Если компилятор  должен создать временную локальную пере-
менную в условном выражении, он не знает в каком месте вызвать
дестрактор, поскольку  переменная может быть инициализирована,
а может и нет.  Временная переменная должна быть создана явно,
как с именем класса (val,  val) или неявно посредством другого
кода. Переделайте свой код,  чтобы устранить эту временную пе-
ременную.

     Destructor name must match the class name
     Имя дестрактора должно соответствовать имени класса

     В классах C++ имя дестрактора начинается с "~". Имя дест-
рактора должно быть то же, что и имя класса.

     Division by zero
     Деление на ноль

     Ваш исходный файл содержит деление в константном  выраже-
нии с делителем, равным 0.

Предупреждение:
     Division by zero
     Деление на ноль

     Делимое или остаток имеют в качестве делителя литеральный
ноль.

     do statement must have while
     Оператор do должен иметь while

     Для оператора do пропущено ключевое слово while.

     do-while statement missing (
     В операторе do-while пропущена (

     В операторе do компилятор не обнаружил ( после  ключевого
слова while.

     do-while statement missing )
     В операторе do-while пропущена )

     В операторе do компилятор не нашел ) после условного  вы-
ражения.

     do-while statement missing ;
     В операторе do-while пропущена ;

     В операторе do компилятор не нашел ; после )

     Duplicate case
     Дублирование case

     Каждый case оператора switch должен иметь уникальное зна-
чение константного выражения.

     Enum syntax error
     Синтаксическая ошибка в enum

     Объявление enum  не  содержит  правильно  сформированного
списка идентификаторов.

     Error directive: message
     Директива ошибки: message

     Это сообщение   выдается,   когда  выполняется  директива
#error в исходном файле.  Текст  этой  директивы  выводится  в
сообщении.

     Error writing output file
     Ошибка записи в выходной файл

     Ошибка DOS при записи Borland C++ .OBJ,  .EXE или времен-
ного   файла.   Проверьте  -n  или  Options/Directories/Output
directory и убедитесь,  что указан правильный справочник.  Так
же проверьте, достаточно ли памяти на диске.

     Expression expected
     Ожидается выражение

     Здесь ожидается выражение, но текущий символ не может на-
чинать  выражение.  Это  сообщение может встречаться там,  где
ожидается управляющее выражение в if или while; или при иници-
ализации  переменной.  Часто  это  случается  из-за  случайной
вставки или удаления символа в исходном коде.

     Expression is too complicated
     Слишком сложное выражение

     Компилятор может обрабатывать очень сложные выражения, но
выражения с сотнями термов могут быть слишком  сложными.  Раз-
бейте это выражение на 2 или более.

     Expression of arithmetic type expected
     Ожидается выражение арифметического типа

     Унарные операторы + и - требуют выражения арифметического
типа - разрешены только типы char,  short,  int,  long,  enum,
float, double, long double.

     Expression of integral type expected
     Ожидается выражение целого типа

     Оператор ~  требует  выражения  целого  типа  - разрешены
только типы char, short, int, long, enum.

     Expression of scalar type expected
     Ожидается выражение скалярного типа

     Операторы !  ++  --  требуют  выражения скалярного типа -
разрешены только типы char,  short,  int,  long,  enum, float,
double, long double и типы указателей.

     Expression syntax
     Синтаксис выражения

     Это общее сообщение об ошибке, когда компилятор разбирает
выражение  и встречает серьезную ошибку.  Обычно это связано с
двумя операторами подряд,  несоответствующими или пропущенными
() или пропущенной ";" в предыдущем операторе.

     Expression type does not match the return type
     Тип выражения не соответсвует возвращаемому типу

     Тип выражения в return не может быть преобразован к  типу
функции.

     extern variable cannot be initialized
     Нельзя инициализировать внешнюю переменную

     Класс памяти extern,  примененный к переменной, означает,
что переменная объявлена,  но не определена здесь - память под
переменную не распределена. Следовательно Вы не можете инициа-
лизировать переменную как часть объявления.

     Extra parameter in call
     Лишний параметр в вызове

     Вызов функции через указатель, определенный с прототипом,
содержит слишком много аргументов.

     Extra parameter in call to function
     Лишний параметр в вызове function

     Вызов function (которая определена с прототипом) содержит
слишком много аргументов.

     Field field cannot be used without on object
     Поле field не может использоваться без объекта

     Это означает,  что пользователь написал class::field, где
field  -  это  обычный  (нестатический)  элемент и нет класса,
ассоциированного с этим  полем.  Например  правильно  написать
obj.class::field, а не class::field

     Field field is ambiguous in class
     Поле field неоднозначно в class

     Вы должны квалифицировать ссылку на поле  соответствующим
именем  базового класса.  В C++ класс class,  поле field может
быть найдено в более,  чем одном базовом классе и нет квалифи-
катора, указывающего, какой из них использовать. Это применимо
только при множественном наследовании,  где имя поля в  каждом
базовом  классе  не  скрыто  тем  же именем поля в производном
классе. Правило C++ требует, чтобы проверка на неоднозначность
была сделана до проверки на права доступа (private, protected,
public). Следовательно Вы можете получить это  сообщение  даже
если  обращаетесь  только к одному (или не обращаетесь вообще)
полю.

     Field identifier expected
     Ожидается идентификатор поля

     Здесь ожидается имя поля  класса  или  структуры.  Правая
сторона  оператора  "." или "->" должна быть полем в структуре
или классе в левой части оператора.

     File must contain at least one external declaration
     Файл должен содержать по крайней мере одно внешнее объяв-
ление

     Этот модуль  компиляции  логически  пустой  - не содержит
объявлений. ANSI C и C++ требуют, чтобы модуль компиляции объ-
являл что-либо.

     File name too long
     Слишком длинное имя файла

     Имя файла в директиве  #include  слишком  длинное.  Имена
файлов в DOS должны быть не более 79 символов.

     For statement missing (
     Пропущена ( в операторе for

     В операторе for компилятор не  нашел  (  после  ключевого
слова for.

     For statement missing )
     Пропущена ) в операторе for

     В операторе for компилятор не нашел ) после  управляющего
выражения.

     For statement missing ;
     Пропущена ; в операторе for

     В операторе for компилятор не нашел ; после одного из вы-
ражений.

     Found : instead of ::
     Найдено ":" вместо "::"

     Вы использовали :  вместо :: для разделения квалификатора
класса от его поля в объявлении или в выражении.

     Friend declarations need a function signature
     Дружественное объявление требует описание функции

     Если Вы  объявляете  дружественную  функцию,  Вы   должны
представить  типы параметров т.к.  дружественная функция может
быть найдена среди перегруженных.

     Friends must be functions or classes, not fields
     Дружественной должна быть функция или класс, но не поле

     Дружественной классу   должна  быть  функция  или  другой
класс; поле не может быть дружественным.

     Function call missing )
     В вызове функции пропущена )

     Список аргументов  в  вызове  функции  содержит синтакси-
ческую ошибку, такую как пропущенная или несбалансированная )

     Function calls not supported
     Вызов функции не поддерживается

     При вычислении  выражения в интегрированном отладчике вы-
зов  функций   (включая   функции   неявного   преобразования,
констракторы,  дестракторы,  перегруженные  операторы и inline
функции) не поддерживаются.

     Function defined inline after use as extern
     Функция определяется  как  inline после использования как
внешняя

     Функция не может стать inline после того, как она уже бы-
ла использована. Либо передвиньте определение inline функции в
файле, либо удалите его.

     Function definition cannot be a typedef'ed declaration
     Определение функции не может быть объявлением typedef

     Объявление указателя  на функцию делается более читаемым,
используя typedef.  Но в C++ такое typedef не может  использо-
ваться для определения функции.
     Например, здесь тип F - это функция без параметров, возв-
ращающая int:
     typedef int F(void);
     Неверно определять g:
     F g { /* ... */ }
     Можно определить g как функцию, возвращающую указатель на
тип F:
     F *g (...)  { /* ... */ }

     Function function cannot be static
     Функция function не может быть статической

     Только обычные  функции элементы и операторы new и delete
могут быть объявлены как статические. Констракторы, дестракто-
ры и другие операторы не должны быть статическими.

     Function function should have a prototype
     Функция должна иметь прототип

     Вызванная функция не имеет прототипа в области действия.
     В С, Int Foo(); не является прототипом, а Int Foo(Int); и
Int Foo(void) являются прототипами.  В С++ Int Foo(); является
прототипом и совпадает с Int Foo(void); В С прототипы рекомен-
дуются для  всех  функций.  В  С++ прототип требуются для всех
функций. Во всех случаях определение функции (заголовок  функ-
ции и ее тело) служит прототипом, если оно появилось перед лю-
бым другим упоминанием функции.

     Function cannot return arrays or functions
     Функция не может возвращать массив или функцию.

     Эта функция объявлена как возвращающая функцию или массив
вместо указателя на функцию или элемент массива.

Предупреждение:
     Functions containing  local  destructors are not expanded
inline in function
     Функция, содержащая  локальные дестракторы,  не расширена
inline в функции.

     Вы создали inline функцию, для которой Borland C++ отклю-
чил механизм встроенных строк. Вы можете игнорировать это пре-
дупреждение, если хотите;  функция будет генерироваться не как
inline.

Предупреждение:
     Functions containing  reserved  word  are  not   expanded
inline
     Функции, содержащие резервированное слово,  не  расширены
inline

     Функции, содержащие  одно  из  зарезервированных слов do,
for, while,  goto,  switch,  break,  continue и case, не могут
быть расширены inline, даже если были заданы как inline. Функ-
ция все еще безупречно правильна, но она будет рассматриваться
как обыкновенная статическая (а не глобальная) функция.  Копия
функции будет появляться в каждом модуле компиляции при  вызо-
ве.

Предупреждение:
     Function should return a value
     Функция должна возвращать значение

     Текущая функция возвращает тип, отличный от int или void,
но компилятор встретил возврат без значения.  Обычно это ошиб-
ка.

     Function should return a value
     Функция должна возвращать значение

     Эта функция  объявлена  (может  быть неявно) возвращающей
значение.  Оператор возврата был найден без возвращающего зна-
чения или был достигнут конец функции,  а оператор возврата не
найден. Либо вставьте возврат значения, либо измените объявле-
ние функции на возврат void.

     Functions may not be part of a struct or union
     Функция не может быть частью структуры или объединения

     Это поле  структуры  или  объединения в Си было объявлено
типа функция,  вместо указателя на функцию. Функции в качестве
полей разрешены только в C++.

     Global anonymous union not static
     Глобальное анонимное объединение не статическое

     В C++ глобальное анонимное объединение  на  уровне  файла
должно быть статическим.

     Goto bypasses initialization of a local variable
     Goto миновал инициализацию локальной переменной.

     В С++ нельзя миновать инициализацию локальной  переменной
каким-либо образом.  В этом случае есть оператор Goto, который
может передать управление после этой локальной переменной.

     Goto statement missing label
     В операторе goto пропущена метка

     За ключевым словом goto должен следовать идентификатор.

     Group overflowed maximum size: name
     Группа превышает максимальный размер: name

     Общий размер сегментов в группе (например DGROUP)  превы-
шает 64К.

     Hexadecimal value contains more then 3 digits
     16-ричное значение содержит более 3 цифр

     В старых версиях Си 16-ричная esc последовательность мог-
ла  содержать  не более 3 цифр.  Новый ANSI стандарт позволяет
задавать любое число цифр,  значение которых помещается в бай-
те.  Это предупреждение выдается, когда задана длинная 16-рич-
ная esc последовательность с  несколькими  лидирующими  нулями
(как в "\х00045").

     Identifier identifier cannot have a type qualifier
     Идентификатор identifier не может иметь квалификатор типа

     Здесь нельзя использовать квалификатор class::identifier.
Квалификатор не разрешен в именах typedef, объявлениях функций
(за исключением определений на уровне файла),  локальных пере-
менных или параметров функций или элемента класса, за исключе-
нием использования его собственного класса  как  квалификатора
(странно, но допустимо).

     Identifier expected
     Ожидается идентификатор

     Здесь ожидается,  но не найден, идентификатор. В Си это в
списке параметров заголовка функции старого типа,  после заре-
зервированных слов struct или union, когда отсутствуют скобки,
и как имя поля в структуре или объединении (за исключением би-
товых полей с длиной 0).  В C++ идентификатор так же ожидается
в  списке  базовых классов,  следующим после ::  и после слова
operator, когда не присутствует символ оператора.

     If statement missing (
     Пропущена ( в операторе if

     В операторе if компилятор не нашел ( после ключевого сло-
ва if.

     If statement missing )
     Пропущена ) в операторе if

     В операторе  if компилятор не нашел ) после условного вы-
ражения.

     Illegal character character (0xvalue)
     Неверный символ character (0хvalue)

     Компилятор встретил неверный символ во входном файле. Пе-
чатается 16-ричное значение этого символа.  Это так  же  может
возникать из-за передачи в макрофункцию лишних параметров.

     Illegal initialization
     Неверная инициализация

     Инициализация должна быть  либо  константным  выражением,
либо  адресом  глобальной extern или static переменной + или -
константа.

     Illegal octal digit
     Неверная 8-ричная цифра

     Компилятор обнаружил  8-ричную константу,  содержащую не-
восьмеричную цифру (8 или 9).

     Illegal pointer subtraction
     Неверное вычитание указателя

     Вызвана попыткой вычесть указатель из не указателя.

     Illegal structure operation
     Неверная операция над структурой

     Структуры могут использоваться только с операторами . & =
или могут передаваться в или из функций как параметры.  Компи-
лятор встретил структуру с другим оператором.

     Illegal to take address of bit field
     Нельзя взять адрес битового поля

     Нельзя взять  адрес  битового поля,  хотя Вы можете взять
адрес любого другого поля.

     Illagel use of floating point
     Неверное использование плавающей точки

     Над операндами с плавающей точкой нельзя выполнять опера-
ции сдвига,  побитовые булевские  операции,  условные  (?  :),
косвенные (*) и некоторые другие.

     Illegal use of pointer
     Неверное использование указателя

     Указатели могут  использоваться  в  сложении,  вычитании,
присваивании, сравнении, * и ->.

Предупреждение
     Ill-formed pragma
     Неверно сформированная pragma

     pragma не  соответствует ни одной из ожидаемых компилято-
ром Borland C++.


     Improper use of typedef identifier
     Неправильное использование typedef identifier

     В исходном файле используется символ typedef в выражении,
где должна появляться переменная.  Проверьте объявление симво-
ла, возможно неправильное написание.

     Improper use of a typedef symbol
     Неправильное использование typedef

     В исходном файле используется символ typedef в выражении,
где должна появляться переменная.  Проверьте объявление симво-
ла, возможно неправильное написание.

     Incompatible type conversion
     Несовместимое преобразование типа

     Требуемое приведение типа не может быть выполнено.

     Incorrect command-line option: option
     Неверная опция командной строки: option

     Компилятор не может распознать опцию командной строки.

     Incorrect configuration file option: option
     Неверная опция конфигурационного файла: option

     Компилятор не может распознать опцию  в  конфигурационном
файле; проверьте предшествующий дефис (-).

     Incorrect number format
     Неверный формат числа

     Компилятор встретил десятичную точку в 16-ричном числе.

     Incorrect use of default
     Неверное использование default

     Компилятор не   нашел  двоеточие  после  ключевого  слова
default.

Предупреждение
     Initialization is only partially bracketed
     Инициализация только частично в скобках

     При инициализации структуры скобки  могут  использоваться
для того, чтобы отметить инициализацию каждого элемента струк-
туры. Если элемент сам является массивом или структурой, могут
использоваться вложенные скобки.  Когда некоторые необязатель-
ные скобки пропущены, компилятор выдает это предупреждение.

Предупреждение
     Initializing identifier with type
     identifier инициализируется типом type

     Переменная типа  enum  инициализирована значением другого
типа. Например,
     enum count { zero, one, two } x = 2;
     В результате выдается это  сообщение,  поскольку  2  типа
int,  а не типа enum count.  Лучшей практикой программирования
является использование идентификатора enum вместо целых  чисел
при присвоении или инициализации enum типа.
     Это ошибка,  но стоит как предупреждение, чтобы дать воз-
можность программе работать дальше.

     Inline assembly not allowed in an inline function
     inline ассемблер не разрешен в inline функции

     Компилятор не может обрабатывать операторы inline ассемб-
лера в inline функции C++.  Вы можете  выполнить  это,  удалив
класс памяти inline, или inline ассемблерный код.

     Invalid combination of opcode and operands
     Неправильная комбинация кодов операций и операндов

     Ассемблерный код операций  не  допускает  эту  комбинацию
операндов. Возможными причинами ошибки являются:
     - слишком много операндов для  этого  ассемблерного  кода
или   неправильное   их  количество;  например,  INC AX,BX или
MOV AX.
     - число операндов правильно,  но их типы или  порядок  не
соответствуют коду операций;  например,  DEC 1,  MOV AX,CL или
MOV 1,AX.

     Invalid indirection
     Неверная ссылка

     Оператор ссылки * требует не void  указателя  в  качестве
операнда.

     Invalid macro argument separator
     Неверный разделитель аргументов макро

     В макроопределении аргументы должны разделяться запятыми.
Компилятор встретил после имени аргумента другой символ.

     Invalid pointer addition
     Неверное сложение указателя

     Вы пытаетесь сложить 2 указателя.

     Invalid register combination (e.g.[BP+BX])
     Неверная комбинация регистров

     Правильными комбинациями   индексных  регистров  являются
[BX], [BP],  [SI],  [DI], [BX+SI], [BX+DI], [BP+SI] и [BP+DI].
Другие комбинации   индексных   регистров  (такие,  как  [AX],
[BP+BX] и [SI+DX]) недопустимы.
     Примечание. Локальные переменные (переменные, объявленные
в процедурах и функциях) обычно помещаются в стек,  а доступ к
ним можно  получить через регистр ВР.  Ассемблер автоматически
добавляет [ВР] в ссылках на такие  переменные,  поэтому  такая
конструкция,  как Local[ВХ] (где Local - локальная переменная)
является правильной, а Local[BP+BX] уже нет.

     Invalid use of dot
     Неверное использование точки

     Оператор "." должен быть указан с идентификатором.

Фатальная ошибка
     Irreducible expression tree
     Несокращаемое дерево выражения

     Это означает  ошибку  компилятора.  Какое-то выражение на
указанной строке исходного файла привело к тому, что генератор
кода не может сгенерировать код. Избегайте таких выражений.

     Items of  type  <type>  need  constructors  and  can't be
     passed with ...
     Элементы типа type требуют констракторов и не могут быть
     переданы с ...

     Нельзя передавать объекты типа, требующего констрактор, в
переменный список аргументов (указанный с ...).

     Left side must be a structure
     С левой стороны должна быть структура

     Левая сторона оператора  "."  (или  оператора  C++  ".*")
должна вычисляться в структурный тип.

     Linkage specification not allowed
     Указание редактирования не разрешено

     Указание редактирования такое,  как extern "С"  разрешено
только на уровне файла. Переместите объявление этой функции на
уровень файла.

     Lvalue required
     Требуется lvalue

     Левая часть оператора присваивания должна быть адресуемым
выражением.  Оно включает числовые и указательные  переменные,
ссылки на поля структуры или индексированный элемент массива.

     Macro argument sintax error
     Синтаксическая ошибка аргумента макро

     Аргумент в макроопределении должен быть  идентификатором.
Компилятор  встретил  неидентификаторный символ на месте аргу-
мента.

     Macro expansion too long
     Слишком длинное макрорасширение

     Макро не может расширяться в более, чем 4096 символов.

     main must have a return type of int
     main должна иметь тип возврата int

     Функция main имеет специальные требования,  одно из кото-
рых  заключается в том,  что она может быть объявлена только с
возвращаемым типом int.

     May compile only one file when an  output  file  name  is
     given
     Когда задано имя выходного файла,  можно  откомпилировать
     только один файл

     Вы задали  опцию  командной строки -o,  которая допускает
только одно имя выходного файла.  Первый файл компилируется, а
остальные игнорируются.

     Member <member> is initialized more then once
     Элемент member инициализирован более одного раза

     В констракторе  класса  список  инициализаций   заголовка
констрактора включает одно поле более одного раза.

     Member functions can only have static storage class
     Функция-элемент может иметь только статический класс  па-
мяти

     Сообщение пояснений не требует.

     Memory reference expected
     Ожидается ссылка памяти

     Операнд Ассемблера  не  является ссылкой памяти,  которая
требуется в этом месте.  Вероятнее всего Вы  забыли  поставить
квадратные скобки вокруг операнда индексного регистра;  напри-
мер, MOV AX,BX+SI вместо MOV AX,[BX+SI].

     Misplaced break
     Неверное размещение break

     Компилятор встретил оператор break вне switch или цикла.

     Misplaced continue
     Неверное размещение continue

     Компилятор встретил оператор continue вне цикла.

     Misplaced decimal point
     Неверное размещение точки

     Компилятор встретил десятичную точку в константе с плава-
ющей точкой как часть экспоненты.

     Misplaced elif directive
     Неверное размещение директивы elif

     Компилятор встретил директиву #elif  без  соответствующей
директивы #if, #ifdef или #ifndef.

     Misplaced else
     Неверное размещение else

     Компилятор встретил оператор  else  без  соответствующего
оператора if. Это сообщение может быть вызвано лишним операто-
ром else,  а так же лишней ";",  пропущенными {} или синтакси-
ческой ошибкой в операторе if.

     Misplaced else directive
     Неверное размещение директивы else

     Компилятор встретил директиву #else  без  соответствующей
директивы #if, #ifdef или #ifndef.

     Misplaced endif directive
     Неверное размещение директивы endif

     Компилятор встретил директиву #endif без  соответствующей
директивы #if, #ifdef или #ifndef.

Предупреждение
     Mixing pointers to signed and unsigned char
     Смешанные указатели на signed и unsigned char

     Вы преобразовали char указатель на unsigned char или нао-
борот, без использования явного приведения типов.  (Строго го-
воря, это  неправильно,  но  на 8086 это часто бывает безвред-
ным).

     Multiple base classes require explicit class names
     Несколько базовых классов требуют явных имен классов

     В констракторе  класса каждый вызов констрактора базового
класса требует указания имени базового класса, если существует
более одного непосредственного базового класса.

     Multiple declaration for identifier
     Многократное объявление identifier

     Этот идентификатор был объявлен более  одного  раза.  Это
может  быть вызвано конфликтными объявлениями такими,  как int
a;  double a;,  объявлением функции двумя различными способами
или повторением метки в одной функции или повторяющемся объяв-
лением, другим, чем extren функции или простой переменной.

     Multiple scope qualifiers
     Многократные квалификаторы сферы действия

     Этот идентификатор был квалифицирован более,  чем с одним
именем класса; только один класс может квалифицировать иденти-
фикатор.

     Must take аddress of a memory location
     Должен быть адрес области памяти

     Был использован адресный оператор & с выражением,  что не
может использоваться; например регистровая переменная.

     Need an identifier to declare
     Для объявления требуется идентификатор

     В этом контексте для полного объявления необходим иденти-
фикатор.  Это может быть typedef без имени,  или лишняя ";" на
уровне файла. В C++ это может быть имя класса, неверно исполь-
зуемое как другой тип идентификатора.

     'new' and 'delete' not supported
     new и delete не поддерживаются

     При вычислении выражений в интегрированном отладчике опе-
раторы new и delete не поддерживаются.

     No : following the ?
     Нет : после ?

     Нет соответствия ?  и : в этом выражении. Пропущено : или
неправильно вложенные или пропущенные ().

     No base class to initialize
     Нет базового класса для инициализации

     Этот констрактор пытается неявно вызвать констрактор  ба-
зового класса, но этот класс был объявлен без базовых классов.
Проверьте Ваши объявления.

     No body defined for this inline function
     Для этой inline функции не определено тело функции

     Эта функция объявлена как inline, но тело функции невиди-
мо.  Тело inline функции обычно помещается в тот же файл заго-
ловка, что и объявление функции.

     No constructor parameters allowed for array of class
     Параметры констрактора не разрешены для массива классов

     Когда Вы объявляете массив классов, нельзя передать пара-
метры в констрактор класса. Констрактор, не использующий пара-
метров (констрактор по умолчанию),  должен использоваться  для
определения каждого элемента массива.

Предупреждение
     No declaration for function function
     Нет объявления для функции function

     Это сообщение выдается,  если Вы вызвали функцию без пер-
вого объявления этой функции.  В С Вы можете объявить  функцию
без прототипа,  как int func();. В C++ каждое объявление функ-
ции - это  так  же  прототип;  этот  пример  эквивалентен  int
func(void);. Объявление  может  быть как классического,  так и
современного (прототип) стиля.

     No file name ending
     Нет окончания имени файла

     Для имени  файла в операторе #include была пропущена зак-
рывающая кавычка или угловая скобка.

     No file names given
     Не заданы имена файлов

     Командная строка  компилятора Borland C++ (ВCC) не содер-
жит имен файлов. Вы должны указать имя исходного файла.

     No matching )
     Нет соответствующей )

     ( не  соответствует  ).  Проверьте  это выражение на сба-
лансированность ().

Предупреждение
     Non-const function <function> called for const object
     Неконстантная функция function вызывается для константно-
го объекта

     Не-const функция-элемент  function  вызывается  для const
объекта. Это ошибка, но была отнесена к предупреждениям, чтобы
дать возможность программе завершить работу.

Предупреждение
     Nonportable pointer comparision
     Непереносимое сравнение указателя

     Сравнивается указатель   с  не  указателем,  другим,  чем
константа 0.  Вы должны использовать приведение типа для  пре-
дотвращения этого сообщения, если сравнение верно.

     Nonportable pointer conversion
     Непереносимое преобразование указателя

     Требуется неявное преобразование между типами указателя и
целым  типом,  но эти типы разных размеров.  Преобразование не
может быть выполнено без явного приведения типа.  Это преобра-
зование  может  не иметь смысла и Вы должны быть уверены,  что
хотите сделать именно это.

Предупреждение
     Nonportable pointer conversion
     Непереносимое преобразование указателя

     Ненулевое целое значение используется  в  контексте,  где
требуется  указатель или целое значение;  размер целого типа и
указателя одинаков.  Используйте явное приведение  типа,  если
здесь делается именно то, что Вы хотели.

     Non-virtual function <function> declared pure
     Невиртуальная функция function объявлена как чистая

     Только виртуальная  функция  может  быть  объявлена   как
чистая,  поскольку  производные классы должны обладать возмож-
ностью перекрыть ее.

Предупреждение
     Non-volatile function   <function>  called  for  volatile
     object
     Неизменяемая функция была вызвана для изменяемого объекта

     В С++ элемент-функция класса была вызвана для изменяемого
объекта типа класс, но функция не была объявлена с "volatile",
следующим за  заголовком  функции.  Только  изменяемые элемен-
ты-функции можно вызывать для изменяемых объектов.

     Not an allowed type
     Неразрешенный тип

     Был объявлен запрещенный тип; например, функция возвраща-
ет функцию или массив.

     Not a valid expression format type
     Неверный тип формата выражения

     В окне  просмотра или вычисления был указан неверный спе-
цификатор формата  после  выражения.  Правильный  спецификатор
формата - это символ формата (c,  d, f[n], h, x, m, p, r, s).

     No type information
     Нет информации о типе

     Отладчик не имеет информации о типе для  этой  переменной
или  модуль был откомпилирован без включения отладочной инфор-
мации, или другим компилятором или Ассемблером.

     Numeric constant too large
     Слишком длинная числовая константа

     Не может быть сгенерирована символьная или esc последова-
тельность большая, чем 16-ричная \xFF или 8-ричная \377. Двух-
байтная символьная константа может быть задана с использовани-
ем второго \.  Числовая литеральная константа следующая за esc
последовательностью должна быть разбита как:
     printf("\x0D" "12345");
     Будет выводиться возврат каретки, а затем 12345.

     Object must be initialized
     Объект должен быть инициализирован

     Объект объявлен  как  const,   но   не   инициализирован.
Поскольку ему не может быть присвоено значение, он должен быть
инициализирован в точке объявления.

Предупреждение
     Obsolete syntax; use :: instead
     Устаревший синтаксис, используйте ::

     Ранние версии C++ используют "." или  ":"  для  отделения
имени  элемента  от имени класса в объявлении или определении.
Это устарело, должно использоваться "::".
     Старый стиль:
          void myclass.func(int i) { /* ... */ }
     Новый стиль:
          void myclass::func(int i) { /* ... */ }

     Only one of a set of overloaded function can be function
     Может быть   только   один  набор  перегруженных  функций
     function

     По умолчанию функции C++ перегруженные и компилятор  наз-
начает  новое  имя  каждой функции.  Если Вы желаете перекрыть
назначение  нового  имени   компилятором,   объявляя   функцию
function, Вы можете сделать это только для одного набора функ-
ций с одним именем.  (Иначе редактор найдет более  одной  гло-
бальной функции с тем же именем).

     Operand expected
     Ожидается операнд

     При вычислении выражения компилятору недостаточно операн-
дов  для использования всех операторов.  Либо вставлены лишние
операторы (+ * / и т.д.), либо пропущено имя переменной.

     Operands are of differing or incompatible type
     Операнды различных или несовместимых типов

     Левая и  правая часть бинарного оператора (+ / == и т.д.)
не могут быть объединены этим способом.

     Operator [] missing ]
     В операторе [] пропущена ]

     Оператор C++  operator[]  был объявлен как operator[.  Вы
должны добавить недостающую ] или иначе сделать объявление.

     operator -> must return a pointer or a class
     operator -> должен возвращать указатель или класс

     Функция C++  operator -> должна возвращать класс или ука-
затель на класс (или структуру или объединение).  В любом слу-
чае, это должно быть тем, к чему можно применить оператор ->.

     Operator cannot be applied to these operand types
     Оператор не может быть применен к операндам этих типов

     Левая и правая часть бинарного оператора (+ - == и  т.д.)
неправильного типа для этого оператора; например Вы можете пы-
таться сложить 2 массива.

     operator delete must have  a  single  parameter  of  type
     void*
     operator  delete должен использовать один параметр
     типа void*

     Этот перегруженный operator delete объявлен другим образом.

     operator delete must return void
     operator delete должен возвращать void

     Этот перегруженный operator delete объявлен другим образом.

     operator new must  have  an  initial  parameter  of  type
     size_t
     operator new должен иметь начальный параметр типа size_t

     Оператор new может быть объявлен  с  произвольным  числом
параметров, но всегда должен быть, по крайней мере, один пара-
метр, который задает количество памяти для распределения.

     operator new must have an single parameter of type size_t
     operator new   должен  использовать  один  параметр  типа
     size-t

     Этот перегруженный operator new объявлен другим образом.

     operator new must return an object of type void*
     operator new должен возвращать объект типа void*

     Этот перегруженный operator new объявлен другим образом.

     Other objects cannot be declared in function definition
     В определении функции нельзя объявить другие объекты

     За телом функции не может следовать ",",  чтобы  добавить
другие объвления списком. Например,
     int f(), j;   // объявление - верно
     int f() {return 0;}, j;  // определение - неверно

Фатальная ошибка
     Out of memory
     Недостаточно памяти

     Исчерпана рабочая  память.  Компилируйте файл на машине с
большим объемом памяти. Если Вы уже используете 640К, Вы може-
те упростить исходный файл.

     Overlays only supported in medium, large, and huge memory
     models
     Оверлеи поддерживаются  только  в  моделях памяти medium,
     large и huge

     Это поясняется в главе  6,  что  могут  быть  оверлейными
программы, использующие  только модели памяти medium,  large и
huge.

     Overloadeble operator expected
     Ожидается перегружаемый оператор

     Почти все  операторы  C++  можно перегрузить.  Исключение
составляют .  .* :: ?:. Препроцессорные операторы # и ## - это
не  операторы языка Си или C++ и так же не могут быть перегру-
жены.  Другие неоператорные знаки пунктуации,  такие как  ";",
конечно не могут быть перегружены.

     Overloaded function resolution not supported
     Разрешение перегруженной функции не поддерживается

     При вычислении выражения в интегрированном отладчике раз-
решение  перегруженной  функции  или операторов не поддержива-
ется, даже чтобы взять адрес.

Предупреждение
     overload is now unnecessary and obsolete
     overload не необходима и устарела

     Ранние версии   C++   требуют   зарезервированного  слова
overload, чтобы отметить имена перегруженных функций. Сейчас в
C++ все функции считаются перегружаемыми, если не указано про-
тивное.

     Parameter parameter missing name
     В параметре parameter пропущено имя

     В заголовке определения  функции  этот  параметр  состоит
только из спецификатора типа без имени параметра.  В  С это не
разрешено.  (Это разрешено в C++, но не существует способа об-
ратиться к этому параметру в функции).

     Parameter names are used only with a function body
     Имена параметров используются только в теле функции

     Когда объявляется функция (без определения  ее  тела)  Вы
должны  либо  использовать  пустые (),  либо прототип функции.
Только список  имен параметров не разрешен.
     Примеры объявлений:
     int func();   // объявление без прототипа - верно
     int func(int, int);   // объявление с прототипом - верно
     int func(int i, int j);  // имена параметров в
                              // прототипе - верно
     int func(i, j);   // только имена параметров - неверно

Предупреждение
     Parameter parameter is never used
     Параметр parameter никогда не используется

     Этот параметр,  объявленный в функции, никогда не исполь-
зуется  в теле функции.  Это может быть ошибкой и часто случа-
ется из-за неправильного написания имени. Это сообщение так же
может выдаваться,  если идентификатор переобъявлен как автома-
тическая  (локальная)  переменная  в  теле  функции.  Параметр
маскируется  автоматической  переменной и остается неиспользо-
ванным.

     Pointer required on left side of ->
     С левой стороны -> требуется указатель

     С левой стороны -> разрешен только указатель.

Предупреждение
     Possible use of identifier before definition
     Возможно использование identifier до определения

     Используется переменная в выражении до того,  как ей было
присвоено значение. Компилятор использует простое сканирование
программы  для определения этого условия.  Если Вы используете
переменную до того,  как выполняется присваивание, это сообще-
ние будет генерироваться.  Конечно,  реальное выполнение прог-
раммы может назначать значение переменной до того,  как  прог-
рамма использует ее.

Предупреждение
     Possible incorrect assigment
     Возможно некорректное присваивание

     Это предупреждение генерируется,  когда компилятор встре-
чает оператор присваивания как главный оператор условного  вы-
ражения  (т.е.  как  часть if,  while или do-while).  Наиболее
часто это ошибка набора для оператора равенства. Если Вы жела-
ете подавить это предупреждение, заключите присваивание в () и
явно сравните его с 0. Так
     if (a = b) ...
должно быть
     if ((a = b) != 0) ...

     Previously specified  default  argument  value  cannot be
     changed
     Предварительно заданное  значение  аргумента по умолчанию
     нельзя изменить

     Когда параметр функции C++ объявлен со значением по умол-
чанию,  это  значение  нельзя  изменить или пропустить в любом
другом объявлении этой же функции.

     Pure function function not overridden in class
     "Чистая" функция function не перекрывается в class

     "Чистая" виртуальная  функция  должна быть либо перекрыта
(новым объявлением), либо переобъявлена "чистой" в производном
классе.

Предупреждение
     Program flow can skip this initialization; try using {}
     Ход программы  может пропустить эту инициализацию;  попы-
     тайтесь использовать {}

     Эта инициализация переменной управляется оператором if  и
может быть пропущена. Вам, вероятно, требуется {} вокруг блока
для управления сферой действия этой переменной.

Предупреждение
     Redifinition of macro is not identical
     Переопределение macro не идентично

     Макро переопределено с использованием текста,  который не
точно  такой же,  как в первом определении макро.  Новый текст
заменяет старый.

     Reference member member is not initialized
     Ссылочный элемент member не инициализирован

     Ссылки всегда  должны инициализироваться.  Элемент класса
ссылочного типа должен иметь инициализатор во всех констракто-
рах этого класса.  Это означает, что Вы не можете надеяться на
то, что компилятор сгенерирует констракторы для такого класса,
поскольку он не может определить как инициализировать ссылки.

     Reference member    member    nedds   a   temporary   for
initialization
     Ссылочный элемент member требует временной памяти для
инициализации

     Пользователь задал начальное значение для ссылочного  ти-
па,  который  не  является lvalue.  Это требует от компилятора
создать временную переменную для инициализации.  Поскольку  не
существует  очевидного места для хранения этой временной пере-
менной, инициализация недопустима.

Фатальная ошибка:
     Register allocation failure
     Ошибка распределения регистра

     Это означает ошибку компилятора.  Выражение  в  указанной
строке настолько сложно,  что генератор кода не может сгенери-
ровать код для него.  Упростите выражение.  Если это не решает
проблемы, избегайте этого выражения.

     register is the only storage class allowed
     Разрешен только класс памяти register

     Для параметров   функции  разрешен  только  класс  памяти
register.

     Repeat count needs an lvalue
     Число повторений требует lvalue

     Выражение до "," в окнах Watch или Evaluate  должно  быть
изменяемой  областью памяти.  Например следующие выражения не-
верны:
     i++, 10d
     x = y, 10m

Предупреждение:
     Restarting compile using assembly
     Рестарт компиляции с использованием ассемблирования

     Компилятор встретил asm и не были указаны  опция  -B  или
#pragma inline.  Компилятор перезапускается, используя Ассемб-
лер.

     Right side of .* is not a member pointer
     С правой стороны от ".*" не указатель на элемент

     Правая сторона  оператора  ".*" должна быть объявлена как
указатель на элемент класса,  заданного в левой стороне опера-
тора.

     Side effects are not allowed
     Сторонние эффекты не разрешены

     Сторонние эффекты, такие как присваивания, ++, -- не раз-
решены  в  окне Watch.  Общая ошибка - это использование х = y
вместо x==y, для проверки на равенство.

     Size of identifier is unknown or zero
     Размер identifier неизвестен или 0

     Этот идентификатор был использован в контексте,  где тре-
буется его размер.  Только тип структуры или extern массив мо-
гут  быть  объявлены без размера.  Переставьте Ваши объявления
так, чтобы размер identifier был доступен.

     sizeof may not be applied to a bit field
     sizeof не может применяться к битовому полю

     sizeof возвращает размер объекта данных в байтах,  что не
применимо к битовому полю.

     sizeof may not be applied to a function
     sizeof не может применяться к функции

     sizeof может применяться только к объектам данных,  но не
к функциям. Вы можете запросить размер указателя на функцию.

     Size of the type is unknown or zero
     Размер типа неизвестен или 0

     Этот тип  был использован в контексте,  где требуется его
размер.  Только тип структуры может быть объявлен без размера.
Переставьте Ваши объявления так,  чтобы размер типа был досту-
пен.

     Size of this expression is unknown or zero
     Размер выражения неизвестен или 0

     Это выражение включает тип или переменную, размер которой
неизвестен и используется в контексте,  где требуется  размер.
Только  тип  структуры  или extern массив могут быть объявлены
без размера.  Переставьте Ваши объявления  так,  чтобы  размер
identifier был доступен.

     Stack overflow
     Переполнение стека

     Эта ошибка выдается в том случае, если функция откомпили-
рована с включенным предупреждением о переполнении стека, ког-
да недостаточно стековой памяти для размещения локальных пере-
менных функции.  Увеличьте размер стека,  используя переменную
_stklen.
     Эта ошибка может быть вызвана бесконечной  рекурсией  или
ассемблерной процедурой, которая не поддерживает стековый про-
ект.

     Statement is required here
     Здесь требуется оператор

     Эта часть программы требует оператор (может  быть  просто
";");  он  помещается  между меткой и концом блока и после if,
do, while или for.

     Statement missing ;
     В операторе пропущена ;

     Компилятор встретил оператор без ;

     Storage class storage class not allowed for a field
     Класс памяти storage class не разрешен для поля

     В Си класс памяти не разрешен при объявлении поля.  В C++
поле может быть typedef,  поле данных может быть static и поле
функция может быть inline.  Ничего более не разрешено и только
один класс памяти может быть указан.

     Storage class storage class not allowed for a function
     Класс памяти storage class не разрешен для функции

     В Си и C++ функция может быть extern или  static.  В  C++
функция может быть inline.  Ничего более не разрешено и только
один класс памяти может быть указан.

     Storage class storage class is not allowed here
     Класс памяти storage class не разрешен здесь

     Данный класс памяти здесь не разрешен. Вероятно указаны 2
класса памяти, а может быть использован только один из них.

Предупреждение:
     Structure passed by value
     Структура передается по значению

     Если включено предупреждение "Structure passed by value",
это предупреждение генерируется каждый  раз,  когда  структура
передается  по значению.  Частая ошибка при программировании -
пропускать адресный оператор & при передаче структуры как  ар-
гумента.  Поскольку  структуры могут передаваться по значению,
этот пропуск допустим.

     Structure size too large
     Слишком большая структура

     Объявлена структура, большая, чем 64К.

Предупреждение:
     Style of function definition is now obsolete
     Старый стиль определения функции

     В C++ старый Си стиль определения функции неверен.
     int func(p1, p2) int p1, p2; { /* ... */ }
     Этот способ  может быть не разрешен в других компиляторах
C++.

     Subscripting missing ]
     Пропущена ]

     Компилятор встретил индексированное выражение,  в котором
пропущена ].

Предупреждение:
     Superfluous & with function
     Ненужный & с функцией

     Адресный оператор & не требуется с именем функции;  любой
такой оператор отбрасывается.

Предупреждение:
     Suspicious pointer conversion
     Подозрительное преобразование указателя

     Компилятор встретил   преобразование  указателя,  которое
приведет к тому,  что указатель указывает на другой тип.  Если
преобразование  правильное,  Вы должны использовать приведение
типа для запрещения этого предупреждения.

     Switch selection expression must be of integer type
     Выражение выбора в switch должно быть целого типа

     Выражение выбора  в операторе switch должно вычисляться в
целый тип (char,  short, int, long, enum). Вы можете использо-
вать явное приведение типа для выполнения этого требования.

     Switch statement missing (
     В операторе switch пропущена (

     В операторе switch компилятор не обнаружил ( после ключе-
вого слова switch.

     Switch statement missing )
     В операторе switch пропущена )

     В операторе switch компилятор не обнаружил ) после  выра-
жения выбора.

     'this' can only be used within a member function
     'this' может использоваться только внутри функции-элемента

     В C++ 'this' может  использоваться  только  внутри  функ-
ции-элемента.

Предупреждение:
     Temporary used to initialize identifier
     Используется временная     память    для    инициализации
identifier
     Temporary used for parameter number in call to identifier
     Используется временная  память для параметра number в вы-
зове identifier
     Temporary used  for  parameter  parameter  in   call   to
identifier
     Используется временная память для параметра  parameter  в
вызове identifier
     Temporary used for parameter number
     Используется временная  память  для  параметра number
     Temporary used for parameter parameter
     Используется временная  память  для  параметра parameter

     В C++ переменная или параметр ссылочного типа должны быть
присвоены ссылке на объект того же типа.  Если типы  не  соот-
ветствуют, действительное значение назначается временной памя-
ти  правильного  типа  и  адрес временной памяти присваивается
ссылочной переменной или параметру. Это предупреждение означа-
ет,  что ссылочная переменная или параметр не ссылаются на то,
на что Вы ожидаете, а на временную память.
     Например здесь функция f требует ссылку на int, а с имеет
тип char:
     f(int&);
     char c;
     f(c);
     Вместо вызова f с адресом c,  компилятор компилирует код,
эквивалентный коду C++:
     int X = c, f(X);

     The constructor <constructor> is not allowed here
     Констрактор constructor здесь недопустим.

     Констракторы вида  X::(X)  недопустимы.  Чтобы  правильно
скопировать констракторы, напишите X::(const X&).

     The value for identifier is not within the  range  of  an
int
     Значение для identifier выходит за диапазон для int

     Все вычисления должны иметь значения,  которые могут быть
представлены как целое число. Вы пытаетесь присвоить значение,
которое выходит  за  диапазон  целых  чисел.  Если  Вам  нужна
константа именно с таким значением, используйте const.

     Too few parameters in call
     Слишком мало параметров в вызове

     Вызов функции с прототипом (через указатель  на  функцию)
содержит слишком мало аргументов. Прототип требует, чтобы были
заданы все параметры.

     Too few parameters in call to function
     Слишком мало параметров в вызове function

     Вызов данной  функции (объявленной с прототипом) содержит
слишком мало аргументов.

     Too many decimal points
     Слишком много десятичных точек

     Компилятор обнаружил  константу  с плавающей точкой с бо-
лее, чем одной десятичной точкой.

     Too many default cases
     Слишком много default

     Компилятор обнаружил  более,  чем один оператор default в
операторе switch.

     Too many error or warning messages
     Слишком много ошибок или предупреждений

     Может быть  выдано  максимально  255  ошибок и сообщений,
после этого компилятор останавливается.

     Too many exponents
     Слишком много экспонент

     Компилятор обнаружил   более,   чем   одну  экспоненту  в
константе с плавающей точкой.

     Too many initializers
     Слишком много инициализаторов

     Компилятор встретил больше инициализаторов, чем разрешено
объявлением.

     Too many storage classes in declaration
     В объявлении слишком много классов памяти

     Объявление не может содержать более одного класса памяти.

     Too many types in declaration
     В объявлении слишком много типов

     Объявление не может содержать более  одного  из  основных
типов:   char,   int,  float,  double,  struct,  union,  enum,
typedef-имя.

     Too much global data defined in file
     В файле определено слишком много глобальных данных

     Сумма объявлений  глобальных  данных  превышает 64К байт.
Проверьте объявления  массивов,  которые  могут  быть  слишком
большими. Возможно так же реорганизовать программу или исполь-
зовать far переменные, если все объявления необходимы.

     Trying to derive a far class from near base
     Попытка породить дальний класс из ближнего базового

     Если класс  объявлен (или по умолчанию) near,  все произ-
водные классы так же должны быть near.

     Trying to derive a near class from far base
     Попытка породить ближний класс из дальнего базового

     Если класс объявлен (или по умолчанию) far, все производ-
ные классы так же должны быть far.

     Two consecutive dots
     Две точки подряд

     Поскольку в  ...  содержится 3 точки,  а десятичная точка
или оператор выбора элемента используют одну точку,  две точки
подряд не допустимы в программах на Си.

     286/287 instructions not enabled
     Инструкции 286/287 не включены

     Используйте опцию компилятора командной строки -Z или оп-
ции 80286    из    диалогового    окна   Options/Compiler/Code
generation/Advanced code generation,  чтобы сделать доступными
коды операций 286/287.  Знайте,  что результирующий код нельзя
запускать на машинах 8086 и 8088.

     Two operands must evaluate to the same type
     Два операнда должны вычисляться в один тип

     Типы выражений  с обоих сторон ":" в операторе ?:  должны
быть одинаковыми, за исключением обычных преобразований, таких
как  char  в int или float в double,  или void* в определенный
указатель.  В этом выражении обе стороны вычисляются в различ-
ные  типы,  которые автоматически не преобразуются.  Это может
быть ошибка или можно использовать приведение типа одной  сто-
роны в тип другой.

     Type mismatch in parameter number
     Несоответствие типа в параметре number

     Вызванная функция была объявлена с прототипом; параметр с
номером  number (считая слева направо от 1) не может быть пре-
образован в объявленный тип параметра.

     Type mismatch in parameter number in call to function
     Несоответствие типа   в   параметре   number  при  вызове
function

     Вызванная функция была объявлена с прототипом; параметр с
номером  number (считая слева направо от 1) не может быть пре-
образован в объявленный тип параметра.

     Type mismatch in parameter parameter
     Несоответствие типа в параметре parameter

     Вызванная функция была объявлена с прототипом; этот пара-
метр не может быть преобразован в объявленный тип параметра.

     Type mismatch in parameter parameter in call to function
     Несоответствие типа  в  параметре  parameter  при  вызове
function

     Вызванная функция была объявлена с прототипом; этот пара-
метр не может быть преобразован в объявленный тип параметра.

     Type mismatch in redeclaration of identifier
     Несоответствие типа в переобъявлении identifier

     В исходном файле переменная переобъявляется с типом,  от-
личным от первоначального типа для этой переменной.  Это может
происходить, если вначале функция вызывается, а затем переобъ-
является для возврата чего либо отличного от целого.  Если это
происходит, Вы должны объявить функцию до ее первого вызова.

     Type name expected
     Ожидается имя типа

     Встретилась одна из ошибок:
     - в объявлении переменной уровня файла или поля struct не
задано ни имя типа, ни класс памяти.
     - в объявлении typedef не задано имя типа.
     - в объявлении дестрактора для класса Cи++ имя дестракто-
ра было не именем типа (оно должно  быть  таким  же,  как  имя
класса).
     - при  указании  имени базового класса имя было не именем
класса.

     Type qualifier identifier must be a struct or class name
     Квалификатор типа identifier должен быть именем структуры
или класса.

     Квалификатор в  конструкции квалификатор::identifier - не
имя struct или class.

     Unable to create output file filename
     Нельзя создать выходной файл filename

     Эта ошибка  возникает,  если диск заполнен или защищен от
записи.  Если диск заполнен, попробуйте удалить ненужные файлы
и перезапустить компиляцию. Если диск защищен от записи, пере-
пишите исходные файлы на диск, доступный для записи, и переза-
пустите компиляцию.  Эта ошибка так же возникает,  если не су-
ществует выходной справочник.

     Unable to create borlandc.$ln
     Нельзя создать borlandc.$ln

     Компилятор не  может создать временный файл BORLANDC.$LN,
поскольку не может обратиться к диску или диск заполнен.

     Unable to execute command command
     Нельзя выполнить команду command

     TLINK или TASM не могут быть найдены или,  возможно, пло-
хой диск.

     Unable to open include file filename
     Нельзя открыть включаемый файл filename

     Компилятор не  может  найти  этот файл.  Это может так же
произойти,  если #include включает самого себя или если Вы  не
установили  FILES в config.sys (попытайтесь установить FILES =
20). Проверьте, существует ли этот файл.

     Unable to open input file filename
     Нельзя открыть входной файл filename

     Эта ошибка возникает,  если не найден исходный файл. Про-
верьте написание имени и находится ли этот файл в соответству-
ющем справочнике и устройстве.

     Undefined label identifier
     Неопределенная метка identifier

     Это имя указано в операторе goto,  но метка не определена
в этой функции.

Предупреждение:
     Undefined structure identifier
     Неопределенная структура identifier

     Структура используется в исходном файле,  вероятно с ука-
зателем на структуру,  но не имеет определения в исходном фай-
ле. Вероятно, неправильно написано имя структуры или пропущено
объявление.

     Undefined structure structure
     Неопределенная структура structure

     Использована структура,  но  не было определения для этой
структуры.  Вероятно, пропущено объявление или неправильно на-
писано имя структуры.

     Undefined symbol identifier
     Неопределенный символ identifier

     Этот идентификатор не имеет объявления.  Вероятно, непра-
вильно написано имя в этой точке или в объявлении.

     Unexpected }
     Неожиданная }

     Была встречена лишняя }.

     Unexpected )-check for matching parenthesis
     Неожиданная ) - проверьте соответствие скобок

     Была встречена лишняя ).

     Unexpected : found
     Найдено неожиданное :

     Было встречено лишнее ":". Проверьте, не пропущен ли "?".

     Unexpected end of file in comment started on line number
     Неожиданный конец файла в комментарии,  начатом на строке
line number.

     Исходный файл закончился в середине комментария. Наверное
пропущены "*/".

     Unexpected end  of  file  in  coditional  started on line
number
     Неожиданный конец  файла  в  условном операторе на строке
line number

     Исходный файл закончился до того, как компилятор встретил
#endif.

     union cannot have a base type
     union не может иметь базовый тип

     В общем,  в C++ класс может быть  типа  union,  но  такой
класс не может быть производным от любого другого класса.

     Union member cannot require initialization
     Элементы объединения не могут требовать инициализации

     Поскольку время жизни элемента объединения не определено,
нельзя объявлять его с инициализацией.

Предупреждение:
     Unknown assembler instruction
     Неизвестная инструкция Ассемблера

     Компилятор встретил  оператор  inline  Ассемблера с неиз-
вестным кодом.  См.  главу 9 "Интерфейс с языком  Ассемблера".
Это предупреждение по умолчанию отключено.

     Unknown language, must be C or C++
     Неизвестный язык, должен быть Си или C++.

     В конструкции C++
     extern name type func( /* ... */ );
     name в кавычках должно быть С или C++;  другое имя  языка
не распознается. Вы можете объявить внешнюю функцию Паскаля:
     extern "C" int pascal func( /* ... */ );
     Функция в C++ может быть объявлена как паскалевская и до-
пускает обычное переименование компилятором:
     extern int pascal func( /* ... */ );

     Unknown preprocessor directive: identifier
     Неизвестная директива препроцессора: identifier

     Компилятор встретил символ # в начале строки, а за ней не
следует ни одно из имен директив:  define,  undef,  line,  if,
ifdef, ifndef, include, else, endif.

Предупреждение:
     Unreachable code
     Недостижимый код

     За оператором break, continue, goto или return не следует
метка или конец цикла или функции.  Компилятор проверяет циклы
while,  do и for с проверкой констант  и  пытается  распознать
циклы, которые нельзя пройти вообще.

     Unterminated string or character constant
     Незавершенная строка или символьная константа

     Компилятор не обнаружил завершающей " после начала строки
или символьной константы.

Предупреждение:
     Untyped bit field assumed signed int
     Нетипированное битовое поле, принимается signed int

     Это битовое поле не имеет спецификаций типа и принимается
signed int.  Некоторые компиляторы по умолчанию  устанавливают
unsigned int.

     Use . or -> to call function
     Используйте "." или "->" для вызова function

     Вы пытаетесь вызвать функцию-элемент, не указав объект.

     Use :: to take the address of a member function
     Используйте :: для получения адреса функции-элемента

     Если f - это функция-элемент класса с, Вы получите ее ад-
рес, используя синтаксис &c::f.  Заметьте использование  имени
типа класса,  а  не  имени объекта,  и ::  для отделения имени
класса от имени функции.  (Указатель на функцию-элемент -  это
не действительный тип указателя и не ссылается на любой из эк-
земпляров класса.)

     Use ; to terminate declarations
     Используйте ; для завершения объявления

     Это объявление не завершено ";" или ",".

     User break
     Прерывание пользователя

     Вы набрали Ctrl-Break при компиляции или редактировании в
интегрированной  среде.  (Это не ошибка,  а просто подтвержде-
ние.)

     Value of type void is not allowed
     Значение типа void не разрешено

     Значение типа  void в действительности не является значе-
нием и не может появляться в контексте, где требуется действи-
тельное  значение.  Такой  контекст  включает  правую  сторону
присваивания,  аргумент функции и управляющие выражения опера-
торов if, for, while.

     Variable identifier is initialized twice
     Переменная identifier инициализируется дважды

     Эта переменная инициализирована более одного  раза.  Воз-
можно  объявить переменную уровня файла более одного раза,  но
должна быть только одна инициализация  (даже  если  объявления
одинаковы).

     Variable name expected
     Ожидается имя переменной

     Когда используется оператор адреса & или в C++  возвраща-
ется ссылка на объект,  должен быть указан действительный объ-
ект.  Обычно это имя переменной.  В данном случае был запрошен
адрес чего-либо несоответствующего.

     Vectors of classes must use the default constructor
     Вектора классов должны использовать констрактор по  умол-
чанию

     При инициализации  вектора  (массива)  классов  Вы должны
использовать  констрактор  без   аргументов.   Он   называется
констрактором  по  умолчанию,  что означает,  что Вы не можете
указать аргументы констрактора при инициализации такого векто-
ра.

     Virtual function function1 conflicts with function2
     Виртуальная функция function1 конфликтует с function2

     Виртуальная функция имеет те же типы аргументов,  что и в
базовом классе, но различные типы возврата. Это неверно.

     virtual specified more than once
     virtual задана более одного раза

     В объявлении функции-элемента ключевое слово virtual  мо-
жет появляться только один раз.

     void & is not a valid type
     void & - неразрешенный тип

     Явное сообщение для очевидного ограничения.  Это отлавли-
вается до того,  как Вы пытаетесь инициализировать или исполь-
зовать тип ссылки.

Предупреждение:
     Void functions may not return a value
     void функции не могут возвращать значение

     Функция объявлена как возвращающая  void,  но  компилятор
встретил  оператор  return со значением.  Значение в операторе
return игнорируется.

     While statement missing (
     В операторе while пропущена (

     В операторе компилятор не  обнаружил  (  после  ключевого
слова while.

     While statement missing )
     В операторе while пропущена )

     В операторе компилятор не обнаружил ) после условного вы-
ражения.

     Wrong number of arguments in call of macro
     Неверное число аргументов в вызове macro

     Вызывается макро с неверным числом аргументов.
