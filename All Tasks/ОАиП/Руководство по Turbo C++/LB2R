     raise
──────────────────────────────────────────────────────────────
Функция        Посылает сигнал в выполняемую программу.

Синтаксис      #include <signal.h>
               int raise(int sig);

Прототип в     signal.h

Примечания     Функция raise  посылает в программу сигнал типа
               sig .  Если в программе  установлен  обработчик
               сигнала  для  типа sig,  будет выполняться этот
               обработчик.  Если обработчик не установлен, бу-
               дут  выполняться стандартные действия для этого
               типа сигнала.
               В настоящее время в signal.h определены следую-
               щие типы сигналов:
               ───────────────────────────────────────────────
                Сигнал                   Значение
               ───────────────────────────────────────────────
                SIGABRT     Аварийное завершение (*)
                SIGFPE      Ошибка операции с плавающей точкой
                SIGILL      Недопустимая инструкция (#)
                SIGINT      Прерывание по CTRL-Break
                SIGSEGV     Неверный доступ к памяти (#)
                SIGTERM     Запрос завершения программы (*)
               ───────────────────────────────────────────────
               Типы сигналов,  помеченные (*), не генерируются
               DOS или Borland C++ при нормальной работе.  Од-
               нако они  могут  быть  сгенерированы  с помощью
               raise.  Сигналы,  помеченные (#), не могут быть
               сгенерированы  асинхронно  на  8088 и 8086 про-
               цессорах,  но могут быть сгенерированы на неко-
               торых других процессорах (см.  signal для уточ-
               нения).

Значение       raise возвращает 0 при  успешном  завершении  и
               ненулевое значение в противном случае.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См.также       abort, signal

Пример         #include <signal.h>
               int main(void)
               {  int a, b;
                  a = 10;
                  b = 0;
                  if (b == 0)
                  /* предупреждение возникновения
                     ошибки деления на ноль */
                     raise(SIGFPE);
                  a = a / b;
                  return 0;
               }

     rand
──────────────────────────────────────────────────────────────
Функция        Генератор случайных чисел.

Синтаксис      #include <stdlib.h>
               int rand(void);

Прототип в     stdlib.h

Примечания     rand использует   мультипликативный   генератор
               случайных чисел со сдвигом по модулю с периодом
               2**32  для возврата последовательных псевдослу-
               чайных чисел в диапазоне от 0 до RAND_MAX. Сим-
               вольная   константа   RAND_MAX   определена   в
               stdlib.h; ее значение 2**15 - 1.

Значение       rand возвращает сгенерированное псевдослучайное
               число.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См.также       random, randomize, srand

Пример         #include <stdlib.h>
               #include <stdio.h>
               int main(void)
               {  int i;
                  printf("Ten random numbers from 0 "
                         "to 99\n\n");
                  for(i = 0; i < 10; i++)
                     printf("%d\n", rand() % 100);
                  return 0;
               }

     randbrd
──────────────────────────────────────────────────────────────
Функция        Читает произвольный блок.

Синтаксис      #include <dos.h>
               int randbrd(struct fcb *fcb, int rcnt);

Прототип в     dos.h

Примечания     randbrd читает с диска rcnt записей. fcb - ука-
               затель  на  открытый  блок  управления   файлом
               (FCB), из которого производится чтение.  Записи
               помещаются в память  по  текущему  адресу  вво-
               да-вывода  (DTA),  начиная  с  дисковой записи,
               указанной в поле произвольной записи  FCB.  Это
               осуществляется  вызовом  системной  функции DOS
               0х27.  Действительное число прочитанных записей
               может быть определено проверкой поля произволь-
               ной записи FCB.  Поле произвольной записи прод-
               вигается на число действительно прочитанных за-
               писей.

Значение       В зависимости   от  результата  работы  randbrd
               возвращаются следующие значения:
                  0   Все записи прочитаны.
                  1   Достигнут конец файла,  и последняя  за-
                      пись прочитана полностью.
                  2   При чтении записей адрес превысил грани-
                      цу  0хFFFF  (прочитано  столько записей,
                      сколько возможно).
                  3   Достигнут конец  файла,  и последняя за-
                      пись прочитана не полностью.

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См.также       getdta, randbwr, setdta

Пример         #include <process.h>
               #include <string.h>
               #include <stdio.h>
               #include <dos.h>
               int main(void)
               {  char far *save_dta;
                  char line[80], buffer[256];
                  struct fcb blk;
                  int i, result;
                  /* получаем от пользователя
                     имя входного файла для dta */
                  printf("Enter drive and file name "
                         "(no path - i.e. a:file.dat)\n");
                  gets(line);
                  /* помещаем имя файла в fcb */
                  if (!parsfnm(line, &blk, 1)) {
                     printf("Error in call to parsfnm\n");
                     exit(1);
                  }
                  printf("Drive #%d  File: %s\n\n",
                         blk.fcb_drive, blk.fcb_name);
                  /* открываем файл с помощью DOS FCB */
                  bdosptr(0x0F, &blk, 0);
                  /* сохраняем предыдущий dta,
                     и установить новый  dta */
                  save_dta = getdta();
                  setdta(buffer);
                  /* установка информации для нового dta */
                  blk.fcb_recsize = 128;
                  blk.fcb_random = 0L;
                  result = randbrd(&blk, 1);
                  /* проверка результата randbrd */
                  if (!result)
                     printf("Read OK\n\n");
                  else {
                     perror("Error during read");
                     exit(1);
                  }
                  /* прочитаем данные из нового dta */
                  printf("The first 128 characters are:\n");
                  for (i = 0; i < 128; i++)
                     putchar(buffer[i]);
                  /* восстановим предыдущий dta */
                  setdta(save_dta);
                  return 0;
               }

     randbwr
──────────────────────────────────────────────────────────────
Функция        Записывает произвольный блок.

Синтаксис      #include <dos.h>
               int randbwr(struct fcb *fcb, int rcnt);

Прототип в     dos.h

Примечания     randbwr записывает на диск rcnt записей.  fcb -
               указатель  на  открытый  блок управления файлом
               (FCB).  Это  осуществляется  вызовом  системной
               функции DOS 0х28.  Если rcnt равен 0, файл усе-
               кается до точки, указанной в поле произвольной
               записи FCB.
               Действительное число  записанных  записей может
               быть определено проверкой поля произвольной за-
               писи FCB. Поле произвольной записи продвигается
               на число действительно записанных записей.

Значение       В зависимости   от  результата  работы  randbwr
               возвращаются следующие значения:
                  0   Все записи записаны.
                  1   Недостаточно места на диске  для  записи
                      (ни одна запись не записана).
                  2   При записи адрес превысил границу 0хFFFF
                      (записано столько записей,  сколько воз-
                      можно).

Переносимость  Эта функция доступна только в DOS.  Она не сов-
               местима с Windows.

См.также       randbrd

Пример         #include <process.h>
               #include <string.h>
               #include <stdio.h>
               #include <dos.h>
               int main(void)
               {  char far *save_dta;
                  char line[80];
                  char buffer[256] = "RANDBWR test!";
                  struct fcb blk;
                  int result;
                  /* получаем новое имя файла
                     от пользователя */
                  printf("Enter a file name to create "
                         "(no path - ie. a:file.dat\n");
                  gets(line);
                  /* делаем синтаксический анализ нового
                     имени файла для dta */
                  parsfnm(line,&blk,1);
                  printf("Drive #%d  File: %s\n",
                         blk.fcb_drive, blk.fcb_name);
                  /* вызов функции DOS для создания файла */
                  if (bdosptr(0x16, &blk, 0) == -1) {
                     perror("Error creating file");
                     exit(1);
                  }
                  /* сохранение старого dta и установка
                     нового dta */
                  save_dta = getdta();
                  setdta(buffer);
                  /* записываем новые записи */
                  blk.fcb_recsize = 256;
                  blk.fcb_random = 0L;
                  result = randbwr(&blk, 1);
                  if (!result)
                     printf("Write OK\n");
                  else {
                     perror("Disk error");
                     exit(1);
                  }
                  /* вызов функции DOS для закрытия файла */
                  if (bdosptr(0x10, &blk, 0) == -1) {
                     perror("Error closing file");
                     exit(1);
                  }
                  /* восстановление старого dta */
                  setdta(save_dta);
                  return 0;
               }

     random
──────────────────────────────────────────────────────────────
Функция        Генератор случайных чисел.

Синтаксис      #include <stdlib.h>
               int random(int num);

Прототип в     stdlib.h

Примечания     random возвращает случайное  число  между  0  и
               (num - 1). random(num) - это макрос, определен-
               ный в stdlib.h. И num, и возвращаемое случайное
               число являются целыми числами.

Значение       random возвращает число между 0 и (num - 1).

Переносимость  Соответствующая функция имеется в Turbo Pascal.

См.также       rand, randomize, srand

Пример         #include <stdlib.h>
               #include <stdio.h>
               #include <time.h>
               /* печатаем случайное число в диапазоне
                  от 0 to 99 */
               int main(void)
               {  randomize();
                  printf("Random number in the 0-99 "
                         "range: %d\n", random (100));
                  return 0;
               }

     randomize
──────────────────────────────────────────────────────────────
Функция        Инициализирует генератор случайных чисел.

Синтаксис      #include <stdlib.h>
               #include <time.h>
               void randomize(void);

Прототип в     stdlib.h

Примечания     randomize инициализирует   генератор  случайных
               чисел случайным значением.  Поскольку randomize
               реализована как макрос,  который вызывает функ-
               цию time (с прототипом в time.h), мы рекоменду-
               ем также включать time.h,  когда вы используете
               эту функцию.

Значение       Нет.

Переносимость  Соответствующая функция имеется в Turbo Pascal.

См.также       rand, random, srand

Пример         #include <stdlib.h>
               #include <stdio.h>
               #include <time.h>
               int main(void)
               {  int i;
                  randomize();
                  printf("Ten random numbers "
                         "from 0 to 99\n\n");
                  for(i = 0; i < 10; i++)
                      printf("%d\n", rand() % 100);
                  return 0;
               }

     _read
──────────────────────────────────────────────────────────────
Функция        Читает данные из файла.

Синтаксис      #include <io.h>
               int _read(int handle, void *buf, unsigned len);

Прототип в     io.h

Примечания     _read пытается прочитать len байтов  из  файла,
               связанного с обработчиком handle.  buf - указа-
               тель на  буфер  чтения.  _read  обращается  не-
               посредственно к системной функции чтения DOS.
               Когда файл открыт в текстовом режиме,  _read не
               удаляет символ возврата каретки.
               handle - это номер обработчика файла,  получен-
               ный при вызове create, open, dup или dup2.
               Для дисковых файлов _read начинает чтение с те-
               кущего указателя файла. Когда чтение завершено,
               файловый  указатель увеличивается на количество
               прочитанных байтов.  Для устройств байты  чита-
               ются непосредственно с устройства.
               Максимальное количество  байтов,  которое может
               прочитать функция _read, равно 65534, поскольку
               65535 (т.е.  0xFFFF) - это то же самое, что -1,
               т.е.  значение,  возвращаемое этой функцией при
               ошибке.

Значение       При успешном  завершении _read возвращает поло-
               жительное целое число - количество байтов,  по-
               мещенных  в  буфер.При  достижении  конца файла
               _read возвращает 0.  В случае ошибки  возвраща-
               ется -1, и глобальная переменная errno устанав-
               ливается в одно из следующих значений:
                 EACCES   Доступ запрещен
                 EBADF    Неверный номер (обработчика) файла

Переносимость  Эта функция доступна только в DOS.

См.также       _open, read, _write

Пример         #include <stdio.h>
               #include <io.h>
               #include <alloc.h>
               #include <fcntl.h>
               #include <process.h>
               #include <sys\stat.h>
               int main(void)
               {  void *buf;
                  int handle, bytes;
                  buf = malloc(10);
                  /* Ищем файл TEST.$$$ в текущем справочнике
                     и пытаемся считать  из него 10 байтов.
                     Чтобы использовать этот пример, вы должны
                     создать файл TEST.$$$ */
                  if ((handle =
                      open("TEST.$$$", O_RDONLY | O_BINARY,
                           S_IWRITE | S_IREAD)) == -1)
                  {  printf("Error Opening File\n");
                     exit(1);
                  }
                  if ((bytes = _read(handle, buf, 10)) == -1)
                  {  printf("Read Failed.\n");
                     exit(1);
                  }
                  else {
                     printf("_read: %d bytes read.\n", bytes);
                  }
                  return 0;
               }

     read
──────────────────────────────────────────────────────────────
Функция        Читает данные из файла.

Синтаксис      #include <io.h>
               int read(int handle, void *buf, unsigned len);

Прототип в     io.h

Примечания     read пытается прочитать len  байтов  из  файла,
               связанного с обработчиком handle.  buf - указа-
               тель на буфер чтения.
               Для файла,  открытого в текстовом режиме,  read
               удаляет символ возврата каретки и интерпретиру-
               ет символ Ctrl-Z как конец файла.
               handle - это номер обработчика файла,  получен-
               ный при вызове create, open, dup или dup2.
               Для дисковых  файлов read начинает чтение с те-
               кущего указателя файла. Когда чтение завершено,
               файловый  указатель увеличивается на количество
               прочитанных байтов.  Для устройств байты  чита-
               ются непосредственно с устройства.
               Максимальное количество  байтов,  которое может
               прочитать функция read,  равно 65534, поскольку
               65535 (т.е.  0xFFFF) - это то же самое, что -1,
               т.е.  значение,  возвращаемое этой функцией при
               ошибке.

Значение       При успешном завершении read возвращает положи-
               тельное целое число - количество байтов,  поме-
               щенных  в  буфер.  Если файл открыт в текстовом
               режиме, read не включает символ возврата карет-
               ки  или  символ Ctrl-Z в количество прочитанных
               байтов.
               В случае достижения конца файла read возвращает
               0.  В случае ошибки возвращается -1, и глобаль-
               ная переменная errno устанавливается в одно  из
               следующих значений:
                 EACCES   Доступ запрещен
                 EBADF    Неверный номер (обработчика) файла

Переносимость  Эта функция доступна в системах UNIX.

См.также       open, _read, write

Пример         #include <stdio.h>
               #include <io.h>
               #include <alloc.h>
               #include <fcntl.h>
               #include <process.h>
               #include <sys\stat.h>
               int main(void)
               {  void *buf;
                  int handle, bytes;
                  buf = malloc(10);
                  /* Ищем файл TEST.$$$ в текущем справочнике
                     и пытаемся считать 10 байтов из него.
                     Чтобы использовать этот пример, вы должны
                     создать файл TEST.$$$ */
                  if ((handle =
                     open("TEST.$$$", O_RDONLY | O_BINARY,
                          S_IWRITE | S_IREAD)) == -1) {
                     printf("Error Opening File\n");
                     exit(1);
                  }
                  if ((bytes = read(handle, buf, 10)) == -1) {
                     printf("Read Failed.\n");
                     exit(1);
                  }
                  else {
                     printf("Read: %d bytes read.\n", bytes);
                  }
                  return 0;
               }

     real
──────────────────────────────────────────────────────────────
Функция        Возвращает вещественную    часть   комплексного
               числа или преобразует число формата BCD обратно
               во float, double или long double.

Синтаксис      ДЛЯ Complex:               ДЛЯ bcd:
               #include <complex.h>       #include <bcd.h>
               double real(complex x);    double real(bcd x);

Прототип в     complex.h                  bcd.h

Примечания     С каждым комплексным числом связаны два числа с
               плавающей точкой.  real возвращает то  из  них,
               которое является вещественной частью.
               Вы можете также использовать функцию  real  для
               преобразования двоично-кодированного десятично-
               го числа обратно  во  float,  double  или  long
               double.

Значение       Вещественная часть комплексного числа.

Переносимость  Комплексные функции требуют С++ и не переносимы

См.также       bcd, complex, imag

Пример 1       #include <iostream.h>
               #include <complex.h>
               int main(void)
               {  double x = 3.1, y = 4.2;
                  complex z = complex(x,y);
                  cout << "z = " << z << "\n";
                  cout << "  has real part = " << real(z)
                       << "\n";
                  cout << "  and imaginary real part = "
                       << imag(z) << "\n";
                  cout << "z has complex conjugate = "
                       << conj(z) << "\n";
                  return 0;
               }

Пример 2       #include <iostream.h>
               #include <bcd.h>
               int main(void)
               {  bcd x = 3.1;
                  cout << " The bcd number x = " << x"\n";
                  cout << " Its binary equivalent is "
                       << real(x) << "\n";
                  return 0;
               }

     realloc
──────────────────────────────────────────────────────────────
Функция        Перераспределяет основную память.

Синтаксис      #include <stdlib.h>
               void *realloc(void *block, size_t size);

Прототип в     stdlib.h, alloc.h

Примечания     realloc пытается сжать или расширить  предвари-
               тельно распределенный блок до размера size бай-
               тов. block - указатель на блок памяти, получен-
               ный  ранее  при  вызове  malloc,   calloc   или
               realloc. Если block есть NULL, realloc работает
               точно, как malloc.
               realloc приводит  размер  уже   распределенного
               блока к size байтов,  копируя при необходимости
               его содержимое в новую область памяти.

Значение       realloc возвращает  адрес   перераспределенного
               блока, который   может   отличаться  от  адреса
               исходного блока.  Если блок не может быть пере-
               распределен,  или  size==0,  realloc возвращает
               NULL.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См.также        calloc, farrealloc, free, malloc

Пример         #include <stdio.h>
               #include <alloc.h>
               #include <string.h>
               int main(void)
               {  char *str;
                  /* распределяем память для строки */
                  str = malloc(10);
                  /* помещаем "Hello" в строку */
                  strcpy(str, "Hello");
                  printf("String is %s\n  Address is %p\n",
                         str, str);
                  str = realloc(str, 20);
                  printf("String is %s\n  "
                         "New address is %p\n", str, str);
                  /* освобождаем память */
                  free(str);
                  return 0;
               }

     rectangle
──────────────────────────────────────────────────────────────
Функция        Рисует прямоугольник.

Синтаксис      #include <graphics.h>
               void far rectangle(int left, int top,
                                  int right, int bottom);

Прототип в     graphics.h

Примечания     rectangle рисует  прямоугольник  текущими типом
               линии, толщиной и цветом.
               (left,top) -    левый    верхний    угол,     а
               (right,bottom) - правый нижний угол прямоуголь-
               ника.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       bar, bar3d, setcolor, setlinestyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int left, top, right, bottom;
                  /* инициализация графики
                     и локальных переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {  printf("Graphics error: %s\n",
                             grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  left = getmaxx() / 2 - 50;
                  top = getmaxy() / 2 - 50;
                  right = getmaxx() / 2 + 50;
                  bottom = getmaxy() / 2 + 50;
                  /* рисуем прямоугольник */
                  rectangle(left, top, right, bottom);
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     registerbgidriver
──────────────────────────────────────────────────────────────
Функция        Регистрирует код загруженного пользователем или
               включенного  при  редактировании  связей графи-
               ческого драйвера в графической системе.

Синтаксис      #include <graphics.h>
               int registerbgidriver(void (*driver)(void));

Прототип в     graphics.h

Примечания     registerbgidriver дает пользователю возможность
               загрузить драйвера из  файла  и  "зарегистриро-
               вать" его.  Как только его адрес в памяти будет
               передан в  registerbgidriver,  initgraph  будет
               использовать зарегистрированный драйвер.  Заре-
               гистрированный пользователем драйвер может быть
               загружен  с  диска  в  кучу  или преобразован в
               .OBJ-файл (используя BINOBJ.EXE)  и  включен  в
               .EXE-файл при редактировании связей.
               Вызов registerbgidriver информирует графическую
               систему,  что драйвер,  указанный в driver, был
               включен  во  время  редактирования связей.  Эта
               функция проверяет код указанного драйвера; если
               код  допустимый,  она регистрирует его во внут-
               ренних таблицах.  Драйверы,  включаемые при ре-
               дактировании  связей,  детально описаны в файле
               UTIL.DOS,  имеющемся  на  Ваших  дистрибутивных
               дисках.
               Используя имя  включенного  при  редактировании
               связей драйвера при  вызове  registerbgidriver,
               вы также даете команду компилятору (и редактору
               связей) включить объектный файл с этим именем.

Значение       registerbgidriver возвращает отрицательный  код
               графической ошибки,  если указанный драйвер или
               шрифт    неверны.    В    остальных     случаях
               registerbgidriver возвращает номер драйвера.
               Если вы регистрируете пользовательский драйвер,
               вы   обязаны   передать    результат    функции
               registerbgidriver в initgraph в качестве номера
               драйвера, который должен быть использован.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       graphresult,    initgraph,    installusedriver,
               registerbgifont

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  /* регистрация драйвера, который был
                     добавлен в graphics.lib */
                  errorcode =
                           registerbgidriver(EGAVGA_driver);
                  /* сообщение об ошибках регистрации */
                  if (errorcode < 0)
                  {  printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  /* инициализация графики
                     и локальных переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {  printf("Graphics error: %s\n",
                             grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  /* нарисуем линию */
                  line(0, 0, getmaxx(), getmaxy());
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     registerbgifont
──────────────────────────────────────────────────────────────
Функция        Регистрирует код штрихового шрифта,  включенный
               при редактировании связей.

Синтаксис      #include <graphics.h>
               int registerbgifont(void (*font)(void));

Прототип в     graphics.h

Примечания     Вызов registerbgifont  информирует  графическую
               систему, что шрифт,  указанный в font,  включен
               во время  редактирования  связей.  Эта  функция
               проверяет  код указанного шрифта;  если код до-
               пустимый,  она регистрирует его  во  внутренних
               таблицах. Шрифты, включаемые при редактировании
               связей, детально описаны в разделе BGIOBJ файла
               UTIL.DOS, который имеется на Ваших дистрибутив-
               ных дисках.
               Используя имя  включенного  при  редактировании
               связей шрифта при  вызове  registerbgifont,
               вы также даете команду компилятору (и редактору
               связей) включить объектный файл с этим именем.
               Если вы  регистрируете  пользовательский шрифт,
               вы   обязаны   передать    результат    функции
               registerbgifont в settextstyle в качестве номе-
               ра шрифта, который должен быть использован.

Значение       registerbgifont возвращает  отрицательный   код
               графической ошибки,  если указанный шрифт неве-
               рен. В остальных случаях, registerbgifont возв-
               ращает номер зарегистрированного шрифта.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       graphresult,    initgraph,    installusedriver,
               registerbgidriver, settextstyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy;
                  /* регистрация файла шрифта, добавленного
                     в graphics.lib */
                  errorcode = registerbgifont(triplex_font);
                  /* сообщение об ошибках регистрации */
                  if (errorcode < 0)
                  {  printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  /* инициализация графики
                     и локальных переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {  printf("Graphics error: %s\n",
                             grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;
                  /* выбор зарегистрированного шрифта */
                  settextstyle(TRIPLEX_FONT, HORIZ_DIR, 4);
                  /* вывод текста */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  outtextxy(midx, midy, "The TRIPLEX FONT");
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     remove
──────────────────────────────────────────────────────────────
Функция        Удаляет файл.

Синтаксис      #include <stdio.h>
               int remove(const char *filename);

Прототип в     stdio.h

Примечания     remove удаляет  файл с именем *filename.  Это -
               макрос, который просто преобразует свой вызов в
               вызов unlink.  Если файл открыт, его необходимо
               закрыть до удаления.
         !!!   Строка *filename может  содержать  полный  путь
               DOS.

Значение       При успешном завершении remove возвращает 0.  В
               случае ошибки возвращается -1, и глобальная пе-
               ременная errno устанавливается в одно из следу-
               ющих значений:
                 ENOENT   Файл или справочник не существует
                 EACCES   Доступ запрещен

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См.также       unlink

Пример         #include <stdio.h>
               int main(void)
               {  char file[80];
                  /* запрос имени удаляемого файла */
                  printf("File to delete: ");
                  gets(file);
                  /* удаление файла */
                  if (remove(file) == 0)
                     printf("Removed %s.\n",file);
                  else
                     perror("remove");
                  return 0;
               }

     rename
──────────────────────────────────────────────────────────────
Функция        Переименовывает файл.

Синтаксис      #include <stdio.h>
               int rename(const char *oldname,
                          const char *newname);

Прототип в     stdio.h

Примечания     rename изменяет   имя   файла   с  *oldname  на
               *newname.  Если в *newname  задан  спецификатор
               устройства,  он  должен быть таким же,  как и в
               *oldname.
               Справочники в oldname и newname не обязаны сов-
               падать,  поэтому rename может быть использована
               для переноса файла из одного справочника в дру-
               гой. Символы шаблона не допускаются.

Значение       При успешном переименовании  rename  возвращает
               0.  В случае ошибки возвращается -1, и глобаль-
               ная переменная errno устанавливается в одно  из
               следующих значений:
                 ENOENT   Файл или справочник не существует
                 EACCES   Доступ запрещен
                 ENOTSAM  Другое устройство

Переносимость  Эта функция совместима с ANSI C.

Пример         #include <stdio.h>
               int main(void)
               {  char oldname[80], newname[80];
                  /* запрос имени файла для переименования
                     и нового имени */
                  printf("File to rename: ");
                  gets(oldname);
                  printf("New name: ");
                  gets(newname);
                  /* переименование файла */
                  if (rename(oldname, newname) == 0)
                     printf("Renamed %s to %s.\n", oldname,
                            newname);
                  else
                     perror("rename");
                  return 0;
               }

     restorecrtmode
──────────────────────────────────────────────────────────────
Функция        Возвращает экран в режим,  имевший место до вы-
               зова initgraph.

Синтаксис      #include <graphics.h>
               void far restorecrtmode(void);

Прототип в     graphics.h

Примечания     restorecrtmode возвращает первоначальный видео-
               режим, обнаруженный initgraph.
               Эта функция может быть использована в сочетании
               с  setgraphmode  для попеременного переключения
               между   текстовым   и   графическим   режимами.
               textmode  не должна использоваться для этой це-
               ли;  используйте ее только тогда,  когда  экран
               находится  в текстовом режиме,  для выбора раз-
               личных текстовых режимов.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       getgraphmode, initgraph, setgraphmode

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int x, y;
                  /* инициализация графики
                     и локальных переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {  printf("Graphics error: %s\n",
                             grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  x = getmaxx() / 2;
                  y = getmaxy() / 2;
                  /* вывод сообщения */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  outtextxy(x, y,
                           "Press any key to exit graphics:");
                  getch();
                  /* восстановление текстового режима */
                  restorecrtmode();
                  printf("We're now in text mode.\n");
                  printf("Press any key to return to "
                         "graphics mode:");
                  getch();
                  /* возврат в графический режим */
                  setgraphmode(getgraphmode());
                  /* вывод сообщения */
                  settextjustify(CENTER_TEXT, CENTER_TEXT);
                  outtextxy(x, y,
                            "We're back in graphics mode.");
                  outtextxy(x, y + textheight("W"),
                            "Press any key to halt:");
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     rewind
──────────────────────────────────────────────────────────────
Функция        Позиционирует указатель  файла  к началу потока
               ввода-вывода.

Синтаксис      #include <stdio.h>
               void rewind(FILE *stream);

Прототип в     stdio.h

Примечания     rewind(stream) равносильно   fseek(stream,  0L,
               SEEK_SET), за исключением того, что rewind очи-
               щает  индикатор конца файла и индикатор ошибки,
               в то время,  как fseek - только индикатор конца
               файла.
               Следующей после rewind операцией c файлом может
               быть либо ввод, либо вывод.

Значение       Нет.

Переносимость  Эта функция доступна во всех  системах  UNIX  и
               определена в ANSI C.

См. также      fopen, fseek, ftell.

Пример         #include <stdio.h>
               #include <dir.h>
               int main(void)
               {  FILE *fp;
                  char *fname = "TXXXXXX", *newname, first;
                  newname = mktemp(fname);
                  fp = fopen(newname, "w+");
                  fprintf(fp, "abcdefghijklmnopqrstuvwxyz");
                  rewind(fp);
                  fscanf(fp, "%c", &first);
                  printf("The first character is: %c\n",
                         first);
                  fclose(fp);
                  remove(newname);
                  return 0;
               }

     rmdir
──────────────────────────────────────────────────────────────
Функция        Удаляет справочник DOS.

Синтаксис      #include <dir.h>
               int rmdir(const char *path);

Прототип в     dir.h

Примечания     rmdir удаляет  справочник,  заданный  в  *path.
               Справочник, указанный в *path:
                   - должен быть пуст;
                   - не должен являться текущим;
                   - не должен быть корневым.

Значение       rmdir возвращает  0,  если  справочник  успешно
               удален.  Возвращаемое  значение -1 указывает на
               ошибку;  при этом глобальная  переменная  errno
               устанавливается в одно из следующих значений:
                 EACCES   Доступ запрещен
                 ENOENT   Файл или справочник не существует

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См. также      chdir, getcurdir, getcwd, mkdir

Пример         #include <stdio.h>
               #include <conio.h>
               #include <process.h>
               #include <dir.h>
               #define DIRNAME "testdir.$$$"
               int main(void)
               {  int stat;
                  stat = mkdir(DIRNAME);
                  if (!stat)
                     printf("Directory created\n");
                  else {
                     printf("Unable to create directory\n");
                     exit(1);
                  }
                  getch();
                  system("dir/p");
                  getch();
                  stat = rmdir(DIRNAME);
                  if (!stat)
                     printf("\nDirectory deleted\n");
                  else {
                     perror("\nUnable to delete directory\n");
                     exit(1);
                  }
                  return 0;
               }

     _rotl
──────────────────────────────────────────────────────────────
Функция        Побитовый циклический  сдвиг влево БЕЗЗНАКОВОГО
               целого значения.

Синтаксис      #include <stdlib.h>
               unsigned _rotl(unsigned value, int count);

Прототип в     stdlib.h

Примечания     _rotl циклически  сдвигает значение value влево
               на заданное в count количество бит.  Сдвигаемое
               значение должно быть БЕЗЗНАКОВЫМ целым.

Значение       _rotl возвращает  результат циклического сдвига
               value влево на count бит.

Переносимость  _rotl доступна только в DOS.

См. также      _lrotl, _lrotr, _rotr

Пример         #include <stdlib.h>
               #include <stdio.h>
               int main(void)
               {  unsigned value, result;
                  value = 32767;
                  result = _rotl(value, 1);
                  printf("The value %u rotated left one bit "
                         "is: %u\n", value, result);
                  return 0;
               }

     _rotr
──────────────────────────────────────────────────────────────
Функция        Побитовый циклический сдвиг вправо БЕЗЗНАКОВОГО
               целого значения.

Синтаксис      #include <stdlib.h>
               unsigned _rotr(unsined value, int count);

Прототип в     stdlib.h

Примечания     _rotr циклически сдвигает значение value вправо
               на заданное в count количество бит.  Сдвигаемое
               значение должно быть БЕЗЗНАКОВЫМ целым.

Значение       _rotr возвращает результат циклического  сдвига
               value вправо на значение count бит.

Переносимость  _rotr доступна только в DOS.

См. также      _lrotl, _lrotr, _rotl

Пример         #include <stdlib.h>
               #include <stdio.h>
               int main(void)
               {  unsigned value, result;
                  value = 32767;
                  result = _rotr(value, 1);
                  printf("The value %u rotated right one bit "
                         "is:%u\n", value, result);
                  return 0;
               }
