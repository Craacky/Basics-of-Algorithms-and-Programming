                           ГЛАВА 7.
                         МАТЕМАТИКА.

     Эта глава  описывает  опции  плавающей точки и объясняет,
как использовать комплексную математику.

                    Опции плавающей точки.

     В С можно работать с числами  двух  типов:  целыми  (int,
short, long и т.д.) и с плавающей точкой (float, double и long
double).  Процессор компьютера легко обрабатывает целое значе-
ние, но затрачивает много времени и усилий на обработку значе-
ний с плавающей точкой.
     Однако процессоры  iAPх86 имеют соответствующее семейство
математических сопроцессоров 8087,  80287, 80387. Мы будем на-
зывать их математические сопроцессоры 80х87 или сопроцессоры.
     80х87 - это специальный числовой процессор, который может
быть установлен на Вашем компьютере. Он выполняет инструкции с
плавающей точкой очень быстро.  Если Вы используете  плавающую
точку часто, то Вы захотите инсталлировать сопроцессор. CPU на
Вашем компьютере имеет интерфейс с 80х87 через специальные ли-
нии аппаратного обеспечения.
     Примечание: Если Вы используете процессор 80486, числовой
сопроцессор уже встроен в него.

                       Эмуляция 80х87.

     По умолчанию  при  генерации  кода Borland C++ использует
эмуляцию (опция -f компилятора).  Эта  опция  может  использо-
ваться для программ, которые могут использовать или не исполь-
зовать плавающую точку и для компьютеров,  которые могут иметь
или не иметь 80х87.
     С опцией эмуляции компилятор генерирует код,  как если бы
80х87 был установлен,  но так же редактирует библиотеку эмуля-
ции  EMU.LIB.  Когда  программа  выполняется,  она  использует
80х87,  если  он  установлен;  если сопроцессор не установлен,
программа использует специальные программы,  которые эмулируют
80х87.

                  Использование кода 80х87.

     Если Ваша  программа будет работать только на компьютерах
с 80х87, Вы можете сохранить около 10К в Вашем .EXE файле, от-
бросив автообнаружение и эмуляцию 80х87.  Просто задайте опцию
генерации кода  80х87  (опция  компилятора  командной   строки
-f87).  Borland  C++  будет  редактировать  Вашу  программу  с
FP87.LIB вместо EMU.LIB.

                   Код без плавающей точки.

     Если Ваша программа не использует плавающую точку, Вы мо-
жете несколько сократить время редактирования,  отключив гене-
рацию кода с плавающей точкой (опция -f-).  Тогда Borland  C++
не будет редактировать с EMU.LIB, FP87.LIB или MATHx.LIB.

                   Быстрая плавающая точка.

     Borland C++  имеет  опцию  быстрой плавающей точки (опция
компилятора командной строки -ff).  Она может быть выключена с
помощью  -ff-.  Эта  опция разрешает определенные оптимизации,
которые технически противоречат правильной семантике С. Напри-
мер
     double x;
     x = (float) (3.5*x);
     Чтобы выполнить это корректно, х, умноженный на 3.5, дает
double, который отсекается до точности float, а затем сохраня-
ется в х как double. При опции быстрой плавающей точки резуль-
тат long double прямо преобразуется в double.  Поскольку очень
немногие  программы  зависят от потери точности при передаче в
менее точный тип с плавающей точкой,  быстрая плавающая  точка
установлена по умолчанию.

                   Переменная окружения 87.

     Если Вы разрабатываете программу с эмуляцией 80х87,  Ваша
программа  автоматически  проверяет установлен ли х87,  и если
да, использует его.
     Существуют ситуации, в который Вам может понадобиться от-
менить это автообнаружение.  Например, на Вашем компьютере мо-
жет быть установлен 80х87, а Вам требуется проверить поведение
программы на компьютере без сопроцессора.  Или Вашей программе
требуется выполнить систему, совместимую с РС, но эта конкрет-
ная система возвращает некорректную информацию в логику  авто-
обнаружения (говоря, что доступен несуществующий 80х87, и нао-
борот).
     Borland C++ предоставляет возможность для перекрытия кода
автообнаружения;  это возможно с помощью переменной  87  среды
DOS.
     Вы устанавливаете переменную 87  с  помощью  команды  DOS
SET:
     SET 87=N
     или
     SET 87=Y
     Не используйте пробелы вокруг равенства.  Установка пере-
менной 87 в N  говорит  начальному  коду,  что  Вы  не  хотите
использовать 80х87, даже если он установлен на Вашем компьюте-
ре.
     Установка переменной  87  в  Y означает,  что сопроцессор
установлен и Вы хотите использовать его.  Это опасно!  Если Вы
установили  87=Y,  а  80х87  не установлен,  Ваш компьютер за-
виснет.
     Если переменная  87  определена и Вы хотите отключить ее,
введите:
     SET 87=
     Сразу после знака равенства нажмите Enter.

                      Регистры и 80х87.

     Существует 2 момента,  которые  Вы  должны  понимать  при
использовании плавающей точки:
     1. В режиме эмуляции  округление  регистров  и  некоторые
другие возможности 80х87 не поддерживаются.
     2. Если  Вы  смешиваете  плавающую  точку  со  встроенным
ассемблером,  Вам  могут  потребоваться  специальные  меры при
использовании регистров.  Это происходит из-за того,  что  ре-
гистры  80х87  устанавливаются пустыми до вызова функции.  Вам
может понадобиться получить и сохранить регистры 80х87 до  вы-
зова функций, использующих сопроцессор, если только Вы не уве-
рены, что существует достаточно много свободных регистров.

         Исключительные ситуации с плавающей точкой.

     По умолчанию программа на Borland C++ завершается аварий-
но, если происходит переполнение с плавающей точкой или ошибка
деления на 0.  Вы можете замаскировать исключительные ситуации
с плавающей точкой, вызвав _control87 в main до выполнения лю-
бых операций с плавающей точкой. Например
     #include <float.h>
     main()   {
        _control87(MCW_EM,MCW_EM);
        ...
     }
     Вы можете определить произошли ли исключительные ситуации
с плавающей точкой,  вызвав _status87 или _clear87. См. описа-
ние этих функций в Справочном руководстве по библиотеке.
     Некоторые ошибки могут возникать в библиотечных функциях;
например если Вы пытаетесь получить квадратный корень из отри-
цательного  числа.  Реакция по умолчанию - это вывод сообщения
об ошибке на экран и  возврат  NAN  (IEEE  not-a-number  -  не
число). Использование NAN будет приводить к ошибке с плавающей
точкой позже,  приводя к аварийному завершению программы, если
оно  не  замаскировано.  Если Вы не хотите выводить сообщение,
вставьте следующую версию matherr в Вашу программу.
     #include <math.h>
     int cdecl matherr(struct exception *e)
     {
        return l;    /* ошибка была обработана  */
     }
     Любое другое использование matherr для обработки  матема-
тических  ошибок нежелательно,  так как считается устаревшим и
может не поддерживаться будущими версиями Borland C++.

            Использование комплексной математики.

     Комплексные числа - это числа в форме х+yi,  где x и y  -
действительные числа, а i - квадратный корень из -1. В Borland
C++ определен тип
     struct complex
     {
        double  x, y;
     };
в math.h.  Этот тип удобен для хранения комплексных чисел, так
как они могут рассматриваться как пара  действительных  чисел.
Однако,  С имеет ограничения при вычислении комплексных чисел.
В С ++ комплексная математика намного проще.
     Чтобы использовать  комплексные  числа  в  C++,  включите
complex.h.  В этом файле перекрыты операторы и функции для об-
работки комплексных чисел:
     - все обычные арифметические операторы.
     - операторы потоков, >>, <<.
     - обычные математические функции, такие как sqrt и log.
     Библиотека комплексных чисел вызывается только,  если ар-
гумент типа complex.  Так, чтобы получить комплексный квадрат-
ный корень из -1, используйте
     sqrt(complex(-1))
а не
     sqrt(-1)
     Как пример  использования  комплексных  чисел,  следующая
функция вычисляет сложное преобразование Фурье.
     #include <complex.h>
     //calculate the discrete Fourier transform of a(0),...,a[n-1].
     void Fourier(int n, complex a[], complex b[])
     {
        int j, k;
        complex i(0, 1);       // square root of -1
        for (j = 0; j < n; ++j)
        {
           b[j] = 0;
           for (k = 0; k < n; ++k)
              b[j] += a[k] * exp(2*M_PI*j*k*i/n);
           b[j] /= sqrt(n);
        }
     }

                Использование математики BCD.

     Borland C++ выполняет арифметику  над  двоичными  числами
(т.е. с основанием 2). Многие числа, которые точно представля-
ются в основании 10, такие как 0.01, могут быть представлены в
основании 2 только приблизительно.
     Двоичные числа применимы для большинства программ,  но  в
некоторых случаях нежелательны ошибки округления,  возникающие
при преобразовании между основаниями 2 и 10.  Наиболее  частый
случай - это финансовые программы,  в которых результат должен
быть точным.  Рассмотрим  программу,  которая  складывает  100
пенсов и вычитает доллар:
     #include <stdio.h>
     int i;
     float x = 0.0;
     for (i = 0; i < 100; ++i)
        x += 0.01;
     x -= 1.0;
     printf("100*.01 - l = %g\n",x);
     Правильный ответ  0.0,  но получится значение,  близкое к
0.0. При вычислении получается небольшая ошибка округления при
преобразовании  0.01 в основание 2.  Изменение типа х в double
или long double уменьшает ошибку, но не устраняет ее.
     Для решения  этой  проблемы Borland C++ предоставляет тип
bcd,  который объявлен в bcd.h.  С bcd число 0.01 представлено
точно и переменная х типа bcd даст точное число пенсов.
     #include <bod.h>
     int i;
     bod x = 0.0;
     for (i = 0;i < 100; ++i)
        x += 0.01;
     x -= 1.0;
     cout << "100*.01 - l = " << "\n";
     Некоторые факты, которые требуется помнить о bcd:
     - bcd не исключает всех ошибок округления: вычисление ти-
па 1.0/3.0 дает ошибку округления.
     - обычные математические функции такие,  как sqrt  и  log
перегружены для bcd аргументов.
     - BCD числа имеют около 17 десятичных разрядов и диапазон
от 10**-125 до 10**125.

                     Преобразование BCD чисел.

     bcd тип  отличается  от  float,  double  или long double;
десятичная арифметика выполняется только,  если хотя  бы  один
операнд типа bcd.
     ВАЖНО! bcd функция-элемент real преобразует BCD  число  в
обычный формат на основании 2 (float, double или long double),
хотя преобразование не выполняется автоматически.  real выпол-
няет обязательное преобразование в long double,  который может
быть затем преобразовано в другие типы с помощью обычных  пре-
образований С. Например
     bcd a = 12.1;
можно вывести, используя любую из строк:
     double x = a; printf("a = %g", x)
     printf("a = %Lg", real(a));
     printf("a = %g", (double)real(a));
     cout << "a = " << a;
     Заметим, что поскольку printf не производит проверки  ар-
гументов, спецификатор формата должен иметь L, если передается
long double значение real(a).

                    Число десятичных цифр.

     Вы можете задать, какое число десятичных цифр после деся-
тичной точки будет сформировано при преобразовании из двоично-
го типа в bcd.  Это число  -  необязательный  второй  аргумент
констрактора bcd.  Например,  чтобы преобразовать $1000.00/7 в
переменную bcd, округленную до ближайшего пенса, используйте:
     bcd a = bcd(1000.00/7, 2)
     где 2 указывает, что после десятичной точки должно быть 2
цифры. Так
     1000.00/7              =  142.85714...
     bcd(1000.00/7, 2)      =  142.860
     bcd(1000.00/7, 1)      =  142.960
     bcd(1000.00/7, 0)      =  143.000
     bcd(1000.00/7, -1)     =  140.000
     bcd(1000.00/7, -2)     =  100.000
     Число округляется с  использованием  округления  банкира,
что означает округление до ближайшего целого числа. Например,
     bcd(12.335, 2)         =  12.34
     bcd(12.345, 2)         =  12.34
     bcd(12.355, 2)         =  12.36
     Примечание. Этот  метод  округления  задается  с  помощью
IEEE.
