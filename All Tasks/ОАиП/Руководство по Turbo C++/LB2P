     parsfnm
──────────────────────────────────────────────────────────────
Функция        Синтаксический анализ имени файла.

Синтаксис      #include <dos.h>
               char *parsfnm(const char *cmdline,
                             struct fcb *fcb, int opt);

Прототип в     dos.h

Примечания     parsfnm производит  синтаксический анализ стро-
               ки, содержащей имя файла. (Обычно это командная
               строка).  cmdline - указатель на эту строку.  В
               блок управления файлом (FCB) помещаются отдель-
               но имя устройства,  имя файла и расширение. fcb
               - указатель на FCB.
               Параметр opt - значение регистра AL при  вызове
               системной  функции DOS для синтаксического ана-
               лиза.  Описание операций, выполняющих синтакси-
               ческий   анализ  имени  файла  см.  в  описании
               системной функции DOS 0х29 в Вашем  Руководстве
               по DOS.

Значение       При успешном завершении возвращается  указатель
               на  байт,  следующий  после  конца имени файла.
               Если при анализе имени файла  возникла  ошибка,
               возвращается NULL.

Переносимость  Эта функция доступна только в DOS.

Пример         #include <process.h>
               #include <string.h>
               #include <stdio.h>
               #include <dos.h>

               int main(void)
               {
                  char line[80];
                  struct fcb blk;

                  /* получить имя файла */
                  printf("Enter drive and file name "
                         "(no path - ie. a:file.dat)\n");
                  gets(line);

                  /* поместить имя файла в fcb */
                  if (parsfnm(line, &blk, 1) == NULL)
                     printf("Error in parsfm call\n");
                  else
                     printf("Drive #%d  Name: %11s\n",
                            blk.fcb_drive, blk.fcb_name);

                  return 0;
               }

     peek
──────────────────────────────────────────────────────────────
Функция        Возвращает слово,  расположенное  в  памяти  по
               указанному адресу segment:offset.

Синтаксис      #include <dos.h>
               int peek(unsigned segment, unsigned offset);

Прототип в     dos.h

Примечания     peek возвращает слово,  расположенное по адресу
               segment:offset.
               Вызов peek,  когда включен dos.h, интерпретиру-
               ется   как   макрос,   который   расширяется  в
               inline-код.  Когда dos.h не  включен,  или  при
               включенном     dos.h     выполнена    директива
               #undef peek, будет осуществлен вызов функции.

Значение       peek возвращает слово данных,  расположенное  в
               памяти по адресу segment:offset.

Переносимость  Эта функция доступна только для процессоров се-
               мейства 8086.

См.также       harderr, peekb, poke

Пример         #include <stdio.h>
               #include <conio.h>
               #include <dos.h>

               int main(void)
               {
                  int value = 0;

                  printf("The current status of your keyboard is:"
                         "\n");
                  value = peek(0x0040, 0x0017);
                  if (value & 1)
                     printf("Right shift on\n");
                  else
                     printf("Right shift off\n");

                  if (value & 2)
                     printf("Left shift on\n");
                  else
                     printf("Left shift off\n");

                  if (value & 4)
                     printf("Control key on\n");
                  else
                     printf("Control key off\n");

                  if (value & 8)
                     printf("Alt key on\n");
                  else
                     printf("Alt key off\n");

                  if (value & 16)
                     printf("Scroll lock on\n");
                  else
                     printf("Scroll lock off\n");

                  if (value & 32)
                     printf("Num lock on\n");
                  else
                     printf("Num lock off\n");

                  if (value & 64)
                     printf("Caps lock on\n");
                  else
                     printf("Caps lock off\n");

                  return 0;
               }

     peekb
──────────────────────────────────────────────────────────────
Функция        Возвращает байт, расположенный в памяти по ука-
               занному адресу segment:offset.

Синтаксис      #include <dos.h>
               char peekb(unsigned segment, unsigned offset);

Прототип в     dos.h

Примечания     peekb возвращает байт,  расположенный по адресу
               segment:offset.
               Вызов peekb, когда включен dos.h, интерпретиру-
               ется   как   макрос,   который   расширяется  в
               inline-код.  Когда dos.h не  включен,  или  при
               включенном     dos.h     выполнена    директива
               #undef peekb, будет осуществлен вызов функции.

Значение       peekb возвращает  байт данных,  расположенный в
               памяти по адресу segment:offset.

Переносимость  Эта функция доступна только для процессоров се-
               мейства 8086.

См.также       peek, pokeb

Пример         #include <stdio.h>
               #include <conio.h>
               #include <dos.h>

               int main(void)
               {
                  int value = 0;

                  printf("The current status of your keyboard is:"
                         "\n");
                  value = peekb(0x0040, 0x0017);
                  if (value & 1)
                     printf("Right shift on\n");
                  else
                     printf("Right shift off\n");

                  if (value & 2)
                     printf("Left shift on\n");
                  else
                     printf("Left shift off\n");

                  if (value & 4)
                     printf("Control key on\n");
                  else
                     printf("Control key off\n");

                  if (value & 8)
                     printf("Alt key on\n");
                  else
                     printf("Alt key off\n");

                  if (value & 16)
                     printf("Scroll lock on\n");
                  else
                     printf("Scroll lock off\n");

                  if (value & 32)
                     printf("Num lock on\n");
                  else
                     printf("Num lock off\n");

                  if (value & 64)
                     printf("Caps lock on\n");
                  else
                     printf("Caps lock off\n");

                  return 0;
               }

     perror
──────────────────────────────────────────────────────────────
Функция        Печатает сообщение о системной ошибке.

Синтаксис      #include <stdio.h>
               void perror(const char *s);

Прототип в     stdio.h

Примечания     perror выводит   в  поток  stderr  (обычно  это
               консоль) сообщение о системной ошибке последней
               библиотечной программы, выполнение которой при-
               вело к ошибке.
               Сначала выводится аргумент s,  затем двоеточие,
               затем сообщение,  соответствующее текущему зна-
               чению глобальной переменной  errno,  и  наконец
               символ конца строки. Обычно предполагается, что
               через  строку-аргумент  передается  имя   файла
               программы.
               Доступ к массиву  строк  сообщений  об  ошибках
               осуществляется   через   глобальную  переменную
               sys_errlist.  Глобальная переменная errno может
               быть  использована  в  качестве  индекса  этого
               массива для поиска строки,  соответствующей но-
               меру ошибки.  Ни одна из этих строк не включает
               символ конца строки.
               Глобальная переменная  sys_nerr  содержит число
               элементов этого массива.
               Более полная  информация содержится в описаниях
               errno,  sys_errlist и sys_nerr в Главе 3  "Гло-
               бальные переменные".

Значение       Нет.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См.также       clearerr, eof, _strerror, strerror

Пример         #include <stdio.h>

               int main(void)
               {
                  FILE *fp;

                  fp = fopen("perror.dat", "r");
                  if (!fp)
                     perror("Unable to open file for reading");
                  return 0;
               }

     pieslice
──────────────────────────────────────────────────────────────
Функция        Рисует и заполняет круговой сектор.

Синтаксис      #include <graphics.h>
               void far pieslice(int x, int y, int stangle,
                                 int endangle, int radius);

Прототип в     graphics.h

Примечания     pieslice рисует  и  заполняет круговой сектор с
               центром  в  (x,y)  и  радиусом  radius.  Сектор
               рисуется   в  направлении  от  начального  угла
               (stangle) до конечного (endangle). Граница сек-
               тора рисуется текущим цветом линий,  а сам сек-
               тор заполняется текущим шаблоном и  цветом  за-
               полнения.
               Углы для  pieslice  задаются  в градусах.  Углы
               отсчитываются против часовой  стрелки:  0  гра-
               дусов  соответствуют  "3 часам",  90 градусов -
               "12 часам" и т.д.
         !!!   Если вы  используете  CGA или монохромный адап-
               тер, примеры из  этой  книги  по  использованию
               графических функций могут не дать ожидаемых ре-
               зультатов. Если ваша система работает с CGA или
               монохромным  адаптером,  используйте значение 1
               вместо  символических  констант  для  цветов  и
               посмотрите во 2-м примере для функции arc,  как
               использовать функцию pieslice.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       fillellipse, fill_patterns(перечислимый   тип),
               graphresult, sector, setfillstyle

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  /* Запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int midx, midy;
                  int stangle = 45, endangle = 135, radius = 100;

                  /* инициализация графики и локальных
                     переменных */
                  initgraph(&gdriver, &gmode, "");

                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)  /* обнаружена ошибка */
                  {
                     printf("Graphics error: %s\n",
                            grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* выход с кодом ошибки */
                  }

                  midx = getmaxx() / 2;
                  midy = getmaxy() / 2;

                  /* установить стиль заполнения и нарисовать
                     сектор круга */
                  setfillstyle(EMPTY_FILL, getmaxcolor());
                  pieslice(midx, midy, stangle, endangle, radius);

                  /* очистить */
                  getch();
                  closegraph();
                  return 0;
               }

     poke
──────────────────────────────────────────────────────────────
Функция        Записывает целое число в память  по  указанному
               адресу segment:offset.

Синтаксис      #include <dos.h>
               void poke(unsigned segment, unsigned offset,
                         int value);

Прототип в     dos.h

Примечания     poke записывает  целое  число value в память по
               адресу segment:offset.
               Вызов poke,  когда включен dos.h, интерпретиру-
               ется   как   макрос,   который   расширяется  в
               inline-код.  Когда dos.h не  включен,  или  при
               включенном     dos.h     выполнена    директива
               #undef poke, будет осуществлен вызов функции.

Значение       Нет.

Переносимость  Эта функция доступна только для процессоров се-
               мейства 8086.

См.также       harderr, peek, pokeb

Пример         #include <dos.h>
               #include <conio.h>

               int main(void)
               {
                  clrscr();
                  cprintf("Make sure the scroll lock key "
                          "is off and press any key\r\n");
                  getch();
                  poke(0x0000,0x0417,16);
                  cprintf("The scroll lock is now on\r\n");
                  return 0;
               }

     pokeb
──────────────────────────────────────────────────────────────
Функция        Записывает заданное значение в байт  памяти  по
               указанному адресу segment:offset.

Синтаксис      #include <dos.h>
               void pokeb(unsigned segment, unsigned offset,
                          char value);

Прототип в     dos.h

Примечания     pokeb записывает  значение  value в байт памяти
               по адресу segment:offset.
               Вызов pokeb, когда включен dos.h, интерпретиру-
               ется  как   макрос,   который   расширяется   в
               inline-код.  Когда  dos.h  не включен,  или при
               включенном     dos.h     выполнена    директива
               #undef pokeb, будет осуществлен вызов функции.

Значение       Нет.

Переносимость  Эта функция доступна только для процессоров се-
               мейства 8086.

См.также       peekb, poke

Пример         #include <dos.h>
               #include <conio.h>

               int main(void)
               {
                  clrscr();
                  cprintf("Make sure the scroll lock key is "
                          "off and press any key\r\n");
                  getch();
                  pokeb(0x0000,0x0417,16);
                  cprintf("The scroll lock is now on\r\n");
                  return 0;
               }

     polar
──────────────────────────────────────────────────────────────
Функция        Возвращает комплексное число с заданными  моду-
               лем и аргументом.

Синтаксис      #include <complex.h>
               complex polar(double mag, double angle);

Прототип в     complex.h

Примечания     polar(mag, angle) - это
                 complex(mag * cos(angle), mag * sin(angle)).

Значение       Комплексное число с заданными значениями модуля
               и аргумента.

Переносимость  Комплексные функции требуют С++ и не  переноси-
               мы.

См.также       arg, complex, norm

Пример         #include <iostream.h>
               #include <complex.h>

               int main(void)
               {
                  double x = 3.1, y = 4.2;
                  complex z = complex(x,y);
                  cout << "z = " << z << "\n";
                  cout << "  has real part = " << real(z) << "\n";
                  cout << "  and imaginary real part = " << imag(z)
                       << "\n";
                  cout << "z has complex conjugate = " << conj(z)
                       << "\n";

                  double mag = sqrt(norm(z));
                  double ang = arg(z);
                  cout << "The polar form of z is:\n";
                  cout << "   magnitude = " << mag << "\n";
                  cout << "   angle (in radians) = " << ang
                       << "\n";
                  cout << "Reconstructing z from its polar form "
                       "gives:\n";
                  cout << "   z = " << polar(mag,ang) << "\n";
                  return 0;
               }

     poly
──────────────────────────────────────────────────────────────
Функция        Генерирует полиномиальную  функцию из своих ар-
               гументов.

Синтаксис      #include <math.h>
               double poly(double x,
                           int degree, double coeffs[]);

Прототип в     math.h

Примечания     poly генерирует полиномиальную функцию (многоч-
               лен) степени degree от переменной х с коэффици-
               ентами coeffs[0], coeffs[1],...,coeffs[degree].
               Например, если n = 4, генерируется полиномиаль-
               ная функция:
               coeffs[4] * x**4 + coeffs[3] * x**3 +
                + coeffs[2] * x**2 + coeffs[1] * x + coeffs[0]

Значение       poly возвращает значение полиномиальной функции
               для заданного значения х.

Переносимость  Эта функция доступна в системах  UNIX.

Пример         #include <stdio.h>
               #include <math.h>

               /* полином:  x**3 - 2x**2 + 5x - 1 */

               int main(void)
               {
                  double array[] = { -1.0, 5.0, -2.0, 1.0 };
                  double result;

                  result = poly(2.0, 3, array);
                  printf("The polynomial: x**3 - 2.0x**2 + 5x - 1 "
                         "at 2.0 is %lf\n", result);
                  return 0;
               }

     pow
──────────────────────────────────────────────────────────────
Функция        Вычисляет х в степени y.

Синтаксис      ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               #include <math.h>       #include <complex.h>
               double pow(double x,    complex pow(complex x,
                          double y);               complex y);
                                       complex pow(complex x,
                                                   double y);
                                       complex pow(double x,
                                                   complex y);

Прототип в     ВЕЩЕСТВЕННАЯ ВЕРСИЯ:    КОМПЛЕКСНАЯ ВЕРСИЯ:
               math.h                  complex.h

Примечания     pow вычисляет х ** у.
               Для комплексных чисел  эта функция определяется
               как
               pow(основание, показатель) =
                             exp(показатель * log(основание)).

Значение       При успешном  завершении возвращается вычислен-
               ное значение x ** y.
               Иногда аргументы, передаваемые функции pow, вы-
               зывают  переполнение  или делают вычисление ре-
               зультата невозможным.  Когда переполнение явля-
               ется  правильным  результатом,  pow  возвращает
               значение HUGE_VAL. Если модуль результата слиш-
               ком  велик,  глобальная  переменная errno может
               быть установлена в значение
                 ERANGE  Результат вне допустимого диапазона
               Если переданный  pow  аргумент  х- вещественное
               число, меньшее 0, а y не является целым числом,
               глобальная  переменная  errno устанавливается в
               значение:
                 EDOM  Ошибка области определения
               Если оба аргумента x и y равны 0, pow возвраща-
               ет 1.
               Обработка ошибок  для  этой  функции может быть
               модифицирована посредством функции matherr.

Переносимость  Вещественная версия доступна в системах UNIX  и
               определена  в  ANSI C.  Комплексная версия этой
               функции требует С++ и, вероятно, не переносима.

См.также       complex, exp, pow10, sqrt

Пример         #include <math.h>
               #include <stdio.h>

               int main(void)
               {
                  double x = 2.0, y = 3.0;

                  printf("%lf raised to %lf is %lf\n", x, y,
                         pow(x, y));
                  return 0;
               }

     pow10
──────────────────────────────────────────────────────────────
Функция        Вычисляет 10 в степени p.

Синтаксис      #include <math.h>
               double pow10(int p);

Прототип в     math.h

Примечания     pow10 вычисляет 10 ** p.

Значение       При успешном завершении pow10 возвращает значе-
               ние 10 ** p.
               На самом деле результат вычисляется с точностью
               long double.  Все аргументы допустимы, хотя не-
               которые могут вызвать потерю значимости или пе-
               реполнение.

Переносимость  Эта функция доступна в системах  UNIX.

См.также       exp, pow

Пример         #include <math.h>
               #include <stdio.h>

               int main(void)
               {
                 double p = 3.0;

                 printf("Ten raised to %lf is %lf\n", p, pow10(p));
                 return 0;
               }

     printf
──────────────────────────────────────────────────────────────
Функция        Форматированный вывод  в  стандартный  выходной
               поток (stdout).

Синтаксис      #include <stdio.h>
               int printf(const char *format[, argument,...]);

Прототип в     stdio.h

Примечания     printf принимает список аргументов, применяет к
               каждому  из них спецификатор формата,  содержа-
               щийся в строке формата *format,  и выводит  от-
               форматированные данные в stdout. Число специфи-
               каторов формата и аргументов должно быть одина-
               ковым.
Строка         Строка формата  используется при каждом обраще-
формата        нии к функциям семейства ...printf для указания
               того, как функция должна преобразовать, сформа-
               тировать и вывести свои аргументы.
               Аргументов не должно быть меньше спецификаторов
               формата.  В  противном  случае  результаты неп-
               редсказуемы и, возможно, катастрофические. Лиш-
               ние  аргументы  (сверх  количества,  требуемого
               строкой формата) просто игнорируются.
               Строка формата - символьная строка,  содержащая
               объекты двух типов: основные символы и специфи-
               каторы формата.
               - Основные символы просто копируются в выходной
                 поток без изменений.
               - Спецификаторы формата вызывают применение оп-
                 ределяемого ими  форматирования  к  значениям
                 аргументов перед выводом их в поток.
               СПЕЦИФИКАТОРЫ ФОРМАТА
               Спецификаторы формата     функций     семейства
               ...printf имеют следующую форму:
                  % [flags] [width] [.prec] [F|N|h|l|L] type
               Каждый спецификатор формата начинается с симво-
               ла процента (%).  После %  следуют, в указанном
               порядке:
               - необязательная    последовательность   симво-
                 лов-флагов, [flags]
               - необязательный спецификатор ширины, [width]
               - необязательный спецификатор точности, [.prec]
               - необязательный модификатор  длины  аргумента,
                 [F|N|h|l|L]
               - type - символ типа преобразования.
Необязательные Необязательные символы, спецификаторы и модифи-
символы        каторы строки формата управляют следующими  об-
строки         щими аспектами форматирования:
формата        ───────────────────────────────────────────────
               Символ или           Чем управляет или
               спецификатор         что определяет
               ───────────────────────────────────────────────
               flags        Выравнивание при выводе, отображе-
                            ние знака числа, десятичной точки,
                            незначащих нулей,  восьмеричные  и
                            шестнадцатеричные префиксы
               width        Минимальное количество    символов
                            для печати,  дополнение  пробелами
                            или нулями
               precision    Максимальное количество   символов
                            для печати;  для целых чисел - ми-
                            нимальное  количество цифр для пе-
                            чати
               size         Изменяет принимаемое по  умолчанию
                            значение длины аргумента:
                                 N = near pointer
                                 F = far pointer
                                 h = short int
                                 l = long
                                 L = long double
               ───────────────────────────────────────────────
Символы        Следующая таблица  содержит символы типа преоб-
типа           разования для функций ...printf,  а  также  для
преобра-       каждого из них ожидаемый тип аргумента и формат
зования        вывода.
               Информация в этой таблице приведена в предполо-
               жении, что никакие символы-флаги, спецификаторы
               ширины,  точности или модификаторы длины  аргу-
               мента не содержатся в строке формата. Чтобы уз-
               нать,  как добавление необязательных  элементов
               влияет  на  вывод  функций ...printf,  смотрите
               последующие таблицы.
               ───────────────────────────────────────────────
               Символ  Входной         Формат вывода
               типа    аргумент
               ───────────────────────────────────────────────
               Числовые
                d      integer         Десятичное целое
                                       (с учетом знака)
                i      integer         Десятичное целое
                                       (с учетом знака)
                o      integer         Беззнаковое восьмерич-
                                       ное целое
                u      integer         Беззнаковое десятичное
                                       целое
                x      integer         Беззнаковое шестнадца-
                                       теричное целое (с
                                       цифрами a,b,c,d,e,f)
                X      integer         Беззнаковое шестнадца-
                                       теричное целое (с
                                       цифрами A,B,C,D,E,F)
                f      floating-point  Значение (с учетом
                                       знака) в виде
                                         [-]dddd.dddd
                e      floating-point  Значение (с учетом
                                       знака) в виде
                                         [-]d.ddd...e[+/-]ddd
                g      floating-point  Значение (с учетом зна-
                                       ка) либо в виде e, либо
                                       в виде f, исходя из за-
                                       данного значения и точ-
                                       ности. Незначащие нули
                                       и десятичная точка вы-
                                       водятся, только если
                                       это необходимо
                E      floating-point  То же, что и е, но для
                                       экспоненты используется
                                       символ E
                G      floating-point  То же, что и g, но для
                                       экспоненты используется
                                       символ E, если выводит-
                                       ся формат e
               Символьные
                c      character       Одиночный символ
                s      указатель       Символы выводятся, пока
                       на строку       не встретится нуль-сим-
                                       вол (\0) или пока не
                                       будет выведено макси-
                                       мальное число символов
                                       (значение спецификатора
                                       точности)
                %      нет             Выводится символ %
               Указатели
                n      указатель       Записывыает (по адре-
                       на int          су, на который указыва-
                                       ет аргумент) счетчик
                                       выведенных ранее симво-
                                       лов
                p      pointer         Выводит аргумент в виде
                                       указателя. Формат зави-
                                       сит от используемой мо-
                                       дели памяти: XXXX:YYYY
                                       или YYYY (только смеще-
                                       ние)
               ───────────────────────────────────────────────
Соглашения     В следующей таблице приводятся соглашения, свя-
               занные с некоторыми спецификаторами формата.
               ───────────────────────────────────────────────
               Символы   Соглашения
               ───────────────────────────────────────────────
               е или Е   Аргумент преобразуется к виду
                           [-]d.ddd...e[+/-]ddd, где
                         - одна цифра предшествует десятичной
                           точке.
                         - количество цифр после десятичной
                           точки равно значению точности.
                         - порядок всегда содержит по крайней
                           мере две цифры.
               f         Аргумент преобразуется в десятичную
                         нотацию вида [-]ddd.ddd..., где коли-
                         чество цифр после десятичной точки
                         равно значению точности (если задано
                         ненулевое значение точности).
               g или G   Аргумент выводится в формате e, E или
                         f, причем значение точности определя-
                         ет количество значащих цифр. Незнача-
                         щие нули удаляются из результата, а
                         десятичная точка появляется только
                         при необходимости.
                         Если символ преобразования - g, аргу-
                         мент выводится в формате e или f (с
                         некоторыми ограничениями), если сим-
                         вол преобразования G - в формате Е
                         или f. Формат е используется, только
                         если порядок результата преобразова-
                         ния превышает значение точности или
                         меньше -4.
               x или X   При преобразовании типа x в качестве
                         шестнадцатеричных цифр выводятся бук-
                         вы a,b,c,d,e и f; при преобразовании
                         типа X выводятся буквы A,B,C,D,E и F.
               ───────────────────────────────────────────────
         !!!   Бесконечные числа с плавающей точкой  выводятся
               как +INF и -INF. Не-Число (в смысле IEEE) выво-
               дится как +NAN или -NAN.
Символы-       Символы-флаги - это минус (-),  плюс (+),  диез
флаги          (#) и пробел ( ).  Они могут появляться в любом
               порядке и сочетании.
               ───────────────────────────────────────────────
               Флаг    Что определяет
               ───────────────────────────────────────────────
               -       Результат выравнивается влево и допол-
                       няется пробелами справа. Если не задан,
                       результат выравнивается вправо и допол-
                       няется слева пробелами или нулями.
               +       Результат преобразования с учетом знака
                       всегда начинается со знака плюс (+) или
                       минус (-).
               пробел  Если значение неотрицательно, вывод на-
                       чинается с пробела вместо плюса; отри-
                       цательные значения начинаются с минуса.
               #       Определяет, что arg преобразуется с
                       помощью "альтернативной формы". Смотри
                       следующую таблицу.
               ───────────────────────────────────────────────
         !!!   Плюс (+) имеет приоритет над пробелом( ),  если
               заданы оба.
Альтерна-      Если флаг # используется с символом  преобразо-
тивные         вания,  это  оказывает следующее воздействие на
формы          преобразуемый аргумент (arg):
               ───────────────────────────────────────────────
               Символ     Воздействие # на arg
               ───────────────────────────────────────────────
               c,s,d,i,u  Не влияет.
               o          В начало ненулевого arg
                          добавляется 0.
               x или X    В начало arg добавляется 0х (или 0Х)
               e,E или f  Результат всегда содержит десятичную
                          точку, даже если после нее нет цифр.
                          Обычно десятичная точка появляется,
                          только если после нее есть цифры.
               g или G    То же, что е и Е; кроме того, незна-
                          чащие нули не удаляются.
               ───────────────────────────────────────────────
Спецификаторы  Спецификатор ширины  устанавливает  минимальную
ширины         ширину поля для вывода значения.
               Ширина задается  одним  из  двух способов:  не-
               посредственно - строкой  десятичных  цифр,  или
               косвенно - звездочкой (*).  Если вы используете
               звездочку, минимальная ширина поля вывода опре-
               деляется  значением очередного аргумента (кото-
               рый должен иметь тип int).
               Ни при каких обстоятельствах спецификатор шири-
               ны, его отсутствие или неверное значение не бу-
               дет вызывать усечения выводимого поля. Если ре-
               зультат преобразования оказывается  шире  уста-
               новленного  спецификатором,  поле вывода просто
               расширяется, чтобы поместить результат преобра-
               зования.
               ───────────────────────────────────────────────
               Спецификатор    Как влияет на ширину поля
                  ширины               вывода
               ───────────────────────────────────────────────
                n        По крайней мере n символов будут на-
                         печатаны. Если выводимое значение со-
                         держит менее n символов, поле вывода
                         дополняется пробелами (справа - если
                         указан символ-флаг "минус"(-), сле-
                         ва - в остальных случаях).
                0n       По крайней мере n символов будут на-
                         печатаны. Если выводимое значение со-
                         держит менее n символов, поле вывода
                         дополняется нулями слева.
                *        Значение спецификатора ширины содер-
                         жится в списке аргументов и предшест-
                         вует форматируемому аргументу.
               ───────────────────────────────────────────────
Спецификаторы  Спецификатор точности всегда начинается с точки
точности       (.),  которая  отделяет  его от предшествующего
               спецификатора ширины.  Как и  ширина,  точность
               задается  либо  непосредственно - строкой деся-
               тичных цифр,  либо косвенно -  звездочкой  (*).
               Если  вы  используете звездочку,  точность поля
               вывода определяется значением очередного  аргу-
               мента (который интерпретируется как int).
               Если вы используете звездочки для ширины,  точ-
               ности,  или для того и другого, аргумент ширины
               должен соответствовать текущему  спецификатору,
               за  ним  должен следовать аргумент точности,  а
               затем - аргумент с данными, которые должны быть
               преобразованы.
               ───────────────────────────────────────────────
               Спецификатор  Как влияет на выходную точность
                 точности
               ───────────────────────────────────────────────
                (не задан)   Точность устанавливается по
                             умолчанию:
                                1 - для типов d, i, o, u, x, X
                                6 - для типов e, E, f
                                все значащие цифры - для типов
                                                     g, G
                                выводятся все символы до пер-
                                вого нуль-символа - для типа s
                                не влияет - на тип с.
                .0           Для типов d,i,o,u,x точность ус-
                             танавливается по умолчанию;
                             для типов e,E,f - не выводится
                             десятичная точка.
                .n           Выводится n символов или n деся-
                             тичных позиций. Если выводимое
                             значение содержит более n симво-
                             лов, оно может быть усечено или
                             округлено (в зависимости от сим-
                             вола типа).
                *            Значение спецификатора точности
                             содержится в списке аргументов и
                             предшествует форматируемому аргу-
                             менту.
               ───────────────────────────────────────────────
         !!!   Если явно задана нулевая точность, И специфика-
               тор формата  для данного поля относится к цело-
               численным (т.е.,  d,i,o,u,x), И значение, кото-
               рое должно быть выведено,  равно 0,  - ни одной
               цифры не будет выведено в это поле  (т.е.  поле
               будет заполнено пробелами).
               ───────────────────────────────────────────────
               Символ типа      Как спецификатор точности (.n)
               преобразования   влияет на преобразование
               ───────────────────────────────────────────────
                d            .n указывает, что по крайней мере
                i            n цифр будут выведены. Если вход-
                o            ной аргумент имеет менее n цифр,
                u            выводимое значение дополняется
                x            слева нулями. Если входной аргу-
                X            мент имеет более n цифр, выводи-
                             мое значение не усекается.

                e            .n указывает, что после десятич-
                E            ной точки выводятся n символов,
                f            и последняя выводимая цифра окру-
                             гляется.

                g            .n указывает, что выводится не
                G            более n значащих цифр.

                c            .n не влияет на выводимое поле.

                s            .n указывает, что выводится не
                             более n символов.
               ───────────────────────────────────────────────
Модификатор    Символы модификатора длины аргумента (F,  N, h,
длины          l и L) задают длину очередного аргумента:
аргумента         F = дальний указатель
                  N = ближний указатель
                  h = short int
                  l = long
                  L = long double
               Модификаторы длины аргумента (F,  N,  h, l и L)
               влияют на то,  как функции семейства  ...printf
               интерпретируют  тип данных соответствующего ар-
               гумента arg.  F и N применяются только к  аргу-
               ментам,  которые являются указателями (%p, %s и
               %n).  h, l, и L применяются к числовым аргумен-
               там (целым и с плавающей точкой).
               F и N изменяют интерпретацию arg.  Обычно длина
               arg для преобразований  %p,  %s  или  %n  соот-
               ветствует принимаемой по умолчанию для указате-
               лей в используемой модели  памяти.  F  требует:
               "Интерпретировать arg как дальний указатель". N
               требует: "Интерпретировать arg как ближний ука-
               затель".
               h, l  и  L  замещают установленную по умолчанию
               длину числовых аргументов:  l и L применяются к
               целым  типам  (d,i,o,u,x,X) и типам с плавающей
               точкой (e,E,f,g и G),  в то время, как h приме-
               няется только к целым типам. Ни h, ни l не вли-
               яют на символьные типы (c,s) или  на  указатели
               (p,n).
               ───────────────────────────────────────────────
               Модификатор
               длины         Как интерпретируется arg
               аргумента
               ───────────────────────────────────────────────
                F            arg интерпретируется как дальний
                             указатель.
                N            arg интерпретируется как ближний
                             указатель. N не может быть ис-
                             пользовано ни для каких преобра-
                             зований в модели памяти huge.
                h            arg интерпретируется как short
                             int для d, i, o, u, x или X
                l            arg интерпретируется как long int
                             для d, i, o, u, x или X;
                             arg интерпретируется как double
                             для e, E, f, g или G.
                L            arg интерпретируется как long
                             double для e, E, f, g или G.
               ───────────────────────────────────────────────

Значение       printf возвращает  число  выведенных байтов.  В
               случае ошибки возвращается EOF.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie. Эта функция не совместима с Windows.

См.также       cprintf, ecvt,  fprintf,  fread,  fscanf, putc,
               puts, putw, scanf, sprintf, vprintf, vsprintf

Пример         #include <stdio.h>
               #include <string.h>

               #define I 555
               #define R 5.5

               int main(void)
               {
                  int i,j,k,l;
                  char buf[7];
                  char *prefix = buf;
                  char tp[20];
                  printf("prefix  6d      6o      8x        "
                         "10.2e        10.2f\n");
                  strcpy(prefix,"%");
                  for (i = 0; i < 2; i++)
                  {
                     for (j = 0; j < 2; j++)
                        for (k = 0; k < 2; k++)
                           for (l = 0; l < 2; l++)
                           {
                              if (i==0)  strcat(prefix,"-");
                              if (j==0)  strcat(prefix,"+");
                              if (k==0)  strcat(prefix,"#");
                              if (l==0)  strcat(prefix,"0");
                              printf("%5s |",prefix);
                              strcpy(tp,prefix);
                              strcat(tp,"6d |");
                              printf(tp,I);
                              strcpy(tp,"");
                              strcpy(tp,prefix);
                              strcat(tp,"6o |");
                              printf(tp,I);
                              strcpy(tp,"");
                              strcpy(tp,prefix);
                              strcat(tp,"8x |");
                              printf(tp,I);
                              strcpy(tp,"");
                              strcpy(tp,prefix);
                              strcat(tp,"10.2e |");
                              printf(tp,R);
                              strcpy(tp,prefix);
                              strcat(tp,"10.2f |");
                              printf(tp,R);
                              printf("  \n");
                              strcpy(prefix,"%");
                           }
                      }
                  return 0;
               }
                             Результат программы:

               prefix   6d    6o      8x       10.2e      10.2f

               %-+#0 |+555  |01053 |0x22b   |+5.50e+00 |+5.50     |
               %-+#  |+555  |01053 |0x22b   |+5.50e+00 |+5.50     |
               %-+0  |+555  |1053  |22b     |+5.50e+00 |+5.50     |
               %-+   |+555  |1053  |22b     |+5.50e+00 |+5.50     |
               %-#0  | 555  |01053 |0x22b   |5.50e+00  |5.50      |
               %-#   | 555  |01053 |0x22b   |5.50e+00  |5.50      |
               %-0   | 555  |1053  |22b     |5.50e+00  |5.50      |
               %-    | 555  |1053  |22b     |5.50e+00  |5.50      |
               %+#0  |+00555|001053|0x00022b|+05.50e+00|+000005.50|
               %+#   |  +555| 01053|   0x22b| +5.50e+00|     +5.50|
               %+0   |+00555|001053|0000022b|+05.50e+00|+000005.50|
               %+    |  +555|  1053|     22b| +5.50e+00|     +5.50|
               %#0   |000555|001053|0x00022b|005.50e+00|0000005.50|
               %#    |   555| 01053|   0x22b|  5.50e+00|      5.50|
               %0    |000555|001053|0000022b|005.50e+00|0000005.50|
               %     |   555|  1053|     22b|  5.50e+00|      5.50|

     putc
──────────────────────────────────────────────────────────────
Функция        Выводит символ в поток.

Синтаксис      #include <stdio.h>
               int putc(int c, FILE *stream);

Прототип в     stdio.h

Примечания     putc -  это макрос,  который выводит символ с в
               поток stream.

Значение       При успешном завершении putc  возвращает  выве-
               денный  символ с.  В случае ошибки возвращается
               EOF.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie.

См.также       fprintf, fputc,   fputch,   fputchar,    fputs,
               fwrite,  getc, getchar, printf, putch, putchar,
               putw, vprintf

Пример         #include <stdio.h>

               int main(void)
               {
                  char msg[] = "Hello world\n";
                  int i = 0;

                  while (msg[i])
                     putc(msg[i++], stdout);
                  return 0;
               }

     putch
──────────────────────────────────────────────────────────────
Функция        Выводит символ на экран.

Синтаксис      #include <conio.h>
               int putch(int c);

Прототип в     conio.h

Примечания     putch выводит  символ с в текущее текстовое ок-
               но.  Эта функция работает в текстовом режиме  и
               осуществляет прямой вывод на консоль.  putch не
               преобразует  символы  LF  (\n)  в  пары   CR/LF
               (\r\n).
               Строка выводится либо прямо в видеопамять, либо
               используя сервис BIOS,  в зависимости от значе-
               ния глобальной переменной directvideo.

Значение       При успешном завершении putch возвращает  напе-
               чатанный символ с. В случае ошибки возвращается
               EOF.

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               совместимыми. Она не совместима с Windows.

См.также       cprintf, cputs, getch, getche, putc, putchar

Пример         #include <stdio.h>
               #include <conio.h>

               int main(void)
               {
                  char ch = 0;

                  printf("Input a string:");
                  while ((ch != '\r'))
                  {
                     ch = getch();
                     putch(ch);
                  }
                  return 0;
               }

     putchar
──────────────────────────────────────────────────────────────
Функция        Выводит символ  в  стандартный  выходной  поток
               (stdout).

Синтаксис      #include <stdio.h>
               int putchar(int c);

Прототип в     stdio.h

Примечания     putchar -   это   макрос,   определяемый    как
               putc(c,stdout).

Значение       При успешном завершении putchar возвращает сим-
               вол с. В случае ошибки возвращается EOF.

Переносимость  Эта функция доступна в системах UNIX и  опреде-
               лена  в  ANSI  C.  Она совместима с Kernighan &
               Ritchie. Эта функция не совместима с Windows.

См.также       fputchar, getc,  getchar,  printf, putc, putch,
               puts, putw, vprintf

Пример         #include <stdio.h>

               /* определение некоторых символов для изображения
                  прямоугольника */
               #define LEFT_TOP  0xDA
               #define RIGHT_TOP 0xBF
               #define HORIZ     0xC4
               #define VERT      0xB3
               #define LEFT_BOT  0xC0
               #define RIGHT_BOT 0xD9

               int main(void)
               {
                  char i, j;

                  /* изобразить верхнюю часть прямоугольника */
                  putchar(LEFT_TOP);
                  for (i=0; i<10; i++)
                     putchar(HORIZ);
                  putchar(RIGHT_TOP);
                  putchar('\n');

                  /* изобразить бока прямоугольника */
                  for (i=0; i<4; i++)
                  {
                     putchar(VERT);
                     for (j=0; j<10; j++)
                        putchar(' ');
                     putchar(VERT);
                     putchar('\n');
                  }

                  /* изобразить нижнюю часть прямоугольника */
                  putchar(LEFT_BOT);
                  for (i=0; i<10; i++)
                     putchar(HORIZ);
                  putchar(RIGHT_BOT);
                  putchar('\n');

                  return 0;
               }

     putenv
──────────────────────────────────────────────────────────────
Функция        Добавляет строку к текущей среде.

Синтаксис      #include <stdlib.h>
               int putenv(const char *name);

Прототип в     stdlib.h

Примечания     putenv принимает строку *name и добавляет ее  к
               среде ТЕКУЩЕГО процесса. Например,
                  putenv("PATH=C:\\TC");
               putenv может также быть использована для обнов-
               ления  или  уничтожения   существующей   строки
               *name.  Существующая строка среды удаляется пу-
               тем присвоения переменной среды пустого  значе-
               ния (например, MYVAR= ).
               putenv может быть использована только для изме-
               нения среды текущей  программы.  По  завершении
               программы старая среда восстанавливается.
               Заметим, что строка, передаваемая putenv, долж-
               на быть статической или  глобальной.  Если  ло-
               кальная  или динамическая строка,  передаваемая
               putenv, используется после того, как занимаемая
               ею память будет освобождена, могут быть получе-
               ны непредсказуемые результаты.

Значение       При успешном завершении putenv возвращает 0,  в
               случае неудачи возвращается -1.

Переносимость  Эта функция доступна в системах UNIX.

См.также       getenv

Пример         #include <stdio.h>
               #include <stdlib.h>
               #include <alloc.h>
               #include <string.h>
               #include <dos.h>

               int main(void)
               {
                  char *path, *ptr;
                  int i = 0;

                  /* получить текущий путь среды */
                  ptr = getenv("PATH");

                  /* установить новый путь */
                  path = malloc(strlen(ptr)+15);
                  strcpy(path,"PATH=");
                  strcat(path,ptr);
                  strcat(path,";c:\\temp");

                  /* поместить текущий путь и вывести на экран
                     текущее окружение */
                  putenv(path);
                  while (environ[i])
                      printf("%s\n",environ[i++]);

                  return 0;
               }

     putimage
──────────────────────────────────────────────────────────────
Функция        Выводит битовый образ на экран.

Синтаксис      #include <graphics.h>
               void far putimage(int left, int top,
                                 void far *bitmap, int op);

Прототип в     graphics.h

Примечания     putimage выводит битовый образ,  предварительно
               сохраненный функцией getimage,  обратно на  эк-
               ран. Левый верхний угол образа будет находиться
               в точке (left,top).  bitmap - указатель на  об-
               ласть памяти, где находится исходный образ.
               Параметр op определяет оператор комбинирования,
               который  устанавливает,  как  вычисляется  цвет
               каждого выводимого пиксела на экране, исходя из
               уже существующего пиксела  на  экране  и  соот-
               ветствующего пиксела в памяти.
               Перечисление putimage_ops,    определенное    в
               graphics.h, дает имена этим операторам.
               ───────────────────────────────────────────────
                  Имя    Значение    Описание
               ───────────────────────────────────────────────
                COPY_PUT      0      Копирование
                XOR_PUT       1      Исключающее ИЛИ
                OR_PUT        2      ИЛИ
                AND_PUT       3      И
                NOT_PUT       4      Инверсия
               ───────────────────────────────────────────────
               Другими словами, COPY_PUT копирует исходный би-
               товый образ на экран, XOR_PUT осуществляет опе-
               рацию "исключающее ИЛИ"  (XOR)  между  исходным
               образом и образом на экране, OR_PUT осуществля-
               ет операцию "ИЛИ" (OR) между исходным образом и
               образом на экране и т. д.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       getimage, imagesize, putpixel, setvisualpage

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               #define ARROW_SIZE 10
               void draw_arrow(int x, int y);
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  void *arrow;
                  int x, y, maxx;
                  unsigned int size;
                  /* инициализация графики
                     и локальных переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {  printf("Graphics error: %s\n",
                             grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  maxx = getmaxx();
                  x = 0;
                  y = getmaxy() / 2;
                  draw_arrow(x, y);
                  /* подсчитаем размер образа
                     и распределим для него память */
                  size = imagesize(x, y - ARROW_SIZE,
                                   x + (4 * ARROW_SIZE),
                                   y + ARROW_SIZE);
                  arrow = malloc(size);
                  /* запоминаем образ */
                  getimage(x, y - ARROW_SIZE,
                           x + (4 * ARROW_SIZE),
                           y + ARROW_SIZE, arrow);
                  /* повторяем до нажатия клавиши */
                  while (!kbhit()) {
                     /* удаляем старый образ */
                     putimage(x, y - ARROW_SIZE, arrow,
                              XOR_PUT);
                     x += ARROW_SIZE;
                     if (x >= maxx)
                        x = 0;
                     /* рисуем новый образ */
                     putimage(x, y - ARROW_SIZE, arrow,
                              XOR_PUT);
                  }
                  free(arrow);
                  /* выход из графики */
                  closegraph();
                  return 0;
               }
               void draw_arrow(int x, int y) {
                  /* рисуем стрелку на экране */
                  moveto(x, y);
                  linerel(4 * ARROW_SIZE, 0);
                  linerel(-2 * ARROW_SIZE, -1 * ARROW_SIZE);
                  linerel(0, 2 * ARROW_SIZE);
                  linerel(2 * ARROW_SIZE, -1 * ARROW_SIZE);
               }

     putpixel
──────────────────────────────────────────────────────────────
Функция        Изображает пиксел в указанной точке.

Синтаксис      #include <graphics.h>
               void far putpixel(int x, int y, int color);

Прототип в     graphics.h

Примечания     putpixel изображает точку (x,y) цветом, опреде-
               ленным в color.

Значение       Нет.

Переносимость  Эта функция доступна только в Borland C++.  Она
               работает  только  с ПЭВМ IBM PC и совместимыми,
               оснащенными дисплеем с  графическим  адаптером.
               Эта функция не совместима с Windows.

См.также       getpixel, putimage

Пример         #include <graphics.h>
               #include <stdlib.h>
               #include <stdio.h>
               #include <conio.h>
               #include <dos.h>
               #define PIXEL_COUNT 1000
               #define DELAY_TIME  100  /* в миллисекундах */
               int main(void)
               {  /* запрос автообнаружения */
                  int gdriver = DETECT, gmode, errorcode;
                  int i, x, y, color, maxx, maxy, maxcolor,
                      seed;
                  /* инициализация графики
                     и локальных переменных */
                  initgraph(&gdriver, &gmode, "");
                  /* чтение результата инициализации */
                  errorcode = graphresult();
                  if (errorcode != grOk)   /* ошибка */
                  {  printf("Graphics error: %s\n",
                             grapherrormsg(errorcode));
                     printf("Press any key to halt:");
                     getch();
                     exit(1); /* завершение с кодом ошибки */
                  }
                  maxx = getmaxx() + 1;
                  maxy = getmaxy() + 1;
                  maxcolor = getmaxcolor() + 1;
                  while (!kbhit())
                  {  /* инициализация генератора
                        случайных чисел */
                     seed = random(32767);
                     srand(seed);
                     for (i = 0; i < PIXEL_COUNT; i++) {
                        x = random(maxx);
                        y = random(maxy);
                        color = random(maxcolor);
                        putpixel(x, y, color);
                     }
                     delay(DELAY_TIME);
                     srand(seed);
                     for (i = 0; i < PIXEL_COUNT; i++) {
                        x = random(maxx);
                        y = random(maxy);
                        color = random(maxcolor);
                        if (color == getpixel(x, y))
                           putpixel(x, y, 0);
                     }
                  }
                  /* выход из графики */
                  getch();
                  closegraph();
                  return 0;
               }

     puts
──────────────────────────────────────────────────────────────
Функция        Выводит строку  в  стандартный  выходной  поток
               (stdout).

Синтаксис      #include <stdio.h>
               int puts(const char *s);

Прототип в     stdio.h

Примечания     puts копирует строку *s,  завершаемую нуль-сим-
               волом,  в  стандартный  выходной поток stdout и
               добавляет символ конца строки.

Значение       При успешном завершении puts возвращает неотри-
               цательное значение.  В противном случае возвра-
               щается EOF.
                                                       2
Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C. Она не совместима с Windows.

См.также       cputs, fputs, gets, printf, putchar

Пример         #include <stdio.h>
               int main(void)
               {  char string[] =
                       "This is an example output string\n";
                  puts(string);
                  return 0;
               }

     puttext
──────────────────────────────────────────────────────────────
Функция        Копирует текст из памяти на экран  в  текстовом
               режиме.

Синтаксис      #include <conio.h>
               int puttext(int left, int top, int right,
                           int bottom, void *source);

Прототип в     conio.h

Примечания     puttext выводит  содержимое  области  памяти  в
               прямоугольную область экрана,  определенную па-
               раметрами left, top, right и bottom.
               source - указатель на исходную область.
               Все координаты являются  абсолютными  экранными
               координатами,  не  зависящими от текущего окна.
               Верхний левый угол находится в точке (1,1).
               puttext помещает  содержимое  области  памяти в
               указанный прямоугольник  последовательно  слева
               направо и сверху вниз.
               puttext - функция,  осуществляющая прямой вывод
               на экран в текстовом режиме.

Значение       puttext возвращает  ненулевое  значение,   если
               операция завершилась успешно;  в случае неудачи
               возвращается 0 (например,  если заданные значе-
               ния  координат не допустимы для текущего режима
               экрана).

Переносимость  Эта функция  работает  только  с  ПЭВМ IBM PC и
               BIOS-совместимыми. Она не совместима с Windows.

См.также       gettext, movetext, window

Пример         #include <conio.h>
               int main(void)
               {  char buffer[512];
                  /* вывод текст на экран */
                  clrscr();
                  gotoxy(20, 12);
                  cprintf("This is a test.  "
                          "Press any key to continue ...");
                  getch();
                  /* сохранение содержимого экрана */
                  gettext(20, 12, 36, 21,buffer);
                  clrscr();
                  /* вывод сохраненного текста
                     обратно на экран */
                  gotoxy(20, 12);
                  puttext(20, 12, 36, 21, buffer);
                  getch();
                  return 0;
               }

     putw
──────────────────────────────────────────────────────────────
Функция        Выводит целое число в поток.

Синтаксис      #include <stdio.h>
               int putw(int w, FILE *stream);

Прототип в     stdio.h

Примечания     putw выводит  целое  число  w в заданный поток.
               putw не предполагает и не обеспечивает никакого
               специального выравнивания в файле.

Значение       При успешном  завершении  putw возвращает w.  В
               случае ошибки возвращается EOF. Поскольку EOF -
               допустимое  целое значение,  используйте ferror
               для выявления ошибочной ситуации после putw.

Переносимость  Эта функция доступна в системах UNIX.

См.также       getw, printf

Пример         #include <stdio.h>
               #include <stdlib.h>
               #define FNAME "test.$$$"
               int main(void)
               {  FILE *fp;
                  int word;
                  /* запись слова в файл */
                  fp = fopen(FNAME, "wb");
                  if (fp == NULL) {
                     printf("Error opening file %s\n", FNAME);
                     exit(1);
                  }
                  word = 94;
                  putw(word,fp);
                  if (ferror(fp))
                      printf("Error writing to file\n");
                  else
                      printf("Successful write\n");
                  fclose(fp);
                  /* повторное открытие файла */
                  fp = fopen(FNAME, "rb");
                  if (fp == NULL) {
                     printf("Error opening file %s\n", FNAME);
                     exit(1);
                  }

                  /* извлекаем слово */
                  word = getw(fp);
                  if (ferror(fp))
                     printf("Error reading file\n");
                  else
                     printf("Successful read: word = %d\n",
                            word);
                  /* выход */
                  fclose(fp);
                  unlink(FNAME);
                  return 0;
               }

     qsort
──────────────────────────────────────────────────────────────
Функция        Реализует алгоритм "быстрой сортировки".

Синтаксис      #include <stdlib.h>
               void qsort(void *base,
                    size_t nelem, size_t width,
                    int (*fcmp)(const void *, const void *));

Прототип в     stdlib.h

Примечания     qsort реализует вариант "среднее из трех" алго-
               ритма  "быстрой  сортировки".  qsort  сортирует
               элементы таблицы, повторно вызывая определенную
               пользователем функцию сравнения fcmp.
               - base указывает на базу (0-й элемент) таблицы,
                 подлежащей сортировке.
               - nelem - количество элементов в таблице.
               - width - длина каждого элемента в байтах.
               Функция сравнения *fcmp принимает два  аргумен-
               та,  elem1 и elem2,  каждый из которых является
               указателем на элемент таблицы.  Указанные  эле-
               менты (*elem1 и *elem2) сравниваются,  и исходя
               из  результата  сравнения  возвращается   целое
               число.
                 *elem1 < *elem2   *fcmp возвращает целое < 0
                 *elem1 == *elem2  *fcmp возвращает 0
                 *elem1 > *elem2   *fcmp возвращает целое > 0
               При сравнении  символ "меньше" (<) значит,  что
               левый элемент должен находиться перед правым  в
               отсортированной последовательности. Аналогично,
               символ "больше" (>) означает, что левый элемент
               должен находиться после правого в отсортирован-
               ной последовательности.

Значение       Нет.

Переносимость  Эта функция  доступна в системах UNIX и опреде-
               лена в ANSI C.

См.также       bsearch, lsearch

Пример         #include <stdio.h>
               #include <stdlib.h>
               #include <string.h>
               int sort_function(const void *a,
                                 const void *b);
               char list[5][4] = {"cat", "car", "cab", "cap",
                                  "can" };
               int main(void)
               {  int  x;
                  qsort((void *)list, 5, sizeof(list[0]),
                        sort_function);
                  for (x = 0; x < 5; x++)
                     printf("%s\n", list[x]);
                  return 0;
               }
               int sort_function(const void *a, const void *b)
               {  return( strcmp(a,b) );
               }

               Результат программы: cab, can, cap, car, cat
