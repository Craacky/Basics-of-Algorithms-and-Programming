                           ГЛАВА 6.
                     УПРАВЛЕНИЕ ПАМЯТЬЮ.

     Эта глава посвящена:
     - Ошибки выхода из памяти. Что делать при получении.
     - Моделям памяти, от tiny до huge. Мы объясним что они из
себя представляют,  как выбрать необходимую и почему Вам лучше
использовать (или нет) ту или иную модель памяти (см.  в главе
3 "Построение приложений Windows" Руководства пользователя ин-
формацию о выборе модели памяти для модулей Windows).
     - Оверлеи. Как они работают и как их использовать.

                       Выход из памяти.

     При компиляции Borland C++ не генерирует никаких промежу-
точных  структур  данных  на  диск  (Borland C++ на диск пишет
только файлы .OBJ); вместо этого он использует для промежуточ-
ных структур данных RAM.  Из-за этого Вы можете получить сооб-
щение "Out of memory...", если компилятору не хватает памяти.
     Решение этой  проблемы состоит в уменьшении Ваших функций
или разбиении файлов,  содержащих эти большие  функции.  Можно
также удалить любые RAM-резидентные программы для освобождения
большей памяти для использования Borland C++.

                        Модели памяти.

     Borland C++ предоставляет Вам 6 моделей памяти,  примени-
мые для разных программ и размеров кода.  Каждая модель памяти
по разному использует память.  Что Вам требуется знать,  чтобы
использовать модели памяти?  Чтобы ответить на этот вопрос  мы
рассмотрим работу компьютера.  Его процессор принадлежит к се-
мейству Intel iAPx86;  он может быть 8088, 8086, 80186, 80286,
80386 и 80486. Мы будем говорить о нем, как о 8086.

                        Регистры 8086.

     Существует несколько регистров в 8086. Мы не будем описы-
вать регистр IP,  поскольку Borland C++ не может обращаться  к
нему напрямую.

                          Рис. 6.1.
                        Регистры 8086.

      Регистры общего назначения
    ┌──────────────┬──────────────┐ Аккумулятор
 AX │      AH      │      AL      │ (математические операции)
    ├──────────────┼──────────────┤
 BX │      BH      │      BL      │ База (индексная адресация)
    ├──────────────┼──────────────┤
 CX │      CH      │      CL      │ Счетчик (индексная адресация)
    ├──────────────┼──────────────┤
 DX │      DH      │      DL      │ Данные (хранение данных)
    └──────────────┴──────────────┘
        Сегментные регистры
    ┌─────────────────────────────┐
 CS │                             │ Указатель сегмента кода
    ├─────────────────────────────┤
 DS │                             │ Указатель сегмента данных
    ├─────────────────────────────┤
 SS │                             │ Указатель сегмента стека
    ├─────────────────────────────┤
 ES │                             │ Указатель экстра сегмента
    └─────────────────────────────┘
    Регистры специального назначения
    ┌─────────────────────────────┐
 SP │                             │ Указатель стека
    ├─────────────────────────────┤
 BP │                             │ Указатель базы
    ├─────────────────────────────┤
 SI │                             │ Индекс источника
    ├─────────────────────────────┤
 DI │                             │ Индекс назначения
    └─────────────────────────────┘

                 Регистры общего назначения.

     Регистры общего  назначения  наиболее  часто используются
для хранения и манипуляции данными.  Каждый из них имеет опре-
деленную специальную функцию. Например
     - Некоторые  математические  операции  могут  выполняться
только с помощью АХ.
     - ВХ может использоваться только как индексный регистр.
     - СХ используется в loop и некоторых строковых инструкци-
ях.
     - DX  неявно используется в некоторых математических опе-
рациях. Ряд операций могут выполнять все эти регистры.

                     Сегментный регистр.

     Сегментные регистры содержат начальный адрес одного из  4
сегментов.  Как описано в следующем разделе 16-битное значение
сегментного регистра сдвигается влево на 4 бита (умножается на
16), чтобы получить 20-битный адрес этого сегмента.

              Регистры специального назначения.

     8086 так же имеет регистры специального назначения:
     - регистры SI и DI могут использоваться как индексные ре-
гистры.  Они так же используются в Borland C++ под регистровые
переменные.
     - регистр  SP  указывает на текущую вершину стека и явля-
ется смещением в сегменте стека.
     - регистр BP - это вторичный сегментный указатель, обычно
используется для индексирования в стеке при использовании  ар-
гументов или автоматических переменных.
     Функции Borland C++ используют регистр BP как базовый ад-
рес  для  аргументов  и  автоматических переменных.  Параметры
используют положительное смещение от BP,  которое  меняется  в
зависимости от модели памяти. BP всегда указывает на сохранен-
ное предыдущее значение BP.  Функции без аргументов не исполь-
зуют  BP  или  сохраняют  BP,  если опция Standard Stack Frame
установлена в Off.
     Автоматические переменные имеют отрицательное смещение от
BP.  Смещение зависит от того, сколько пространства было выде-
лено под переменные.

                       Регистр флагов.

     16-битный регистр  флагов содержит информацию о состоянии
8086 и результатах последней инструкции.
     Например, если Вы хотите знать где вычитание дало нулевой
результат,  Вы проверяете флаг нуля (бит Z в регистре  флагов)
сразу после инструкции;  если он установлен Вы знаете, что ре-
зультат равен 0.  Другие флаги, такие как флаги переноса и пе-
реполнения,  информируют  о результатах логических и арифмети-
ческих операций.

                          Рис. 6.2.
                     Регистр флагов 8086.

            Виртуальный режим 8086
            │  Возобновление
            │  │     Вложенность задач
            │  │     │   Уровень защиты В/В
            │  │     │   │  Переполнение
            │  │     │   │  │  Направление
            │  │     │   │  │  │  Разрешение прерываний
            │  │     │   │  │  │  │  Системное прерывание
            │  │     │   │  │  │  │  │  Знак
            │  │     │   │  │  │  │  │  │  Ноль
            │  │     │   │  │  │  │  │  │  │Дополнительный перенос
            │  │     │   │  │  │  │  │  │  │     │     Четность
            │  │     │   │  │  │  │  │  │  │     │     │   Перенос
31          │  │  15 │   │  │  │  │  │  7  │     │     │     0
┌─┬─┬─┐  ┌─┬──┬──┬──┬──┬───┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
│ │ │ │..│ │V │R │  │N │IOP│O │D │I │T │S │Z │  │A │  │P │  │C │
└─┴─┴─┘  └─┴──┴──┴──┴──┴───┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
          23
└─────────┬──────┘└────┬───┘└─────────────────┬────────────────┘
  только для 80386   80286         для всех 80х86 процессоров
                     80386

     Другие флаги  контролируют режимы работы 8086.  Флаг нап-
равления управляет направлением,  в котором работают строковые
инструкции, а флаг прерывания управляет, разрешены ли в данный
момент прерывания от аппаратных устройств, таких как клавиату-
ра  или  модема,  и  разрешается для прерываний текущего кода,
чтобы обслужить самые неотложные потребности.  Флаг системного
прерывания используется только программным обеспечением.
     Регистр флагов обычно напрямую не модифицируется и не чи-
тается. Вместо этого регистр флагов управляется с помощью спе-
циальных ассемблерных инструкций (таких как CLD,  STI,  CMC) и
через арифметические и логические инструкции,  которые модифи-
цируют определенные флаги. Аналогично содержимое некоторых би-
тов  регистра  флагов воздействует на такие инструкции как JZ,
RCR,  MOVSB. Регистр флагов не используется как память, а ско-
рее для хранения статуса и контрольных данных 8086.

                     Сегментация памяти.

     Процессор 8086  имеет  сегментную архитектуру памяти.  Он
имеет общее пространство памяти 1Мб,  но  сконструирован  так,
что  может  прямо адресовать только 64К памяти в каждый момент
времени. 64К-байтная часть памяти известна как сегмент.
     - 8086  отслеживает  4 сегмента:  кода,  данных,  стека и
extra.  Сегмент кода - это машинные инструкции; сегмент данных
-  это  информация;  стек  -  это конечно стек и extra сегмент
используется для дополнительных данных.
     - 8086  имеет  четыре 16-битных сегментных регистра.  CS,
DS,  SS и ES указывающих на сегменты  кода,  данных,  стека  и
extra соответственно.
     - Сегмент может быть расположен в любом месте памяти - по
крайней  мере,  почти везде.  Сегмент должен начинаться на ад-
ресе, кратном 16 (в системе с основанием 10).

                      Вычисление адреса.

     Полный адрес 8086 составляется из двух  16-битных  значе-
ний:  адреса сегмента и смещения.  Предположим, что адрес сег-
мента данных -  значение  в  регистре  DS  -  2f84  (16-ричное
представление) и Вы хотите вычислить адрес данных, находящихся
в этом сегменте со смещением 0532 (16-ричное представление) от
начала сегмента данных; как это сделать?
     Адрес вычисляется  так:  значение  сегментного   регистра
сдвигается на 4 бита влево и к нему прибавляется смещение.
     Результирующее 20-битное значение - это адрес данных:

 регистр DS (сдвиг) :  0010  1111  1000  0100  0000  =  2F840
 смещение :                  0000  0101  0011  0010  =  00532
 ────────────────────  ────────────────────────────────────────
 адрес :               0010  1111  1101  0111  0010  =  2FD72

     Начальный адрес сегмента - это всегда 20-битное число, но
поскольку сегментный регистр содержит только 16  бит,  младшие
16  бит  принимаются равными 0.  Именно поэтому адрес сегмента
кратен 16 и начинается с адреса,  где  последние  четыре  бита
(или последняя 16-ричная цифра) равны 0.  Так, если в регистре
DS хранится значение 2f84, сегмент данных начинается по адресу
2f840.
     Примечание: Часть памяти в 16 байт называется параграфом,
поэтому  можно сказать,  что сегмент начинается на границе па-
раграфа.
     Стандартная запись адреса имеет форму:  сегмент:смещение;
например предыдущий адрес может быть записан,  как  2f84:0532.
Заметим, что поскольку смещения могут перекрываться, пара сег-
мент:смещение не является уникальной;  следующие адреса ссыла-
ются на одно положение в памяти:
     0000:0123
     0002:0103
     0008:00A3
     0010:0023
     0012:0003
     Сегменты могут (но не делайте этого) перекрываться.  Нап-
ример,  все 4 сегмента могут начинаться с одного  адреса,  что
означает, что Ваша программа использует не больше 64К - но это
все пространство, которое у Вас имеется для Вашего кода, Ваших
данных и Вашего стека.

                          Указатели.

     Хотя Вы  можете  объявить тип указателя или функции неза-
висимо от используемой модели памяти,  но по умолчанию тип мо-
дели   памяти,  выбранный  Вами,  определяет  тип  указателей,
используемых для кода и данных. Указатели могут быть: near (16
бит), far (32 бит), huge (так же 32 бит) и segment (16 бит).

                       Указатели near.

     16-битный указатель  используется  внутри одного сегмента
для получения адреса. Например, указатель на функцию добавляет
16-битное значение к сдвинутому влево содержимому регистра ко-
дового сегмента (CS). Аналогично, near указатель на данные со-
держит смещение относительно регистра DS. Указатели near легко
обрабатывать,  поскольку любые арифметические операции  (такие
как сложение) производятся без учета сегмента.

                        Указатели far.

     32-битные указатели  содержат  не  только смещение внутри
сегмента,  но так же адрес сегмента (как другое 16-битное зна-
чение),  которое затем сдвигается влево и добавляется к смеще-
нию. Используя far указатели, Вы можете использовать несколько
кодовых  сегментов;  это означает,  что Вы можете использовать
программы больше 64К.  Вы можете так же адресовать  более  64К
данных.
     Когда Вы используете far указатели на данные,  Вам требу-
ется  учитывать некоторые потенциальные проблемы при манипуля-
циях над указателями.  Как объяснялось вычисление  адреса,  Вы
можете  иметь  различные  пары  сегмент:смещение при ссылке на
один адрес.  Например,  far указатели 0000:0120,  0010:0020  и
0012:0000 - все решаются в один 20-битный адрес.  Однако, если
Вы имеете 3 различных far указателя a,  b и  c,  содержащих  3
значения, следующие выражения будут давать false:
     if (a == b) ...
     if (b == c) ...
     if (a == c) ...
     Аналогичные проблемы возникают,  когда Вы хотите сравнить
far указатели, используя операторы >, >=, <, <=. В этих случа-
ях только смещение используется при сравнениях; следующие зна-
чения будут true:
     if (a > b) ...
     if (b > c) ...
     if (a > c) ...
     Операторы ==  и  !=  используют  32-битное  значение  как
unsigned long (но не как полный адрес памяти). Операторы срав-
нения <=, >=, >, < используют только смещение.
     Операторы == и != используют 32 бита при сравнении с NULL
указателем (0000:0000).  Если Вы используете  только  смещение
для проверки равенства,  любой указатель со смещением 0000 бу-
дет равен указателю NULL, чего Вам бы вероятно не хотелось.
     ВАЖНО! Если Вы добавляете значение к far указателю, изме-
няется только смещение.  Если Вы добавляете достаточно большое
значение,  чтобы смещение превысило FFFF, указатель будет "пе-
реходить" на начало сегмента.  Например,  если Вы добавите 1 к
5031:FFFF,  результат будет 5031:0000 (а не 6031:0000). Анало-
гично,  при вычитании 1 из 5031:0000 Вы получите 5031:FFFF  (а
не 5030:000F).
     Если Вы хотите  сравнивать  указатели,  используйте  либо
near указатели - которые используют один сегментный адрес, ли-
бо huge указатели, описанные ниже.

                       Указатели huge.

     Huge указатели имеют длину так же 32 бита. Как и far ука-
затели,  они содержат адрес сегмента и смещение. Однако, в от-
личие от far указателей,  они нормализованы для предотвращения
проблем, связанных с far указателями.
     Что такое нормализованный указатель? Это 32-битный указа-
тель, который имеет максимально возможное значение адреса сег-
мента. Поскольку сегмент может начинаться через каждые 16 байт
(10  в  16-ричном представлении),  это означает,  что значение
смещения может быть в диапазоне от 0  до  15  (от  0  до  F  в
16-ричном представлении).
     Чтобы нормализовать указатель, преобразуйте его в 20-бит-
ный  адрес,  затем используйте правых 4 бита для смещения и 16
левых бит для сегмента. Например, указатель 2f84:0532 преобра-
зуется  в  абсолютный  адрес  2fd72,  который  нормализуется в
2fd7:0002. Приведем несколько указателей с их нормализованными
эквивалентами:
     0000:0123     0012:0003
     0040:0056     0045:0006
     500D:9407     594D:0007
     7418:D03F     811B:000F
     Существует 3 причины,  по которым важно хранить huge ука-
затели нормализованными.
     1. Во-первых, для каждого адреса памяти существует только
один возможный huge адрес - пара сегмент:смещение. Это означа-
ет,  что операторы == и != работают корректно для любого  huge
указателя.
     2. Кроме того, нормализация гарантирует, что операторы >,
>=,  <,  <=, использующие 32-битное значение для huge указате-
лей, будут давать правильный результат.
     3. Наконец,  благодаря нормализации, смещение в huge ука-
зателе автоматически округляется через каждые 16 значений,  но
в отличие от far указателей, сегмент так же изменяется. Напри-
мер, если Вы увеличили 811В:000F, то получится 811С:0000; ана-
логично,  если Вы уменьшите 811С:0000,  то получите 811В:000F.
Это свойство  huge  указателей  позволяет  Вам  манипулировать
структурами данных, большими, чем 64К. Это гарантирует, напри-
мер,  что если имеется huge массив  из  структур,  превышающий
64К,  то индексирование массива и выбор поля struct всегда бу-
дут работать со структурами любого размера.
     За использование  huge  указателей приходится платить до-
полнительными вычислениями.  Арифметика huge указателей произ-
водится вызовом специальных программ.  В результате арифметика
для huge указателей значительно медленнее,  чем  для  far  или
near указателей.

                      6 моделей памяти.

     Borland C++  дает  Вам  6  моделей памяти:  tiny,  small,
medium, compact, large, huge. Требование к Вашей программе оп-
ределяют Ваш выбор. Приведем краткое описание моделей:

                             tiny

     Это самая  маленькая модель памяти.  Все 4 сегментных ре-
гистра (CS,  DS, SS, ES) установлены на один адрес так, что Вы
используете всего 64К для кода, данных и стека. Всегда исполь-
зуются near указатели. Программа модели tiny может быть преоб-
разована в формат
.COM при редактировании с опцией /t.
     Примечание. Используйте эту модель,  когда память пользу-
ется большим спросом.

                            small

     Код и данные используют различные сегменты и эти сегменты
не  перекрываются,  так  что Вы можете использовать 64К кода и
64К данных и стека.  Всегда используются near  указатели  (это
хороший размер для средней программы).

                            medium

     Для кода используются far указатели, для данных - near. В
результате данные и стек ограничены 64К,  а код может занимать
до  1Мб.  (Оптимально для больших программ,  которые не хранят
много данных в памяти).

                           compact

     far указатели используются для данных,  near - для  кода.
Код ограничен 64К, а данные могут занимать до 1 Мб. (Оптималь-
но для небольшого кода с необходимостью адресации большого ко-
личества данных).

                            large

     far указатели  используются для кода и данных,  с возмож-
ностью адресации каждого из них до 1 Мб. (large и huge исполь-
зуются только для очень больших программ).

                             huge

     far указатели  используются  только  для  кода  и данных.
Обычно Borland C++ ограничивает размер статических данных 64К;
huge модель позволяет данным занимать более 64К.
     Для того, чтобы выбрать эти модели памяти, Вы используете
либо меню в интегрированной среде, либо опцию командной строки
компилятора Borland C++.
     Следующие рисунки (с 6.3 по 6.8) показывают распределение
памяти в 6 моделях памяти Borland C++.

                          Рис. 6.3.
              Сегментация в модели памяти tiny.

       Сегментные регистры:                        Размер сегмента:

ниж-   CS,DS,SS ──Ў┌─ ┌─────────────────────────────┐ ─┐
ние  °             │  │      _TEXT класс 'CODE'     │  │
адре-│             │  │            код              │  │
са   │             │  ├─────────────────────────────┤  │
     │             │  │      _DATA класс 'DATA'     │  │
     │             │  │  инициализированные данные  │  │
     │             │  ├─────────────────────────────┤  │
     │     DGROUP ─┤  │      _BSS класс 'BSS'       │  ├─ до 64К
     │             │  │ неинициализированные данные │  │
     │             │  ├─────────────────────────────┤  │
верх-│             │  │         КУЧА ∙              │  │
ние  │             │  │█████████████████████████████│  │  свободная
адре-│    SP(TOS) ─┼─Ў│█████████████████████████████│ ў┼─ память
са   ∙             │  │         СТЕК °              │  │
        начало SP─Ў└─ └─────────────────────────────┘ ─┘

                          Рис. 6.4.
              Сегментация в модели памяти small.

       Сегментные регистры:                        Размер сегмента:

ниж-         CS ────Ў ┌─────────────────────────────┐
ние  °                │      _TEXT класс 'CODE'     │
адре-│                │            код              │
са   │     DS,SS ─Ў┌─ ├─────────────────────────────┤ ─┐
     │             │  │      _DATA класс 'DATA'     │  │
     │             │  │  инициализированные данные  │  │
     │             │  ├─────────────────────────────┤  │
     │     DGROUP ─┤  │      _BSS класс 'BSS'       │  ├─ до 64К
     │             │  │ неинициализированные данные │  │
     │             │  ├─────────────────────────────┤  │
     │             │  │         КУЧА ∙              │  │
     │             │  │█████████████████████████████│  │  свободная
     │    SP(TOS) ─┼─Ў│█████████████████████████████│ ў┼─ память
     │             │  │         СТЕК °              │  │
верх-│  начало SP─Ў└─ ├─────────────────────────────┤ ─┘
ние  │                │       FAR КУЧА ∙            │
адре-│                │█████████████████████████████│     свободная
са   ∙                │█████████████████████████████│ ў── память
                      └─────────────────────────────┘

                             Рис. 6.5.
                Сегментация в модели памяти medium.

     Несколько исходных файлов
     (sfile):
    ┌────────────────┐
    │  sfile A       │
    ├────────────────┤
CSЎ │  sfile B       │ ў──┐
    ├────────────────┤    │
    │   ...          │    │
    ├────────────────┤    │
    │  sfile Z       │    │
    └────────────────┘    │
                          │
                          │
    Сегментные регистры:  │                        Размер сегмента:
                          │
             CS ────Ў ┌───┼─────────────────────────┐
ниж-                  │┌──┴──┐                      │  каждый до
ние  °                ││sfile│ _TEXT класс 'CODE'   │  64К
адре-│                │└─────┘     код              │
са   │     DS,SS ─Ў┌─ ├─────────────────────────────┤ ─┐
     │             │  │      _DATA класс 'DATA'     │  │
     │             │  │  инициализированные данные  │  │
     │             │  ├─────────────────────────────┤  │
     │     DGROUP ─┤  │      _BSS класс 'BSS'       │  ├─ до 64К
     │             │  │ неинициализированные данные │  │
     │             │  ├─────────────────────────────┤  │
     │             │  │         КУЧА ∙              │  │
     │             │  │█████████████████████████████│  │  свободная
     │    SP(TOS) ─┼─Ў│█████████████████████████████│ ў┼─ память
     │             │  │         СТЕК °              │  │
верх-│  начало SP─Ў└─ ├─────────────────────────────┤ ─┘
ние  │                │       FAR КУЧА ∙            │
адре-│                │█████████████████████████████│     свободная
са   ∙                │█████████████████████████████│ ў── память
                      └─────────────────────────────┘

                             Рис. 6.6.
               Сегментация в модели памяти compact.

       Сегментные регистры:                        Размер сегмента:

ниж-         CS ────Ў ┌─────────────────────────────┐
ние  °                │      _TEXT класс 'CODE'     │  до 64К
адре-│                │            код              │
са   │       DS ──Ў┌─ ├─────────────────────────────┤ ─┐
     │             │  │      _DATA класс 'DATA'     │  │
     │             │  │  инициализированные данные  │  │
     │      DGROUP─┤  ├─────────────────────────────┤  ├─ до 64К
     │             │  │      _BSS класс 'BSS'       │  │
     │             │  │ неинициализированные данные │  │
     │       SS ─Ў └─ ├─────────────────────────────┤ ─┘
     │                │█████████████████████████████│     свободная
     │    SP(TOS) ───Ў│█████████████████████████████│ ў── память
     │                │         СТЕК °              │ до 64К
     │   начало SP─Ў  ├─────────────────────────────┤
верх-│                │         КУЧА ∙              │
ние  │                │█████████████████████████████│     свободная
адре-│                │█████████████████████████████│ ў── память
са   ∙                └─────────────────────────────┘

                             Рис. 6.7.
                Сегментация в модели памяти large.

 Несколько исходных файлов
 (sfile):
    ┌────────────────┐
    │  sfile A       │
    ├────────────────┤
    │  sfile B       │
    ├────────────────┤
    │   ...          │
    ├────────────────┤
CSЎ │  sfile Z       │ ў──┐
    └────────────────┘    │
                          │
                          │
    Сегментные регистры:  │                        Размер сегмента:
                          │
                      ┌───┼─────────────────────────┐
ниж-                  │┌──┴──┐                      │  каждый до
ние  °                ││sfile│ _TEXT класс 'CODE'   │  64К
адре-│                │└─────┘     код              │
са   │       DS ──Ў┌─ ├─────────────────────────────┤ ─┐
     │             │  │      _DATA класс 'DATA'     │  │
     │             │  │  инициализированные данные  │  │
     │     DGROUP ─┤  ├─────────────────────────────┤  ├─ до 64К
     │             │  │      _BSS класс 'BSS'       │  │
     │             │  │ неинициализированные данные │  │
     │       SS ─Ў └─ ├─────────────────────────────┤ ─┘
     │                │█████████████████████████████│     свободная
     │    SP(TOS) ───Ў│█████████████████████████████│ ў── память
     │                │         СТЕК °              │  до 64К
верх-│   начало SP─Ў  ├─────────────────────────────┤
ние  │                │         КУЧА ∙              │
адре-│                │█████████████████████████████│     свободная
са   ∙                │█████████████████████████████│ ў── память
                      └─────────────────────────────┘

                             Рис. 6.8.
                  Сегментация модели памяти huge.

 Несколько исходных файлов        Несколько исходных файлов
 (sfile):                         (sfile):
    ┌────────────────┐                ┌────────────────┐
    │  sfile A       │                │  sfile A       │
    ├────────────────┤                ├────────────────┤
    │  sfile B       │            ┌─Ў │  sfile B       │ ў─DS
    ├────────────────┤            │   ├────────────────┤
    │   ...          │            │   │   ...          │
    ├────────────────┤            │   ├────────────────┤
CSЎ │  sfile Z       │ ў──┐       │   │  sfile Z       │
    └────────────────┘    │       │   └────────────────┘
                          │       │
                          │       │
    Сегментные регистры:  │       │                Размер сегмента:
                          │       └──────────────────────┐
                      ┌───┼─────────────────────────┐    │
ниж-                  │┌──┴──┐                      │    │каждый
ние  °                ││sfile│ _TEXT класс 'CODE'   │    │до 64К
адре-│                │└─────┘     код              │    │
са   │                ├─────────────────────────────┤    │
     │                │┌─────┐                      │    │
     │                ││sfile├──────────────────────┼────┘
     │                │└─────┘ _DATA класс 'DATA'   │ каждый до
     │                │  инициализированные данные  │ 64К
     │       SS ────Ў ├─────────────────────────────┤
     │                │█████████████████████████████│     свободная
     │    SP(TOS) ───Ў│█████████████████████████████│ ў── память
     │                │         СТЕК °              │ до 64К
верх-│ начиная с SP─Ў ├─────────────────────────────┤
ние  │                │         КУЧА ∙              │
адре-│                │█████████████████████████████│     свободная
са   ∙                │█████████████████████████████│ ў── память
                      └─────────────────────────────┘

     Таблица 6.1 сравнивает модели между собой.  Модели  часто
группируются  в  соответствии  с малой (64К) или большой (1Мб)
моделью кода или данных.

                 Таблица 6.1. Модели памяти.
────────────────────────────────────────────────────────────
размер                          размер кода
данных    ──────────────────────────────────────────────────
                   64К                        1Мб
────────────────────────────────────────────────────────────
 64К      tiny (данные и код
          перекрываются; общий
          размер 64К)

          small (не перекрываются;    medium (малые данные,
          общий размер 128К)          большой код)
────────────────────────────────────────────────────────────
 1Мб      compact (большие данные,    large (большие данные
          малый код)                  и код)

                                      huge (как large, но
                                      статические данные
                                      больше 64К)
────────────────────────────────────────────────────────────
     Примечание. Модели tiny, small и compact являются моделя-
ми небольшого кода, потому что, по умолчанию, указатели кода -
near;  аналогично,  compact,  large и huge  являются  моделями
больших данных,  потому что,  по умолчанию, указатели данных -
far.
     ВАЖНО! Когда  Вы компилируете модуль,  результирующий код
для него не может превышать  64К,  поскольку  он  должен  быть
внутри одного кодового сегмента. Это справедливо, даже если Вы
используете одну из моделей с большим  кодом  (medium,  large,
huge).  Если Ваш модуль не помещается в один сегмент кода,  Вы
должны разбить его на несколько исходных файлов, компилировать
каждый файл отдельно,  а затем редактировать вместе. Аналогич-
но,  несмотря на то,  что модель huge разрешает размер  стати-
ческих  данных  более 64К,  они должны оставаться меньше 64К в
каждом из модулей.

    Программирование со смешанными моделями: модификаторы
                          адресации.

     Borland C++ вводит 8 новых ключевых слов,  по сравнению с
ANSI C (near,  far,  huge,  _cs, _ds, _es, _ss, _seg), которые
могут  использоваться как модификаторы указателей (и в некото-
рых случаях функций),  с определенными ограничениями и предуп-
реждениями.
     В Borland C++ Вы можете модифицировать  объявления  функ-
ций, объектов и указателей ключевыми словами near, far и huge.
Мы объяснили указатели на данные near, far и huge ранее в этой
главе. Можно объявить дальние объекты, используя ключевое сло-
во far.  near функции используют ближний вызов  и  возврат  из
функций.  Аналогично  far  функции  вызываются  как  дальние и
используют дальний возврат.  huge функции аналогичны far функ-
циям, за исключением того, что huge функции устанавливают DS в
новое значение, а far функции - нет.
     Существует 4  специальных near указателя на данные:  _cs,
_ds, _es, _ss. Эти 16-битные указатели связаны с соответствую-
щими сегментными регистрами. Например, если Вы объявили указа-
тель:
     char _ss *p;
то р содержит 16-битное смещение в сегменте стека.
     Функции и  указатели внутри данной программы по умолчанию
near или far в зависимости от выбранной  модели  памяти.  Если
функция  или  указатель near,  она автоматически связывается с
регистром CS или DS.
     Следующая таблица  показывает  это.  Заметим,  что размер
указателя соответствует тому, работает ли он в пределах памяти
64К  (near внутри сегмента) или вне общего пространства памяти
1Мб (far, имеет свой собственный сегментный адрес).

             Таблица 6.2. Результаты указателей.
───────────────────────────────────────────────────────────
модель памяти  указатель на функцию  указатель на данные
───────────────────────────────────────────────────────────
     tiny         near, _cs             near, _ds
     small        near, _cs             near, _ds
     medium       far                   near, _ds
     compact      near, _cs             far
     large        far                   far
     huge         far                   far
───────────────────────────────────────────────────────────

                    Сегментные указатели.

     Используйте _seg для объявления типа сегментного указате-
ля.  Результирующие  указатели являются 16-битными сегментными
указателями. Синтаксис для _seg:
     datatype _seg *identifier;
Например,
     int _seg *name;
     Любая ссылка через identifier имеет предполагаемое смеще-
     ние  0.
     Действия над сегментными указателями ограничены:
     1. Нельзя использовать операторы ++,  --,  += и -= с сег-
ментными указателями.
     2. Нельзя вычитать один сегментный указатель из другого.
     3. При добавлении ближнего указателя к сегментному, в ре-
зультате  получается дальний указатель,  который формируется с
использованием сегмента из сегментного указателя и смещения из
ближнего указателя. Более того, два указателя должны указывать
на один и тот же тип или должны быть указателями на void.  Не-
зависимо от типа,  на который они указывают, увеличения смеще-
ния не происходит.
     4. Когда  сегментный  указатель  используется в косвенном
выражении, он так же неявно преобразуется в дальний указатель.
     5. Когда  Вы добавляете или вычитаете целое к сегментному
указателю, он неявно преобразуется в дальний указатель, с сег-
ментом,  взятым из сегментного указателя и смещением, получен-
ным при увеличении размера указываемого объекта на целый  опе-
ранд.  Арифметическая операция выполняется,  как если бы целое
добавлялось или вычиталось из дальнего указателя.
     6. Сегментные указатели можно присваивать,  инициализиро-
вать и передавать из функций и в функции, сравнивать их и т.д.
(Они  сравниваются  как  если бы их значения были unsigned це-
лые).  Другими словами,  как и выше,  они обрабатываются точно
так, как и любые другие указатели.

                 Объявление дальних объектов.

     В Borland C++ можно объявлять дальние объекты. Например,
     int far x = 5;
     int far z;
     extern int far y = 4;
     static long j;
     Borland C++ создает отдельный сегмент для каждого дальне-
го объекта.  Опции компилятора командной строки -zE, -zF и -zH
(которые можно установить с помощью #pragma option) влияют  на
имя дальнего сегмента,  класс и группу,  соответственно. Когда
Вы изменяете их с помощью #pragma option,  Вы можете  изменить
их  в  любое  время,  и  они применяются для любого объявления
дальних объектов. Таким образом, Вы можете использовать следу-
ющую  последовательность для создания дальнего объекта в конк-
ретном сегменте:
     #pragma option -zEmysegment -zHmygroup -zFmyclass
     int far x;
     #pragma option -zE* -zH* -zF*
     В результате х будет помещен в сегмент MYSEGMENT'MYCLASS'
в группу 'MYGROUP',  а затем все элементы дальнего объекта бу-
дут установлены  в  значения  по  умолчанию.  Заметим,  что  с
использованием  этих  опций  несколько  дальних объектов можно
собрать в отдельный сегмент:
     #pragma option -zEcombined -zFmyclass
     int far x;
     double far y;
     #pragma option -zE* -zF*
     x и y появятся в сегменте COMBINED 'MYCLASS' без группы.

                Объявление near и far функций.

     Иногда Вам  может  понадобиться  перекрыть тип функции по
умолчанию.
     Например, предположим,  что  Вы используете модель памяти
large и используете рекурсивную функцию:
     double  power(double x,int exp)
     {
        if (exp <= 0)
           return(1);
        else
           return(x * power(x, exp-1));
     }
     Каждый раз, когда power вызывает саму себя, она выполняет
дальний вызов, который требует больше стековой памяти и циклов
таймера.  Объявив power как near,  Вы  установите  все  вызовы
функций как near:
     double  near power(double x,int exp)
     Это гарантирует,  что power вызывается только из сегмента
кода,  в котором она была откомпилирована и что все вызовы бу-
дут ближними вызовами.
     Это означает, что если Вы используете большую модель кода
(medium,  large  или huge),  Вы можете вызвать power только из
модуля,  в котором она определена.  Другие модули  имеют  свой
собственный  сегмент  кода и не могут вызывать near функции из
других модулей. Более того, near функция должна быть определе-
на или объявлена до первого ее использования. Иначе компилятор
не знает, что ему требуется сгенерировать ближний вызов.
     Аналогично, объявление функции как far означает,  что ге-
нерируется дальний вызов.  В малых моделях  кода  far  функция
должна быть объявлена или определена до ее первого использова-
ния.
     Вернемся к примеру с power. Будет разумным объявить power
как static,  поскольку она будет вызываться только изнутри те-
кущего  модуля.  При  этом ее имя не будет доступным для любых
функций вне этого модуля.

           Объявление near, far и huge указателей.

     Для чего может понадобиться изменение размера  указателя?
По тем же причинам, что и в предыдущем разделе: либо для избе-
жания лишней работы (объявляя near, когда по умолчанию исполь-
зуется far),  либо для ссылок за пределами сегмента по умолча-
нию (объявляя far или huge вместо near по умолчанию).
     При изменении размера функций или указателей возможны по-
тенциальные ошибки.  Например,  у Вас  есть  программа  модели
small:
     void myputs(s)
     char *s;
     {
        int  i;
        for (i = 0; s(i) != 0; i++0 putc(s[i]);
     }
     main()
     {
        char  near *mystr;
        mystr = "Hello, world\n";
        myputs(mystr);
     }
     Эта программа работает прекрасно и  объявление  near  для
mystr верно,  поскольку все указатели на код и на данные будут
near.
     Что будет,  если Вы перекомпилируете программу, используя
модель памяти compact (или large или huge)?  Указатель mystr в
main - near.  Однако указатель s в myputs сейчас far (по умол-
чанию).  Это означает,  что myputs работает с двумя словами  в
стеке  для того,  чтобы создать far указатель,  а это не соот-
ветствует mystr.
     Как решить  эту проблему?  Необходимо определить myputs в
современном стиле С:
      void myputs(char *s)
     {
        /* body of myputs */
     }
     Сейчас, когда Borland C++ компилирует Вашу программу,  он
знает,  что myputs ожидает указатель на char;  и поскольку  Вы
компилируете для большой модели,  он знает, что указатель дол-
жен быть far.  Поэтому Borland C++ будет помещать регистр сег-
мента  данных  (DS) в стек вместе с 16-битным значением mystr,
формируя дальний указатель.
     Примечание: Если  Вы  явно  объявляете указатель типа far
или near,  используйте прототипы функций для любой из функций,
которая может использовать эти указатели.
     Что будет в обратном случае: если аргументы myputs объяв-
лены как far и компилируются с малой моделью памяти?  Без про-
тотипа функции у Вас будут проблемы,  поскольку main будет по-
мещать в стек смещение и сегмент, а myputs ожидает только сме-
щение. С использованием прототипа функции main помещает в стек
только смещение.

             Адресация данного сегмент:смещение.

     Как сделать,  чтобы  дальний указатель указывал на данное
положение памяти (заданное адресом сегмент:смещение)? Вы може-
те использовать встроенную библиотечную программу MK_FP, кото-
рая берет сегмент и смещение и возвращает  дальний  указатель.
Например
     MK_FP(значение-сегмента,значение-смещения)
     Для дальнего  указателя  fp  Вы  можете получить значение
сегмента с помощью FP_SEG(fp) и смещение с помощью FP_OFF(fp).
Для  дополнительной информации смотрите справочное руководство
по библиотеке.

              Использование библиотечных файлов.

     Borland C++  предоставляет  версию  программ  стандартной
библиотеки для каждой из 6 моделей памяти. Borland C++ выбира-
ет соответствующую библиотеку в зависимости от выбранной  Вами
модели  памяти.  Однако,  если Вы используете редактор Borland
C++ TLINK, Вам необходимо указать используемые библиотеки. См.
раздел  по TLINK в главе 7 "Утилиты" в руководстве пользовате-
ля.

              Редактирование смешанных модулей.

     Что, если Вы компилируете 1 модуль,  используя малую  мо-
дель памяти, и другой, используя большую модель, и затем хоти-
те отредактировать их вместе?
     Файлы будут  редактироваться вместе,  но Вы можете столк-
нуться с проблемами, описанными в предыдущих разделах.
     Если функция в небольшом модуле вызывает функцию из боль-
шого модуля,  она сделает это с ближним вызовом, что будет ги-
бельно. Более того, Вы столкнетесь с проблемами с указателями,
описанными ранее,  поскольку функция в небольшом модуле  будет
ждать для передачи и получения near указатели,  в то время как
функция в большом модуле будет ждать far указатели.
     И снова  решение  заключается  в использовании прототипов
функции.  Предположим, что Вы поместили myputs в отдельный мо-
дуль и компилируете его с моделью памяти large. Затем создайте
файл заголовка myputs.h (или с  другим  именем  с  расширением
.h), в котором будет содержаться прототип функции:
     void far myputs(char far *s);
Теперь поместите main в другой модуль MYMAIN.C:
     #include <stdio.h>
     #include 'myputs.h"

     main()
     {
        char  near *mystr;
        mystr = "Hello, world\n";
        myputs(mystr);
     }
     Когда Вы  компилируете эту программу,  Borland C++ читает
прототип функции из MYPUTS.H и видит,  что  это  far  функция,
ожидающая far указатель.  Поэтому он генерирует правильный вы-
зывающий код даже если при компиляции использовалась малая мо-
дель памяти.
     С какими библиотечными программами Вам  требуется  сейчас
редактировать?  Лучше  всего  использовать  одну  из библиотек
большой модели и объявить каждую из них как far. Чтобы сделать
это, скопируйте каждый файл заголовка, который Вы обычно вклю-
чаете (такой как stdio.h) и переименуйте копию  во  что-нибудь
соответствующее (например fstdio.h).
     Затем отредактируйте каждый  прототип  функции  в  копии,
указав явно far:
     int far cdecl printf(char far * format, ...);
     Таким образом программы не только вызываются как far,  но
и указатели передаются как far указатели. Исправьте Вашу прог-
рамму так, чтобы включить новый файл заголовка:
     #include <stdio.h>

     main()
     {
        char  near *mystr;
        mystr = "Hello, world\n";
        printf(mystr);
     }
     Откомпилируйте Вашу программу  с  компилятором  командной
строки  ВCC  или  ВССХ  (защищенный  режим) и отредактируйте с
TLINK или TLINKX, указав библиотеку большой модели памяти, та-
кую как CL.LIB.  Смешанные модели памяти - это непростая вещь,
но это можно сделать; будьте только готовы к трудноотлавливае-
мым ошибкам, если Вы что-то сделали неправильно.

                      Оверлеи (VROOMM).

     Оверлеи являются частями кода программы, которые разделя-
ют общую область памяти.  В один момент времени в памяти нахо-
дятся только те части программы,  которые требуются для данной
функции.
     Примечание. Приложения VROOMM и серверы сетевых файлов не
смешиваются.
     Оверлеи могут  значительно  уменьшить общую потребность в
памяти в момент выполнения программы. С оверлеями можно выпол-
нять программы,  которые значительно превышают общую доступную
память,  поскольку в данный момент времени в памяти  находятся
только части программы.

                    Как работают оверлеи.

     Менеджер оверлеев   Borland   C++  (называемый  VROOMM  -
Virtual Run-time Object-Oriented  Memory  Manager)  очень  со-
фистичен;  он  делает  для  Вас очень много работы.  В обычной
оверлейной системе модули группируются вместе в  базу  и  мно-
жество  оверлейным  модулей.  Подпрограммы в данном оверлейном
модуле могут вызывать другие подпрограммы этого же модуля  или
подпрограммы  из  базы,  но не подпрограммы из других модулей.
Только один оверлейный модуль может  находиться  в  памяти,  и
каждый  занимает  одну и ту же физическую память.  Общее коли-
чество требуемой для выполнения программы памяти равно размеру
базы плюс размер наибольшего оверлея.
     Обычная схема не совсем гибка.  Она требует полного пони-
мания  возможных  зависимостей  вызовов в программе и требует,
чтобы Вы сгруппировали  оверлеи  соответственно  этому.  Может
быть Вам не удастся разбить свою программу на оверлеи, если Вы
не сможете разбить ее на раздельные зависимости вызова.
     Схема VROOMM отличается от обычной схемы. Она обеспечива-
ет динамическую подкачку сегментов. Основной еденицей подкачки
является сегмент.  Сегмент может быть одним или более модулем.
Особенно важно,  что любой сегмент может вызвать другой  любой
сегмент.
     Память разбивается на область для базы плюс область  под-
качки.  Как  только вызывается функция в сегменте,  который не
находится ни в базе,  ни в области подкачки, то в область под-
качки переносится сегмент,  содержащий вызванную функцию, воз-
можно заменяя другие сегменты. Это мощное достижение - оно по-
добно виртуальной памяти программного обеспечения. Вам не нуж-
но больше разбивать свой код на статические,  оверлейные, дру-
гие модули.
     Что произойдет,  когда сегмент будет перенесен в  область
подкачки? Если там есть место для сегмента, то выполнение про-
должится.  Если нет,  то для освобождения пространства из  об-
ласти подкачки должен быть вытолкнут один или более сегментов.
Как решить,  какой  сегмент  вытолкнуть?  Фактически  алгоритм
очень непрост.  Упрощенный вариант:  если есть неактивный сег-
мент,  выберите его для удаления.  Неактивные сегменты  -  это
сегменты без выполняемых функций. Иначе выберите активный сег-
мент и отодвиньте его.  Храните отодвинутые  сегменты  до  тех
пор,  пока есть свободное пространство.  такая техника называ-
ется динамической подкачкой.
     Чем больше  памяти Вы выделите для области подкачки,  тем
лучше будет выполнение программы.  Область подкачки  действует
как  кэш;  чем больше кэш,  тем быстрее выполняется программа.
Наилучшей установкой для  размера  области  подкачки  является
размер "работающего множества" программы.
     Как только оверлей загружается в память,  он помещается в
оверлейный  буфер,  который находится в памяти между сегментом
стека и дальней кучей.  По умолчанию размер оверлейного буфера
оценивается и устанавливается при запуске,  но его можно изме-
нить с помощью глобальной переменной _ovrbuffer.  Если доступ-
ной памяти недостаточно,  будет выдано сообщение DOS об ошибке
"Program too big to fit in memory " или кодом запуска  С  "Not
enough memory to run program".
     Одна очень важная опция оверлеев - это способность  пере-
качивать модули в extended или expanded память,  когда они вы-
талкиваются из оверлейного буфера.  Когда модуль понадобится в
следующий раз, менеджер оверлеев может скопировать его из того
места, куда он был вытолкнут, вместо чтения из файла. Это зна-
чительно ускоряет выполнение.
     При использовании оверлеев память используется  так,  как
показано в следующем рисунке.

                         Рисунок 6.9.
                  Карты памяти для оверлеев.

                         MEDIUM
                   ┌────────────────────┐..............
                   │         класс CODE │ Резидентный
                   │                    │ код
     Эти          ┌┼────────────────────┤
     сегменты     ││      класс OVRINFO │ Оверлей
     автоматически│├────────────────────┤
     генерируются ┤│                    │ Часть сегмента
     редактором   ││      класс STUBSEG │ для каждого
                  ││                    │ оверлейного
                  ││                    │ сегмента
                  └┼────────────────────┤..............
                   │              _DATA │ Ближняя куча
                   │         класс DATA │ и стек разделяет
                   │                    │ сегмент данных
                   │        Ближняя куча│
                   │                    │
                   │  °          STACK  │
                   ├────────────────────┤.............
                   │   Буфер оверлея    │
                   │  (распределяется   │
                   │  начальным кодом)  │
                   ├────────────────────┤..............
                   │ ∙     Дальняя куча │
                   └────────────────────┘

                         LARGE
                   ┌────────────────────┐..............
                   │         класс CODE │ Резидентный
                   │                    │ код
     Эти          ┌┼────────────────────┤
     сегменты     ││      класс OVRINFO │ Оверлей
     автоматически│├────────────────────┤
     генерируются ┤│                    │ Часть сегмента
     редактором   ││      класс STUBSEG │ для каждого
                  ││                    │ оверлейного
                  ││                    │ сегмента
                  └┼────────────────────┤..............
                   │              _DATA │ Несколько
                   │         класс DATA │ сегментов данных
                   │                    │
                   ├────────────────────┤
                   │                    │ Отдельный
                   │  °          STACK  │ сегмент стека
                   ├────────────────────┤.............
                   │    Буфер оверлея   │
                   │   (распределяется  │
                   │   начальным кодом) │
                   ├────────────────────┤..............
                   │ ∙   Дальняя куча   │
                   └────────────────────┘

                         HUGE
                   ┌────────────────────┐..............
                   │         класс CODE │ Резидентный
                   │                    │ код
     Эти          ┌┼────────────────────┤
     сегменты     ││      класс OVRINFO │ Оверлей
     автоматически│├────────────────────┤
     генерируются ┤│                    │ Часть сегмента
     редактором   ││      класс STUBSEG │ для каждого
                  ││                    │ оверлейного
                  ││                    │ сегмента
                  └┼────────────────────┤..............
                   ├────────────────────┤ Несколько
                   ├────────────────────┤ сегментов данных
                   ├────────────────────┤
                   ├────────────────────┤
                   │                    │ Отдельный
                   │  °          STACK  │ сегмент стека
                   ├────────────────────┤.............
                   │    Буфер оверлея   │
                   │   (распределяется  │
                   │   начальным кодом) │
                   ├────────────────────┤..............
                   │ ∙   Дальняя куча   │
                   └────────────────────┘


      Как эффективнее использовать оверлеи Borland C++.

     Чтобы эффективнее использовать оверлеи Borland C++,
     - минимизируйте резидентный код  (резидентную  библиотеку
времени  выполнения,  обработчики  прерываний  и драйверы уст-
ройств - это хорошая отправная точка).
     - установите  размер оверлейного пула равным удобному ра-
ботающему множеству (начните со 128К  и  изменяйте  в  сторону
уменьшения или увеличения и придите к компромиссу размера/ско-
рости).
     - Подумайте о гибкости и разнообразии:  используйте преи-
мущество оверлейной системы для поддержки специальных случаев,
системы  интерактивной  помощи и других случаях,  выгодных для
пользователя, которые раньше рассмотреть было нельзя.

                         Требования.

     Для того чтобы  создать  оверлеи,  Вы  должны  помнить  о
нескольких простых правилах:
     - наименьшая часть программы,  которая может быть сделана
оверлеем - сегмент.
     - оверлейные приложения должны использовать medium, large
и huge модели программирования;  tiny,  small и compact модели
не поддерживаются.
     - оверлейными  сегментами управляют обычные правила слия-
ния сегментов. Таким образом, несколько модулей .OBJ могут по-
пасть в один оверлейный сегмент.
     Генерация оверлеев во время редактирования полностью  от-
деляется от управления оверлеями во время выполнения; редактор
НЕ включает автоматически код для управления оверлеями. Факти-
чески,  с  точки  зрения  редактора,  менеджер  оверлеев - это
совсем другой кусок кода,  чем отредактированный. Единственное
предположение, которое делает редактор - что менеджер оверлеев
принимает векторы прерываний (обычно INT 3FH), с помощью кото-
рого происходит управление всей динамической загрузкой.  Такой
уровень  видимости  делает  реализацию  встроенных  менеджеров
оверлеев очень простой, что позволяет настроится на конкретные
потребности каждого приложения.

                   Использование оверлеев.

     Чтобы сделать оверлейной программу,  все ее модули отком-
пилировать  с включенной опцией компилятора -Y.  Чтобы сделать
оверлейным конкретный модуль,  его нужно откомпилировать с оп-
цией -Yo (-Yo автоматически включает -Y).
     Опция -Yo применяется ко всем модулям и библиотекам,  ко-
торые стоят за этой опцией в командной строке; можно отключить
ее с помощью -Yo-.  Это единственные опции  командной  строки,
которые могут стоять после имен файлов.  Например,  чтобы сде-
лать оверлейным модуль OVL.C,  но не делать оверлейной библио-
теку  GRAPHICS.LIB,  можно  использовать одну из следующих ко-
мандных строк:
     TCC -ml -Yo ovl.c -Yo- graphics.lib
или
     TCC -ml graphics.lib -Yo ovl.c
     Примечание. ВССХ (компилятор  защищенного  режима)  также
можно использовать здесь.
     Если для редактирования файла .ЕХЕ явно вызывается TLINK,
то  в командной строке редактора или командном файле нужно за-
дать опцию /о. Как использовать опцию /о, читайте в разделе по
TLINK в главе 7 "Утилиты" Руководства пользователя.

                       Пример оверлея.

     Предположим, что  Вы хотите сделать оверлейной программу,
состоящую из трех модулей:  MAIN.C,  O1.C и O2.C.  Оверлейными
нужно  сделать только O1.C и O2.C (MAIN.C содержит критические
по времени процедуры и обработчики прерываний, поэтому он дол-
жен   оставаться   резидентным).  Предположим,  что  программа
использует large модель памяти.
     Следующая команда выполнит это задание:
      ВСС -ml -Y main.c -Yo o1.c o2.c
     В результате получится выполнимый файл MAIN.EXE, содержа-
щий два оверлея.

                        Оверлеи в IDE.

     Для того,  чтобы сделать модули оверлейными в IDE,  нужно
выполнить следующие шаги:
     1. Войдите  в   диалоговое   окно   Options/Compiler/Code
Generation и включите кнопку Overlays.
     2. Войдите  в  Options/Linker  и  установите  независимую
кнопку Overlay в On.
     3. В  менеджере  проекта  используйте   элемент   проекта
Options для задания каждого модуля, который должен стать овер-
лейным.
     Первый шаг эквивалентен опции компилятора командной стро-
ки -Y. Если эта независимая кнопка отключена, то следующие две
опции использовать нельзя.  Второй шаг управляет тем, будет ли
использоваться оверлейная информация в процессе редактирования
IDE. Отключив эту опцию, Вы можете глобально отключить оверлеи
без необходимости перекомпиляции или изменения каких-то  уста-
новок конкретного модуля в менеджере проекта. Третья независи-
мая кнопка управляет тем, какие модули становятся оверлейными,
а какие нет. Эта независимая кнопка очень похожа на переключа-
тель компилятора командной строки -Yo.
     Примечание. Если  Вы строите файл .ЕХЕ,  содержащий овер-
леи,  компилируйте  все  модули  с  включенной  кнопкой   Code
Generation/Overlays   (сначала   убедитесь,   что  Вы  выбрали
Options/Full Menus)
     Примечание. Модули,  не являющиеся оверлеями,  никогда не
должны менять имя по умолчанию Code Class. IDE позволяет изме-
нить набор модулей,  находящийся в оверлеях, не заботясь об их
перекомпиляции. Это выполняется только в том случае (с текущей
информацией  .OBJ),  если  оверлеи имеют имена классов кода по
умолчанию.

                    Оверлейные программы.

                 Требования дальних вызовов.

     Используйте модель  большого  кода  (medium,  large   или
huge),  когда  Вы хотите компилировать оверлейный модуль.  При
любом вызове оверлейной функции в другом модуле Вы ДОЛЖНЫ  га-
рантировать, что все текущие активные функции являются дальни-
ми.
     Вы ДОЛЖНЫ  компилировать  все  оверлейные модули с опцией
-Y.
     ВАЖНО! Несоблюдение требований дальних вызовов в оверлей-
ной программе может привести к непредсказуемым  и  катастрофи-
ческим результатам при выполнении программы.

                        Размер буфера.

     По умолчанию  размер  оверлейного  буфера  равен двойному
размеру наибольшего оверлея.  Это является достаточным для не-
которых  приложений.  Но  представим,  что  конкретная функция
программы реализуется через многие модули,  каждый из  который
оверлей.  Если  общий размер этих модулей больше размера овер-
лейного буфера,  то получится существенное количество  области
подкачки, если модули делают частые вызовы друг друга.
     Решение состоит в увеличении размера  оверлейного  буфера
так, что в любой момент времени доступно достаточное количест-
во памяти для содержания всех оверлеев, которые часто вызывают
друг друга. Можно сделать это путем установки глобальной пере-
менной _ovrbuffer в требуемое значение в параграфе.  Например,
чтобы  установить оверлейный буфер в 128К,  включите следующее
утверждение в свой код:
     unsigned _ovrbuffer = 0x2000;
     Для определения идеального размера оверлейного буфера нет
общей формулы.  Turbo Profiler может помочь подобрать подходя-
щее значение.

                   Что не делать оверлеем.

     Не делайте  оверлейными  модули,  содержащие  обработчики
прерываний,  небольшие подпрограммы или процедуры критического
времени.  Благодаря специфике операционной системы DOS, нельзя
делать оверлеями модули,  которые могут быть вызваны функциями
прерывания.
     Менеджер оверлеев  Borland C++ полностью поддерживает пе-
редачу оверлейных функций как аргументов,  присваивание и ини-
циализацию переменных указателей функций с адресами оверлейных
функций и вызов оверлейных подпрограмм через  указатели  функ-
ций.

                      Отладка оверлеев.

     Большинство отладчиков  имеют  очень ограниченные возмож-
ности по отладке оверлеев или  не  имеют  их  вообще.  Не  так
обстоит  дело с интегрированным отладчиком Borland C++ и Turbo
Debugger,  автономным отладчиком. Оба отладчика полностью под-
держивают  пошаговую  отладку  и точки прерывания в оверлеях в
понятном для Вас виде. С помощью оверлеев Вы можете легко соо-
ружать и отлаживать огромные приложения - все внутри IDE или с
помощью Turbo Debugger.

               Внешние подпрограммы в оверлеях.

     Как обычные  функции  С,  external   подпрограммы   языка
Ассемблер должны соблюдать определенные правила программирова-
ния для корректной работы с менеджером оверлеев.
     Если подпрограмма  языка  Ассемблер  делает  вызовы ЛЮБЫХ
оверлейных функций,  то подпрограмма  языка  Ассемблер  ДОЛЖНА
быть  объявлена  FAR,  и  ДОЛЖНА  установить  структуру стека,
используя регистр ВP. Например, в предположении, что OtherFunc
-  оверлейная  функция  в другом модуле,  а подпрограмма языка
Ассемблер ExternFunc вызывает ее,  то ExternFunc  должна  быть
FAR и установить структуру стека, как показано ниже:
     ExternFunc    PROC             FAR

     push     bp               ;Save BP
     mov      bp,sp            ;Set up stack frame
     sub      sp,LocalSize     ;Allocate local variables
     ...
     call     OtherFunc        ;Call another overlaid module
     ...
     mov      sp,bp            ;Dispose local variables
     pop      bp               ;Restore BP
     RET                       ;Return

     ExternFunc ENDP
где LocalSize  -  размер локальных переменных.  Если LocalSize
равен 0,  Вы можете опустить две строки для размещения и осво-
бождения  локальных  переменных,  но  Вы  не должны пропустить
установку структуры стека ВР,  даже если у Вас нет  аргументов
или переменных в стеке.
     Требования остаются теми же,  если ExternFunc делает неп-
рямую ссылку на оверлейные функции.  Например,  если OtherFunc
делает вызовы оверлейных функций, но сама не является оверлей-
ной,  то ExternFunc должна быть FAR и должна установить струк-
туру стека.
     В случае,  когда  подпрограмма  языка Ассемблер не делает
прямые или непрямые ссылки на оверлейные функции,  нет никаких
специальных  требований;  подпрограмма  языка  Ассемблер может
быть объявлена NEAR.  Она не  должна  устанавливать  структуру
стека.
     Оверлейные подпрограммы языка Ассемблер НЕ должны  созда-
вать  переменные  в сегменте кода,  поскольку любые изменения,
сделанные в оверлейном сегменте кода теряются при освобождении
оверлея. Аналогично, указатели на объекты, основанные на овер-
лейном сегменте кода,  не могут ожидаться для правильных вызо-
вов  в  других оверлеях,  поскольку менеджер оверлеев свободно
передвигает и освобождает оверлейные сегменты кода.

                          Перекачка.

     Если у Вас есть доступная extended или  expanded  память,
Вы можете сказать менеджеру оверлеев использовать ее для пере-
качки.  Если Вы так сделаете, то когда менеджер оверлеев будет
выталкивать  модуль из оверлейного буфера (поскольку он должен
загрузить новый модуль,  а буфер полон),  он может хранить вы-
толкнутый  модуль  в памяти.  Любая последующая загрузка этого
модуля сокращается до передачи в памяти, что значительно быст-
рее, чем чтение с дискового файла.
     В обоих  случаях  существует  две  возможности:  менеджер
оверлеев  может  либо обнаружить наличие extended или expanded
памяти и взять ее сам, или может использовать уже обнаруженную
и распределенную часть памяти.  Для extended памяти, использо-
вание обнаруженной памяти не всегда означает удачу из-за  мно-
гих  различных  кэшей  и дисковых программ RAM,  которые берут
extended память без каких-либо пометок.  Чтобы  избежать  этой
проблемы, Вы можете сказать менеджеру оверлеев начальный адрес
extended памяти и какое количество ее безопасно для  использо-
вания.

                       Еxpanded память.

     Функция _OvrInitEms инициализирует перекачку expanded па-
мяти. Прототип:
     extern int far _OvrInitEms
     {
        unsigned emsHandle,
        unsigned emsFirst,
        unsigned emsPages
     };
     Примечание. _OvrInitEms и _OvrInitExt определены в dos.h.
     Если параметр emsHandle равен  0,  то  менеджер  оверлеев
проверяет  наличие  expanded  памяти и распределяет количество
(если может), которое может содержать все оверлеи минус размер
оверлейного буфера. Иначе emsHandle должен быть правильной об-
работкой EMS,  emsFirst - первая используемая страница EMS,  а
emsPages  -  число страниц,  используемых менеджером оверлеев.
Эта функция возвращает 0, если expanded память доступна.

                       Еxtended память.

     Функция _OvrInitExt инициализирует перекачку extended па-
мяти. Прототип:
     extern int far _OvrInitEms
     {
        unsigned long extStart,
        unsigned long extLength
     };
     Если параметр extStart равен 0, то менеджер оверлеев про-
веряет extended  память.  Если  она  есть,  менеджер  оверлеев
использует  количество свободной памяти,  которое может содер-
жать  все  оверлеи  минус  размер  оверлейного  буфера.  Иначе
extStart  -  начало  используемой  extended памяти с extLength
байтами,  используемыми менеджером  оверлеев.  Если  extLength
равно 0, то менеджер оверлеев будет использовать всю доступную
extended память свыше extStart. Эта функция возвращает 0, если
extended память доступна. _OvrInitExt определена в dos.h.
     ВАЖНО! Использование extended памяти нестандартизировано.
Хотя менеджер оверлеев пытается применить каждый известный ме-
тод для нахождения количества  extended  памяти,  которая  уже
используется,  используйте  эту  функцию осторожно.  Например,
если имеется  инсталлированная  программа  2Мб  кэша  жесткого
диска (которая использует extended память),  Вы можете исполь-
зовать следующий вызов,  чтобы менеджер  оверлеев  использовал
оставшуюся extended память:
     if (_OvrInitExt (1024L * (2048 + 1024), 0L))
       puts("Нет extended памяти для подкачки оверлеев");

