                           ГЛАВА 9.
                   ИНТЕРФЕЙС С АССЕМБЛЕРОМ.

     Эта глава рассказывает как писать ассемблерный код, кото-
рый работает совместно с Borland C++.  Мы предполагаем, что Вы
знаете  как писать ассемблерные программы для 8086 и как опре-
делять сегменты,  константы и т.д.  Если Вы не знакомы с этими
концепциями,  прочитайте руководство по Турбо-Ассемблеру, осо-
бенно главу "Интерфейс Турбо-Ассемблера с  Турбо-С"   в  Руко-
водстве пользователя по Турбо-Ассемблеру.  Турбо-Ассемблер 2.0
включает несколько возможностей, которые облегчают интерфейс с
Borland C++.

            Программирование на нескольких языках.

     Borland C++  позволяет  легко вызвать из программы на С и
С++ ассемблерный  код.  Это  называется  inline   ассемблером.
Поскольку Borland   C++   имеет  встроенный  inline  Ассемблер
(BASM), то Вы можете включать подпрограммы языка  Ассемблер  в
свою программу даже в том случае, если Вы не имеете отдельного
Ассемблера.

            Программирование на смешанных языках.

     Borland C++ делает простым вызов в программах С  подпрог-
рамм, написанных на Ассемблере,  и наоборот, вызов подпрограмм
С в программах, написанных на Ассемблере. В этом разделе будет
показан интерфейс Borland C++ с языком Ассемблер.

                     Передача параметров.

     Borland C++  поддерживает 2 способа передачи параметров в
функцию. Один - это стандартный метод С,  который мы  объясним
первым, а второй - это метод Паскаля.

                   Передача параметров в С.

     Предположим, Вы объявили прототип функции:
     void funca(int p1, int p2, long p3);
     По умолчанию  Borland  C++ использует передачу параметров
С, так же называемую соглашением о вызовах С. Когда вызывается
функция  (funca), параметры  вталкиваются в стек справа налево
(p3, p2, p1) с последующим адресом возврата. Так, если Вы выз-
вали
     main()
     {
        int  i, j;
        long k;
        ...
        i = 5;j = 7; k = 0x1407AA;
        funca(i,j,k);
        ...
     }
стек будет выглядеть (до вталкивания адреса возврата):
     sp + 06:  0014
     sp + 04:  07AA  k = p3
     sp + 02:  0007  j = p2
     sp:       0005  i = p1
     Примечание. В 8086, стек растет от большей памяти к мень-
шей, так что i находится вверху стека.
     Вызываемая программа не должна знать сколько именно пара-
метров  было помещено в стек.  Предполагается только,  что все
параметры переданы.
     Также - и это очень важно - вызываемая программа не долж-
на выталкивать параметры из стека. Почему? Потому, что это де-
лает вызывающая программа. Так компилятор создает из исходного
кода для главной функции С:
     mov  WORD PTR [bp-8],5
     mov  WORD PTR [bp-6],7
     mov  WORD PTR [bp-2],0014h
     mov  WORD PTR [bp-4],07AAh
     push WORD PTR [bp-2]
     push WORD PTR [bp-4]
     push WORD PTR [bp-6]
     push WORD PTR [bp-8]
     call NEAR Ptr funca
     add  sp,8
     Заметим, что последняя инструкция add sp,  8.  Компилятор
знает в этой точке сколько параметров было помещено в стек; он
так  же знает,  что в стек был помещен адрес возврата и что он
был вытолкнут из стека инструкцией ret в функции funca.

                Передача параметров в Паскале.

     Другой подход - это стандартный метод Паскаля для переда-
чи параметров.  Это не означает, что Вы можете вызвать функцию
Турбо-Паскаля из Borland C++, Вы не можете сделать этого. Если
funca объявлена
     void pascal funca(int p1, int p2, long p3);
     то когда  эта функция вызывается,  параметры передаются в
стек слева направо (p1,  p2,  p3),  а за ними адрес  возврата.
Так, если Вы вызвали
     main()
     {
        int  i, j;
        long k;
        ...
        i = 5;j = 7; k = 0x1407AA;
        funca(i,j,k);
        ...
     }
     стек имеет вид (непосредственно перед вталкиванием адреса
возврата):
     sp + 06:  0005  i = p1
     sp + 04:  0007  j = p2
     sp + 02:  0014
     sp:       07AA  k = p3
     Итак, в чем же отличия?  Кроме изменения порядка выталки-
вания параметров,  Pascal последовательность передачи парамет-
ров  предполагает,  что функция funca знает сколько параметров
передано ей.  Другими словами, вызов funca на Ассемблере имеет
вид:
     push WORD PTR [bp-8]
     push WORD PTR [bp-6]
     push WORD PTR [bp-2]
     push WORD PTR [bp-4]
     call NEAR Ptr funca
     Заметим, что  здесь  нет add sp,  8 после вызова функции.
Вместо этого funca использует инструкцию ret 8, очищая стек до
возврата в main.
     По умолчанию  все  функции,  написанные  в  Borland  C++,
используют С   метод  передачи  параметров.  Однако,  если  Вы
используете опцию компилятора -p (или установите кнопку Pascal
в диалоговом окне Code Generation), все функции используют ме-
тод Паскаля.  В данной ситуации Вы можете заставить определен-
ную функция использовать С  метод передачи параметров, исполь-
зую модификатор cdecl:
     void cdecl funca(int p1, int p2, int p3);
     Он перекрывает директиву компилятора -p.
     Для чего может понадобиться использовать соглашение о вы-
зовах Паскаля? Существует 2 причины:
     - Вы можете вызывать существующую ассемблерную программу,
которая использует эти соглашения.
     - Этот код несколько меньше, поскольку он не очищает стек
после вызова.
     Примечание. Использование  соглашений  о  вызовах Паскаля
может привести к некоторым проблемам.
     Во-первых, это  не так надежно,  как соглашения о вызовах
С.  Вы не можете передать переменное число параметров (как при
использовании  соглашений  С),  поскольку вызываемая процедура
знает сколько параметров передается и  соответственно  очищает
стек.  Передача  большего  или меньшего числа параметров будет
приводить к серьезным проблемам, в то время, как использование
соглашений С не приведет к ошибкам (кроме, возможно, ошибочных
ответов).
     Во-вторых, если  Вы используете опцию компилятора -p,  Вы
должны включить файлы заголовков для  стандартных  функций  С,
вызываемых Вами.  Почему? Потому, что если Вы не сделаете это-
го, Borland C++ будет использовать соглашения о вызовах Паска-
ля  (и  именование)  для каждой из этих функций и программа не
будет редактироваться.
     Файлы заголовков  объявляет  каждую  из  этих функций как
cdecl и,  если Вы включите их, компилятор увидит это и исполь-
зует соглашение о вызовах С.
     Вывод: Если Вы используете соглашения о вызовах Паскаля в
программах  Borland  C++,  используйте  прототипы  функций где
только возможно,  явно объявляя каждую функцию как  cdecl  или
pascal.   В   этом   случае  полезно  включить  предупреждение
"Function call with no prototype" (функция вызвана без  прото-
типа),  чтобы  убедиться,  что  каждая вызванная функция имеет
прототип.

                  Вызов .ASM из Borland C++.

     Для того,  чтобы  вызывать  подпрограммы  Ассемблера   из
Borland C++,  Вы должны выполнять определенные действия и сле-
довать определенным соглашениям.  Этот раздел опишет их, начи-
ная с того,  как установить Ваш код и кончая тем, как написать
ассемблерный код для оптимального использования.

            Установка вызова .ASM  из Borland C++.

     Когда Вы пишите программу на Ассемблере, Вы должны следо-
вать  определенным соглашениям для того,  чтобы (1) обеспечить
редактор связи необходимой информацией и (2)  обеспечить  сог-
ласование моделей памяти.

                 Упрощенные директивы сегментации.

     Обычно ассемблерные модули состоят из 3 частей: код, ини-
циализированные данные и неинициализированные  данные.  Каждый
тип информации находится в собственном сегменте с определенным
именем, который зависит от используемой модели памяти С  прог-
раммы.
     Турбо-Ассемблер (TASM) предоставляет 3 упрощенные  дирек-
тивы сегментации (.CODE,  .DATA,  .DATA?) для определения этих
сегментов. Они говорят ассемблеру использовать имена сегментов
по умолчанию для модели памяти, которую Вы указываете, исполь-
зуя директиву .MODEL.  Например,  если С программа  использует
модель  памяти small,  Вы можете организовать ассемблерный мо-
дуль с упрощенными директивами  сегментации,  как  показано  в
следующей таблице:

        Таблица 9.1. Упрощенные директивы сегментации.
_____________________________________________________________
     .MODEL SMALL
     .CODE
     ... сегмент кода ...
     .DATA
     ... сегмент инициализированных данных ...
     .DATA?
     ... сегмент неинициализированных данных ...
_____________________________________________________________

              Стандартные директивы сегментации.

     В некоторых  случаях  Вам может понадобиться использовать
имена сегментов,  отличных от умалчиваемых для  данной  модели
памяти.  Чтобы сделать это, Вы должны использовать стандартные
директивы сегментации, как показано в таблице 9.2.

           Таблица 9.2. Формат ассемблерного файла.
──────────────────────────────────────────────────────────────
code      SEGMENT      BYTE PUBLIC 'CODE'
          ASSUME       CS:code, DS:dseg
          ...сегмент кода...
code      ENDS

dseg      GROUP        _DATA, _BSS
data      SEGMENT      WORD PUBLIC 'DATA'
          ...сегмент инициализированных данных...
data      ENDS

_BSS      SEGMENT      WORD PUBLIC 'BSS'
          ...сегмент неинициализированных данных...
_BSS      ENDS

          END
──────────────────────────────────────────────────────────────
     Идентификаторы code, data и dseg имеют определенные заме-
щения,  в  зависимости от используемой модели памяти;  таблица
9.3 показывает, что Вы используете для каждой модели. filename
в таблице 9.3 - это имя модуля; используйте его последователь-
но в директиве NAME и при замещении идентификаторов.
     Заметим, что  для  модели памяти huge нет сегмента _BSS и
определение GROUP пропускается.  В общем случае _BSS  необяза-
тельно.  Вы  определяете  его  только если оно будет использо-
ваться.
     Лучший способ создать эти определения сегментов - это от-
компилировать пустую программу в .ASM (используя опцию -S ВCC)
и посмотреть сгенерированный ассемблерный код.

         Таблица 9.3. Идентификаторы и модели памяти.
─────────────────────────────────────────────────────────────
  модель           замещение              указатели на код
                 идентификатора               и данные
─────────────────────────────────────────────────────────────
 Tiny,Small      code = _TEXT             Code:DW _TEXT:xxx
                 data = _DATA             Data:DW DGROUP:xxx
                 dseg = DGROUP

 Compact         code = _TEXT             Code:DW _TEXT:xxx
                 data = _DATA             Data:DD DGROUP:xxx
                 dseg = DGROUP

 Medium          code = filename_TEXT     Code:DDxxx
                 data = _DATA             Data:DW DGROUP:xxx
                 dseg = DGROUP

 Large           code = filename_TEXT     Code:DDxxx
                 data = _DATA             Data:DD DGROUP:xxx
                 dseg = DGROUP

 Huge            code = filename_TEXT     Code:DDxxx
                 data = filename_DATA     Data:DDxxx
─────────────────────────────────────────────────────────────

              Определение констант и переменных.

     Модели памяти   так   же   воздействуют   на  определение
констант,  которые указывают на код, данные или и то и другое.
Таблица 9.3 показывает как должны выглядеть эти указатели, где
ххх - это указываемый адрес.
     Некоторые определения используют DW (Define Word), другие
используют DD (Define Doubleword), указывающих размер указате-
ля. Числовые текстовые константы определяются как обычно.
     Переменные определяются так же,  как константы.  Если Вам
необходима переменная,  которая неинициализирована в требуемое
значение,  Вы можете объявить ее в сегменте _BSS,  указав  (?)
вместо значения.

      Определение глобальных и внешних идентификаторов.

     После того,  как Вы создали модуль, программе Borland C++
требуется знать,  какие функции можно вызвать и на какие пере-
менные  можно  ссылаться.  Аналогично  Вам может потребоваться
вызвать функции Borland C++ из ассемблерной программа или  об-
ратиться к переменным, объявленным в программе Borland C++.
     Когда Вы делаете такие вызовы,  Вам  необходимо  понимать
принцип  работы компилятора и редактора Borland C++.  Когда Вы
объявляете внешний идентификатор, компилятор автоматически до-
бавляет  "_"  в начало идентификатора в объектном модуле.  Это
означает,  что Вы должны поместить "_" в начале любого иденти-
фикатора  из ассемблерного модуля,  к которому Вы хотите обра-
щаться из  программы С.  Идентификаторы Паскаля  интерпретиру-
ются  отлично  от  идентификаторов С  - они пишутся прописными
буквами и не используют "_" в начале.
     По умолчанию идентификаторы С используются с "_",  но оно
необязательно. Оно может быть отключено опцией командной стро-
ки  -u-.  Однако,  если  Вы используете стандартные библиотеки
Borland C++, у Вас будут проблемы, если Вы не перекомпилируете
библиотеки.  (Чтобы сделать это,  Вам необходим другой продукт
Borland C++ - исходный код библиотеки времени выполнения.)
     Если любой asm код в исходном файле ссылается к идентифи-
каторам С (данным или функциям),  то эти идентификаторы должны
начинаться с "_" (если только они не используют один из указа-
телей языка, описанных выше).
     Турбо-Ассемблер (TASM)  не различает прописные и строчные
буквы;  другими словами, когда Вы ассемблируете программу, все
идентификаторы сохраняются как прописные.  Опция /mx TASM поз-
воляет различать регистр для общих и внешних символов.  Редак-
тор  Borland  C++  так  же сохраняет extern идентификаторы как
прописные.  В наших примерах мы помещаем ключевые слова и  ди-
рективы как прописные,  а все другие идентификаторы и инструк-
ции - как строчные;  это соответствует стилю справочного руко-
водства TASM.  Вы  можете  использовать  всех их как прописные
(или все как строчные),  или смешанные любым образом - как Вам
удобно.
     Чтобы сделать идентификаторы видимыми  вне  ассемблерного
модуля, Вам необходимо объявить их как PUBLIC.
     Так, например, если Вы пишете модуль, который имеет целые
функции  max  и  min  и  целые  переменные  MAXINT,  lastmax и
lastmin, Вы должны поместить утверждение
     PUBLIC _max, _min
в свой сегмент кода, и операторы
     PUBLIC   _MAXINT, _lastmax, _lastmin
     _MAXINT   DW  32767
     _lastmin  DW  0
     _lastmax  DW  0
в сегмент данных.
     Примечание: Турбо-Ассемблер 2.0 расширяет синтаксис  мно-
гих директив, разрешая необязательный спецификатор языка. Нап-
ример, если Вы укажете С в директиве .MODEL, все имена иденти-
фикаторов  будут сохраняться в объектном модуле с предшествую-
щим "_".  Эта возможность может быть использована в  отдельных
директивах. Используя спецификатор С, последние объявления мо-
гут быть записаны:
     PUBLIC C max, min
     PUBLIC C MAXINT, lastmax, lastmin
     MAXINT   DW  32767
     lastmin  DW  0
     lastmax  DW  0

               Написание ассемблерных программ.

     Давайте посмотрим   как  писать  ассемблерные  программы.
Здесь необходимо рассмотреть следующие вопросы: передачу пара-
метров, возврат значений и использование регистров.
     Предположим, что Вы хотите написать функцию min,  которую
Вы используете со следующим прототипом функции:
     extern int min(int v1, int v2);
     Вы хотите,  чтобы  min возвращала минимальное из 2 значе-
ний, переданных в нее. Общий формат min:
           PUBLIC  _min
     _min  PROC    NEAR
           ...
     _min  ENDP
     Это предполагает,  что  min должна быть ближней функцией;
если она должна быть дальней функцией,  Вы  замените  NEAR  на
FAR. Заметьте, что мы добавили "_" в начало min так, чтобы ре-
дактор Borland C++ мог корректно  разрешить  ссылки.  Если  Вы
использовали  спецификатор языка С Турбо-Ассемблера 2.х в опе-
раторе PUBLIC, Ассемблер будет выполнять это за Вас.

                       Передача параметров.

     Вначале Вы должны решить, какое соглашение о передаче па-
раметров  использовать;  если нет достаточных причин использо-
вать соглашения Паскаля, используйте соглашения С. Это означа-
ет, что при вызове min стек выглядит:
     sp + 04:  v2
     sp + 02:  v1
     sp:       return addr
     Если Вы  хотите получить параметры без выталкивания их из
стека, то Вы должны сохранить указатель базы (ВР), передвинуть
указатель  стека (СР) на указатель базы,  а затем использовать
его для прямой индексации в стеке полученных  значений.  Заме-
тим,  что когда Вы сохраняете ВР в стеке, относительное смеще-
ние параметров увеличится на 2, поскольку теперь в стеке будет
более двух байтов.
     Турбо-Ассемблер 2.х  предоставляет  более  простой способ
ссылки к  параметрам  функции  и работы со стеком.  Прочитайте
это; это важно для понимания того, как работает адресация сте-
ка.

               Обработка возвращаемых значений.

     Ваша функция  возвращает целое значение;  где оно помеща-
ется?  Для 16-битовых (2-байтовых) значений (char, short, int,
enum и near указатели) Вы используете регистр АХ;  для 32-бит-
ных (4-байтовых) значений (включая far и  huge  указатели)  Вы
используете регистры DX, AX со старшим словом в DX и младшим в
AX.
     float, double  и  longdouble  значения возвращаются в ре-
гистре 80х87 ST(0); если используется эмулятор 80х87, значение
возвращается  в  регистре  TOS  эмулятора.  Вызывающая функция
должна копировать это значение.
     Структуры длиной 1 байт возвращаются в AL. Структуры дли-
ной 2 байта возвращаются в AX.  Структуры длиной 4 байта возв-
ращаются в AX:DX. Структуры длиной от 3 байт до 5 байт возвра-
щают результат,  помещая значение в статическую область данных
и  возвращая  указатель на эту область (в AX для малых моделей
данных и DX:AX в больших моделях данных). Вызываемая программа
копирует возвращаемое значение в область, на которую указывает
указатель.
     В примере min Вы работаете с 16-битным значением, которое
помещается в AX.
           PUBLIC  _min
     _min  PROC    NEAR
           push    bp
           mov     bp,sp
           mov     ax,[bp+4]
           cmp     ax,[bp+6]
           jle     exit
           mov     ax,[bp+6]
     exit: pop     bp
           ret
     _min  ENDP
     Что, если Вы объявите min как far функцию?  Главное отли-
чие в том, что стек на входе будет выглядеть:
     sp + 06:  v2
     sp + 04:  v1
     sp + 02:  return segment
     sp:       return offset
     Это означает,  что смещения  в  стеке  увеличатся  на  2,
поскольку 2 дополнительных байта (для сегмента возврата) втал-
киваются в стек. Дальняя версия min:
           PUBLIC  _min
     _min  PROC    FAR
           push    bp
           mov     bp,sp
           mov     ax,[bp+6]
           cmp     ax,[bp+8]
           jle     exit
           mov     ax,[bp+6]
     exit: pop     bp
           ret
     _min  ENDP
     Заметим, что все смещения для v1 и v2 увеличились  на  2,
отражая дополнительные байты в стеке.
     Что произойдет,  если Вы решите  использовать  соглашения
Паскаля о передаче параметров?
     Стек на входе имеет вид (в случае,  если min снова  ближ-
няя функция):
     sp + 04:  v1
     sp + 02:  v2
     sp:       return addr
     Кроме того,  Вам необходимо следовать соглашениям Паскаля
для идентификатора min: верхний регистр и без "_".
     Кроме перестановки v1 и v2 эти соглашения так же требуют,
чтобы min очищала стек при возврате, указывая в инструкции ret
сколько байт вытолкнуть из стека.  В этом случае Вы должны вы-
толкнуть из стека четыре дополнительных байта для v1 и v2 (ад-
рес возврата автоматически выталкивается с помощью RET).
           PUBLIC  MIN
     MIN   PROC    NEAR
           push    bp
           mov     bp,sp
           mov     ax,[bp+6]
           cmp     ax,[bp+4]
           jle     exit
           mov     ax,[bp+4]
     exit: pop     bp
           ret     4
     MIN   ENDP
     И последний  пример,  который показывает,  для чего может
понадобиться соглашение С о передаче параметров.  Предположим,
Вы переопределили min:
     int min(int count,...);
     min сейчас может принимать любое количество целых чисел и
будет возвращать минимальное значение.  Однако,  поскольку min
не знает, сколько параметров будет передано, необходимо первым
параметром передать число значений.
     Например, Вы можете использовать:
     i = min(5, j, limit, indx, lcount, 0);
     при условии,  что i, j, limit, indx, lcount типа int (или
совместимого типа). Стек на входе имеет вид:
     sp + 08:  (etc.)
     sp + 06:  v2
     sp + 04:  v1
     sp + 02:  count
     sp:       return addr
    Модифицированная версия min:
              PUBLIC  _min
     _min     PROC    NEAR
              push    bp
              mov     bp,sp
              mov     cx,[bp+4]
              cmp     cx,0
              jle     exit
              lea     bx,[bp+6]
              mov     ax,bx
              jmp     ltest
     compare: cmp     ax,[bx]
              jle     ltest
              mov     ax,[bx]
     ltest:   add     bx,2
              loop    compare
     exit:    pop     bp
              ret
     _min     ENDP
     Эта версия  правильно обрабатывает все возможные значения
count.
     - Если count <= 0, min возвращает 0.
     - Если count =  1,  min  возвращает  первое  значение  из
     списка.
     - Если count >= 2, min выполняет сравнения для нахождения
наименьшего значения из списка параметров.
     Сейчас, когда Вы понимаете как манипулировать стеком  при
написании  функций,  мы  рассмотрим  некоторые расширения Тур-
бо-Ассемблера 2.х.  Эти расширения позволяют Вам автоматически
создавать имена переменных, устанавливать и очищать стек внут-
ри PROC и обращаться к параметрам, используя соглашения задан-
ного языка.
     Первая версия min может быть переписана:
            PUBLIC  C MIN
     min    PROC    C NEAR  v1: WORD; v2: WORD
            mov     ax,v1
            cmp     ax,v2
            jle     exit
            mov     ax,v2
     exit:  ret
     min    ENDP

     Паскалевская версия:
            PUBLIC  PASCAL MIN
     min    PROC    PASCAL NEAR  v1: WORD; v2: WORD
            mov     ax,v1
            cmp     ax,v2
            jle     exit
            mov     ax,v2
     exit:  ret
     min    ENDP
     Заметьте, что оба варианта идентичны,  за исключением то-
го, что PASCAL используется вместо С.  Однако код, который ге-
нерируется  Ассемблером,  соответствует  нашим  первоначальным
примерам.  См.  документацию по Турбо-Ассемблеру  для  полного
описания новых возможностей.
     Как и обычные функции С,  external ассемблерная процедура
должна соответствовать определенным правилам,  чтобы корректно
работать с менеджером оверлеев.
     Если ассемблерная  программа  вызывает  любую  оверлейную
функцию,  она должна быть дальней и должна устанавливать стек,
используя регистр BP.

                          Регистры.

     Вы используете в min несколько регистров.  Какие регистры
Вы можете использовать в программах на Borland C++?
     При входе в функцию Вам необходимо сохранить регистр BP в
стеке и восстановить его при выходе из функции.
     Borland C++  использует  регистры SI и DI под регистровые
переменные.  Если Вы используете их в ассемблерной  программе,
то должны сохранить их (вероятно в стеке) при входе в програм-
му и восстановить при выходе.  Однако,  если  Вы  компилируете
программу  на Borland C++ с опцией -r- (или выключили Register
Variables в диалоговом окне Code Generation),  эти регистры не
нужно сохранять.
     Примечание: Вы должны осторожно использовать  опцию  -r-.
См.  главу  6 Руководства пользователя для деталей по этой оп-
ции.
     Регистры CS, DS, SS, ES имеют определенное значение в за-
висимости от используемой модели памяти. Взаимосвязь:
     Tiny,Small    CS = DS = SS
                   ES = случайный
     Compact       CS != DS, DS = SS
                   ES = случайный
     Medium,Large  CS != DS != SS
                   ES = случайный
                   (один CS на модуль)
     Huge          CS != DS != SS
                   ES = случайный
                   (один CS и один DS на модуль)
     Вы можете  установить  DS  не равным SS для моделей tiny,
small,  medium,  установив опции командной строки: -mt!, -ms!,
-mm!. См. главу 6 Руководства пользователя.
     Турбо-Ассемблер 2.х позволяет Вам указать это (DS !=  SS)
при использовании упрощенных директив сегментации (модификатор
модели в директиве .MODEL).

          Редактирование ассемблерных модулей с С++.

     Компилятор и редактор должны работать вместе, чтобы вызо-
вы функций  между  модулями использовали правильные типы аргу-
ментов. Процесс, называемый сокращением имен, обеспечивает не-
обходимую информацию о типах аргументов. Сокращение имен моди-
фицирует имя функции для указания того,  какие аргументы функ-
ция принимает.
     Когда Вы строите программу полностью в С++, то сокращение
имен происходит автоматически.  Однако, когда Вы пишете модуль
на языке Ассемблер,  а он должен редактироваться с  программой
С++, Вы должны убедиться в том, что ассемблерный модуль содер-
жит сокращенные имена.  Это легко можно сделать , написав лож-
ную функцию в С++ и откомпилировав ее в Ассемблер.  Файл .ASM,
который сгенерирует Borland C++,  будет иметь  соответствующие
сокращенные имена.   Используйте   эти   имена  при  написании
действительного ассемблерного модуля.
     Например, следующий  фрагмент кода определяет четыре раз-
личные версии функции test:
     void test()
     {
     }
     
     void test(int)
     {
     }
     
     void test(int, int)
     {
     }
     
     void test(float, double)
     {
     }
     Если код компилируется с опцией командной строки  -S,  то
компилятор создает ассемблерный выходной файл (.ASM). Он будет
выглядеть так:
     ;        void test()
     @test$qv         proc     near
              push    bp
              mov     bp,sp
              pop     bp
              ret
     @test$qv         endp
     
     ;        void test(int)
     @test$qi         proc     near
              push    bp
              mov     bp,sp
              pop     bp
              ret
     @test$qi         endp
     
     ;        void test(int, int)
     @test$qii        proc     near
              push    bp
              mov     bp,sp
              pop     bp
              ret
     @test$qii        endp
              
     ;        void test(float, double)
     @test$qfd        proc     near
              push    bp
              mov     bp,sp
              pop     bp
              ret
     @test$qfd        endp
     
            Вызов программ С и С++ из Ассемблера.

     Как и  при  вызове  ассемблерных  подпрограмм из С и С++,
есть определенные вещи,  которые можно сделать для  облегчения
интерфейса.

                          Установка.

     Использование оператора  EXTRN позволяет Вам ссылаться из
ассемблерного модуля к функциям и  переменным,  объявленным  в
программе Borland C++.

                       Обращение к функциям.

     Чтобы вызвать С или С++ функцию из ассемблерной программы
Вы должны объявить ее в ассемблерном модуле
     EXTRN fname: fdist
где fname - имя функции,  а fdist - это либо  near,  либо  far
в зависимости от того, является С функция ближней или дальней.
Так Вы можете использовать в сегменте кода:
     EXTRN  _myCfunc1:near, _myFunc2:far
что позволяет Вам вызвать myCfunc1 и myCfunc2 из  ассемблерной
программы.
     Примечание: Используя  спецификатор  языка   C   в   Тур-
бо-Ассемблере 2.х, оператор можно написать:
     EXTRN  C myCfunc1:near, myFunc2:far

                     Обращение к данным.

     Чтобы обратиться к переменным,  поместите соответствующий
оператор EXTRN внутри сегмента данных
     EXTRN vname: size
где vname - имя переменной, а size - размер переменной.
     Возможные значения size:
      BYTE(1 byte)            QWORD(8 bytes)
      WORD(2 bytes)           TBYTE(10 bytes)
      DWORD(4 bytes)
     Так если С или С++ программа имеет  следующие  глобальные
переменные:
      int   i,jarray[10];
      char  ch;
      long  result;
     Вы можете  сделать их видимыми внутри Вашего модуля с по-
мощью:
     EXTRN _i:WORD,_jarray:WORD;_ch:BYTE;_result:DWORD
или используя спецификатор С/С++ в Турбо-Ассемблере 2.х:
     EXTRN C i:WORD,jarray:WORD;ch:BYTE;result:DWORD
     ВАЖНО! Если Вы используете модель памяти huge,  операторы
EXTRN должны появляться вне любого сегмента. Это относится и к
функциям, и к переменным.

             Пример вызова ассемблерного модуля.

     Теперь давайте вызовем С или С++ программу из  ассемблер-
ного модуля.  Вначале  необходимо  сделать функцию С видимой в
ассемблерном модуле.  Мы уже кратко обсуждали как сделать это:
объявить ее как EXTRN с модификатором near или far.  Например,
у Вас есть функция:
     long docalc(int *fact1, int fact2, int fact3);
     Предположим, что docalc - это С функция.  Предположим так
же,  что  используется модель памяти tiny,  small или compact,
тогда Вы объявляете ее в ассемблерном модуле:
     EXTRN  _docalc:near
     Если Вы используете модель medium,  large  или  huge,  Вы
объявляете ее как _docalc:far.
     Используя спецификаторы языка С Турбо-Ассемблера 2.х, эти
объявления могут быть переписаны как
     EXTRN C docalc:near
       и
     EXTRN C docalc:far
     docalc вызывается с 3 параметрами:
     - адресом положения с именем xval.
     - значением, хранящимся в положении с именем imax.
     - константным значением 421 (десятичное представление).
     Предположим, что  Вы хотите сохранить результат в 32-бит-
ной ячейке памяти с именем ans. Например
     ans = docalc(&xval,imax,421);
     Вам необходимо втолкнуть 421 в стек первым,  затем  imax,
затем  адрес xval и вызвать docalc.  После возврата из нее Вам
необходимо очистить стек,  который имеет 6 лишних байт  и  пе-
реслать возвращенное значение в ans и ans+2.
     mov     ax,421
     push    ax
     push    imax
     lea     ax,xval
     push    ax
     call    _docalc
     add     sp,6
     mov     ans,bx
     mov     ans+2,dx
     Турбо-Ассемблер 2.х использует расширения, которые облег-
чают интерфейс с С.  Эти  расширения  позволяют  автоматически
создавать  имена переменных в стиле С,  вталкивать параметры в
стек в правильном для С порядке и очищать стек после вызова  С
функции. Например, docalc может быть написана
     EXTRN C docalc:near
     mov     bx,421
     lea     ax,xval
     call    _docalc C ax,imax,bx
     mov     ans,ax
     mov     ans+2,dx
     См. документацию по Турбо-Ассемблеру для полного описания
этих возможностей.
     Что, если docalc использует соглашение о  передаче  пара-
метров  Паскаля?  Вам необходимо изменить порядок параметров и
не нужно заботиться об очистке стека после возврата  из  функ-
ции,  поскольку программа сделает это за Вас. Так же Вам необ-
ходимо написать docalc,  используя  соглашения  Паскаля  (про-
писные буквы и без "_").
     Оператор extern выглядит
     EXTRN  DOCALC:near
и код, вызывающий docalc
     mov     ax,xval
     push    ax
     push    imax
     mov     ax,421
     push    ax
     call    DOCALC
     mov     ans,ax
     mov     ans+2,dx
     Турбо-Ассемблер версии 2.х так же включает расширения для
упрощения ассемблерного интерфейса в стиле  Паскаля,  позволяя
Вам  автоматически создавать имена переменных и помещать пара-
метры в стек по соглашениям Паскаля.  Например docalc в  стиле
Паскаля
     EXTRN  PASCAL  docalc:near
     mov     bx,421
     call    docalc   PASCAL ax,imax,bx
     mov     ans,ax
     mov     ans+2,dx
     Это все, что необходимо знать для интерфейса Ассемблера с
Borland C++.

   Псевдопеременные, inline Ассемблер и функции прерываний.

     Что, если Вы хотите выполнить низкоуровневую  работу,  но
не  хотите использовать отдельный ассемблерный модуль?  В этом
случае Borland C++ предоставляет 3 возможности: псевдоперемен-
ные,  встроенный  ассемблер  и функции прерывания.  Оставшаяся
часть главы показывает как использовать эти возможности.

                      Псевдопеременные.

     CPU в Вашей системе (процессор 8088 или 80х86) имеет  ряд
регистров  или специальных областей памяти,  которые использу-
ются для манипуляции значениями. Каждый регистр имеет длину 16
бит (2  байта);  большинство из них имеет определенные задачи,
хотя несколько могут использоваться для  общих  целей.  См.  в
разделе "Модели памяти" главы 6 регистры CPU.
     При низкоуровневом  программировании  Вам  может  понадо-
биться прямо обращаться к этим регистрам из С программ.
     - Вам может понадобиться  загрузить  значение  до  вызова
системной программы.
     - Вам может понадобиться посмотреть их текущие значения.
     Например Вы можете вызвать программы ROM BIOS,  используя
инструкцию INT. Но вначале Вам необходимо поместить информацию
в определенные регистры, например:
     void readchar(unsigned char page, unsigned char *ch,
                   unsigned char *attr);
     {
        _AH = 8;
        _BH = page;
        geninterrupt(0x10)
        *ch = _AL;
        *attr = _AH;
     }
     Как Вы  видите,  код  функции и номер дисплейной страницы
передаются программе INT 10h; возвращаемые значения копируются
в ch и attr.
     Borland C++ делает процесс доступа к этим регистрам очень
простым  с  помощью  псевдопеременных.  Псевдопеременные - это
просто идентификаторы,  соответствующие данным  регистрам:  Вы
можете  использовать их,  как если бы это были переменные типа
unsigned int или unsigned char.
     Правила использования псевдопеременных:
     - Присваивание простой переменной  в  псевдопеременную  и
       наоборот не портит других регистров,  если не использо-
       валось приведение типа.
     - Присваивание  констант  псевдопеременным  не  разрушает
       данные других регистров,  за  исключением  присваивания
       сегментным  регистрам (_CS,  _DS,  _SS,  _ES),  которое
       использует регистр AX.
     - Простая ссылка через указатель будет разрушать данные в
       одном из _BX, _SI или _DI, и, возможно, _ES.
     - Если  Вы устанавливаете ряд регистров (например для вы-
       зова ROM BIOS) надежнее  устанавливать  _AX  последним,
       поскольку он может изменяться другими операторами.
     Следующая таблица показывает полный список псевдоперемен-
ных,  который Вы можете использовать, их типы, регистры, соот-
ветствующие им и их обычное использование.

                Таблица 9.4. Псевдопеременные.
─────────────────────────────────────────────────────────────
псевдо-
переменная     тип           регистр              назначение
─────────────────────────────────────────────────────────────
     _AX    unsigned int      AX       Общий/аккумулятор.
     _AL    unsigned char     AL       Младший байт AX.
     _AH    unsigned char     AH       Старший байт АХ.

     _BX    unsigned int      BX       Общий/индексация.
     _BL    unsigned char     BL       Младший байт ВX.
     _BH    unsigned char     BH       Старший байт ВХ.

     _CX    unsigned int      CX       Общий/счетчик и циклы.
     _CL    unsigned char     CL       Младший байт СX.
     _CH    unsigned char     CH       Старший байт СХ.

     _DX    unsigned int      DX       Общий/хранение данных.
     _DL    unsigned char     DL       Младший байт DX.
     _DH    unsigned char     DH       Старший байт DХ.

     _CS    unsigned int      CS       Адрес сегмента кода.
     _DS    unsigned int      DS       Адрес сегмента данных.
     _SS    unsigned int      SS       Адрес сегмента стека.
     _ES    unsigned int      ES       Адрес extra сегмента.

     _SP    unsigned int      SP       Указатель стека
                                       (смещение к SS).
     _BP    unsigned int      BP       Базовый указатель
                                       (смещение к SS).
     _DI    unsigned int      DI       Используется для
                                       регистровых
                                       переменных.
     _SI    unsigned int      SI       Используется для
                                       регистровых переменных.
     _FLAGS unsigned int      FLAGS    Статус процессора.
──────────────────────────────────────────────────────────────
     Псевдопеременные могут  интерпретироваться,  как  если бы
они были обычными глобальными переменными соответствующего ти-
па.  Однако, поскольку они ссылаются к регистрам процессора, а
не к произвольным участкам памяти,  существует некоторое огра-
ничение.
     - Вы не можете использовать оператор адреса & с псевдопе-
ременной, поскольку она не имеет адреса.
     - Поскольку компилятор постоянно генерирует код,  исполь-
зующий  регистры (кроме того,  это делают инструкции 8086),  у
Вас нет гарантии,  что значения, помещенные в псевдопеременные
будут сохраняться длительное время.
     Это означает,  что Вы  должны  присваивать  значения  не-
посредственно  перед их использованием и читать значения сразу
после их получения,  как в readchar (предыдущий пример).  Осо-
бенно это касается регистров общего назначения (AX,  AH,  AL и
т.д.),  поскольку компилятор использует их как  временную  па-
мять.  Кроме того, процессор изменяет их способом, которого Вы
можете не ожидать; например использует CX, когда устанавливает
цикл  или для операции сдвига;  или использует DX для хранения
старшего слова 16-битного умножения.
     - Вы  не  должны  ожидать,  что значения псевдопеременной
останутся теми же самыми после вызова функции. Например:
     _CX = 18;
     myFunc();
     i = _CX;
     Поскольку не все регистры  сохраняются  во  время  вызова
функции,  нет гарантии,  что i будет присвоено 18. Только _DS,
_BP, _SI, _DI сохраняют те же значения до и после вызова функ-
ции.
     - Необходимо очень осторожно изменять некоторые регистры,
поскольку это может привести к неожиданным эффектам. Например,
прямое сохранение значений в _CS,  _DS,  _SS,  _SP,  _BP может
привести  (и  наверняка приведет) к ошибочному поведению прог-
раммы,  поскольку  машинный  код,  генерируемый  Borland  C++,
использует эти регистры.

                      inline Ассемблер.

     Вы познакомились  как писать отдельные ассемблерные прог-
раммы и связывать их с программами на Borland C++. Borland C++
так  же позволяет писать ассемблерный код внутри  С программы.
Это известно как inline Ассемблер.
     Чтобы использовать inline Ассемблер в С программе, Вы мо-
жете использовать опцию компилятора -B. В этом случае компиля-
тор сначала генерирует ассемблерный файл, затем вызывает Turbo
Assembler (TASM) и создает файл .OBJ.
     Вы можете также вызвать TASM,  опустив опцию -B,  если Вы
включите оператор #pragma inlinе в исходном коде.  Этот опера-
тор включает опцию -B, когда компилятор встретит его.
     Примечание: По умолчанию -B вызывает TASM.  Вы можете пе-
рекрыть его с помощью -Exxx,  где ххх - другой Ассемблер.  См.
главу 6 Руководства пользователя.

                            BASM.

     Если Вы не используете ни один из этих методов для вызова
TASM, Borland  C++ может ассемблировать Ваши инструкции inline
Ассемблера, используя  встроенный   Ассемблер   (BASM).   Этот
Ассемблер делает все, что может делать TASM, со следующими ог-
раничениями:
     - Он не может использовать ассемблерные макро;
     - Он не может обрабатывать инструкции 80386 и 80486;
     - Он не допускает синтаксис режима Ideal;
     - Он допускает только ограниченный набор ассемблерных ди-
       ректив.

                      Inline синтаксис.

     Конечно, Вы  должны  быть  знакомы с набором инструкций и
архитектурой 80х86.  Пока Вы не написали  полную  ассемблерную
программу, Вам нужно знать, как работают используемые инструк-
ции, как их использовать и как их не использовать.
     После этого  Вам  необходимо только использовать ключевое
слово asm для ввода inline ассемблерной инструкции. Формат
     asm opcode operands; или новая строка
где
     - opcode  -  это  инструкция  8086 или 80286 (таблица 9.5
приводит все разрешенные  инструкции).  Для  инструкций  80286
используйте опцию компилятора командной строки -Z или включите
опцию 80286    instruction    set    в     диалоговом     окне
Options/Compiler/Code generation/More.
     - operands содержит операнды,  разрешенные для  opcode  и
может ссылаться к константам, переменным и меткам С.
     - ; или новая строка указывают на конец оператора asm.
     Новый оператор  asm  может  быть помещен на той же строке
после ";",  но оператор asm не может быть продолжен на следую-
щую строку.
     Если Вам  необходимо  использовать  несколько  операторов
asm, используйте {}:
     asm   {
        pop ax; pop ds
        iret
     }
     Примечание. Открывающая фигурная скобка ДОЛЖНА  появиться
на той же строке, что и ключевое слово asm.
     Для начала комментария не используется ";" (как в  TASM).
Для комментирования asm используются С комментарии:
     asm mov ax,ds;              /* правильный комментарий */
     asm {pop ax; pop ds; iret;} /* правильный комментарий */
     asm push ds                  ; неправильный комментарий
     Ассемблерная часть  оператора  прямо копируется на выход,
объединяясь с кодом, сгенерированным Borland C++ из инструкций
С. Все  символы  С  заменяются  соответствующими эквивалентами
языка Ассемблера.
     Inline Ассемблер - это неполный Ассемблер,  поэтому он не
принимает некоторые конструкции Ассемблера.  Если же это прои-
зойдет, то Borland C++ выдаст сообщение об ошибке. Затем у Вас
есть два выхода.  Вы можете упростить свой inline ассемблерный
код  так,  что Ассемблер примет его,  или используйте опцию -В
для вызова TASM. Во втором случае TASM будет отлавливать боль-
шое количество ошибок.  Однако, TASM не может идентифицировать
положение ошибки, поскольку номера оригинальных исходных строк
С потеряны.
     Каждый оператор asm рассматривается как оператор С.  Нап-
ример
     myFunc()
     {
        int i;
        int x;

        if (i > 0)
           asm  mov  x,4
        else
           i = 7;
     }
     Эта конструкция - правильный оператор if  в  С.  Заметим,
что не требуется ";" после инструкции mov x,4.  Оператор asm -
это единственный оператор в С,  который зависит  от  положения
новой строки.
     Ассемблерный оператор может использоваться как выполнимый
оператор  внутри  функции или как внешнее объявление вне функ-
ции.  Ассемблерные операторы, расположенные вне функции, поме-
щаются в сегмент DATA, а ассемблерные операторы, расположенные
внутри функции, помещаются в сегмент CODE.
     Приведем ассемблерную версию функции min.
     int min (int V1, int V2)
     {
        asm  {
           mov  ax, V1
           cmp  ax, V2
           jle  minexit
           mov  ax, V2
        }
        minexit:
        return (_AX);
     }

                        Коды операции.

     Вы можете включить любые коды операций  инструкции  80х86
как inline  ассемблерный  оператор.  Borland  C++  разрешает 4
класса инструкций:
     - Нормальные инструкции - обычный набор инструкций 80х86.
     - Строковые инструкции.
     - Инструкции перехода.
     - Директивы ассемблирования - распределение и определение
       данных.
     Заметим, что компилятор разрешает все операнды, даже если
они ошибочны или запрещены Ассемблером. Компилятор не проверя-
ет точный формат операндов.
     Следующая таблица  приводит  список  мнемонических  кодов
операций, которые можно использовать в Ассемблере:

                 Таблица 9.5. Коды операций.
──────────────────────────────────────────────────────────────
     aaa              fdivrp           fpatan           lsl
     aad              feni             fprem            mov
     aam              ffree**          fptan            mul
     aas              fiadd            frndint          neg
     adc              ficom            frstor           nop
     add              ficomp           fsave            not
     and              fidiv            fscale           or
     bound            fidivr           fsqrt            out
     call             fild             fst              pop
     cbw              fimul            fstcw            popa
     clc              fincstp**        fsten            popf
     cld              finit            fstp             push
     cli              fist             fstsw            pusha
     cmc              fistp            fsub             pushf
     cmp              fisub            fsubp            rcl
     cwd              fisubr           fsubr            rcr
     daa              fld              fsubrp           ret
     das              fld1             ftst             rol
     dec              fldcw            fwait            ror
     div              fldenv           fxam             sahf
     enter            fldl2e           fxch             sal
     f2xm1            fldl2t           fxtract          sar
     fabs             fldlg2           fyl2x            sbb
     fadd             fldln2           fyl2xp1          shl
     faddp            fldpi            hlt              shr
     fbld             fldz             idiv             smsw
     fbstp            fmul             imul             stc
     fchs             fmulp            in               std
     fclex            fnclex           inc              sti
     fcom             fndisi           int              sub
     fcomp            fneni            into             test
     fcompp           fninit           iret             verr
     fdecstp**        fnop             lahf             verw
     fdisi            fnsave           lds              wait
     fdiv             fnstcw           lea              xchg
     fdivp            fnstenv          leave            xlat
     fdivr            fnstsw           les              xor
──────────────────────────────────────────────────────────────
     Примечание: Если Вы используете inline Ассемблер в  прог-
раммах, использующих эмуляцию плавающей точки (опция -f компи-
лятора командной строки),  то коды, помеченные ** не поддержи-
ваются.
     Когда используются инструкции 80186 во inline Ассемблере,
Вы должны задать опцию -1.  Это вставляет соответствующие опе-
раторы в ассемблерный выход компилятора так, что Турбо-Ассемб-
лер  будет  ожидать эти инструкции.  Если Вы используете более
старый Ассемблер, эти инструкции могут не поддерживаться.

                    Строковые инструкции.

     Строковые инструкции, приведенные в следующей таблице мо-
гут использовать префиксы повторения.

              Таблица 9.6. Строковые инструкции.
──────────────────────────────────────────────────────────────
     cmps         insw        movsb       outsw       stos
     cmpsb        lods        movsw       scas        stosb
     cmpsw        lodsb       outs        scasb       stosw
     ins          lodsw       outsb       scasw
     insb         movs
──────────────────────────────────────────────────────────────

                          Префиксы.

     Могут использоваться префиксы:
     lock     rep     repe     repne     repnz     repz

                       Инструкции перехода.

     Инструкции перехода интерпретируются по особому. Посколь-
ку нельзя включить метки на сами инструкции,  переходы  должны
переходить на метки С (См.  "Использование инструкций перехода
и меток"). Разрешены следующие инструкции перехода:

              Таблица 9.7. Инструкции перехода.
──────────────────────────────────────────────────────────────
     ja           jge          jnc          jnp        js
     jae          jl           jne          jns        jz
     jb           jle          jng          jnz        loop
     jbe          jmp          jnge         jo         loope
     jc           jna          jnl          jp         loopne
     jcx          jnae         jnle         jpe        loopnz
     je           jnb          jno          jpo        loopz
     jg           jnbe
──────────────────────────────────────────────────────────────

                      Ассемблерные директивы.

     Следующие ассемблерные  директивы  разрешены   в   inline
ассемблерных операторах Borland C++:
     db  dd  dw  extrn

                  Обращение к данным и функциям.

     В операторах  asm  Вы  можете  использовать  символы   С;
Borland  C++  автоматически  преобразует  их в соответствующие
операнды языка Ассемблера и добавляет "_" к именам.  Вы можете
использовать любой символ,  включая автоматические (локальные)
переменные, регистровые переменные и параметры функций.
     В общем,  Вы  можете  использовать любой символ С в любой
позиции,  где разрешен адресный операнд.  Конечно,  Вы  можете
использовать регистровую переменную, где разрешен регистр.
     Если Ассемблер встречает идентификатор в качестве операн-
да ассемблерной инструкции,  он ищет этот идентификатор в таб-
лице символов С. Имена регистров 8086 исключаются из этого по-
иска.  Может  быть  использована  прописная или строчная форма
имен регистров.

          inline Ассемблер и регистровые переменные.

     inline ассемблерный код может свободно  использовать  ре-
гистровые переменные SI и DI. Если Вы используете эти регистры
в inline ассемблерном коде,  компилятор не использует  их  под
регистровые переменные.

       inline Ассемблер, смещения и перекрытия размера.

     При программировании  Вас  не  интересуют точные смещения
локальных переменных.  Простое использование имени будет вклю-
чать правильное смещение.
     Однако может потребоваться включить WORD  PTR,  BYTE  PTR
или  другое перекрытие размера в ассемблерной инструкции.  Пе-
рекрытие DWORD PTR требуется в LES или в инструкции косвенного
дальнего вызова.

             Использование элементов структур С.

     Вы можете ссылаться к элементам структур в inline Ассемб-
лере обычным способом (т.е. переменная.элемент). В этом случае
Вы  можете  сохранить или получить значения.  Однако Вы можете
так же прямо обращаться к имени элемента (без  имени  перемен-
ной)  как к константе.  В этом случае константа равна смещению
(в байтах)  от  начала  структуры,  содержащей  этот  элемент.
Рассмотрим фрагмент программы:
     struct myStruct   {
        int a_a;
        int a_b;
        int a_c;
     }  myA ;

     myfunc()
     {
        ...
        asm  {mov  ax, myA.a_b
              mov  bx, [di].a_b
             }
        ...
     }
     Мы объявили тип структуры  myStruct  с  тремя  элементами
a_a,  a_b,  a_c.  Мы  так  же  объявили  переменную  myA  типа
myStruct.  Первый ассемблерный  оператор  пересылает  значение
myA.a_b в регистр AX. Второй пересылает значение адреса [di] +
offset(a_c) в регистр BX (он берет адрес из DI и  добавляет  к
нему смещение a_c от начала myStruct).  Этот ассемблерный опе-
ратор создает код:
     mov  ax, DGROUP : myA+2
     mov  bx, [di+4]
     Для чего это понадобится? Если Вы загружаете регистр (та-
кой как DI) адресом структуры типа myStruct, Вы можете исполь-
зовать имена элементов для прямой ссылки к элементам. Имя эле-
мента может использоваться в любом месте, где разрешена число-
вая константа в операнде ассемблерного оператора.
     Элемент структуры должен использоваться с  точкой,  чтобы
указать,  что это имя элемента,  а не обычный символ  С. Имена
элементов заменяются в ассемблерном выводе смещениями  элемен-
тов структур  (числовое  смещение а_с равно 4),  а не содержа-
щейся в них информацией. Эти элементы могут использоваться как
константы времени компиляции в ассемблерных операторах.
     Существует, однако, одно ограничение. Если две структуры,
которые  Вы используете в inline Ассемблере,  имеют одинаковое
имя элемента, Вы должны различить их. Вставьте имя структуры в
круглых скобках между точкой и именем элемента, как при приве-
дении типа. Например
     asm  mov  bx,[di].(struct tm)tm_hour

          Использование инструкций перехода и меток.

     Вы можете  использовать  любые инструкции условного и бе-
зусловного перехода и инструкции цикла  в  inline  Ассемблере.
Они  разрешены  только внутри функции.  Поскольку в операторах
asm  нельзя  определить  метки,  инструкции  перехода   должны
использовать метки С как объекты для перехода.  Если метка на-
ходится слишком далеко, то переход автоматически преобразуется
в дальний переход.  Нельзя генерировать прямые дальние перехо-
ды.
     В следующем коде переход выполняется на метку а:
     int     x()
     {
     a:
        ...
        asm  jmp  a
        ...
     }
     Так же  разрешены косвенные переходы.  Чтобы использовать
косвенный переход,  Вы можете использовать имя  регистра,  как
операнд инструкции перехода.

                     Функции прерывания.

     8086 резервирует  первые 1024 байт памяти,  чтобы устано-
вить 256 дальних указателей - известных как вектора прерываний
- на специальные системные программы, известные как обработчи-
ки прерываний. Эти программы вызываются инструкцией 8086
     INT int#
     где int# от oh до FFh.  При этом компьютер сохраняет сег-
мент кода CS, указатель инструкции IP, флаги статуса, запреща-
ет прерывания и выполняет дальний переход на положение, указы-
ваемое соответствующим вектором прерывания. Например Вы можете
вызвать
     int 21h
     которая вызывает большинство программ DOS. Многие вектора
прерываний  не используются,  что означает,  что Вы можете на-
писать собственный обработчик прерывания и поместить far  ука-
затель на него в один из неиспользуемых векторов прерывания.
     Чтобы написать обработчик прерывания  в  Borland  C++, Вы
должны  определить  функцию  типа interrupt;  она должна иметь
вид:
     void interrupt myhandler(bp, di, si, ds, es, dx,
                              cx, bx, ax, ip, cs, flags, ...);
     Как Вы видите, все регистры передаются как параметры так,
что Вы можете использовать  любой  из  них  без  использования
псевдопеременных. Вы так же можете передать дополнительные па-
раметры (flags,  ...) в  обработчик;  они  должны  быть  соот-
ветственно определены.
     Функция типа interrupt будет автоматически  сохранять  (в
дополнение к SI,  DI, BP) регистры AX, BX, CX, DX, ES, DS. Эти
регистры восстанавливаются при выходе из обработчика  прерыва-
ний.
     Обработчик прерывания  может  использовать  арифметику  с
плавающей точкой во всех моделях памяти.  Код обработчика пре-
рывания,  который использует 80х87, должен сохранять состояние
сопроцессора на входе и восстанавливать его на выходе.
     Функция прерывания может модифицировать  свои  параметры,
при этом будут изменяться соответствующие регистры при возвра-
те из обработчика прерывания.  Это может быть полезным,  когда
Вы используете обработчик прерывания,  действующий как пользо-
вательская функция,  подобно функциям DOS INT 21.  Заметим так
же,  что  выход  из функции прерывания выполняется инструкцией
IRET.
     Для чего  необходим свой обработчик прерывания?  Например
для резидентных программ. Они инсталлируют себя как обработчи-
ки   прерываний.   После  выполнения  какого-то  определенного
действия (скажем при нажатии клавиатуры) эти  программы  могут
быть  вызваны для обработки прерывания и выполнения определен-
ного действия.  После этого они передают управление в програм-
му, которая работала до их вызова.

               Низкоуровневое программирование.

     Приведем более  сложный пример низкоуровневого программи-
рования. Давайте напишем обработчик прерывания, который выдает
сигнал при его вызове.
     Вначале напишем саму функцию:
     #include  <dos.h>

void  interrupt  mybeep(unsigned bp, unsigned di, unsigned si,
                        unsigned ds, unsigned es, unsigned dx,
                        unsigned cx, unsigned bx, unsigned ax)
{
   int  i, j;
   char originalbits, bits;
   unsigned char  bcount = ax >> 8;
   bits = originalbits = inportb(0x61);

   for (i = 0; i <= bcount: i++) {

      outportb(0x61, bits & 0xfc);
      for (j = 0; j <= 100; j++) {
         ;

      outportb(0x61, bits j 2);
      for (j = 0; j <= 100; j++)
         ;
      }

      outportb(0x61, originalbits);
}
     Затем напишем  функцию,  которая  инсталлирует обработчик
прерывания.  Передадим ей адрес обработчика прерывания и номер
прерывания (от 0 до 255 или от 0х00 до 0хFF):
     void install(void interrupt (*faddr) (), int inum
     {
        setvect(inum, faddr);
     }
Наконец, вызовем программу для ее тестирования.
     void testbeep(unsigned char bcount, int inum)
     {
        _AH = bcount;
        geninterrupt(inum);
     }
Функция main имеет вид:
     main()
     {
        char  ch:

        install(mybeep,10);
        testbeep(3,10);
        ch = getch();
     }
     Вы можете так же сохранить оригинальный вектор прерывания
и восстанавливать его при завершении  главной  программы.  Для
этого используйте функции getvect и setvect.
