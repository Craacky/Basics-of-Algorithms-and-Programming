                        ПРИЛОЖЕНИЕ А.
                 ОТКОМПИЛИРОВАННЫЕ ЗАГОЛОВКИ.

     Borland C++  может генерировать и использовать откомпили-
рованные заголовки для Ваших проектов. Откомпилированные заго-
ловки могут существенно увеличить скорость компиляции.

                      Как они работают.

     При компиляции  больших программ С или С++ компилятор мо-
жет половину времени потратить на  анализ  файлов  заголовков.
Когда компилятор анализирует файл заголовка, он выводит объяв-
ления и определения в таблицу имен.  Если десять исходных фай-
лов включают один и тот же файл заголовков, то этот файл заго-
ловков анализируется десять раз,  создавая каждый раз одинако-
вую таблицу имен.
     Файлы откомпилированных заголовков  сокращают  этот  про-
цесс. Во время компиляции компилятор хранит образ таблицы имен
на диске в файле с именем TCDEF.SYM по  умолчанию.  (ТCDEF.SYM
хранится  в  том же справочнике,  что и компилятор).  Позднее,
когда тот же файл компилируется  снова  (или  другой  исходный
файл,  включающий такие же файлы заголовков), компилятор пере-
загружает TCDEF.SYM с диска  вместо  повторного  анализа  всех
файлов заголовка. Прямая загрузка таблицы имен с диска занима-
ет в десять раз меньше времени, чем анализ текста файлов заго-
ловков.
     Откомпилированные заголовки будут использоваться только в
том  случае,  если вторая компиляция использует один или более
таких же файлов заголовков,  что и первая компиляция,  а также
идентичны опции компилятора, определенные макросы и т.д.
     Если во время компиляции исходного файла Borland C++  об-
наружил, что первые #include идентичны тем же самым предыдущей
компиляции (того же исходного кода или другого),  то он загру-
зит  двоичный образ для этих #include и проанализирует осталь-
ные #include.
     Использование откомпилированного  заголовка  для  данного
модуля - это все или ничего: файл откомпилированных заголовков
не обновляется для модуля,  если компиляция какого-то включен-
ного файла заголовков заканчивается неудачно.

                         Недостатки.

     При использовании откомпилированных заголовков  TCDEF.SYM
может стать очень большим,  потому что он содержит образы таб-
лиц имен для всех включений,  встречающихся в  Ваших  исходных
файлах.  Можно уменьшить размер этого файла; см. раздел "Опти-
мизация откомпилированных заголовков".
     Если заголовок  содержит  какой-либо код,  то он не может
быть заранее откомпилирован.  Например, в то время как опреде-
ления класса С++ могут появиться в файле заголовков, Вы должны
проследить,  чтобы в заголовке были определены только те  эле-
менты-функции,  которые расширены inline; может появиться пре-
дупреждение типа "Functions containing for  are  not  expanded
inline" (содержащиеся функции не расширены inline).

         Использование откомпилированных заголовков.

     Можно управлять использованием откомпилированных заголов-
ков одним из трех способов:
     - изнутри     IDE     используйте     диалоговое     окно
Options/Compiler/Code Generation. IDE основывает имя файла от-
компилированных   заголовков   на   имени   проекта,  создавая
PROJECT.SYM;
     - из  командной строки используйте опции -H,  -H=filename
или -Hu;
     - изнутри   своего  кода  используйте  прагмы  hdrfile  и
hdrstop (см. главу 4 в руководстве программиста).

                    Установка имен файлов.

     Компилятор использует только один файл для хранения  всех
откомпилированных заголовков.  Именем файла по умолчанию явля-
ется TCDEF.SYM.  Можно явно установить имя с помощью опции ко-
мандной строки -H=filename или директивы #pragma hrdfile.
     ПРЕДОСТЕРЕЖЕНИЕ! Вы можете заметить,  что Ваш  .SYM  файл
меньше, чем он должен быть. Если это произошло, значит не хва-
тило места на диске при  написании  компилятором  файла  .SYM.
     Когда это  произошло,  компилятор  удаляет .SYM для того,
чтобы появилось место для файла .OBJ,  а затем начинает созда-
вать  новый (и более короткий) файл .SYM.  Если это случилось,
освободите часть дискового пространства перед компиляцией.

                   Установка идентичности.

     Чтобы прежде  сгенерированный откомпилированный заголовок
был загружен при  последующей  компиляции,  следующие  условия
должны быть идентичными.
     Второй и следующие исходные файлы должны:
     - иметь  одинаковое  множество включенных файлов в том же
порядке;
     - иметь  одинаковые  макросы,  определенные с идентичными
значениями;
     - использовать один язык (С или С++);
     - использовать файлы  заголовков  с  идентичной  отметкой
времени;  эти  файлы  заголовков могут быть включены прямо или
непрямо.
     Вдобавок, исходные  файлы должны компилироваться с одина-
ковыми установками следующих опций:
     - модели памяти, включая SS!=DS (-mx);
     - подчеркивания для внешних имен (-u);
     - максимальной длины идентификатора (-iL);
     - выходного файла DOS (по умолчанию) или Windows (-W  или
-Wx);
     - генерации выравнивания по слову (-a);
     - вызовов Pascal (-p);
     - обработки вычислений как целых чисел (-b);
     - по умолчанию char как unsigned (-K);
     - управления виртуальной таблицей (-Vx).

          Оптимизация откомпилированных заголовков.

     Чтобы Borland  C++  компилировал   наиболее   эффективно,
используйте откомпилированные заголовки,  употребляя следующие
правила:
     - Организуйте  свои  файлы заголовков в той же последова-
тельности, что и исходные файлы;
     - Самые большие файлы заголовков поставьте первыми;
  - Накачивайте  TCDEF.SYM  наиболее   часто   используемой
последовательностью файлов заголовков;
     - Используйте #pragma hdrstop для завершения списка  фай-
лов  заголовков  в  хорошо выбранных местах.  Это позволит Вам
сделать список файлов заголовков в  различных  исходных  кодах
выглядеть похожими для компилятора.  #pragma hdrstop описана в
главе 4 Руководства программиста.
     Например, даны  два исходных файла ASOURCE.C и BSOURCE.C,
оба включают windows.h и myhdr.h,
ASOURCE.C:   #include <windows.h>
             #include "myhdr.h"
             #include "xxx.h"
             <...>
BSOURCE.C:   #include "zz.h"
             #include <string.h>
             #include "myhdr.h"
             #include <windows.h>
             <...>
     Вы можете переорганизовать начало BSOURCE.C так:
Исправленный #include <windows.h>
BSOURCE.C:   #include "myhdr.h"
             #include "zz.h"
             #include <string.h>
             <...>
     Заметим, что windows.h и myhdr.h стоят в том же порядке в
BSOURCE.C,  что  и в ASOURCE.C.  Вы можете также создать новый
исходный файл с именем PREFIX.C,  содержащий только  заголовки
файлов:
PREFIX.C     #include <windows.h>
             #include "myhdr.h"
     Если Вы  компилируете  PREFIX.C  первым  (или  вставляете
#pragma hrdstop в оба файла ASOURCE.C и BSOURCE.C после опера-
тора  #include  "myhdr.h"),  то эффект заключается в том,  что
после исходной компиляции  PREFIX.C,  оба  файла  ASOURCE.C  и
BSOURCE.C  смогут загрузить таблицу имен,  созданную PREFIX.C.
Компилятору нужно  будет  только  проанализировать  xxx.h  для
ASOURCE.C, zz.h и string.h для BSOURCE.C.
