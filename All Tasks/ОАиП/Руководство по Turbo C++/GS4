                           ГЛАВА 4

        УЧЕБНИК ДЛЯ НАЧИНАЮЩИХ ПРОГРАММИРОВАТЬ НА С++

     Эта глава описывает основные идеи С++. Глава 5 "Работа на
С++"  дает возможность быстро изучить несколько примеров прог-
рамм на С++.
     Эта глава дает Вам почуствовать особенность языка С++. Мы
объясним некоторые жаргонные выражения и объединим немного те-
ории с простыми,  иллюстративными примерами.  Исходный код для
этих примеров находится на дистрибутивных дискетах, поэтому Вы
можете изучить,  отредактировать,  откомпилировать и выполнить
их.  (Графические примеры, конечно, будут выполняться только ,
если у Вас есть графический адаптер и монитор.  Эти  программы
будут выполняться на CGA, EGA, VGA или Hercules.)
     Borland C++  обеспечивает все свойства С AT&T версии 2.0.
С++ - расширение популярного языка С,  в  который  добавляются
специальные  свойства для объектно - ориентированного програм-
мирования (ООП).
     ООП - метод программирования,  который стремится имитиро-
вать способ, которым мы создаем модели мира.Чтобы справиться с
жизненными сложностями,  мы развили прекрасные возможности для
обобщения,  классификации и генерации абстракций. Почти каждое
существительное в нашем словаре представляет  класс  объектов,
совместно  использующих некоторое множество атрибутов или осо-
бенностей поведения. В мире много разных собак, но мы выделяем
абстрактный  класс  - "собака".  Это позволяет нам развивать и
отрабатывать идеи о клыках,  не отвлекаясь на детали, касающи-
еся  какой  -  либо определенной собаки.  Расширение ООП в С++
развивает эту естественную тенденцию классификации и абстраги-
рования  - фактически С++ первоначально назывался "С с класса-
ми".
     Три главных свойства характеризуют язык ООП:
     - Инкапсуляция: комбинирование структуры данных с функци-
ями (действиями или методами),  предназначенными для манипули-
рования данными.  Инкапсуляция достигается посредством  нового
механизма  структурирования  и  типирования  данных - создание
класса.
     - Наследование:  Построение новых,  порожденных  классов,
которые наследуют данные и функции из одного или более предва-
рительно определенных базовых классов. При этом, в порожденных
классах возможно переопределение или добавление новых данных и
действий. Это создает иерархию классов.
     - Полиморфизм:  Присваивание действию  одного  имени  или
обозначения,  которое  совместно  используется вверх и вниз по
классовой иерархии, при этом каждый класс в иерархии реализует
действие способом, соответствующим этому классу.
     Borland C++  предоставляет Вам всю мощь объектно - ориен-
тированного программирования:
     - большую возможность  управления  структурой  и  модуль-
ностью программы
     - возможность  создавать новые типы данных с собственными
специализированными операторами
     - и средства,  помогающие создать  повторно  используемый
код.
     Все эти  свойства  обеспечивают разработку кода,  который
может быть более структурированным,  расширяемым и легким  для
сопровождения,  чем код, разработанный с помощью не объектно -
ориентированных языков.
     Чтобы достигнуть этих важных преимуществ С++, Вам необхо-
димо изменить способ мышления о программировании, который счи-
тается стандартным многие годы. Когда Вы сделаете это, Вы уви-
дите,  что С++ - простое, прямое и лучшее средство для решения
многих проблем,  которые  беспокоят  традиционное  программное
обеспечение.
     Ваша квалификация может влиять на то, как Вы будете смот-
реть на С++:
     Если Вы не знакомы с С и С++.  Вначале у Вас возможно бу-
дут трудности с новыми понятиями,  описанными в этой главе, но
работа (и экспериментирование) с  примерами  помогает  сделать
идеи С++ конкретными.  Прежде чем начать изучать С++ вы должны
убедиться,что вы правильно понимаете основные  элементы  языка
С. Как начинающие, Вы имеете одно очень реальное преимущество.
Возможно,  что у вас меньше старых  программистских  привычек,
которые нужно забыть.
     Если Вы  опытный  программист,  использующий язык С.  С++
строится на существующем синтаксисе и возможностях С.  Это об-
легчает изучение С++, если бы Вы изучали полностью новый язык.
Это также позволяет Вам переносить существующие С-программы на
С++  с  минимумом исправлений.  Вы не потеряете возможностей и
эффективности языка С и приобретете  репрезентативную  способ-
ность  классов  и  надежность управления доступом к внутренним
данным.
     Если Вы программируете в Turbo Pascal 5.5.  Turbo  Pascal
5.5. включает многие объектно-ориентированные свойства, одина-
ковые с С++.  Когда вы будете рассматривать основные синтакси-
ческие различия между двумя языками, Вы обнаружите, что объек-
ты Turbo Pascal 5.5 и классы Borland C++ структурируются  оди-
наковым образом.  Вы увидите,  что в С++ функции элементов по-
добны методам в Turbo Pascal 5.5 и можете заметить многие дру-
гие сходства.  Главное различие, которое Вы заметите - это бо-
лее жесткое управление доступом к данным.
     Если Вы имеете  опыт  в  другом  объектно-ориентированном
языке. Вы обнаружите некоторые различия в С++:
     - Во-первых,  синтаксис С++ такой же, как в традиционном,
процедурном языке.
     - Во-вторых,  С++ и Smalltalk фактически по-разному обра-
батывают  объекты во время компиляции.  В Smalltalk связывание
выполняется полностью во время выполнения  программы  (позднее
связывание),  а С++ допускает связывание и во время компиляции
(раннее связывание) и позднее связывание.
     В этой главе мы начнем с подробного описания трех  ключе-
вых идей ООП - инкапсуляции, наследования и полиморфизма. Пер-
вые листинги показывают фрагменты кода для иллюстрации  каждой
темы.  Позднее мы представим полные,  компилируемые программы.
Основной пример развивает объектно-ориентированные представле-
ния,  полезные для графики.  Попутные примеры показывают,  как
С++ работает со строками и другими структурами данных.

                         Инкапсуляция

     Как С++ изменяет способ,  которым вы работаете с кодом  и
данными?  Одним из важных способов является инкапсуляция: сое-
динение кода и данных вместе в отдельный объект классового ти-
па.  Например,  Вы  разработали  структуру  данных,  а  именно
массив,  содержащий информацию,  необходимую  для  изображения
символьного шрифта на экране,  и код (функции) для изображения
на экране, масштабирования, вращения, высвечивания и окрашива-
ния символов шрифта.
     В С обычное решение состоит в том, что структуры данных и
связанные с ними функции помещают в один отдельно  компилируе-
мый  исходный файл,  чтобы попытаться обработать код и данные,
как отдельный модуль.  Хотя это и является шагом в  правильном
направлении, но это еще не достаточно хорошее решение. Точного
соотношения между данными и кодом нет и Вы или другой програм-
мист  могут  получить  доступ  к  данным  непосредственно  без
использования предоставляемых функций.  Это может породить не-
которые проблемы.  Например,  предположим, что Вы решили заме-
нить массив информации о шрифте на связанный список  ?  Другой
программист, работающий над тем же проектом, может решить, что
есть лучший способ доступа к символьным данным, поэтому он пи-
шет  несколько  собственных функций,  которые манипулируют не-
посредственно массивом.  Проблема состоит в том, что массива в
программе уже нет.
     С++ приходит  на  помощь,  расширяя  возможности ключевых
слов struct  и  union  языка  С  и  добавляя  ключевое  слово,
отсутствующее в С:  class. Эти три ключевых слова используются
в С++ для определения классов.
     В С++ сущность отдельного класса (определяемого с помощью
struct,union  или class) состоит в комбинировании функций (на-
зываемых функциями элементов) и данных (называемых  элементами
данных).  Классу  обычно дается приемлемое имя,  например Font
(шрифт). Это имя становится идентификатором нового типа, кото-
рый можно использовать для объявления экземпляров или объектов
класса данного типа:
      class Font {
    //здесь вы объявляете элементы: и данные, и функции;
    //в данный момент не нужно беспокоиться о том,как это
    //делается.
      };
      Font Tiffany;         //объявляет,что Tiffany будет
                            //иметь тип класса Font
      Заметим, что  в  Turbo  C++ можно использовать два слэша
(//),  чтобы ввести однострочный комментарий и в С,  и в  С++.
Можно еще использовать символы комментариев /* */,  если вы их
предпочитаете;  фактически,  они особенно полезны для  длинных
комментариев.
     Предупреждение! Использование   для  комментариев  слэшей
(//) обычно не переносится на другие  компиляторы  С.  Однако,
они переносимы на другие компиляторы С++.
     Переменная Tiffany - экземпляр (иногда называемый конкре-
тизацией) класса  Font.  Можно  многократно  использовать  имя
класса Font,  как обычный тип данных С.  Например,  можно объ-
явить массивы и указатели:
     Font Times[10];  //объявляет массив из 10 элементов  типа
     Font Font* font_ptr; //объявляет указатель на тип Font
     Главное различие  между  классами  С++  и  структурами  С
касается доступности элементов.  Элементы  структуры  С  можно
свободно  использовать в любом выражении или функции внутри их
области действия.  В С++ можно управлять доступом к  элементам
типа struct и class (коду и данным) посредством объявления ин-
дивидуальных элементов  как  public  (общедоступный),  private
(личный)  или protected (защищенный).  Объединение в С++ более
похоже на объединение С,  у которого все элементы  public.  Мы
позже объясним эти три уровня доступа более подробно.
     Примечание. Типы struct и union в С++ не совсем совпадают
с такими же типами в версиях С.
     Структуры и объединения в С++ предлагают больше,  чем  их
двойники в С:  они могут хранить объявления функций и их опре-
деления также как и элементы  данных.  В  С++  ключевые  слова
struct, union и class - все могут использоваться для определе-
ния классов.
     - Класс,  определенный как struct - это просто  класс,  в
котором все элементы имеют уровень доступа public по умолчанию
(но это можно изменить, если возникает необходимость).
      У класса,  определенного  как union,  все элементы имеют
уровень доступа public (этот уровень доступа изменять нельзя).
     - В классе,  определенном как class,  все элементы  имеют
уровень  доступа private по умолчанию (но есть способы измене-
ния этого уровня доступа).
     Поэтому, когда мы говорим о классах в  С++,  мы  включаем
структуры  и объединения также как и типы,  определенные с по-
мощью ключевого слова class.
     Обычно Вы ограничиваете доступ элемента данных к функциям
элемента  :  Вы  объявляете уровень доступа к элементам данных
как private, а к функциям элемента как public.
     Возвращаясь к проблеме обработки шрифтов,  посмотрим  как
помогает понятие класса в С++ ?
     Создавая подходящий  класс  Font,  Вы  можете обеспечить,
чтобы к личным данным шрифта можно было обращаться и манипули-
ровать  ими только посредством общедоступных функций элементов
Font, которые Вы создали для этой цели. Теперь Вы можете в лю-
бой момент изменить структуру данных шрифта: из массива в свя-
занный список и т.п.  Конечно,  нужно будет переписать функции
элементов для обработки новой структуры данных шрифта, но если
имена функций и аргументов не изменяются,  то на программы  (и
программистов)  в других частях системы эти усовершенствования
влиять не будут!
     Следующий рисунок сравнивает способы обеспечения  доступа
к шрифту в С и С++.

               Рисунок 4.1. С в сравнении с С++
               СТРУКТУРА И КОД в С КЛАСС в С++
    ┌──────────────┐                ┌────────────────────────┐
    │struct data   │                │ ДАННЫЕ                 │
    │{             │                │ class                  │
    │...           │                │ {                      │
    │}             │                │ ...                    │
    └──────────────┘                │ ...                    │
                                    │ ...                    │
    ┌──────────────────────────┐    ├────────────────────────┤
    │/* код, который что-то */ │    │ ФУНКЦИИ                │
    │/* делает с данными */    │    │ /* Функции элементов */│
    │{                         │    │ construction(...)      │
    │init(...);                │    │ get(...)               │
    │get(...);                 │    │ sort(...)              │
    │sort(...);                │    │ print(...)             │
    │print(...);               │    │ }                      │
    │...                       │    │                        │
    │}                         │    │                        │
    └──────────────────────────┘    └────────────────────────┘

     Таким образом, технология инкапсуляции в классах, помога-
ет обеспечить реальное преимущество модульности, которым обла-
дают такие языки,  как Ada и Modula2.  Класс С++ устанавливает
хорошо определенный интерфейс,  который  помогает  составлять,
реализовывать,  сопровождать  и многократно использовать прог-
раммы. Отладка С++ программ часто проще, так как многие ошибки
можно быстро проследить в одном определенном классе.
     Понятие класса  ведет  к  идее  абстракции  данных.  Наша
структура данных font не привязана к  какой-либо  определенной
физической  реализации;  она  определена  в  терминах операций
(функций элементов) допустимых для нее. В то же время, филосо-
фия  С,  которая  рассматривает  программу как набор функций с
данными (которые как бы второстепенные члены),  также  изменя-
ется.  С++ класс соединяет данные и функции в качестве равных,
взаимозависимых партнеров.

                         Наследование

     Описательные отрасли науки (необходимые  перед  тем,  как
объяснительные  и  предсказательные  направления  науки смогут
приносить плоды) тратят много времени на классификацию  объек-
тов в соответствии с определенными особенностями. В этом часто
помогает организация классификации как фамильного дерева с од-
ной  общей категорией в корне и подкатегориями,  разветвляющи-
мися на подподкатегории и т.д.
     Энтомологи, например,  классифицируют насекомых как пока-
зано на рис.4.2.  Внутри типа насекомых есть два деления: кры-
латые и бескрылые. Среди крылатых насекомых существует большее
количество категорий: мотыльки, бабочки, мухи и т.д.

             Рисунок 4.2.  Частичная  таксономи-
                    ческая схема насекомых
                            ┌─────────┐
                            │Насекомые│
                            └────┬────┘
                    ┌────────────┴───────────┐
                ┌───┴────┐              ┌────┴────┐
                │крылатые│              │бескрылые│
                └───┬────┘              └─────────┘
      ┌─────────────┼──────────┐
  ┌───┴────┐    ┌───┴───┐    ┌─┴──┐
  │мотыльки│    │бабочки│    │мухи│
  └────────┘    └───────┘    └────┘

     Такой процесс  классификации называется таксономией.  Это
хорошая начальная метафора для механизма наследования в ООП.
     Пытаясь провести классификацию некоторых  новых  животных
или объектов, мы задаем следующие вопросы: Чем этот объект по-
хож на другие объекты общего класса ? Чем он отличается ? Каж-
дый  класс имеет набор поведений и характеристик,  которые его
определяют. Мы начинаем с верхушки фамильного дерева образца и
будем спускаться по ветвям,  задавая эти вопросы на протяжении
всего пути. Более высокие уровни являются более общими, а воп-
росы более простыми: есть крылья или нет крыльев ? Каждый уро-
вень является более специфическим,  чем предыдущий  уровень  и
менее общим.
     Когда характеристика определена, все категории ниже этого
определения включают эту  характеристику.  Поэтому,  когда  Вы
идентифицируете  насекомое  как члена отряда двукрылых (мухи),
то Вам не нужно указывать,  что муха имеет пару  крыльев.  Вид
"муха" наследует эту характеристику из своего отряда.
     ООП -  это процесс построения иерархии классов.  Одним из
наиболее важных свойств,  которое С++ добавляет к С,  является
механизм,  по которому типы классов могут наследовать характе-
ристики из более простых,  общих типов.  Этот механизм называ-
ется  наследованием.  Наследование обеспечивает общность функ-
ций,  в то же время допуская столько особенностей, сколько не-
обходимо.  Если класс D наследует из класса В,  то мы говорим,
что D - это порожденный класс, а В - основной класс.
     Без сомнения это тривиальная задача,  но установить  иде-
альную  иерархию  классов  для  определенного применения очень
трудно.  Таксономия насекомых развивалась сотни лет и  до  сих
пор  подвергается изменениям и саркастическим дебатам.  Прежде
чем вы напишите строку С++ кода,  Вы должны хорошо подумать  о
том,  какие классы необходимы и на каком уровне.  По мере того
как увеличивается применение,  может оказаться, что необходимы
новые  классы,  которые  фундаментально  изменяют всю иерархию
классов.  Есть много книг по этой теме. Напомним, что растущее
число  изготовителей,  поставляют  Borland  C++ с совместимыми
библиотеками классов. Поэтому не изобретайте колеса.
     Иногда вы сталкиваетесь с  классом,  который  комбинирует
свойства более чем одного предварительно определенного класса.
Версия 2.0 С++ предлагает механизм (отсутствующий в более ран-
них   версиях  С++),  называемый  многократным  наследованием,
посредством которого порожденный класс  может  наследовать  от
двух или более основных классов.  Позднее вы увидите,  что это
достигается как  логическое  расширение  механизма  одиночного
наследования.

                         Полиморфизм

     Слово полиморфизм  имеет греческое происхождение:"имеющий
много форм". Полиморфизм в С++ осуществляется с помощью вирту-
альных  функций.  Виртуальные  функции  позволяют использовать
много версий одной и той же функции на всем протяжении  иерар-
хии  классов,  а  во  время  прогона  выполняется определенная
версия функции (это называется поздним связыванием).

                          Перекрытие

     В С можно иметь только одну функцию с данным именем. Нап-
ример, если Вы объявите и определите функцию
     int cube(int number);
то можно получить куб целого числа. Но предположим, что вы хо-
тите возвести в куб число с  плавающей  запятой  или  число  с
двойной  точностью.  Конечно,  можно объявить функции для этих
целей, но они не могут использовать имя cube :
     float fcube (float float_number);  double  dcube  (double
     double_number);
     Тем не менее в С++ функции можно перекрывать. Это означа-
ет,  что Вы можете иметь несколько функций, которые имеют одно
и то же имя, но работают с различными типами данных. Таким об-
разом, можно объявить:
     int cube (int number);  float cube (float  float_number);
     double cube (double double_number);
     Так как  все списки аргументов различны,  С++ заботится о
вызове правильной функции для заданного аргумента.  Если у Вас
есть вызов cube(10),  то вызывается int версия cube, если есть
вызов cube(2.5),  то будет вызываться double версия cube. Если
вы  вызываете  cube(2.5F),  то вы передаете литеру с плавающей
точкой,  а не число  типа  double,  поэтому  будет  вызываться
версия float. Даже такие операторы, как + могут быть перекрыты
и переопределены так,  чтобы они работали не только с числами,
но и с графическими объектами, строками или с чем-нибудь, под-
ходящим для данного класса.

        Моделирование реального мира с помощью классов

     Класс С++ фактически  обеспечивает  естесственный  способ
построения компьютерных моделей систем реального мира.  Бьярне
Строуструп изобрел язык AT&T Bell Labs для того,  чтобы смоде-
лировать большую систему переключения телефонов.
     Есть много применений С++ в машиностроительной промышлен-
ности.  Например,  при моделировании транспортных средств. Вас
будет интересовать и физическое описание (количество шин, мощ-
ность двигателя,  вес и т.д.) и поведение (ускорение, торможе-
ние,  управление  и расход топлива).  Класс Car (машина) может
объединять физические параметры (данные) и их поведение (функ-
ции) в общем смысле. Используя наследование, можно затем выде-
лить специализированные классы Sports_car (спортивные  машины)
и Station_wagon (железнодорожные вагоны),  добавляя новые типы
данных и функций,  а также модифицируя (перекрывая)  некоторые
функции  основного  класса.  Большая часть разработанного кода
основного(ых) класса(ов) повторно используется или, по-крайней
мере, выполняется в цикле.

            Построение классов: графический пример

     В графической среде было бы разумно начать с класса,  ко-
торый  моделирует  физические  пикселы на экране в абстрактных
точках планиметрии.  Первой попыткой может быть класс  struct,
называемый Point (точка),  который сводит вместе X и Y коорди-
наты как элементы данных:
     struct Point { //определяет класс struct,
                    //называемый Point
        int X;  //элементы данных struct int Y; //общедоступны
        по умолчанию
     };
     Примечание. Когда Вы определяете класс, Вы добавляете но-
вый тип данных к С++. Язык обрабатывает новый тип данных таким
же образом, каким он обрабатывает встроенные типы данных.
     Теперь можно объявить несколько  переменных  типа  struct
Point (для краткости,  мы часто будем ссылаться на такие пере-
менные, как переменные типа Point).В С можно было бы использо-
вать следующие объявления, например:
     struct Point Origin, Center, Cur_Pos, AnyPoint;
но в С++ достаточно написать:
     Point Origin, Center, Cur_Pos, AnyPoint;
     Примечание. Термины  экземпляр объекта и экземпляр класса
взаимозаменяемы в С++.
     Переменная типа Point (например,Origin) является одним из
многих  возможных  экземпляров  типа  Point.  Отметим,  что Вы
присваиваете значение  (определенные  координаты)  экземплярам
класса Point, а не самому классу Point. Начинающие часто пута-
ют тип данных Point с  переменными,  являющимися  экземплярами
типа Point. Можно написать Center = Origin (т.е. присвоить ко-
ординаты Origin переменной Center), но Point = Origin не имеет
смысла.
     Когда Вам  нужно  думать  о  координатах X и Y по отдель-
ности,  Вы можете думать о них ,  как о независимых X и Y эле-
ментах (полях) структуры. С другой стороны, когда нужно думать
о координатах X и Y как о переменных, действующих вместе, что-
бы  зафиксировать  положение на экране,  то можно думать о них
сообща, как о Point.
     Предположим, что нужно изобразить  на  экране  светящуюся
точку в заданной позиции. Кроме элементов позиции X и Y, кото-
рые Вы уже видели, Вам понадобится элемент, который определяет
есть ли в этой позиции светящийся пиксел или нет.  Ниже приве-
ден новый тип struct, который включает все три элемента:
     enum Boolean {false,true}; //false = 0; true = 1
     struct Point {
        int X;
        int Y;
        Boolean Visible;
     };
     Примечание. Тип Boolean - хорошо  известен  программистам
на Turbo Pascal.
     Этот код использует перечислимый тип (enum), для проверки
true (истины) или false(лжи).  Так как значения  перечислимого
типа начинаются с 0,  то Boolean может иметь одно из двух зна-
чений: 0 или 1 (ложь или истина).

                     Объявление объектов

     Также как и для других типов данных можно иметь указатели
на классы и массивы классов:
   Point Origin;         //объявляет объект Origin типа  Point
   Point Row[80]; //объявляет массив из 80 объектов типа Point
   Point *point_ptr;      //объявляет "указатель на тип Point"
   point_ptr = &Origin; //указатель указывает на объект Origin
   point_ptr = Row;       //затем он будет указывать на Row[0]

                      Функции элементов

     Как Вы видели ранее,  С++ классы могут содержать наряду с
данными и функции. Функция элемента - это функция, объявленная
внутри определения классов и жестко  связанная  с  этим  типом
класса (функции элементов известны как методы в других объект-
но  -  ориентированных   языках,   например,   Turbo   Pascal,
Smalltalk).
     Примечание. Элементы  данных  - это то,  что класс знает;
функции элементов это то, что класс делает.
     Добавим простую функцию элементов GetX  к  классу  Point.
Есть два способа добавления функции элементов к классу :
     - Определить функцию внутри класса
     - Объявить  ее  внутри  класса,  затем  определить ее вне
класса
     Два метода имеют различные синтаксисы и технические  реа-
лизации.
     Первый метод подобен следующему:
     struct Point  {
        int X,Y;
        Boolean Visible;
        int GetX() { return X;} //определена встроенная
                                //функция элементов
     };
     Примечание. Встроенные функции подробно описываются ниже.
     Эта форма определения делает GetX встроенной функцией  по
умолчанию.  Коротко,  встроенные  функции  являются достаточно
"небольшими",чтобы они могли успешно компилироваться на  своем
месте в отличие от макросов, избегая непроизводительных расхо-
дов при обычных вызовах функций.
     Заметим, что  определение  встроенной  функции  элементов
придерживается  обычного  синтаксиса  языка  С для определения
функции:  функция GetX возвращает значение типа int и не имеет
аргументов.  Тело  функции,  заключенное  между { и } содержит
предложения,  определяющие  функцию  -  в   нашем   случае   -
единственное предложение return X;
     При втором способе Вы просто объявляете функцию элементов
внутри struct Point (используя обычный С синтаксис  объявления
функций),  а  затем  приводите ее полное определение (вместе с
предложениями тела) в любом месте вне тела определения класса.
     struct Point {
        int X,  Y;
        Boolean Visible;
        int  GetX();          //объявление функции элементов
     };
        int Point::GetX() {  //функция  элементов,  return  X;
                             //определенная вне класса
        };
     Примечание. ::  известен как оператор разрешения  области
действия; он говорит компилятору, чему принадлежит функция.
     Функции элементов,  определенные вне определения классов,
можно сделать встроенными (если выполняются определенные усло-
вия), но для этого необходим точный запрос с помощью ключевого
слова inline.
     Рассмотрим использование  оператора  разрешения   области
действия  в  Point ::  GetX в определении функции.  Имя класса
Point необходимо,  чтобы сообщить компилятору,  какому  классу
принадлежит GetX (могут быть другие версии GetХ, принадлежащие
другим классам).  Во внутреннем определении  не  нужно  писать
Point::  модификатор, так как, конечно, ясно, что GetX принад-
лежит Point.
     Примечание. В Главе 3 " C++" Руководства программиста бо-
лее подробно описана область действия классов.
     Point:: перед GetX также служит и другой цели.  Его влия-
ние распространяется и на определение функции так, что Х в вы-
ражении  return  X;  рассматривается  как  ссылка на элемент Х
класса Point.  Заметим, что тело функции Point::GetX находится
в пределах области действия Point независимо от его физическо-
го расположения.
     Какой бы метод определения мы не использовали,  важно то,
что  теперь  у  нас  есть функция элементов GetX,  связанная с
классом Point.  Так как это функция элементов,  то  она  имеет
доступ ко всем переменным данных, которые принадлежат Point. В
нашем простом случае GetX просто обращается к Х  и  возвращает
его значение.

                   Вызов функции элементов

     Функции элементов представляют собой операции над  объек-
тами  их класса,  поэтому,  когда мы вызывали GetX,  нужно ка-
ким-то образом  указать,  на  какой  объект  Point  она  будет
действовать.  Если  бы GetX была бы обычной С функцией (или не
функцией элементов в С++), то эта проблема не возникала бы. Вы
просто  вызвали  бы  функцию  с помощью выражения GetX().  Для
функций элементов нужно задать имя целевого объекта. Использу-
емый  синтаксис  -  это  естественное  расширение  синтаксиса,
используемого в С для ссылки на элементы  структуры.  Так  же,
как Вы ссылаетесь на Origin.X для X-компоненты объекта Origin,
или на Endpoint.Y для Y-компоненты объекта Endpoint, Вы можете
вызвать  GetX с Origin.  GetX() или Endpoint.Get(X).  Оператор
"." служит как селектор компонент класса и для элементов  дан-
ных и для функций. Общий синтаксис вызова имеет следующий вид
     класс -  объект - имя.элемент - функция - имя (список ар-
     гументов)
     Аналогично, если у Вас есть указатель на объект Point, то
нужно  использовать  селектор  элементов  для указателя "->" :
Point_pointer -> GetX(). Вы увидите много примеров таких вызо-
вов функции элемента в примерах этой главы.

                  Констракторы и дестракторы

     Существуют два   специальных   типа    функций    элемен-
тов:констракторы и дестракторы, которые играют ключевую роль в
С++.  Чтобы оценить их значение,  необходимо вернуться немного
назад.  В  традиционных  языках  инициализация  является общей
проблемой. Прежде чем использовать структуру данных, необходи-
мо  распределить  память и проинициализировать ее.  Рассмотрим
задачу инициализации структуры, определенной ранее:
     struct Point {
        int X;
        int Y;
        Boolean Visible;
     };
     Неопытные программисты могут попытаться присвоить началь-
ные значения элементам X,Y и Visible следующим образом:
     Point ThisPoint;
     ThisPoint.X =  17;
     ThisPoint.Y  =  42;
     ThisPoint.Visible = false;
     Это присваивание  работает,  но оно жестко ограничено од-
ним,  определенным объектом ThisPoint. Если необходимо проини-
циализировать  более одного объекта Point,  то Вам понадобится
много операторов присваивания, которые по существу делают одно
и  то  же.  Естесственным  следующим шагом является построение
функции инициализации, которая обобщает операторы присваивания
для  обработки любого объекта Point,  передаваемого в качестве
аргумента:
     void InitPoint(Point *Target, Int NewX, Int NewY)
     {
       TargetЎX = NewX;
       TargetЎY = NewY;
       TargetЎVisible = false;
     }
     Эта функция  принимает  в качестве аргумента указатель на
объект Point и использует его для присвоения заданных значений
элементам этого объекта (еще раз обратите внимание на оператор
Ў при использовании указателей для ссылки на элементы класса).
Вы  правильно назначили функцию InitPoint специально для обра-
ботки структуры  Point.  Теперь,  почему  нужно  задавать  тип
класса и определенный объект,  на который действует InitPoint?
Ответ заключается в том,  что InitPoint не  является  функцией
элементов.  Что  нам  действительно необходимо для обеспечения
преимущества объектно-ориентированного программирования -  так
это  функция  элементов,  которая будет инициализировать любой
объект Point. Это одно из назначений констрактора.
     С++ имеет целью сделать типы данных, определенные пользо-
вателем  такими  же  общими для языка (и такими же легкими для
использования) как и встроенные типы.  Поэтому, С++ предостав-
ляет специальный тип функции элементов, называемый констракто-
ром.  Констрактор определяет как новый объект типа class будет
создаваться, т.е. распределяет для него память и инициализиру-
ет. Его определение может включать код для распределения памя-
ти,  присваивание значений элементам, преобразование из одного
типа в другой и что - нибудь  еще,  что  может  быть  полезно.
Констракторы могут быть определены пользователем,  или С++ мо-
жет  генерировать  констракторы,  определенные  по  умолчанию.
Констракторы могут вызываться или явно, или неявно. Компилятор
С++ автоматически вызывает  соответствующий  констрактор  там,
где Вы определяете новый объект класса.  Это может случиться в
объявлении данных,  когда копируется объект  или  при  динами-
ческом размещении нового объекта с помощью оператора new.
     Дестракторы, как указывает их название, разрушают объекты
класса,  предварительно созданные констрактором, очищая значе-
ние и освобождая память. Также как и констракторы, дестракторы
можно вызывать явно (используя С++ оператор delete) или неявно
(например,  когда объект выходит из области действия). Если Вы
не определили дестрактор для данного  класса,  С++  генерирует
версию,  определенную  по  умолчанию.  Ниже мы рассмотрим син-
таксис определения дестракторов.  Вначале  давайте  посмотрим,
как составляются констракторы.
     Следующая версия Point добавляет констрактор:
     struct Point {
        int X;
        int Y;
        Boolean Visible; int GetX() { return X;  }
        Point(int NewX,  intNewY); //объявление констрактора
     };
     Point :: Point(int NewX, int NewY)  //определение
                                         //констрактора
     {
       X = NewX; Y = NewY; Visible = false;
     };
     Примечание. Point ::  Point указывает,  что мы определяем
констрактор для класса Point.
     Определение констрактора  здесь  делается вне определения
класса.  Констракторы могут также законно определяться  внутри
класса, как встроенные функции. Или они могут определяться вне
определения класса и становиться встроенными с помощью  ключе-
вого слова inline. Однако, необходима осторожность: размер ко-
да, генерируемого констрактором не всегда пропорционален види-
мому исходному коду в определении.
     Заметим, что имя констрактора совпадает с именем  класса:
Point. Так компилятор узнает,  что он имеет дело с констракто-
ром.  Также заметим, что констрактор может иметь аргументы как
и другие виды функций.  В данном случае  аргументами  являются
переменные NewX и NewY. Тело констрактора строится также как и
тело любой функции элементов,  поэтому констрактор может вызы-
вать  любые функции членов данного класса или обращаться к лю-
бому элементу данных. Однако, констрактор никогда не имеет тип
возврата - даже нельзя указывать void.
     Теперь  можно  объявить  новый  объект  Point,  следующим
образом:
     Point Origin(1,1);
     Это объявление  активизирует  предварительно определенный
констрактор Point.  Как Вы увидите позднее,  для класса  можно
определить несколько констракторов,  и как для других перекры-
ваемых функций С++ , соответствующая версия констрактора будет
активизироваться  автоматически  в  соответствии  с  указанным
списком аргументов. Вы также увидите, что если Вы не определи-
ли констрактор, то С++ по умолчанию генерирует констрактор без
аргументов.
     Другой полезный трюк в С++ состоит в том, что можно иметь
значения для аргументов функций, определенные по умолчанию:
     Point::Point(int NewX = 0, int NewY = 0) //исправленное
                                   // определение констрактора
     {
     //как ранее
     }

     Объявление,

     Point Origin(5);

будет инициализировать Х равным 5, а Y, равным 0 по умолчанию.

                     Код и данные вместе

     Одним из наиболее важных принципов объектно-ориентирован-
ного программирования - это то,  что программист должен думать
о коде и данных вместе во время написания программы.  Ни  код,
ни данные не существуют в вакууме. Данные направляют поток ко-
да, а код манипулирует формой и значениями данных.
     Когда данные и код представляют собой отдельные  объекты,
всегда существует опасность вызова правильной функции с непра-
вильными данными или неправильной функции с правильными данны-
ми.  Согласование  кода  и  данных  обеспечивает  программист,
несмотря на то,  что ANSI C,  в отличие от более старых версий
С,  предоставляет хорошую проверку типов,  в лучшем случае, он
может только сказать, что нельзя использовать вместе.
     Связывая объявления кода и данных вместе,  классы С++ по-
могают обеспечивать их синхронизацию.  Как обычно, чтобы полу-
чить значение одного из элементов данных класса,  Вы вызываете
функцию  элементов,  принадлежащую этому классу и возвращающую
значение требуемого элемента.  Чтобы установить значение поля,
Вы вызываете функцию элементов, которая присваивает этому полю
новое значение.

              Управление доступом к элементам :
      private (частный),   public   (общедоступный)   и
                    protected (защищенный)

     Несмотря на то, что расширенный тип struct в С++ разреша-
ет связывать данные и функции, он не такой скрытый или модуль-
ный,  как мог бы быть.  Как мы упоминали ранее, доступ ко всем
элементам  данных и функциям элементов для struct по умолчанию
public (общедоступный) - т.е.  любое предложение внутри той же
области  действия  может читать или изменять внутренние данные
класса struct.  Как указано ранее,  это нежелательно  и  может
привести  к серьезным проблемам.  Хороший С++ проект применяет
скрытые данные или скрытую информацию - объявляя доступ к эле-
ментам данных как private или protected и обеспечивая санкцио-
нированный интерфейс для доступа к этим элементам.  Общее пра-
вило состоит в том, чтобы сделать все данные типа private так,
чтобы доступ к ним был возможен только с помощью функции  эле-
ментов типа public.  Есть только несколько ситуаций, когда для
элементов  данных  необходим  уровень  доступа  public,  а  не
private  или  protected.  Также  некоторые  функции элементов,
используемые только во внутренних операциях,  могут иметь уро-
вень доступа private или protected, а не public.
     Три ключевых  слова определяют управление доступом к эле-
ментам структуры или класса. Соответствующее ключевое слово (с
двоеточием) помещается перед объявлением элементов, на которые
оно действует:
private: к элементам, которые следуют за этим ключевым словом,
            доступ  возможен  только с помощью функций элемен-
            тов, объявленных внутри того же класса.
protected: к элементам,  которые следуют за этим ключевым сло-
            вом,  доступ  возможен с помощью функций элементов
            внутри того же класса и с помощью функций  элемен-
            тов классов, которые порождаются этим классом (см.
            описание ниже).
public: к элементам,  которые следуют за этим ключевым словом,
            доступ  возможен из любого места внутри той же об-
            ласти действия, которую имеет определение класса.
     Например, ниже  показано,  как  переопределить  структуру
Point так, чтобы элементы данных имели доступ private, а функ-
ции элементов - доступ public :
     struct Point {
     private:
        int X;
        int Y;

     public:
        int GetX();
        Point(int NewX, int NewY);
     };

                 Класс: private по умолчанию

     Класс struct имеет по умолчанию доступ public, поэтому Вы
должны использовать private:,  чтобы определить часть с досту-
пом private,  а затем public:  для части, которая должна иметь
общий доступ. Так как хорошей практикой в С++ является опреде-
ление по умолчанию доступа private  и  тщательное  определение
того,  что должно иметь доступ public, С++ программисты обычно
предпочитают class ключевому слову struct. Единственным разли-
чием  между  class и struct являются определяемые по умолчанию
уровни доступа.
     Point переопределяется как класс, подобный следующему:
     class Point {
        int X; //по умолчанию private
        int Y;

     public:           //необходимо отменить доступ private,
                       //определенный по умолчанию
        int GetX();
        Point(int NewX, int NewY);
     };
     Для элементов  данных модификатор private не является не-
обходимым - по умолчанию они  имеют  доступ  private.  Однако,
функции элементов должны быть объявлены с доступом public так,
чтобы они могли использоваться вне данного класса для  инициа-
лизации и восстановления объектов Point.  Можно повторять спе-
цификации управления доступом так часто, как необходимо:
     enum Boolean { false, true };
     class Employee {
        double salary;  //private  по  умолчанию
        Boolean permanent;
        Boolean professional;

     public:
        char name[50];
        char dept_code[3];

     private:
        int Error_check(void);

     public:
     Employee(double salary,   Boolean   permanent,    Boolean
              professinal, char *name, char *dept_code);
     };
     Примечание. Элементы данных обычно имеют доступ  private,
в то время,  как функции элементов обычно имеют доступ public.
Разрешайте доступ public только там,  где он действительно не-
обходим.
     Здесь элементы данных salary, permanent и professional по
умолчанию  имеют  доступ  private;  элементы  данных  name   и
dept_code  объявляются  public;  функция элементов Error_check
объявляется private (предназначена для внутреннего использова-
ния); и констрактор Employee объявляется public.

                     Прогон С++ программы

     Настало время объединить все ,  что Вы изучили,  вместе в
законченную компилируемую программу. Чтобы откомпилировать С++
программу в интегрированной среде,  загрузите Ваш текст в  ре-
дактор,  как обычно. Можно запустить С++ программу из интегри-
рованной среды (IDE) двумя способами. Во-первых, по умолчанию,
любой  файл  с расширением .СРР будет компилироваться с учетом
синтаксиса С++, а любой файл с расширением .С будет компилиро-
ваться с учетом синтаксиса С. Однако, можно выбрать кнопку С++
Always в диалоговом окне Sourсe Options для  того,  чтобы  все
файлы обрабатывались как исходные файлы на С++,  независимо от
расширения.
     Чтобы откомпилировать С++ программу с помощью компилятора
командной строки, нужно дать файлу расширение .СРР. Или Вы мо-
жете использовать опцию командной строки -Р,  в  таком  случае
Borland  C++  будет  считать,  что файл имеет расширение .СРР.
Если файл имеет другое расширение,  то нужно  дать  расширение
вместе с именем файла. Вы облегчите работу себе и своим преем-
никам, если дадите всем С++ программам расширение .СРР, а всем
С программам - расширение .С.
     Программа POINT.CPP определяет класс Point и манипулирует
значениями его данных:
     Примечание. Этот  код можно загрузить и прогнать под име-
нем POINT.CPP.
/* POINT.CPP иллюстрирует простой класс Point */

#include <iostream.h>  // необходим для C++ I/O

class Point {          // определить класс Point
   int X;              // X и Y  -  private по умолчанию
   int Y;
public:
   Point(int InitX, int InitY) {X = InitX; Y = InitY;}
   int GetX() {return X;}  // функции элементов - public
   int GetY() {return Y;}
};

int main()
{
   int YourX, YourY;

   cout << "Set X coordinate: ";  // экранная подсказка
   cin >> YourX;                // ввод с клавиатуры для YourX

   cout << "Set Y coordinate: ";  // другая подсказка
   cin >> YourY;                // ввод с клавиатуры для YourY

   Point YourPoint(YourX, YourY); // объявление вызова
                                  // констрактора

   cout << "X is " << YourPoint.GetX(); // вызов функции
                                        // элемента
   cout << '\n';                        // новая строка
   cout << "Y is " << YourPoint.GetY(); // вызов функции
                                        // элемента
   cout << '\n';
   return 0;
}
     Класс Point теперь содержит новую функцию элементов GetY.
Эта функция работает также, как и GetX, определенная ранее, но
обращается к private элементу данных Y,  а не к X. Обе функции
"короткие" и являются хорошими кандидатами для встроенной фор-
мы определения внутри тела класса.
     Также как и макрос,  использующий директиву #define,  код
для встроенной функции помещается непосредственно в  файл  при
каждом использовании функции,  что позволяет избежать непроиз-
водительных издержек при вызове функции за счет размера  кода.
Эта классическая дилемма "или размер,  или время" возникает во
многих программных ситуациях. Как правило, Вы должны использо-
вать  только  встроенные  определения  для "коротких" функций,
например, от одного до трех предложений. Заметим, что, в отли-
чии  от макроса,  встроенная функция не приносит в жертву про-
верку типов,  которая помогает предотвратить ошибки в  вызовах
функций.  Количество  аргументов  в функции также должно соот-
ветствовать Вашему решению о том, является ли функция встроен-
ной или нет, так как структура аргументов влияет на непроизво-
дительные издержки при вызове функции.  Нужно определять функ-
цию как встроенную,  когда общий код тела функции меньше кода,
который требуется для вызова внешней функции. Может возникнуть
необходимость  попробовать  оба  метода  и  просмотреть  вывод
ассемблерного кода прежде,  чем решить какой подход будет наи-
лучшим в соответствии с Вашими потребностями.
     Делать констрактор  встроенным  или нет - зависит от того
используются или нет базовые констракторы.  Констрактор порож-
денного  класса,  особенно  в  случае использования в иерархии
виртуальных функций,  может генерировать большой объем  "спря-
танного" кода.
     В вышеприведенном примере констрактор Point был определен
как внешний,  следуя после объявления класса.  Несмотря на то,
что  Вы можете располагать определения в любом порядке (и даже
помещать их в любом месте текущего файла),  имеет смысл в  не-
больших программах из одного файла, располагать те определения
,  которые не являются встроенными,  сразу  после  определения
класса в порядке, в котором они объявляются.
     Когда код  получается большой,  возможно,  что объявления
классов будут располагаться в файлах заголовков, а определения
функций  класса  (код  реализации)  в  отдельно  компилируемых
исходных файлах С++.  Однако,  определения встроенных  функций
должны всегда быть в файле заголовков.
     Эта программа  также  использует С++ iostreams библиотеку
(обратите внимание на предложение #include <iostream.h> в  на-
чале программы).
     сout представляет  стандартный выходной поток (по умолча-
нию,  экран).  Данные (значения переменных и строк,  например)
посылаются на экран, используя "вывод на" или оператор вставки
<<.
     сin представляет стандартный поток ввода (обычно - клави-
атура). Значения, набранные на клавиатуре, сохраняются в пере-
менных,  посредством использования оператора >> ("ввод с"  или
извлечение). Использование операторов сдвига >> и << для пото-
ка ввода/вывода - это типичный пример перекрытия операторов  в
С++.
     Примечание. iostreams  библиотека подробно описана ниже в
этом руководстве,  а также в Главе 5 " С++ потоки" Руководства
программиста.
     Функции потоков  дают  Вам  возможность  иметь  дело  не-
посредственно с деталями  форматирования,  которые  необходимы
для printf и scanf;  они также разрешают, чтобы ввод/вывод был
нестандартным для определенных классов.
     Когда значения  X  и  Y  получены  с  клавиатуры,  объект
YourPoint  класса Point объявляется с полученными значениями в
качестве аргументов.  Напомним,  что это объявление  автомати-
чески активизирует констрактор для класса Point,  который соз-
дает и инициализирует YourPoint.
     Попробуйте прогнать программу. Результат должен выглядеть
следующим образом:
     Установите Х  координату  :  50 Установите Y координату :
     100 Х равен 50 Y равен 100

                         Наследование

     Классы обычно не существуют в  вакууме.  Программа  часто
должна  работать  с  несколькими  различными,  но  связанными,
структурами данных.  Например,  Вы можете иметь простой  буфер
памяти,  в  котором  Вы можете хранить и из которого Вы можете
выбирать данные.  Позже Вам может понадобиться создание  более
специализированных  буферов :  файловый буфер,  который хранит
данные, передаваемые из или в файл, возможно, буфер для хране-
ния данных для принтера,  и еще один буфер для сохранения дан-
ных,  приходящих из модема или идущих в модем.  Ясно,  что эти
специализированные буферы имеют много общих характеристик, од-
нако каждая из них имеет  некоторые  различия,  вызванные  тем
фактом,  что дисковые файлы, принтеры и модемы используют уст-
ройства, которые работают различным образом.
     Решение С++ для этой  "сходной,  но  различной"  ситуации
заключается  в предоставлении классам возможности наследования
характеристик и поведения из одного или более базовых классов.
Это является интуитивным скачком;  возможно наследование явля-
ется единственным самым  большим  различием  между  С++  и  С.
Классы, наследуемые из базовых классов, называются порожденны-
ми классами. Порожденный класс может сам быть базовым классом,
из  которого порождаются другие классы (генеалогическое дерево
насекомых).

                Переосмысливание класса Point

     Фундаментальным элементом графики является отдельная точ-
ка на экране (один пиксел).  До настоящего времени мы изобрели
несколько  вариантов  класса  Point,  который определяет точку
своими координатами X и Y, констрактор, который создает и ини-
циализирует положение точки и другие функции элементов,  кото-
рые могут вернуть текущие X  и  Y  координаты  точки.  Однако,
прежде чем Вы сможете что-нибудь нарисовать, Вы должны сделать
различия между пикселами, которые "включены" (нарисованы в не-
котором видимом цвете) и пикселами, которые "выключены" (имеют
цвет фона). Конечно, позже Вы можете пожелать определить какой
из  множества  цветов  должна иметь данная точка и,  возможно,
другие атрибуты (такие как мигание).  Достаточно скоро вы смо-
жете получить сложный класс, который имеет множество элементов
данных.
     Давайте переосмыслим нашу стратегию.  Что представляют из
себя  два фундаментальных вида информации о точках ?  Один вид
информации описывает где находится (положение) точка, а другой
вид информации описывает какой является точка (состояние точки
:  Вы можете либо ее видеть,  либо не видеть, и если Вы можете
видеть ее,  она представлена в некотором цвете). Из двух видов
информации,  положение является наиболее фундаментальным:  без
положения Вы вообще не можете иметь точки.
     Так как  все  точки  должны содержать позицию,  Вы можете
сделать класс Point порожденным классом от более фундаменталь-
ного базового класса - Location, который содержит информацию о
координатах X и Y.  Point наследует все,  что имеет Location и
добавляет  все,  что является новым для Point,  создавая Point
таким, каким он должен быть.
     Эти два связанных класса могут определяться таким путем:
     Примечание.Этот код доступен с именем point.h.
/* point.h--Пример из Главы 4  Начального руководства */

// point.h содержит два класса:
// класс Location определяет экранную позицию в X и Y
// координатах класс Point определяет будет ли точка видимой
// или нет

enum Boolean {false, true};

class Location {
protected:          // разрешает порожденному классу доступ
   int X;           // к private данным
   int Y;

public:             // эти функции могут быть доступны извне
   Location(int InitX, int InitY);
   int GetX();
   int GetY();
};
class Point : public Location {  //порожден из класса Location
// порождение public означает, что X и Y защищены внутри Point

   protected:
   Boolean Visible;  // классам, порожденным от Point будет
                     // нужен доступ
public:
   Point(int InitX, int InitY);      // констрактор
   void Show();
   void Hide();
   Boolean IsVisible();
   void MoveTo(int NewX, int NewY);
};
     В данном  случае,  Location - это базовый класс,  а Point
-это порожденный класс.  Процесс может продолжаться  неопреде-
ленно долго :  Вы можете определить другие классы, порожденные
из Location,  другие классы,  порожденные из Point, еще больше
классов,  порожденных из классов,  порожденных из Point и т.д.
Вы даже можете иметь класс,  порожденный из более,  чем одного
базового класса :  это называется многократным наследованием и
будет обсуждаться позже. Большая часть разработки С++ приклад-
ных  программ заключается в построении этой классовой иерархии
и выражении генеалогического дерева классов в этих программах.

              Наследование и управление доступом

    Прежде чем    обсудить    различные    функции   элементов
point.h,давайте рассмотрим механизмы наследования и управления
доступом в С++.
     Элементы данных класса Location объявляются как protected
- напомним, что это означает, что функции элементов и в классе
Location  ,и  в  порожденном классе Point будут иметь доступ к
ним,  но если их объявить как "общедоступные во всем  объеме",
то  эти  функции  элементов не будут иметь доступа к элементам
данных.
     Вы объявляете порожденный класс следующим образом:
     class D : access_modifier В { //по умолчанию доступ
                                   //private
        ...
     }
или
     struct D : access_modifier В { //по умолчанию доступ
                                    //public
        ...
     }
     D - это имя порожденного класса, access_modifier является
необязательным  (либо  public,  либо private),  а В - является
именем базового класса.
     При использовании ключевого  слова  class,  по  умолчанию
access_ modifier равен private;  при указании struct, по умол-
чанию access_modifier равен public. (Заметим, что классы, объ-
явленные как union не могут быть ни базовыми,  ни порожденными
классами).
     access_modifier - используется для модификации доступа  к
наследуемым элементам, как показано в следующей таблице:
                         Таблица 4.1.
                       Доступ к классу

Доступ в базовый   Модификатор    Наследованный доступ
   класс           доступа              в базе

  public           public         public
  private          public         нет доступа
  protected        public         protected

  public           private        private
  private          private        нет доступа
  protected        private        private

     Примечание.В порожденном классе доступ к элементам из ба-
зового класса может быть сделан более ограниченным, но никогда
нельзя сделать его менее ограниченным.
     При написании новых классов, которые ссылаются на сущест-
вующие классы,  убедитесь,  что Вы понимаете соотношение между
базовыми и порожденными классами.  Насущной частью этого явля-
ется понимание  уровней  доступа,  задаваемых  спецификаторами
private,  protected  и public.  Права на доступ должны переда-
ваться тщательно (или удерживаться) от родителей к  детям,  от
детей к внукам. С++ позволяет Вам делать это, не подвергая Ва-
ши данные действию со стороны.  Уровень доступа элемента базо-
вого  класса  необязательно должен быть таким же,  как уровень
доступа к этому элементу в порожденном классе.  Другими слова-
ми,  когда элементы наследуются, Вы можете в некоторой степени
управлять тем, как их уровни доступа наследуются.
     Примечание. Смотрите Главу 3 " C++" в  Руководстве  прог-
раммиста для лучшего понимания технических деталей.
     Класс может порождаться частным или общедоступным образом
из своего базового класса. Порождение private (определяемое по
умолчанию для классов типа class) превращает элементы public и
protected в базовом классе  в  элементы  private  порожденного
класса,  тогда как элементы private остаются private.(Хотя по-
рождение private является  определяемым  по  умолчанию  -  для
классов,  без сомнения, оно является наиболее часто используе-
мым способом порождения; поэтому мы имеем редкую ситуацию, где
определение по умолчанию не является нормой).
     Порождение public оставляет уровень доступа неизменным.
     Порожденный класс  наследует все элементы своего базового
класса, однако он может только использовать элементы protected
и  public  своего  базового класса.  Элементы private базового
класса не являются непосредственно доступными  через  элементы
порожденного класса.
     Особые определения  Location и Point,  приведенные здесь,
позволят нам позже порождать еще классы  из  Point  для  более
сложных графических применений.
     Примечание. Элементы базового класса,  которые Вы желаете
использовать в порожденном классе, должны быть либо protected,
либо  public.  Элементы  базового класса private не могут быть
доступны,  кроме как для их собственных функций элементов  или
через friend функции.
     Если Вы   используете   порождение  public,  то  элементы
protected базового класса,  остаются protected  в  порожденном
классе,  и таким образом, являются недоступными извне, за иск-
лючением  других  общедоступных  порожденных  и  дружественных
классов.  Хорошей  идеей является всегда определять public или
private, даже если они определены по умолчанию, для того чтобы
избежать путаницы.  Хорошие комментарии также улучшат удобочи-
таемость исходной программы.

                  Упаковка классов в модули

     Классы, такие как Location и Point, могут вместе упаковы-
ваться для использования в дальнейшей разработке программ.  Со
своими встроенными данными,  функциями элементов и управлением
доступа,  класс по существу является модулем.  При  разработке
программы,  часто имеет смысл поместить объявления для каждого
класса или группы соответсвующих классов в отдельном файле за-
головков,  а  определения для невстроенных функций элементов в
отдельном исходном файле.  (Смотрите Главу 4 " Управление мно-
гофайловыми проектами " в Руководстве пользователя,  для более
подробного понимания того, как использовать администратор про-
екта для управления программами, которые состоят из нескольких
исходных файлов).
     Вы также можете комбинировать несколько классовых объект-
ных  файлов  в  библиотеку,  используя  TLIB (смотрите Главу 7
"Утилиты",  в Руководстве пользователя  для  изучения  способа
создания библиотек).
     Есть еще преимущества в модулировании классов;  Вы можете
распределить Ваши классы в объектной форме для других програм-
мистов. Другие программисты могут порождать новые, специализи-
рованные классы из классов,  которые Вы разработали, не требуя
доступа  к Вашей исходной программе.  Даже хотя версия 2.0 С++
достаточно  нова,  уже  появляется  третья  партия   библиотек
классов,  и Вы можете ожидать,  что Ваши собратья программисты
на С++ будут предлагать гораздо больше "сладостей", чем Вы мо-
жете  использовать  для  получения руководящего старта в Ваших
программных проектах.
     Вы можете теперь разработать отдельно компилируемый  "мо-
дуль", содержащий классы Location и Point. Во-первых, объявле-
ния для двух классов (включая их функции  элементов),  опреде-
ленные ранее, помещаются в файл point.h (на Ваших дистрибутив-
ных дискетах).
     Снова обратите внимание на то,  как класс Point  порожда-
ется из класса Location:
     class Point : public Location { ...
     Ключевое слово   public   требуется  перед  Location  для
обеспечения того,  чтобы функции элементов порожденного класса
Point могли иметь доступ к protected элементам X и Y в базовом
классе Location. В дополнение к элементам позиции X и Y, Point
наследует  функции  элементов  GetX и GetY из Location.  Класс
Point также добавляет protected элемент данных Visible  (пере-
числимого  типа Boolean) и пять функций элементов типа public,
включая  констрактор  Point::Point.  Заметьте  снова,  что  мы
использовали  protected,  а не доступ private для определенных
элементов,  так чтобы point.h мог  быть  использован  в  более
поздних примерах, которые будут использовать новые классы, по-
рожденные из Location и Point.
     Файл POINT2.CPP содержит  определения  для  всех  функций
элементов этих двух классов:
     Примечание. Эта программа доступна под именем POINT2.CPP
/* POINT2.CPP--Пример из Главы 4 Начального руководства */

// POINT2.CPP содержит определения для Point и Location
// классов, которые объявлены в файле point.h

#include "point.h"
#include <graphics.h>

// функции элементов для класса Location
Location::Location(int InitX, int InitY) {
   X = InitX;
   Y = InitY;
};

int Location::GetX(void) {
   return X;
};

int Location::GetY(void) {
   return Y;
};

// функции элементов для класса Point: предполагается, что
// главная программа инициализировала графическую систему

Point::Point(int InitX, int InitY) : Location(InitX,InitY) {
   Visible = false;       // сделать невидимой по умолчанию
};

void Point::Show(void) {
   Visible = true;
   putpixel(X, Y, getcolor());  //использует цвет по умолчанию
};

void Point::Hide(void) {
   Visible = false;
   putpixel(X, Y,  getbkcolor());  // использует фоновый цвет
                                   // для гашения пиксела
};

Boolean Point::IsVisible(void) {
   return Visible;
};

void Point::MoveTo(int NewX, int NewY) {
   Hide();         // сделать текущую точку невидимой
   X = NewX;       // изменить X и Y координаты для новой
                   // позиции
   Y = NewY;
   Show();         // высветить точку в новой позиции
};
     Примечание. Базовый  констрактор активизируется перед те-
лом констрактора порожденного класса.
     Этот пример вводит важную концепцию констракторов базово-
го класса. Когда определяется объект Point, мы хотим использо-
вать тот факт,  что его базовый класс Location уже имеет  свой
собственный определенный пользователем констактор. Определение
констрактора Point::Point начинается с двоеточия и  ссылки  на
базовый констрактор Location(InitX,  InitY). Это означает, что
констрактор Point будет сперва вызывать констрактор Location с
аргументами InitX и InitY, посредством чего создаются и иници-
ализируются элементы данных X и Y.  Затем активизируется  тело
констрактора  Point,  создавая  и инициализируя элемент данных
Visible.  Благодаря точному указанию базового констрактора, мы
сами несколько сократили объем кодирования (конечно, в больших
примерах объем сохранения может быть более значительным).
     Фактически, констракторы порожденного класса всегда вызы-
вают  первым констрактор базового класса для обеспечения того,
чтобы наследуемые элементы данных точно создавались и  инициа-
лизировались.  Если базовый класс сам является порожденным, то
процесс вызова базовых констракторов продолжается по  иерархии
вниз.  Если  Вы  не  определили  констрактор для определенного
класса Х,  то С++ будет генерировать по умолчанию  констрактор
формы Х::Х(); то есть, констрактор без аргументов.
     Если констрактор порожденного класса не активизирует точ-
но один из констракторов своего базового класса,  или если  Вы
не определили констрактор базового класса,  то определяемый по
умолчанию констрактор базового класса (без  аргументов)  будет
активизироваться.  Более подробную информацию по констракторам
базового класса Вы можете найти в Главе 3 "  C++"  Руководства
программиста.
     Заметим, что   ссылка   на  констрактор  базового  класса
Location(InitX, InitY) появляется в определении, а не в объяв-
лении констрактора порожденного класса.
     Здесь представлена  главная программа (имеющаяся на Ваших
дистрибутивных дискетах под именем PIXEL.CPP  ),  которая  де-
монстрирует возможности классов Point и Location.
     Примечание. Вам необходимо откомпилировать и скомпоновать
POINT2.CPP,  PIXEL.CPP,  GRAPHICS.LIB,  используя файл проекта
PIXEL.PRJ поставляемый на Ваших дистрибутивных  дискетах  (чи-
тайте  Главу  4  "Управление многофайловыми проектами" в Руко-
водстве пользователя, если Вы не знаете как использовать файлы
проекта.
/* PIXEL.CPP--Пример из Главы 4 Начального руководства */

// PIXEL.CPP демонстрирует Point и Location классы
// Компилировать с POINT2.CPP и связать с GRAPHICS.LIB

#include <graphics.h>   // объявления для графической
                        // библиотеки
#include <conio.h>      // для функции getch()
#include "point.h"      // объявления для Point и Location
                        // классов

int main()
{
   // инициализировать графическую систему
   int graphdriver = DETECT, graphmode;
   initgraph(&graphdriver, &graphmode, "с:..\\bgi");

   // перемещать точку по экрану
   Point APoint(100, 50);   // Начальные X, Y в точке 100, 50
   APoint.Show();           // APoint высвечивает точку
   getch();                 // Ждать нажатие клавиши
   APoint.MoveTo(300, 150); // APoint перемещается в точку
                            // 300,150
   getch();                 // Ждать нажатие клавиши
   APoint.Hide();           // APoint высвечивает точку
   getch();                 // Ждать нажатие клавиши
   closegraph();            // Восстановить первоначальный
                            // экран
   return 0;
}

                     Расширяющиеся классы

     Одним из преимуществ классов является способ, по которому
новые  объекты могут приспосабливаться к классу и давать соот-
ветствующие функциональные возможности. Следующий пример берет
уже  определенные  классы  Location  и Point и порождает новый
класс Circle вместе с функциями для показа,  скрытия, расшире-
ния, перемещения и сжатия окружностей.
     Примечание. Это код CIRCLE.CPP на Ваших дисках.
/* CIRCLE.CPP--Пример из Главы 4 Начального руководства */

// CIRCLE.CPP  Класс Circle порожден из Point

#include <graphics.h>    // объявления графической библиотеки
#include "point.h"       // объявления Location и Point класса
#include <conio.h>       // для функции getch()

// связать с point2.obj и graphics.lib

class Circle : Point {   // порожден частично из класса Point
 // и из класса Location
   int Radius;           // private по умолчанию

public:
   Circle(int InitX, int InitY, int InitRadius);
   void Show(void);
   void Hide(void);
   void Expand(int ExpandBy);
   void MoveTo(int NewX, int NewY);
   void Contract(int ContractBy);
};

Circle::Circle(int InitX, int InitY, int InitRadius) :
Point(InitX,InitY)
{
   Radius = InitRadius;
};

void Circle::Show(void)
{
   Visible = true;
   circle(X, Y, Radius);      // рисует окружность
}

void Circle::Hide(void)
{
   unsigned int TempColor;    // сохранить текущий цвет
   TempColor = getcolor();    // установить в текущий цвет
   setcolor(getbkcolor());    // установить фоновый цвет
                              // изображения
   Visible = false;
   circle(X, Y, Radius);      // нарисовать фоновым цветом для
                              // удаления
   setcolor(TempColor);     // установить обратно текущий цвет
};

void Circle::Expand(int ExpandBy)
{
   Hide();                    // удалить предыдущую окружность
   Radius += ExpandBy;           // увеличить радиус
   if (Radius < 0)               // устранение отрицательного
      Radius = 0;                // радиуса
   Show();                      // нарисовать новую окружность
};

void Circle::Contract(int ContractBy)
{
   Expand(-ContractBy);   //перерисовать с (Radius-ContractBy)
};

void Circle::MoveTo(int NewX, int NewY)
{
   Hide();                    // удалить старую окружность
   X = NewX;                  // установить новую позицию
   Y = NewY;
   Show();                    // нарисовать в новой позиции
};

main()                        // проверить функции
{
   // инициализировать графическую систему
   int graphdriver = DETECT, graphmode;
   initgraph(&graphdriver, &graphmode, "с:..\\bgi");

   Circle MyCircle(100, 200, 50);  // объявить объект circle
   MyCircle.Show();                // показать его
   getch();                        // ждать нажатия клавиши
   MyCircle.MoveTo(200, 250);      // передвинуть окружность
                              // (проверяет также hide и show)
   getch();
   MyCircle.Expand(50);             // увеличить окружность
   getch();
   MyCircle.Contract(75);           // уменьшить окружность
   getch();
   closegraph();
   return 0;
}
     Для того,  чтобы увидеть  как  это  работает  для  класса
Circle,  Вам необходимо исследовать функции элементов в распе-
чатке CIRCLE.CPP и вспомнить объявления класса в point.h.
     Сначала заметим,  что функции  элементов  Circle  требуют
доступ к различным элементам данных в классах Circle,  Point и
Location. Рассмотрим Circle::Expand. Она требует доступа к int
Radius. Нет проблем. Радиус определяется как private (по умол-
чанию) в самом Circle.  Поэтому, Radius является доступным для
Circle :: Expand - действительно, он доступен только для функ-
ций элементов Circle.  (Позже Вы увидите, что private элементы
класса  также могут быть доступными для функций,  которые были
специально определены как friends этого класса.)
     Далее, рассмотрим  функцию  элементов  Circle::Hide.  Она
требует  доступа  к  Boolean Visible из своего базового класса
Point.  В данном примере  Visible  имеет  protected  доступ  в
Point,  а Circle порождается с доступом private (по умолчанию)
из Point.  Поэтому,  по ранее изложенным в общих чертах прави-
лам, Visible имеет доступ private в пределах Circle и доступна
также как Radius.  Заметим,  что если Visible определялась как
private  в  Point,  то она не должна быть доступна для функций
элементов  Circle.  Поэтому  мы  можем  соблазниться   сделать
Visible  public.  Однако это сверхубийственно:  Visible в этом
случае становится доступной функциям,  не являющимся функциями
элементов.  Вы  можете  сказать,  что  protected  -  это  есть
private,  с оттенком public для порожденных  классов:  функции
элементов  порожденных  классов  могут иметь доступ к элементу
protected,  поэтому нет необходимости неправильно  употреблять
доступ public.
     И, наконец, рассмотрим Circle::Show. Circle::Show требует
доступа к элементам Location X и Y для того,  чтобы нарисовать
окружность.  Как  это достигается ?  Circle не порождается не-
посредственно из Location,  поэтому права доступа не  являются
непосредственно очевидными. Circle порождается из Point, кото-
рый порождается  из  Location.  Давайте  проследим  объявления
доступа.
     1. Элементы X и Y объявляются protected в Location.
     2. Point определяет порождение public из Location, поэто-
        му Point также наследует элементы X и Y как protected.
     3. Circle порождается из Point, используя определяемое по
        умолчанию порождение private.
     4. Поэтому   Circle   наследует   X   и  Y  как  private.
        Circle::Show может получать доступ к X и Y.  Заметьте,
        что  X  и  Y  все  еще  являются  protected в пределах
        Location.
     Освоив эту цепь прав доступа, Вы можете пожелать рассмот-
реть  ситуацию,  когда  порожденный  класс  Circle,  такой как
PieChart или Arc необходим.  Да,  Вам понадобится изменить по-
рождение Circle из Point - оно должно стать порождением public
и Radius должен стать protected.
     Теперь легко понять , что происходит в CIRCLE.CPP. Окруж-
ность,  в известном смысле,  является жирной точкой. Она имеет
все,  что имеет точка (позицию в X,Y  и  видимое  /  невидимое
состояние), плюс радиус. По-видимому, класс Circle появляется,
чтобы иметь только отдельный элемент Radius,  однако не  забы-
вайте  обо всех элементах,  которые наследует Circle,  являясь
классом,  порожденным из Point.  Circle  имеет  X,Y,  а  также
Visible,  даже  если  Вы не видите их в определении класса для
Circle.
     Откомпилируйте и  скомпонуйте   CIRCLE.CPP,POINT2.CPP   и
GRAPHICS. LIB. Файл проекта CIRCLE.PRJ на Ваших дистрибутивных
дискетах поможет Вам сделать это. Когда Вы нажмете клавишу, Вы
должны увидеть окружность.  Нажмите клавишу снова и окружность
переместится.  Нажмите снова и окружность  расширится,  а  при
следующем нажатии - сожмется.

                  Многократное наследование

     Как мы уже упоминали ранее, класс может наследовать более
чем  из  одного  базового класса.  Этот механизм многократного
наследования был одной из основных особенностей, добавленных к
С++  версии  2.0.  Для того чтобы увидеть практический пример,
следующая программа позволит  Вам  вывести  на  дисплей  текст
внутри окружности.
     Вашей первой мыслью может быть :  просто добавить строко-
вый элемент данных к классу  Circle,  а  затем  добавить  коды
Circle::Show,  так  чтобы  он  вывел на дисплей текст с окруж-
ностью,  нарисованной вокруг него.  Однако текст и  окружности
действительно достаточно различные объекты. Когда Вы думаете о
тексте,  Вы думаете о шрифтах,  размере символа  и,  возможно,
других атрибутах, ни один из которых не имеет никакого отноше-
ния к окружностям.  Конечно, Вы не можете породить новый класс
непосредственно  из  Circle  и дать ему текстовые возможности.
Однако,  при рассмотрении фундаментально отличающихся функцио-
нальностей,  часто лучше создать новые "фундаментальные" базо-
вые классы,  а затем породить специализированные классы, кото-
рые комбинируют соответствующие особенности.
     Следующая распечатка  MCIRCLE.CPP  иллюстрирует этот под-
ход.  Мы определили новый класс,  названный GMessage,  который
выводит на дисплей строку, начинающуюся в точке с определенны-
ми координатами  X  и  Y.  Этот  класс  будет  другим  предком
MCircle.  MCircle будет наследовать GMessage::Show и использо-
вать его для изображения текста.  Соотношения всех этих вовле-
каемых классов показаны на следующем рисунке.

            Рисунок 4.3 Многократное наследование
                        ┌──────────────────┐
                        │class Location: { │
                        │int X;            │
                        │int Y;            │
                        │...               │
                        │}                 │
                        └────────┬─────────┘
               ┌─────────────────┴──────────────┐
  ┌────────────┴────────────┐   ┌───────────────┴────────────┐
  │class Point : Location { │   │class GMessage : Location { │
  │int Visible;             │   │char *msg;                  │
  │...                      │   │int Font;                   │
  │}                        │   │int Field;                  │
  │                         │   │}                           │
  └────────────┬────────────┘   └───────────────┬────────────┘
  ┌────────────┴────────────┐                   │
  │class Circle : Point {   │                   │
  │int Radius;              │                   │
  │...                      │                   │
  │}                        │                   │
  └────────────┬────────────┘                   │
               └───────────────┬────────────────┘
               ┌───────────────┴─────────────────────┐
               │class MCircle : Circle, GMessage {   │
               │...                                  │
               │}                                    │
               └─────────────────────────────────────┘
     Примечание. Этот код MCIRCLE.CPP имеется на Ваших дисках.
Вы можете прогнать его, используя MCIRCLE.PRJ.
/* MCIRCLE.CPP--Пример из Главы 4 Начального руководства. */

// MCIRCLE.CPP  Иллюстрирует многократное наследование

#include <graphics.h> // Объявления графической библиотеки
#include "point.h"    // Объявления Location и Point классов
#include <string.h>   // для строковых функций
#include <conio.h>    // для консоли I/O

// связать с point2.obj и graphics.lib

// Иерархия классов:
// Location->Point->Circle
// (Circle and CMessage)->MCircle

class Circle  :  public  Point  {  // Порожден из класса Point
                          // и окончательно из класса Location
protected:
   int Radius;
public:
   Circle(int InitX, int InitY, int InitRadius);
   void Show(void);
};


class GMessage : public Location {
// вывести сообщение на графический экран
   char *msg;             // сообщение, которое будет выведено
                            // на экран
   int Font;                // используемый BGI шрифт
   int Field;               // размер поля для масштабирования
                            // текста

public:
   // Инициализировать сообщение
   GMessage(int msgX, int msgY, int MsgFont, int FieldSize,
            char *text);
   void Show(void);         // показать сообщение
};


class MCircle : Circle, GMessage {  //породить из двух классов
public:
   MCircle(int mcircX, int mcircY, int mcircRadius, int Font,
           char *msg);
   void Show(void);         //показать окружность с сообщением
};


// Функции элементов для класса Circle

//Circle констрактор
Circle::Circle(int InitX, int InitY, int InitRadius) :
        Point (InitX, InitY)       //инициализация порожденных
                                   //элементов
// включает также Location констрактор
{
   Radius = InitRadius;
};

void Circle::Show(void)
{
   Visible = true;
   circle(X, Y, Radius); // нарисовать окружность
}

// Функции элементов для класса GMessage

//GMessage констрактор
GMessage::GMessage(int msgX, int msgY, int MsgFont,
   int FieldSize, char *text) :
   Location(msgX, msgY)
//X и Y координаты для центрирования сообщения
{
   Font = MsgFont;    // стандартные шрифты, определенные в
                      // graph.h
   Field = FieldSize; // ширина области, в которую будет
   msg = text;        // выведено сообщение
};

void GMessage::Show(void)
{
   int size = Field / (8 * strlen(msg));     // 8 пикселов для
                                             // символа.
   settextjustify(CENTER_TEXT, CENTER_TEXT); // центр в
                                             // окружности
   settextstyle(Font, HORIZ_DIR,  size);  // если размер > 1,
                                          // то увеличивает
   outtextxy(X, Y, msg);                  // вывести текст
}

// Функции элементов для класса MCircle

// MCircle констрактор
MCircle::MCircle(int mcircX, int mcircY, int mcircRadius,
                int Font, char *msg) : Circle (mcircX, mcircY,
                mcircRadius), GMessage(mcircX,mcircY,Font,
                2*mcircRadius,msg)
{
}

void MCircle::Show(void)
{
   Circle::Show();
   GMessage::Show();
}

main()      //рисует несколько окружностей с текстом
{
   int graphdriver = DETECT, graphmode;
   initgraph(&graphdriver, &graphmode, "..\\bgi");
   MCircle Small(250, 100, 25, SANS_SERIF_FONT, "You");
   Small.Show();
   MCircle Medium(250, 150, 100, TRIPLEX_FONT, "World");
   Medium.Show();
   MCircle Large(250, 250, 225, GOTHIC_FONT, "Universe");
   Large.Show();
   getch();
   closegraph();
   return 0;
}
     Когда Вы  прочитаете  распечатку,  проверьте   объявление
классов  и  обратите  внимание на то,  какие элементы данных и
функции элементов наследуются каждым классом.  Вы также можете
снова  пожелать просмотреть point.h,  так как там определяются
классы Location и Point.  Заметим,  что  как  MCircle,  так  и
GMessage  имеют  Location  в  качестве  их  основного базового
класса: MCircle через Point и Circle и GMessage непосредствен-
но.
     Примечание. Оператор   ::  используется  для  определения
функции из другой области действия,  а не использует (по умол-
чанию) функцию с таким же именем из текущей области действия.
     В теле  определения MCircle::Show,  Вы увидите два вызова
функции Circle::Show();  и GMessage::Show();.  Этот  синтаксис
показывает другое общее использование оператора ::  (оператора
разрешения области действия).  Когда Вы желаете вызвать насле-
дованную функцию, такую как Show, компилятор может потребовать
некоторую помощь:  какая функция show требуется?  Без "отмены"
разрешения области действия, Show() должна ссылаться на Show()
в текущей области действия,  а именно MCircle::Show(). Для то-
го,  чтобы  вызвать  Show()  другой  области действия (конечно
предполагая,  что Вы имеете разрешение на доступ),  Вы  должны
поставить соответствующее имя класса перед оператором ::, а за
ним имя функции (с аргументами,  если таковые есть). Как быть,
если  Вы  хотите вызвать функцию Show,  не являющуюся функцией
элементов?  Вы должны использовать ::Show без  предшествующего
имени класса.
     Примечание. Вы найдете более подробное описание того, как
С++ управляет областью действия в Главе 3 " C++" в Руководстве
программиста.
     Функция элементов  с  данным  именем в порожденном классе
отменяет функцию элементов с тем же  самым  именем  в  базовом
классе,  однако  ее  можно  получить посредством использования
оператора ::. Правила области действия для С++ мало отличаются
от этих правил для С.
     Прежде чем расстаться  с  MCIRCLE.CPP,  кратко  скажем  о
констракторе  для  MCircle.  Вы ранее видели,  как констрактор
Point точно активизирует свой базовый констрактор в  Location.
Так  как  MCircle наследует как из Circle,  так и из GMessage,
констрактор   MCircle    может    удобно    инициализироваться
посредством вызова обеих базовых констракторов :
     MCircle::MCircle
        (int mcircX,  int  mcircY, int  mcircRadius, int font,
        char *msg) : Circle(mcircX, mcircY, mcircRadius),
        GMessage(mcircX, mcircY, 2*mcircRadius, msg) {
     }
     Тело констрактора в данном случае пустое,  потому что вся
необходимая работа выполняется в списке элементов  инициализа-
ции (после оператора :  Вы вводите список инициализирующих вы-
ражений,  отделенных  запятыми.  Вы  встречали  более  простую
версию  этого  синтаксиса  в  отдельных констракторах базового
класса,  используемых в определениях классов Point и  Circle).
Когда    констрактор    MCircle    активизируется   (например,
посредством объявления  объекта  MCircle)  достаточно  большой
объем операций выполняется за кулисами.
     Примечание. Смотрите  Главу  3 " C++" в Руководстве прог-
раммиста  для  лучшего  понимания  последовательности   вызова
констракторов.
     Вначале вызывается   констрактор   Circle.   Затем   этот
констрактор вызывает констрактор Point,  который,  в свою оче-
редь,  вызывает констрактор Location.  И,  наконец, вызывается
констрактор GMessage,  который вызывает  констрактор  Location
для получения копий X и Y из базового класса.  Аргументы,  за-
данные в констракторе MCircle,  передаются для инициализирова-
ния соответствующих элементов данных базовых классов.
     Когда вызываются дестракторы (например,  когда объект вы-
ходит из области действия), то последовательность освобождения
памяти является обратной той,  которая использовалась во время
вызова констракторов.(Виртуальные констракторы базового класса
и  дестракторы имеют некоторые особенности в организации такой
последовательности, которые находятся за пределами компетенции
этой главы).
     Между прочим,  вспомните сделанное ранее замечание:  если
Вы не определили собственные констракторы или дестракторы  С++
будет  скрытым  образом  генерировать и активизировать версии,
определяемые по умолчанию.

                     Виртуальные функции

     Каждый тип  класса в вашей графической иерархии представ-
ляет различный тип фигур на экране:  точка или окружность. Оп-
ределенно есть смысл сказать,  что Вы можете показать точку на
экране или показать  окружность.  Позже,  если  Вы  определили
классы для представления других фигур,  таких как линии, квад-
раты,  дуги и т.д.,  Вы можете написать функцию элементов  для
каждого класса, которая должна выводить такой объект на экран.
В терминах нового способа мышления,  ориентированного на  объ-
ект,  Вы можете сказать, что все эти типы графического рисунка
имеют возможность показывать себя на экране.
     Что является различным для каждого типа объекта,  так это
способ,  с помощью которого он должен показывать себя на экра-
не.  Точка, изображается с помощью программы построения точки,
которой требуется только положение X,Y и,  возможно,  значение
цвета.  Для выведения на  экран  окружности  необходима  более
сложная  графическая  программа,  принимающая  во  внимание не
только X и Y,  но также и радиус. Еще дальше, дуга требует на-
чального  и конечного угла и определенного алгоритма изображе-
ния.  Конечно,  та же самая ситуация применяется для  скрытия,
сдвига и других основных манипуляций формами.
     Обычные функции элементов,  которые Вы видели до сих пор,
определенно позволяют нам определить функцию Show для  каждого
класса   формы.  Однако  они  испытывают  недостаток  основной
составной части.  Графические модули,  основанные на наших су-
ществующих классах и функциях элементов,  должны требовать из-
менений и перекомпиляций исходного кода каждый раз, когда вво-
дится  новый класс формы со своей собственной функцией элемен-
тов Show. Причина в том, что рассмотренные до сих пор механиз-
мы С++ допускают обычно только три способа для разрешения воп-
роса: какая функция Show должна использоваться?
     1. Существует различие благодаря списку аргументов - нап-
        ример,  Show(int, char) не является той же самой функ-
        цией, что и Show(char*, float).
     2. Можно   использовать   оператор   разрешения   области
        действия,  посредством  которого Circle::Show различа-
        ется от Point::Show и :: Show.
     3. Существует разрешение посредством объекта  класса:
        ACircle.Show активизирует   Circle::Show,   тогда  как
        APoint.Show активизирует Point::Show.  Сходным образом
        с указателями на объекты:  APoint_pointer Ў Show акти-
        визирует Point::Show.
     Все эти функциональные разрешения до сих пор  выполнялись
во время компилирования - механизм,  который называется ранним
или статическим связыванием.
     Типичный графический  инструментарий  должен   обеспечить
пользователя  определениями класса в .Н исходных файлах наряду
с предварительно откомпилированным .OBJ или  .LIB  кодами  для
функций элементов. Из-за ограничений раннего связывания, поль-
зователь не может легко прибавить новые классы фигур,  и  даже
разработчик сталкивается с дополнительной работой при расшире-
нии пакета.  С++ предлагает гибкий механизм для  решения  этих
проблем:  позднее  (или  динамическое)  связывание посредством
специальных функций элементов, названных виртуальными функция-
ми.
     Ключевая концепция такова, что вызовы виртуальных функций
разрешаются во время выполнения (отсюда термин позднее  связы-
вание).  В  практических  условиях это означает,  что решение,
касающееся того,  какую функцию Show вызывать,  может отклады-
ваться  до  тех  пор,  пока не станет известен используемый во
время выполнения тип объекта.  Виртуальная функция Show "спря-
танная"  в классе В в предварительно откомпилированной библио-
теке инструментальных средств не связывается с объектами В та-
ким  же способом,  как обычно связываются функции элементов В.
Вы свободно можете создать класс D, порожденный из В для Вашей
собственной  избранной фигуры и написать соответствующие функ-
ции (употребляя Вашу функцию Show,  если она есть).  Затем  Вы
компилируете  и компонуете Ваши OBJ или LIB коды в код инстру-
ментальных средств.  Сделанные вызовы Show или из существующих
функций элементов класса В,  или из новых функций,  которые Вы
написали для класса D,  будут автоматически ссылаться на  пра-
вильную функцию Show.  Это разрешение делается всецело по типу
объекта, используемого в вызове. Теперь посмотрим на виртуаль-
ные  функции  в действии.  Мы имеем потенциального кандидата в
ранее приведенном коде, данном для CIRCLE.CPP.

                Виртуальные функции в действии

     Рассмотрим функцию элементов Circle::MoveTo в CIRCLE.CPP :
     void Circle::MoveTo(int NewX, int NewY)
     {
        Boolean vis = Visible;
        if (vis) Hide();  //маскирует только если объект видим
        X = NewX; Y = NewY; //устанавливает новое положение
        if (vis) Show();  //изображает в новом положении, если
                            //ранее объект был видим
     }
     Заметим, как  сходно  это  определяется  с Point::MoveTo,
приведенном в базовом классе  Circle  для  Point.  Фактически,
возвращаемое  значение,  имя функции,  число и типы формальных
аргументов (известные как сигнатура назначения)  и  даже  само
тело функции,  по-видимому, все являются идентичными! Если С++
встречается с двумя вызовами функций, использующих одно и тоже
имя функции, но отличающихся сигнатурами, то мы уже знаем, что
в таком случае компилятор С++ является достаточно разумным для
решения потенциальных двусмысленностей,  вызванных перекрытием
имен функций.  (Напомним, что С в отличие от С++, требует уни-
кальных имен функций).  В С++,  функции элементов с различными
сигнатурами действительно являются различными функциями,  даже
если они совместно владеют одним и тем же именем.
     Однако, наши две функции MoveTо не предлагают,  на первый
взгляд,  для компилятора каких-либо отличных ключей к разгадке
- а потому,  как он узнает,  какую из функций Вы намереваетесь
вызвать?  Ответ, как Вы видели, в том, что для обычных функций
элементов компилятор определяет целевую функцию из типа класса
объекта, используемого в вызове.
     Поэтому, почему бы не позволить Circle наследовать MoveTo
Point,  точно  также  как  Circle наследует GetX и GetY класса
Point (через Location)?  Причина заключается в том, что Hide и
Show вызванные в Circle::MoveTo не являются такими же как Hide
и Show,  вызванные в Point::MoveTo.  Только имена и  сигнатуры
являются  теми же самыми.  Наследование MoveTo из Point должно
привести к неправильным Hide и Show,  вызываемым  при  попытке
переместить окружность.  Почему?  Потому что версии Point этих
двух функций должны быть  связаны  с  функцией  MoveTo  класса
Point  (и  следовательно,  также с Circle) во время компиляции
(раннее связывание).  Как Вы уже можете предположить,  ответом
является  объявление  Hide и Show в качестве виртуальных функ-
ций.  Это будет задерживать  связывание,  так  что  правильные
версии Hide и Show могут активизироваться, когда действительно
вызывается MoveTo для смещения точки или окружности  (или  еще
чего-нибудь).
     Опять обратите внимание на то, что если мы желаем предва-
рительно откомпилировать наши определения  классов  и  функции
элементов  для Location,  Point и Circle в стройной автономной
библиотеке (с источником выполнения,  заблокированным для дру-
гих наших профессиональных секретов),  мы определенно не знаем
заранее объекты,  которые MoveTo может запрашивать для  смеще-
ния.  Виртуальные  функции  не  только обеспечивают это техни-
ческое преимущество;  они  также  обеспечивают  концептуальные
достижения,  которые находятся в основе ООП. Мы можем концент-
рироваться  на  разработке  классов  и  методов  многократного
использования не беспокоясь о конфликте на уровне имен.
     Хотя расширения  дополнительной  библиотеки  доступны для
большинства языков,  использование виртуальных функций и  мно-
гократного  наследования  в  С++  делает  расширяемость  более
естесственной.  Вы наследуете  все,  что  имеют  Ваши  базовые
классы ,  а затем Вы добавляете новые возможности, которые Вам
необходимы для того,  чтобы заставить новые  объекты  работать
знакомыми способами.
     Классы, которые Вы определяете и  их  версии  виртуальных
функций становятся истинным расширением упорядоченной иерархии
возможностей.  Так как это является частью проекта языка, а не
мыслью,   пришедшей  слишком  поздно,  существует  очень  мало
взысканий к качеству выполнения.
     Узнав о достоинствах виртуальных функций, давайте посмот-
рим как Вы можете реализовать их, а также рассмотрим некоторые
правила, которым Вы должны следовать.

                  Определение виртуальных функций

     Синтаксис является   открытым:   добавьте   классификатор
virtual в первое объявление функции элементов:
     virtual void Show();
     virtual void Hide();
     Важно! Только функции  элементов  могут  объявляться  как
virtual. Когда функция объявляется virtual, она не должна пов-
торно объявляться в любом порожденном классе с  тем  же  самым
списком  формальных  аргументов и тем же самым типом возврата.
Если Вы повторно объявите Show с тем же самым списком формаль-
ных  аргументов и тем же типом возврата,  новая Show автомати-
чески станет виртуальной независимо  от  того  используете  Вы
классификатор virtual или нет.  Это означает, что новая вирту-
альная функция Show отменяет Show в ее базовом классе.
     Вы можете объявлять Show с другим списком формальных  ар-
гументов  (независимо от того изменяете ли Вы тип возврата или
нет) - однако виртуальный механизм является недействующим  для
этой версии Show.
     Начинающие программисты должны избегать безрассудного пе-
рекрытия - существуют ситуации,  где невиртуальная функция мо-
жет скрыть  виртуальную  функцию,  объявленную  в  ее  базовом
классе.
     Определенная вызванная функция Show будет зависеть только
от класса объекта, для которого активизируется Show, даже если
вызов  активизируется  через указатель (или ссылку) на базовый
класс. Например,
  Circle ACircle;
  Point* APoint_pointer = &ACircle;  //указатель на Circle
                                     //присваиваемый указателю
                                     //на базовый класс Point
  APoint_pointer->Show();            //вызывает  Circle::Show!

     vpoint.h и VCIRC.CPP (находящиеся на Ваших дистрибутивных
дискетах) являются версиями point.h и CIRCLE.CPP  с  функциями
Show и Hide, сделанными виртуальными. Откомпилируйте VCIRC.CPP
с POINT2.  CPP,  используя VCIRC.PRJ.  Программа будет  прого-
няться точно также как CIRCLE.CPP. Мы не будем здесь полностью
перечислять виртуальные версии,  так как различия  могут  быть
суммированы следующим образом:
     - В  vpoint.h,  функции Show и Hide класса Point объявля-
ются с помощью ключевого слова virtual.  Show и Hide в  порож-
денном  классе Circle из файла VCIRC имеют тот же самый список
аргументов и значения возврата,  как  и  у  базовых  версий  в
Point; это подразумевает, что они также виртуальные, даже если
не используется ключевое слово virtual в их объявлениях.
     - В VCIRC.CPP Circle больше не  имеет  своей  собственной
функции элементов MoveTo.
     - Теперь  мы частично порождаем Circle из Point для того,
чтобы получить доступ к МоvеТо.
     Суммируем значимость  этих  изменений:
     Объекты Circle могут  теперь  безопасно  вызвать  MoveTo,
наследуемую  из Point.  Show и Hide,  вызванные MoveTo,  будут
связаны во время  выполнения  с  Show  и  Hide  принадлежащими
Circle.  Любые объекты Point, вызывающие MoveTo, будут активи-
зировать версии Point.

            Разработка полного графического модуля

     В качестве  более полного и реального примера виртуальных
функций давайте создадим модуль,  который определяет некоторые
классы  фигур  и  обобщенные способы их перемещения по экрану.
Этот модуль figures.h и FIGURES.CPP (на  Ваших  дистрибутивных
дискетах)  является простой реализацией графических инструмен-
тальных средств, которые обсуждались ранее.
     Основной целью при конструировании модуля  FIGURES  явля-
ется  предоставление пользователям модуля возможности расшире-
ния классов,  определенных в модуле - а также использовать все
возможности  модуля.  Создание  некоторых способов перемещения
произвольного графического рисунка по экрану в ответ  на  ввод
пользователя представляет собой интересную задачу.
     В качестве первого подхода, мы можем рассмотреть функцию,
которая принимает объект как аргумент,  а затем перемещает та-
кой объект по экрану:
     void Drag(Point& AnyFigure, int DragBy)
     {
        int DeltaX, DeltaY;
        int FigureX, FigureY;
        AnyFigure.Show();        //выводит на дисплей рисунок,
                                 //который нужно перемещать
        FigureX = AnyFigure.GetX();   //получает начальные
                                      //положения X,Y рисунка
        FigureY = AnyFigure.GetY();
        // Это цикл для перемещения
        while (GetDelta(DeltaX, DeltaY))
        {
           //Применяет delta к рисунку X, Y
           FigureX = FigureX + (DeltaX * DragBy);
           FigureY = FigureY + (DeltaY * DragBy);
           //И вызывает перемещение рисунка
           AnyFigure.MoveTo(FigureX, FigureY);
        };
     };

                         Типы ссылок

     Обратите внимание на то,  что AnyFigure объявляется  типа
Point&.  Это означает "ссылку на объект типа Point" и является
новой особенностью С++. Как Вы знаете, С обычно передает аргу-
менты посредством значения, а не ссылки. В С, если Вы пожелае-
те воздействовать непосредственно на переменную,  передаваемую
в функцию, Вы должны передать указатель на переменную, что мо-
жет привести к неудобному синтаксису, так как Вы должны не за-
быть  разыменовать  указатель.  С++ позволяет Вам передавать и
модифицировать действительную  переменную,  используя  ссылку.
Для  объявления ссылки просто укажите тип данных с последующим
амперсандом (&) в объявлении переменной.
     Drag вызывает вспомогательную функцию GetDelta,  не пока-
занную здесь,  которая получает некоторые изменения в X и Y от
пользователя.  Оно может задаваться с клавиатуры,  "мышки" или
джойстика.  (С  целью упрощения,  наш пример получает вводимые
данные с помощью клавиш-стрелок на клавиатуре).
     Относительно Drag важно отметить,  что любой объект  типа
Point, или любой тип, порожденный из Point, может передаваться
в аргумент ссылки AnyFigure.  Объекты типа Point  или  Circle,
или любого типа,  определяемого в будущем,  в качестве потомка
Point  или  Circle,  могут  передаваться  без   осложнения   в
AnyFigure.
     Добавляя новую функцию элементов в существующую классовую
иерархию,  необходимо немного задуматься.  В каком месте в ие-
рархии будет помещена функция элемента?  Подумайте об утилите,
снабженной функцией, и решите насколько широко применима такая
утилита.  При перемещении рисунка используются изменения поло-
жения рисунка в ответ на ввод пользователя.  В терминах насле-
дования  Drag  располагается  непосредственно рядом с MoveTo -
любой объект,  для которого соответствует MoveTo, также должен
наследовать  Drag.  Следовательно,  Drag должна быть элементом
Point,  так чтобы все порожденные типы Point  могли  совместно
использовать ее.
     Решив вопрос  о  месте Drag в иерархии,  мы можем поближе
познакомиться с ее определением. Так как Drag является функци-
ей элементов базового класса Point, не возникает необходимости
в точной ссылки на аргумент Point& AnyFigure.  Мы можем  пере-
писать Drag так,  чтобы функции,  которые вызывает Drag, такие
как GetX,  Show, MoveTo и Hide, правильно ссылались на версии,
соответствующие типу перемещаемого объекта.  Как мы видели ра-
нее,  функции Show и Hide, которые требуют специального кода в
зависимости от задаваемой фигуры, могут быть сделаны виртуаль-
ными.  Затем мы можем  переопределить  их  для  любых  будущих
классов  без  разрушения  модуля  FIGURES.  Это также касается
MoveTo,  так как MoveTo вызывает соответствующие Show  и  Hide
(Вы  вспомните,  что была наша оригинальная мотивация для того
чтобы создать виртуальные функции Show и Hide). GetX и GetY не
представляют проблемы: как обычные функции элементов наследуе-
мые из Point через Location,  они просто  возвращают  элементы
данных  X  и Y вызываемого объекта любого порожденного класса,
имеющегося в данный момент или  будущего.  Запомните,  однако,
что X и Y имеют доступ protected в Location, поэтому мы должны
использовать порождение типа public, как показано.
     Следующее кострукторское решение заключается в том,  сде-
лать ли функцию Drag виртуальной. Лакмусовый тест по превраще-
нию любой функции в виртуальную состоит в  ответе  на  вопрос:
ожидается  ли изменение функциональности где-нибудь ниже в ие-
рархии.  Здесь не существует золотого правила, однако позже мы
обсудим различные компромиссы: или расширяемость, или непроиз-
водительные затраты на выполнение (виртуальные функции требуют
несколько  больше памяти и несколько больше циклов обращения к
памяти). Мы придерживаемся точки зрения, что некоторый будущий
класс, скажем в применении CAD (проектирование с помощью ЭВМ),
может потребовать специального действия для перемещения.  Воз-
можно,  что перемещение изометрического изображения будет тре-
бовать некоторого масштабирования и т.д. В нашем новом опреде-
лении  класса  Point в figures.h,  мы,  следовательно,  делаем
функцию Drag виртуальной.
     Примечание. Напомним,  что  нужно  перекомпилировать все,
что использует файл заголовков.
     class Point : public Location {
     protected:
        Boolean Visible;
     public:
        Point(int InitX, int InitY);
        virtual void Show();           //Show и Hide являются
                                       // виртуальными
        virtual void Hide();
        Boolean IsVisible() {return Visible;}
        void MoveTo(int NewX, int NewY);
        virtual void Drag(int DragBy);
     };
     В данном случае файл заголовков figures.h содержит объяв-
ления классов для модуля FIGURES. Это только часть пакета, ко-
торую необходимо распространять в форме исходного кода:
     Примечание. Код figures.h находится на Ваших дисках.
//  figures.h содержит три класса
//
//  Класс Location описывает позиции на экране в X и Y
//  координатах.
//
//  Класс Point описывает будет ли точка видимой или нет.
//
//  Класс Circle описывает радиус окружности вокруг точки.
//
//  Чтобы использовать этот модуль, поместите #include
//  <figures.h> в Ваш главный исходный файл и откомпилируйте
//  этот файл вместе с исходным файлом FIGURES.CPP

enum Boolean {false, true};

class Location {
protected:
   int X;
   int Y;
public:
   Location(int InitX, int InitY) {X = InitX; Y = InitY;}
   int GetX() {return X;}
   int GetY() {return Y;}
};

class Point : public Location {
protected:
   Boolean Visible;
public:
   Point(int InitX, int InitY);
   virtual void Show();       // Show и Hide виртуальные
   virtual void Hide();
   virtual void Drag(int DragBy); // новая виртуальная функция
                                  // drag
   Boolean IsVisible() {return Visible;}
   void MoveTo(int NewX, int NewY);
};

class Circle : public Point {  // Порожден из класса Point и
                            // окончательно из класса Location
protected:
   int Radius;
public:
   Circle(int InitX, int InitY, int InitRadius);
   void Show();
   void Hide();
   void Expand(int ExpandBy);
   void Contract(int ContractBy);
};

// прототип функции общего назначения, не элементной,
// определен в FIGURES.CPP

Boolean GetDelta(int& DeltaX, int& DeltaY);

     Здесь представлен файл FIGURES.CPP,  содержащий определе-
ния функций элементов.  Это то,  что должно распространяться в
объектной или библиотечной форме коммерческим путем. Заметьте,
что мы определили констрактор Circle вне класса,  так  как  он
активизирует базовые констракторы. Вы можете поэкспериментиро-
вать,  сделав этот констрактор встроенной  функцией  (смотрите
обсуждение дальше).  Функция GetDelta,  не являющаяся функцией
элементов, потребует некоторого обучения, если Вы плохо знако-
мы с С.  Обратите внимание на использование аргументов ссылок,
это является особенностью С++; остальной код является традици-
онным.
     Примечание. Этот  код  находится  на   Ваших   дисках   в
FIGURES.CPP. Вы должны откомпилировать этот код и скомпоновать
его с GRAPHICS.LIB для получения  FIGURES.OBJ.  Вам  необходим
FIGURES.OBJ для следующего упражнения.
// FIGURES.CPP: Этот файл содержит определения для класса
// Point (объявленного в figures.h). Функции элементов для
// класса Location появляются как встроенные функции в
// figures.h.

#include "figures.h"
#include <graphics.h>
#include <conio.h>

// функции элементов для класса Point

//констрактор
Point::Point(int InitX, int InitY) : Location (InitX, InitY)
{
   Visible = false;    // сделать невидимой по умолчанию
}

void Point::Show()
{
   Visible = true;
   putpixel(X, Y, getcolor()); // использует цвет по умолчанию
}

void Point::Hide()
{
   Visible = false;
   putpixel(X, Y, getbkcolor()); // использует фоновый цвет
                                 // для удаления
}

void Point::MoveTo(int NewX, int NewY)
{
   Hide();          // сделать текущую точку невидимой
   X = NewX;        // изменить X и Y координаты
   Y = NewY;
   Show();          // показать точку в новой позиции
}

// функция общего назначения для получения значений
// клавиш движения курсора (это не функция элемента)

Boolean GetDelta(int& DeltaX, int& DeltaY)
{
   char KeyChar;
   Boolean Quit;
   DeltaX = 0;
   DeltaY = 0;

   do
{
      KeyChar = getch();     // читать клавишу
      if (KeyChar == 13)     // возврат каретки
         return(false);
      if (KeyChar == 0)      // расширенный код клавиши
         {
          Quit = true;       // допустимая клавиша
          KeyChar = getch(); //получить оставшийся код клавиши
              switch (KeyChar) {
                 case 72: DeltaY = -1; break; // стрелка вниз
                 case 80: DeltaY =  1; break; // стрелка вверх
                 case 75: DeltaX = -1; break; // стрелка влево
                 case 77: DeltaX =  1; break; //стрелка вправо
                 default: Quit = false; //недопустимая клавиша
                 };
         };
   } while (!Quit);
   return(true);
}

void Point::Drag(int DragBy)
{
   int DeltaX, DeltaY;
   int FigureX, FigureY;

   Show(); //вывести на экран фигуру, которая будет перемещена
     FigureX = GetX(); // получить начальную позицию фигуры
   FigureY = GetY();

   // Это сдвиг в цикле
   while (GetDelta(DeltaX, DeltaY))
{
      // Применить delta к фигуре в X, Y
      FigureX += (DeltaX * DragBy);
      FigureY += (DeltaY * DragBy);
      MoveTo(FigureX, FigureY); // передвинуть фигуру
      };
}
// Функции элементов для класса Circle

//констрактор
Circle::Circle(int InitX, int InitY, int InitRadius) :
Point (InitX, InitY)
{
   Radius = InitRadius;
}

void Circle::Show()
{
   Visible = true;
   circle(X, Y, Radius);     // нарисовать окружность
}

void Circle::Hide()
{
   unsigned int TempColor;   // сохранить текущий цвет
   TempColor = getcolor();   // установить  текущий цвет
   setcolor(getbkcolor());   // установить фоновый цвет
                             // изображения
   Visible = false;
   circle(X, Y, Radius);     // нарисовать в фоновом цвете,
   setcolor(TempColor);     // чтобы восстановить текущий цвет
}

void Circle::Expand(int ExpandBy)
{
   Hide();                       // удалить старую окружность
   Radius += ExpandBy;           // увеличить радиус
   if (Radius < 0)               // если радиус < 0
      Radius = 0;
   Show();                      // нарисовать новую окружность
}

void Circle::Contract(int ContractBy)
{
   Expand(-ContractBy);  // перерисовать с (Radius-ContractBy)
}
     Теперь мы готовы проверить FIGURES посредством  использо-
вания его для нового класса фигур, названного Arc, который оп-
ределяется в  FIGDEMO.CPP.  Arc  (естественно)  порождается  с
доступом public из Circle. Напоминаем, что Drag перемещает фи-
гуру, которой прежде не было!
     Примечание. Этот код находится на Ваших дисках под именем
FIGDEMO.CPP. Вам необходимо откомпилировать и скомпоновать его
с FIGURE.OBJ.
// FIGDEMO.CPP -- Упражнение для Главы 4

// Демонстрирует инструментарий фигур с помощью
// нового типа Arc.

// Связать с FIGURES.OBJ и GRAPHICS.LIB

#include "figures.h"
#include <graphics.h>
#include <conio.h>

class Arc : public Circle {
   int StartAngle;
   int EndAngle;
public:
// констрактор
   Arc(int InitX,int InitY,int InitRadius,int InitStartAngle,
       int InitEndAngle) : Circle (InitX, InitY, InitRadius) {
       StartAngle = InitStartAngle; EndAngle = InitEndAngle;}
   void Show();  // эти функции виртуальные в Point
   void Hide();
};

// Функции элементов для Arc

void Arc::Show()
{
   Visible = true;
   arc(X, Y, StartAngle, EndAngle, Radius);
}

void Arc::Hide()
{
   int TempColor;
   TempColor = getcolor();
   setcolor (getbkcolor());
   Visible = false;
   // нарисовать дугу фоновым цветом, чтобы скрыть ее
   arc(X, Y, StartAngle, EndAngle, Radius);
   setcolor(TempColor);
}

int main()   // проверить новый класс Arc
{
   int graphdriver = DETECT, graphmode;
   initgraph(&graphdriver, &graphmode, "с:..\\bgi");
   Circle ACircle(151, 82, 50);
   Arc AnArc(151, 82, 25, 0, 190);

   // Сначала сдвинуть дугу с помощью клавиш со стрелками
   // (на 5 пикселов при каждом нажатии клавиши)
   // когда устанете - нажмите <Enter>!
   // Теперь сдвинуть окружность
   // (на 10 пикселов при каждом нажатии клавиши со стрелкой)
   // Нажать <Enter> для выхода из FIGDEMO.

   AnArc.Drag(5);   // увеличение сдвига составляет 5 пикселов
   AnArc.Hide();
   ACircle.Drag(10); // теперь каждый сдвиг равен 10 пикселам
   closegraph();
   return 0;
}

          Обычные или виртуальные функции элементов?

     Обычно, из-за того что вызов невиртуальных  функций  эле-
ментов происходит немного быстрее, чем виртуальных функций, мы
рекомендуем использование обычных функций  элементов  пока  не
принимается во внимание расширяемость, а принимается во внима-
ние эффективность. В противном случае, используйте виртуальные
функции.
     Суммируя то,  что  уже было рассмотрено выше,  посоветуем
Вам объявить класс Base,  а в пределах Base  объявить  функцию
элементов  с именем Action.  Как Вы решите,  должна ли функция
Action быть виртуальной или обычной?  Существует правило боль-
шого пальца: делайте Action виртуальной функцией, если сущест-
вует возможность того,  что некоторый будущий класс, порожден-
ный из Base, будет отменять Action и Вы желаете, чтобы будущий
код имел доступ к Base.  Делайте Action обычной функцией, если
очевидно, что для порожденных типов, Action будет выполнять те
же самые пошаговые обработки (даже если это вовлекает  активи-
зирование других виртуальных функций); или порожденные типы не
будут использовать Action.

                     Динамические объекты

     Все приведенные до сих пор примеры, за исключением разме-
щения массива сообщений в MCIRCLE.CPP,  имели статические  или
автоматические  объекты  классовых типов,  которые объявлялись
как обычно и память для  них  распределялась  компилятором  во
время компиляции.  В этом разделе мы рассмотрим объекты, кото-
рые создаются во время выполнения,  а память для них распреде-
ляется из хранилища свободной памяти системы. Создание динами-
ческих объектов - это важный прием для многих прикладных прог-
рамм,  В которых количество данных, которое должно храниться в
памяти,  неизвестно до прогона  программы.  Примером  является
программа  базы данных свободной формы,  которая хранит записи
различной длины в памяти для обеспечения быстрого доступа.
     С++ может использовать С функции динамического  распреде-
ления памяти,  например malloc.  Однако С++ включает несколько
мощных расширений,  которые делают динамическое  размещение  и
освобождение объектов более легким и надежным.  Наиболее важно
то,  что С++ обеспечивает вызов констракторов и  дестракторов.
Например,
     Примечание. Чтобы разместить объект в  свободной  памяти,
объявите  указатель на тип объекта и присвойте результат выра-
жения new тип_объекта указателю.  После этого можно  использо-
вать указатель для ссылок на заново созданный объект.
     Circle *ACircle = new Circle(151,82,50);
     Здесь ACircle - указатель на тип Circle ,  ему присваива-
ется адрес блока памяти достаточно большого для хранения одно-
го объекта типа Circle. Другими словами, ACircle теперь указы-
вает на объект Circle,  размещенный в свободной памяти.  Затем
вызывается констрактор Circle,  чтобы проинициализировать объ-
ект в соответствии с заданными аргументами.
     Если Вы  размещаете  массив,  а не тип данных стандартной
длины, то используйте необязательный синтаксис
     new объект [размер]
     Например, чтобы динамически разместить массив из 50 целых
чисел, называемый counts, используйте
     counts = new int [50];
     Если Вы  хотите создать динамический объект класса Point,
то Вы можете сделать это следующим образом:
     Примечание. Можно   найти   эту  программу  на  дисках  в
DYNPOINT.CPP. Или использовать DYNPOINT.PRJ.
// DPOINT.CPP -- упражнение в Главе 4 Начального руководства

#include <iostream.h>
#include <graphics.h>
#include <conio.h>
#include "figures.h"

int main()
{
// Назначить указатель на динамически размещенный объект;
// вызвать констрактор
Point *APoint = new Point(50, 100);

// инициализировать графическую систему
int graphdriver = DETECT, graphmode;
initgraph(&graphdriver, &graphmode, "..\\bgi");

// Продемонстрировать новый объект
APoint->Show();
cout << "Note pixel at (50,100). Now, hit any key...";
getch();
delete APoint;
closegraph();
return(0);
}

           Дестракторы и оператор delete (удаление)

     Также как можно определить констрактор, который будет вы-
зываться везде, где создается новый объект класса, можно опре-
делить  и дестрактор,  который будет вызываться при разрушении
объекта, т.е. когда его значение очищается и занимаемая им па-
мять освобождается.
     Память для статических объектов размещается компилятором;
констрактор вызывается перед функцией main, а дестрактор вызы-
вается после main.  В случае auto объектов освобождение памяти
происходит, когда кончается область действия объявления (когда
ограниченный блок завершается).  Любой дестрактор,  который Вы
определили, вызывается во время разрушения статических или ав-
томатических объектов.  (Если Вы не определили дестрактор, С++
использует неявный или встроенный дестрактор.)
     Тем не  менее,  если  Вы  создаете  динамический  объект,
используя оператор new, Вы несете ответственность за его осво-
бождение,  т.к. С++ не имеет способа для того, чтобы "узнать",
когда  объект больше не нужен.  Вы используете оператор delete
для освобождения памяти.  Любой дестрактор, который Вы опреде-
лили, вызывается при выполнении delete.
     Оператор delete имеет синтаксис
        delete pointer;
где pointer - это указатель, который используется с оператором
new для размещения памяти.
     Примечание. Более подробная информация,  касающаяся  син-
таксиса  дестрактора,  приведена в Главе 3 " C++ " Руководства
программиста.
     Вы видели,  что констрактор для класса Х идентифицируется
тем же именем Х, а именно Х::Х(). Имя дестрактора для класса Х
- Х::~Х(). Кроме освобождения памяти, дестракторы могут выпол-
нять другие соответствующие действия,  например,  запись полей
элементов данных на диск, закрытие файлов и т.д.

           Пример размещения динамического объекта

     Приведенный ниже  пример программы показывает использова-
ние объекта,  размещенного  динамически  в  свободной  памяти,
включая  использование дестракторов для освобождения объектов.
Эта программа показывает, как можно создать в памяти связанный
список  графических объектов и очистить его,  используя вызовы
delete, когда объекты больше не требуются.
     Построение связанного списка объектов требует, чтобы каж-
дый  объект  содержал  указатель на следующий объект в списке.
Тип Point не содержит такого указателя, наиболее легкий способ
состоит в добавлении к Point указателя,  в этом случае обеспе-
чивается то,  что все типы, порожденные Point, наследуют также
и указатель.  Однако,  добавление чего-нибудь к Point требует,
чтобы у Вас был исходный код для Point,  а как отмечалось  ра-
нее,  одним  из преимуществ С++ является возможность расширить
существующие объекты без необходимости их  перекомпилирования.
Поэтому для этого примера мы будем считать, что исходного кода
для Point нет и покажем, как можно расширить набор графических
средств другим способом.
     Примечание. Смотрите в приведенном ниже листинге объявле-
ния List и Node.
     Одним из многих решений,  которые не требуют изменений  в
Point,  является  создание  нового класса,  не порожденного из
Point.  Тип List - очень простой класс,  чьей  целью  является
формирование списка Point. Так как Point не содержит указателя
на следующий объект в  списке,  то  для  этого  служит  просто
struct  Node.  Node даже проще,  чем List - тем,  что не имеет
функций элементов и не содержит других данных, кроме указателя
на следующий элемент списка и указателя на тип Point.
     List имеет функцию элементов, которая позволяет добавлять
к связанному списку из записей Node новые фигуры, вставляя но-
вый  объект  Node  сразу  после самого себя в качестве объекта
ссылки указателя Nodes.  Функция элементов Add использует ука-
затель  на объект Point,  а не на сам объект Point.  Напомним,
что правила для классовой иерархии в С++ разрешают  передавать
указатели  на  любой  тип,  порожденный  с  доступом public из
Point, в качестве аргумента Item функции List::Add.
     Программа ListDemo объявляет статическую переменную AList
типа  List  и строит связанный список из трех записей.  Каждая
запись указывает на различную графическую фигуру, которая есть
или в Point, или в одном из его порожденных классов. Количест-
во байтов свободной памяти сообщается перед  созданием  любого
динамического объекта, а затем еще раз после того, как все бу-
дет создано.  В конце вся структура, включая три записи Node и
три  объекта Point,  очищаются и удаляются из памяти благодаря
дестрактору для класса  List,  вызываемому  автоматически  для
объекта класса List - AList.
     Примечание. Этот  код  есть  на  Ваших  дисках под именем
LISTDEMO.CPP.
/* LISTDEMO.CPP--Пример из Главы 4 Начального руководства */

// LISTDEMO.CPP  Демонстрирует динамические объекты

// Связать с FIGURES.OBJ и GRAPHICS.LIB

#include <conio.h>          // для getch()
#include <alloc.h>          // для coreleft()
#include <stdlib.h>         // для itoa()
#include <string.h>         // для strcpy()
#include <graphics.h>
#include "figures.h"

class Arc : public Circle {
   int StartAngle, EndAngle;
public:
   // констрактор
   Arc(int InitX, int InitY, int InitRadius,
       int InitStartAngle, int InitEndAngle);
   // виртуальные функции
   void Show();
   void Hide();
};

struct Node {     // элемент списка
   Point *Item;   // может быть Point или любым классом,
                  // порожденным из Point
   Node  *Next;   // указывает на следующий объект Node
};

class List {    //список объектов, указанный посредством nodes
   Node *Nodes;   // указывает на node
public:
   // констрактор
   List();
   // дестрактор
   ~List();
   // добавить объект в список
   void Add(Point *NewItem);
   // просмотреть объекты
   void Report();
};

// определения для автономных функций

void OutTextLn(char *TheText)
{
   outtext(TheText);
   moveto(0, gety() + 12);   // перейти к эквиваленту
                             // следующей строки
}

void MemStatus(char *StatusMessage)
{
   unsigned long MemLeft;  // отметить тип, возвращенный
                           // функцией coreleft()
   char CharString[12];    // временная строка для передачи в
                           // outtext()
   outtext(StatusMessage);
   MemLeft = long (coreleft());

   //преобразование результата в строку с помощью ltoa,а затем
   // копирование его во временную строку
   ltoa(MemLeft, CharString, 10);
   OutTextLn(CharString);
}

// функции элементов для класса Arc

Arc::Arc(int InitX, int InitY, int InitRadius,
         int InitStartAngle, int InitEndAngle) :
         Circle (InitX, InitY,InitRadius)
                              // вызывает констрактор Circle
{
   StartAngle = InitStartAngle;
   EndAngle = InitEndAngle;
}

void Arc::Show()
{
   Visible = true;
   arc(X, Y, StartAngle, EndAngle, Radius);
}

void Arc::Hide()
{
   unsigned TempColor;
   TempColor = getcolor();
   setcolor(getbkcolor());
   Visible = false;
   arc(X, Y, StartAngle, EndAngle, Radius);
   setcolor(TempColor);
}

// функции элементов для класса List

List::List () {
   Node *N;
   N = new Node;
   N->Item = NULL;
   N->Next = NULL;
   Nodes = NULL;       // устанавливает пустой указатель node,
                           // так как в списке пока ничего нет
}

List::~List()              // дестрактор
{
   while (Nodes != NULL) {   // пока не конец списка
      Node *N = Nodes;       // получить указатель на node
      delete(N->Item);  //освободить память, занятую объектами
      Nodes = N->Next;    // ссылка на следующий node
        delete N; // освободить память, занятую указателем
   };
}

void List::Add(Point *NewItem)
{
   Node *N;              // N - указатель на node
   N = new Node;         // создать новый node
   N->Item = NewItem;  // сохранить указатель на объект в node
   N->Next = Nodes;   // следующий объект указывает на текущую
                         // позицию в списке
   Nodes = N;          // теперь последний объект указывает на
                         // этот node
}

void List::Report()
{
   char TempString[12];
   Node *Current = Nodes;
   while (Current != NULL)
   {
      // получить значение X объекта в текущем node и
      // преобразовать в строку
      itoa(Current->Item->GetX(), TempString, 10);
      outtext("X = ");
      OutTextLn(TempString);
      // сделать то же самое для значения Y
      itoa(Current->Item->GetY(), TempString, 10);
      outtext("Y = ");
      OutTextLn(TempString);
      // указывает на следующий node
      Current = Current->Next;
   };
}

void setlist(void);

// Главная программа
main()
{
   int graphdriver = DETECT, graphmode;
   initgraph(&graphdriver, &graphmode, "с:..\\bgi");

   MemStatus("Free memory before list is allocated: ");
   setlist();
   MemStatus("Free memory after List destructor: ");
   getch();
   closegraph();
}

void setlist() {

   // объявить список (вызвать констрактор List)
   List AList;

   // создать и добавить несколько фигур в список
   Arc *Arc1 = new Arc(151, 82, 25, 200, 330);
   AList.Add(Arc1);
   MemStatus("Free memory after adding arc1: ");
   Circle *Circle1 = new Circle(200, 80, 40);
   AList.Add(Circle1);
   MemStatus("Free memory after adding circle1: ");
   Circle *Circle2 = new Circle(305, 136, 35);
   AList.Add(Circle2);
   MemStatus("Free memory after adding circle2: ");
   // просмотреть список и вывести X, Y фигур списка
   AList.Report();
   // 3 узла Alist, Arc и Circle объекты будут удалены
   // автоматически их дестракторами, когда они будут вне
   // области действия главной программы main().
   // Arc и Circle используют неявные дестракторы
   // в отличие от ~List, которые используют явный дестрактор.
   // Однако, Вы можете удалить все явно, если хотите:
   // delete Arc1; delete Circle1; delete Circle2;
   getch();   // ждать нажатия клавиши
   return;
}
     Когда Вы ознакомитесь с LISTDEMO.CPP,  Вы можете попробо-
вать разработать более удовлетворительное  решение,  в  основе
которого лежит следующая идея; определяем новый класс, называ-
емый PointList c помощью многократного наследования из классов
Point и List.

                  Увеличение гибкости в С++

     Хотя у Вас будет время для овладения нюансами этого ново-
го стиля программирования, давайте изучим существенные элемен-
ты  С++.  Есть  несколько  дополнительных свойств,  которых мы
кратко коснемся здесь так,  чтобы Вы знали, что они есть и как
их использовать.
     - Встроенные функции вне определений класса
     - Аргументы функций, определяемые по умолчанию
     - Перекрытие функций и многократные констракторы
     - Дружественные функции - другой способ получения доступа
       к классу
     - Перекрытие операторов для получения новых значений
     - Еще о вводе/выводе в С++ и библиотека потоков
     Примечание. Ни одно из этих свойств не  является  сущест-
венным  для понимания С++,  но их можно добавить для улучшения
гибкости и мощности языка С++.

          Встроенные функции вне определений классов

     Вы уже видели,  что можно включить встроенное определение
функции  элементов  внутри  определения  класса,  как показано
здесь для класса Point:
     class Point: {   // определение класса Point
        int X;        // по умолчанию объекты класса имеют
        int Y;        // доступ private

     public:          //функции элементов с доступом public
        Point(int InitX, int InitY)  {X = InitX, y = InitY;}
        int GetX(void)  {return X;}
        int GetY(void)  {return Y;}
     };
     Все три  функции  элементов класса Point определяются как
встроенные,  поэтому нет необходимости в раздельном  определе-
нии.  Для функций с единственной строкой или кодом это обеспе-
чивает более компактное, легкое для чтение описание класса.
     Примечание.Напомним, что встроенный код заключается в фи-
гурные скобки.
     Функции также можно объявить как встроенные. Единственное
различие состоит в том,  что Вы должны начать объявление функ-
ции  с ключевого слова inline.  Например,  в LISTDEMO.CPP есть
оператор,  который просто перемещает позицию вывода для текста
в  графическом  режиме  вниз на одну строку (он используется в
функции OutTextln).  Если эта функция будет использоваться  во
многих других местах кода, то более эффективным будет объявить
ее как отдельную встроенную функцию:
     inline void graphLn() { moveto (0, gety() + 12);}
     Если Вы желаете,  то можно отформатировать встроенные оп-
ределения так,  чтобы они были более похожи на определение ре-
гулярной функции:
     inline void graphLn()
     {
        moveto(0, gety() + 12);
     }
     Другое преимущество  в  использовании   ключевого   слова
inline состоит в том, что можно избежать раскрытия кода реали-
зации в распределенных файлах заголовков.

      Функции с аргументами, определенными по умолчанию

     Можно определить функции, которые можно вызвать с меньшим
количеством аргументов,  чем определено. Аргументы, которые не
задаются, используют значения, определенные по умолчанию. Если
Вы собираетесь использовать эти определенные по умолчанию зна-
чения  часто,  такие  "сокращенные" вызовы позволяют сократить
затраты на наборку текста программы. Вы не потеряете гибкости,
потому что, когда Вы захотите отменить определенные по умолча-
нию значения, Вы можете просто задать значения, которые Вы хо-
тите.
     Примечание.Если Вы  планируете часто использовать некото-
рые значения для функции,  используйте эти значения как  аргу-
менты  функции,  определяемые  по  умолчанию.  Определяемые по
умолчанию значения должны задаваться первый  раз  при  задании
имени функции.
     Например, следующая версия констрактора для класса Circle
дает по умолчанию окружность с радиусом  в  50  пикселов  и  с
центром в (х = 200, y = 200). Более переносимая программа, ко-
нечно,  должна определить имеющееся в распоряжении графическое
аппаратное обеспечение и в зависимости от этого определить эти
значения.
     Примечание.Также как и ANSI  C,  С++  разрешает  функциям
иметь   переменное   количество  аргументов,  например,  float
average(int number,  ...), может принимать в качестве аргумен-
тов одно или более целых чисел. Более подробная информация со-
держится в Главе 1 " Лексическая грамматика  "  в  Руководстве
программиста.
     class Circle : public Point  { //порождается из класса
                          //Point, и окончательно из класса
                          //Location
     protected:
        int Radius;
     public:
        Circle(int InitX=200,int InitY=200,int InitRadius=50);
        void Show(void);
        void Hide(void);
        void Expand(void);
        void Expand(int ExpandBy);
        void Contract(int ContractBy);
     };
     Теперь объявление
       Circle ACircle;
дает Вам окружность с определенным по умолчанию центром в точ-
ке (200, 200) и радиусом,равным 50.
     Объявление
       Circle ACircle(50, 100);
дает окружность  с  центром в точке (50,100) и определенным по
умолчанию радиусом ,равным 50.
     Объявление
       Circle ACircle(300);
дает окружность с центром в точке Х=300,  а Y=200 (по  умолча-
нию) и определенным по умолчанию радиусом ,равным 50.
     Любые, определенные по умолчанию аргументы, должны быть в
последовательных правых позициях в списке  аргументов.  Напри-
мер, нельзя объявить
     void func(int a = 10, int b, int c),
потому что компилятор не будет знать,  какие значения задаются
при вызове функции.

       Дополнительные сведения о перекрываемых функциях

     Перекрытие -  это  важное и всеобъемлющее средство в С++.
Когда несколько различных функций (или функции элементов,  или
обычные функций) определяются с одинаковым именем внутри одной
области действия,  говорят,  что они должны перекрываться. Вам
встречалось  несколько таких случаев;  например,  три функции,
названные cube.  (Более ранние версии С++ требовали, чтобы та-
ким объявлением предшествовало ключевое слово overload, но те-
перь это требование устарело.)
     Основная идея состоит в  том,  что  вызовы  перекрывающих
функций  различаются  посредством  сравнения типов фактических
аргументов в вызове и  формальных  аргументов  в  определениях
функций.  Фактически правила для устранения неоднозначностей в
этой главе не рассматриваются и вряд ли могут повлиять на  на-
чинающих  программистов (поэтому их нужно предупредить о нера-
зумности дублирования имен функций).  Трудности могут  возник-
нуть для функций, вызываемых с фактическими аргументами, опре-
деленными по умолчанию или с переменным  количеством  аргумен-
тов;  также нужно учитывать обычные преобразования типов аргу-
ментов в С,  наряду с дополнительными преобразованиями  типов,
свойственными С++. Когда встречается вызов перекрывающей функ-
ции, компилятор пытается найти лучшее соответствие фактических
и формальных аргументов,  если нет наилучшего соответствия, то
компилятор выдает сообщение об ошибке.
     Одним из  наиболее  общих  случаев  является   перекрытия
констракторов так, чтобы обеспечить несколько различных спосо-
бов для создания нового объекта класса.  Чтобы  проиллюстриро-
вать это, мы определим очень простой класс String.
     Примечание. Можно загрузить и прогнать STRING.CPP из  ин-
тегрированной  среды  развития (IDE).  После прогона Вы должны
активизировать экран пользователя, чтобы посмотреть полученный
вывод. Используйте функциональную клавишу ALT - F5 или элемент
меню Window/UserScreen.
//STRING.CPP--Пример для Главы 4 Начального руководства */

#include <iostream.h>
#include <string.h>

class String {
   char *char_ptr;   // указатель на содержимое строки
   int length;       // длина строки в символах
public:
   // три разных констрактора
   String(char *text);           // констрактор, использующий
                                 // существующую строку
   String(int size = 80);        // создает по умолчанию
                                 // пустую строку
   String(String& Other_String); // для назначения из других
                                 // объектов этого класса
   ~String() {delete char_ptr;};
   int Get_len (void);
   void Show (void);
};

String::String (char *text)
{
   length = strlen(text);  // получить длину текста
   char_ptr = new char[length + 1];
   strcpy(char_ptr, text);
};

String::String (int size)
{
   length = size;
   char_ptr = new char[length+1];
   *char_ptr = '\0';
};

String::String (String& Other_String)
{
   length = Other_String.length;        // длина другой строки
   char_ptr = new char [length + 1];    // распределить память
   strcpy (char_ptr, Other_String.char_ptr); // скопировать
                                             // текст
};

int String::Get_len(void)
{
   return (length);
};

void String::Show(void)
{
   cout << char_ptr << "\n";
};

main ()                                // проверить функции
{
   String AString ("Allocated from a constant string.");
   AString.Show();

   String BString;             //использует длину по умолчанию
   cout << "\n" << BString.Get_len() << "\n" ; //выводит длину
   BString = "This is BString";

   String CString(BString);    // вызывает третий констрактор
   CString.Show();             // помечает его содержимое
}
     Примечание. При  вызове  констрактора без аргументов (или
при использовании в качестве всех аргументов значений, опреде-
ленных  по  умолчанию)  не  используйте  пустые круглые скобки
после имени объекта.  Например, нужно объявить String BString;
а не String BString();
     Класс String имеет три различных констрактора. Первый бе-
рет обычную постоянную строку, например, "Это строка" и иници-
ализирует   строку  с  этим  содержанием.  Второй  констрактор
использует определенную по  умолчанию  длину  80  и  размещает
строку без сохранения в ней каких - либо символов.  (Это можно
использовать для создания  временного  буфера.)  Заметим,  что
можно отменить определенные по умолчанию значения, просто выз-
вав констрактор с  другой  длиной:  вместо  объявления  String
AString можно объявить например, String AString(40).
     Третий констрактор  берет  ссылку  на  другой объект типа
String (напомним,  что амперсанд после типа означает ссылку на
этот  тип и используется для передачи адреса переменной,  а не
копии ее содержания).  С помощью этого констрактора можно  на-
писать предложения, подобные следующим:
     String AString("Это первая строка");  //создает и инициа-
                                           //лизирует
     String  BString  =  AString; //создает, затем присваивает
                                  //BString содержание AString
     Заметим, что констракторы используются в трех  связанных,
но отдельных аспектах жизни объекта: создание, инициализация и
присваивание.  Использование  оператора  =  для   присваивания
классов приводит нас к следующей теме,  перекрытию операторов.
Если Вы не определили специальный оператор = для класса, то по
умолчанию С++ считает его почленным присваиванием.

     Перекрытие операторов для обеспечения новых значений

     С++ имеет специальное свойство, имеющееся и в других язы-
ках: существующим операторам, например +, можно дать новые оп-
ределения,  чтобы заставить их работать соответствующим, опре-
деленным пользователем способом с объектами класса.  Операторы
представляют собой очень краткий способ выполнения какой - ли-
бо функции.  Если у Вас их нет,  то выражение, подобное line *
width  +  pos  должно   быть   записано   следующим   образом:
add(mult(line, width),pos). К счастью, арифметические операто-
ры в С (и в С++) уже знают,  как работать со  всеми  числовыми
типами  данных - тот же самый оператор +,  который работает со
значениями типа int, также работает, например, и со значениями
типа float.  Используется один и тот же оператор, а генерируе-
мый код явно отличается, так как целые числа и числа с плаваю-
щей запятой представляются в памяти различным образом. Другими
словами, операторы, подобные +, уже перекрыты, даже в регуляр-
ном С.  С++ просто расширяет эту идею, чтобы разрешить пользо-
вателям определять новые версии существующих операторов.
     Чтобы определить оператор,  Вы определяете функцию, кото-
рая в качестве своего имени имеет ключевое слово operator,  за
которым следует символ оператора.  (Так например,  operator+ -
имя новой версии оператора +.) Все функции оператора по  опре-
делению  перекрываются:  они используют оператор,  который уже
имеет определенный смысл в С,  но они переопределяют  его  для
использования с новым типом данных.  Например,  оператор + уже
имеет способность складывать два значения любого  стандартного
числового типа (int, float, double и т.д.).
     Теперь мы можем добавить оператор + к классу String. Этот
оператор будет сцеплять два строковых объекта (как  в  BASIC),
возвращая  результат в виде строкового объекта соответствующей
длины и содержания. Так как сцепление - это "сложение вместе",
символ + подходит для такого использования.  Приверженцы BASIC
часто критикуют С за отсутствие такой естесственной  строковой
операции.  С  помощью  С++  Вы  можете пойти дальше встроенных
строковых возможностей BASIC.
     Файл XSTRING.CPP, находящийся на дистрибутивных дискетах,
имеет   следующие  добавления  к  STRING.CPP  для  обеспечения
простого оператора +.
// XSTRING.CPP--Пример для Главы 4 Начального руководства */
// версия STRING.CPP с перекрываемым оператором +

#include <iostream.h>
#include <string.h>

class String {
   char *char_ptr;   // указатель на содержимое строки
   int length;       // длина строки в символах
public:
   // три различных констрактора
   String(char *text);           // констрактор, использующий
                                 // существующую строку
   String(int size = 80);        // создает пустую строку
                                 // по умолчанию
   String(String& Other_String); // для назначения из другого
                                 // объекта этого класса
   ~String() {delete char_ptr;}; // встроенный дестрактор
   int Get_len (void);
   String operator+ (String& Arg);
   void Show (void);
};

String::String (char *text)
{
   length = strlen(text);  // получить длину текста
   char_ptr = new char[length + 1];
   strcpy(char_ptr, text);
};

String::String (int size)
{
   length = size;
   char_ptr = new char[length+1];
   *char_ptr = '\0';
};

String::String (String& Other_String)
{
   length = Other_String.length;       // длина другой строки
   char_ptr = new char [length + 1];   // распределить память
   strcpy (char_ptr, Other_String.char_ptr); // скопировать
                                             // текст
};

String String::operator+ (String& Arg)
{
  String Temp( length + Arg.length );
  strcpy(Temp.char_ptr, char_ptr);
  strcat(Temp.char_ptr, Arg.char_ptr);
  return Temp;
}

int String::Get_len(void)
{
   return (length);
};

void String::Show(void)
{
   cout << char_ptr << "\n";
};

main ()                                // проверить функции
{
   String AString ("The Quick Brown fox");
   AString.Show();

   String BString(" jumps over Bill");
   String CString;
   CString = AString + BString;
   CString.Show();
}
     Примечание. Чтобы увидеть вывод на дисплей из  интегриро-
ванной среды (IDE), нажмите ALT - F5 или Window/User.
     При прогоне программы, CString присваивается конкатенация
двух строк AString и BString.  Поэтому СString.Show()  выводит
на дисплей следующую строку:
     The Quick Brown Fox jumps over Bill
     Перекрываемый оператор + использует только один явный ар-
гумент, поэтому Вы можете удивиться, как он работает при сцеп-
лении двух строк.  В этом случае компилятор обрабатывает выра-
жение AString + BString следующим образом:
     AString.(оператор + (BString))
поэтому оператор + имеет доступ  к  двум  строковым  объектам.
Первый объект - это объект String,  на который установлена те-
кущая ссылка, а другой - второй строковый объект. Функция опе-
ратора  складывает  длины двух строк вместе,  потом использует
библиотечную функцию strcat для  объединения  содержания  двух
строк,  которое затем возвращается.  В данном случае использу-
ется "скрытый" указатель, известный как this. Что такое this?
     Примечание. Более подробно this описывается в Руководстве
программиста.
     Каждый вызов функции элементов устанавливает указатель на
объект,  под действием которого активизируется этот вызов.  На
этот  указатель можно ссылаться с помощью ключевого слова this
(он называется также "self" или  "pointer-to-self"  (указатель
на себя) в терминах объектно - ориентированного программирова-
ния), обеспечивая функциям доступ к действительному объекту. В
нашем случае this имеет тип "указатель на объект String", поэ-
тому возвращаемое значение должно быть  *this,  действительный
текущий объект - это как раз то, что нужно. Заметим также, что
на отдельные элементы объекта, используемого в вызове функции,
можно ссылаться с помощью выражения this->элемент. Далее нужно
отметить,  что this можно использовать только для функций эле-
ментов, но не для дружественных функций.
     Есть несколько ограничений при перекрытии операторов:
     - С++  не  различает префиксную и постфиксную версии ++ и
       --.
     - Оператор,  который Вы хотите определить, должен уже су-
       ществовать в языке.  Например,  Вы не можете определить
       оператор #.
     - Нельзя перекрывать следующие операторы:
       .  .*  ::  ?:
     - Перекрываемые  операторы сохраняют первоначальный прио-
       ритет операции.
     - Если  @  используется  для  любой унарной  операции, то
       выражения @x и  x@  могут  интерпретироваться  или  как
       x.operator@() или как operator@(x).  Если объявлены две
       формы,  то компилятор будет пытаться разрешить неодноз-
       начность на основе соответствия аргументов. Аналогично,
       если @ используется как перекрываемый  бинарный  опера-
       тор,   x@y   может   означать  или  x.operator@(y)  или
       operator@(xy),  и компилятору необходимо  обращаться  к
       аргументам, если определены обе формы. Вы видели пример
       бинарного оператора + в версии строки,  где  AString  +
       BString   интерпретировалось   как  AString.(operator)+
       (BString)).

                    Дружественные функции

     Обычно, доступ  к элементам класса типа private ограничен
функциями элементов данного класса.  Иногда  может  возникнуть
необходимость предоставить внешним функциям доступ к собствен-
ным данным класса.  Объявление friend внутри объявления класса
дает  возможность определить внешние функции (или даже внешние
классы),  которым  будет  предоставлен  доступ  к  объявляемым
собственным элементам класса. Вам иногда будет встречаться пе-
рекрываемый оператор,  объявленный friend,  но, вообще говоря,
нужно использовать дружественные функции очень осторожно, если
необходимость в них возникает в проекте слишком часто, это мо-
жет  служить  признаком того,  что Вашу иерархию классов нужно
изменить.
     Но предположим, что есть функция, распечатывающая и хоро-
шо форматирующая текст,  называемая Fancy_Print , и Вы хотите,
чтобы она имела доступ к содержанию объектов класса  String  .
Вы  можете добавить следующую строку к списку объявлений функ-
ций элементов:
     class String {
     friend void Fancy_Print(String& AString);
     ...
    Примечание. Расположение объявления не имеет значения.
     В этом явно искусственном примере функция Fancy_Print мо-
жет иметь доступ к элементам char_prt и length объектов класса
String. Т.е., если AString - это строковый объект, Fancy_Print
может   иметь   доступ   к   элементам   AString,  char_Ptr  и
AString.length.  Если функция Fancy_Print  является  элементом
другого класса (например, класса Format), используйте оператор
разрешения области действия в  объявлении  с  ключевым  словом
friend:
     friend void Format::Fancy_Print(String& AString);
     Можно также  сделать  целый  класс  "другом" объявленного
класса посредством использования ключевого слова class в  объ-
явлении:
     friend class Format;
     Теперь любая  функция элементов класса Format может иметь
доступ к собственным элементам класса String.  Заметим,  что в
С++,  как и в жизни, дружба не является транзитивной: если х -
друг y, а y - друг z, то отсюда не следует, что х - друг z.
     Объявление friend должно использоваться только когда  это
действительно необходимо; когда без этого Вам понадобится спи-
ралевидная  иерархия  классов.  По  своей  природе  объявление
friend различает инкапсуляцию и модульность. В частности, если
у Вас возникнет необходимость  сделать  целый  класс  "другом"
другого  класса,  то  нужно оценить это по сравнению с возмож-
ностью порождения класса обычным образом и  использованию  его
для доступа к необходимым элементам.

                    Библиотеки С++ потоков

     Примечание. Этот раздел предназначен просто для возбужде-
ния  Вашего  интереса и правильной ориентации.  Мы рекомендуем
Вам изучить примеры в Главе 5 "С++ потоки" в Руководстве прог-
раммиста и провести собственные эксперименты.
     В то  время  как  все еще используются функции библиотеки
ввода / вывода stdio (такие как printf  и  scanf),  С++  также
предоставляет группу классов и функций для ввода / вывода, оп-
ределяемые  в  библиотеке  iostreams.  Чтобы  получить  к  ним
доступ,   Ваша   программа  должна  иметь  директиву  #include
<iostreams.h>,  которую Вы могли заметить  в  некоторых  наших
примерах.
     Есть много  преимуществ  в использовании iostreams вместо
stdio.  Синтаксис в библиотеке iostreams более простой,  более
изящный и более интуитивный.  Механизм С++ потоков также более
эффективный и гибкий. Форматирование вывода, например, упроща-
ется расширенным использованием перекрытия. Один и тот же опе-
ратор может использоваться для вывода и предварительно опреде-
ленных  типов данных и типов данных,  определенных пользовате-
лем, избегая сложностей списка аргументов printf.
     Начиная с потока, как абстракции для моделирования любого
потока  данных  от  источника  (или производителя) к приемнику
(или потребителю),  iostreams предоставляет  богатую  иерархию
классов  для  обработки  ввода / вывода с буферизацией или без
буферизации для файлов и устройств.
     Borland C++ также поддерживает более старую (версия  1.х)
С++ stream библиотеку, чтобы помочь программистам во время пе-
рехода к новой iostream библиотеке C++ версии 2.0.  Если у Вас
есть  какой  -  нибудь  С++ код,  который использует устарелые
классы stream,  то Вы можете продолжать поддерживать и  прого-
нять  этот  код с помощью Borland C++.  Однако,  сделав выбор,
нужно преобразовать код, используя более эффективный iostream,
и избежать stream при написании нового кода.  Глава 5 "С++ по-
токи" в Руководстве программиста объясняет различие между биб-
лиотеками stream и iostream и предоставляет некоторые подсказ-
ки по преобразованию.  См.  также OLDSTR.DOC на дистрибутивных
дискетах.
     В этом  разделе  мы  рассмотрим  только  наиболее простые
классы в iostream.  Более подробная информация об этом  содер-
жится в Главе 5 "С++ потоки" в Руководстве программиста. Также
можно просмотреть iostream.h на дистрибутивных дискетах и уви-
деть  определения  многих  классов и то,  как они порождаются,
используя одиночное и многократные наследования.

                      Стандартный ввод/вывод

     С++ предоставляет четыре предварительно определенных объ-
екта stream, определенные следующим образом:
     - cin стандартный ввод,  обычно клавиатура, соответствую-
                   щая stdin в С
     - cout стандартный вывод,  обычно экран,  соответствующий
                   stdout в С
     - cerr стандартный вывод ошибок,  обычно на экран,  соот-
                   ветствующий stderr в С
     - clog полностью буферизованная версия cerr ( нет С экви-
                   валента)
     Вы можете перенаправить эти стандартные потоки  из  и  на
другие  устройства  и  файлы.  (В С можно перенаправить только
stdin и stdout.) Вы уже видели наиболее общие из этих  потоков
cin и cout в некоторых примерах этой главы.
     Упрощенный взгляд  на иерархию iostream от примитивного к
специализированному выглядит следующим образом:
     - streambuf обеспечивает методы для буферов памяти.
     - ios обрабатывает переменные состояния потока и ошибки
     - istream обрабатывает форматированные и  неформатирован-
       ные преобразования символов из streambuf.
     - оstream  обрабатывает форматированные и неформатирован-
       ные преобразования символов в streambuf.
     - iostream комбинирует istream и ostream,  чтобы  обрабо-
       тать операции над одним потоком в двух направлениях.
     - istream_withassign предоставляет констракторы и  опера-
       торы присваивания для потока cin.
     - ostream_withassign  предоставляет констракторы и опера-
       торы  присваивания  для   потоков count, cerr и clog.
     Примечание. << , используемый с потоками, называется опе-
ратором вставки или оператором "поместить в",  а >> -  называ-
ется оператором извлечения или оператором "прочитать из".
     Класс istream включает перекрываемые определения для опе-
ратора >>,  используемого со стандартными типами  [int,  long,
double,  float, char*(строка)]. Таким образом, предложение cin
>>  x;  вызывает  соответствующую  функцию  оператора  >>  для
istream  cin,  определенного  в iostream.h и использует ее для
направления этого входного потока в позицию памяти,  представ-
ляемую переменной х.  Аналогично, класс ostream имеет перекры-
ваемые определения для оператора << ,  который разрешает с по-
мощью  предложения  cout  << x;  посылать значение x в ostream
cout для вывода.
     Эти функции  оператора возвращают ссылку на соответствую-
щий классовый тип потока (например, ostream&) наряду с переме-
щением  данных.  Это позволяет расположить в цепочку несколько
таких операторов для ввода и вывода последовательности  симво-
лов:
     int i=0, x=243; double d=0;
     cout << "Значение x равно" << x << 'n';
     cin >> i >> d;           //ввод с клавиатуры int, пробел,
                              //затем double
     Вторая строка будет выводить на дисплей: "Значение x рав-
но 243",  а затем будет идти новая строка. Следующее предложе-
ние  будет игнорировать пробел,  читать и преобразовывать кла-
вишные символы в целое число и помещать его в i,  игнорировать
следующий пробел, читать и преобразовывать следующие клавишные
символы в double и помещать их в d.
     Следующая программа  просто  копирует  cin  в  cout.  При
отсутствии изменения направления она копирует ввод с клавиату-
ры на экран:
// COPYKBD.CPP   Выводит на экран ввод с клавиатуры

#include <iostream.h>

int main(void)
{
   char ch;
   while (cin >> ch)
      cout << ch;
}
     Примечание. Эта  программа просто сохраняет каждый вводи-
мый символ в переменной ch, а затем выводит значение ch на эк-
ран.
     Заметим, что  (cin >> ch) можно проверить как обычное бу-
левское выражение.  Этот полезный прием возможен благодаря оп-
ределениям в классе ios.  Короче,  выражение, такое как (cout)
или (cin >> ch) подобно указателю,  значение которого  зависит
от  наличия ошибок.  Нулевой указатель (проверяемый как false)
указывает на ошибку в потоке, в то время как, ненулевой указа-
тель (проверяемый как true) означает отсутствие ошибок.  Можно
также обратить проверку,  используя !,  так что (!cout)  будет
true для ошибки в потоке cout и false, если ошибок нет:
     if (!cout) errmsg("Ошибка вывода!");

                     Форматируемый вывод

     Простой ввод/вывод в С++ эффективен потому, что выполняет
только  минимальные преобразования в соответствии с используе-
мыми типами данных.  Для целых чисел преобразование такое  же,
как определенное по умолчанию преобразование для printf. Пред-
ложения
     int i=5; cout << i;
и
     int i=5; printf("%d", i);
дают одинаковый результат.
     Форматирование определяется  как множество флагов состоя-
ний формата,  перечисляемых в ios.  Они определяют для каждого
активного  потока систему исчисления для преобразования (деся-
тичная,  восьмеричная и шестнадцатиричная),  заполнение  слева
или  справа,  формат с плавающей запятой (научный или фиксиро-
ванный) и будут ли пропускаться при вводе пробелы.  Другие па-
раметры, которые можно изменять, включают ширину поля (для вы-
вода) и символ,  используемый для заполнения.  Эти флаги можно
проверять,  устанавливать, очищать с помощью различных функций
элементов. Следующий фрагмент показывает, как работают функции
ios::width и ios::fill:
     int previous_width,i = 87;
     previous_width   =
     cout.width(7);             // устанавливает ширину поля,
                                // равной 7 и запоминает
                                // предыдущую  ширину
     cout.fill('*');            // устанавливает символ *
                                // для заполнения
     cout << i << '\n';         // выводит на экран *****87
                                // <новая строка>
     //после << ширина очищается и становится равной  0,
     //предыдущая ширина может быть установлена без
     //последовательных операторов << , поэтому Вы можете
     //восстановить ее с  помощью  следующей строки
     cout.width(previous_width);
     Установление width, равной 0 (по умолчанию) означает, что
дисплей будет использовать столько позиций экрана, сколько не-
обходимо.  Если  заданная  ширина недостаточна для правильного
представления, то считается, что ширина равна 0 (т.е. усечения
нет). По умолчанию заполнение обеспечивает выравнивание справа
(заполнение слева) для всех типов.
     Setf и unsetf - это две общие  функции  для  установки  и
очистки флагов формата:
     cout.setf(ios::left, ios::adjustfield);
     Это устанавливает   заполнение   слева.  Первый  аргумент
использует перечислимую мнемонику для различных позиций  битов
(возможно комбинированным использованием & и │),  а второй ар-
гумент - целевое поле в состоянии формата. Unsetf работает та-
ким  же образом,  но очищает выбранные биты.  (Более подробная
информация об этом содержится в Главе 5 "С++ потоки"  в  Руко-
водстве программиста.)

                         Манипуляторы

     Наиболее изящный способ установки флагов формата  (и  вы-
полнения других функций для потока) использует специальный ме-
ханизм, известный как манипуляторы. Подобно операторам << и >>
манипуляторы могут включаться в цепочку операторов потока:
     cout << setw(7) << dec << i << setw(6) << oct << j;
     Без манипуляторов понадобилось бы шесть отдельных предло-
жений.
     Параметризованный манипулятор setw принимает  один  аргу-
мент типа int, чтобы установить ширину поля.
     Непараметризованные манипуляторы,  например,  dec,  oct и
hex устанавливают систему исчисления для преобразования: деся-
тичную,  восьмеричную  и шестнадцатиричную.  В вышеприведенном
примере int i будет выводится на экран в десятичном виде в по-
ле  шириной  7;  int j будет выводится на экран в восьмеричном
виде в поле шириной 6.
     К другим  простым  параметризованным  манипуляторам   от-
носится   setbase,   setfill,   setprecision,   setiosflags  и
resetiosflags.  Чтобы использовать любые из  параметризованных
манипуляторов, Ваша программа должна включить оба заголовочных
файла: iomanip.h и iostream.h. Непараметризованные манипулято-
ры не требуют iomanip.h.
     Полезные непараметризованные манипуляторы включают:
       ws (извлечение пробелов):  istream >> ws;  будет устра-
нять любые пробелы в istream.
       endl (конец строки и выключение из работы):  ostream <<
endl; будет вставлять новую строку в ostream, а затем выключа-
ет из работы ostream.
       ends (конец строки с нулем): ostream << ends; будет до-
бавлять 0 в ostream.
       flush (выключение выходного потока):  ostream << flush;
выключает ostream.

                       put, write и get

     Две основные функции вывода заслуживают упоминания: put и
write, объявленные в ostream следующим образом:
        ostream& ostream::put(char ch);
        //посылает ch в ostream
        ostream& ostream::write(const char* buff, int n);
        //посылает n символов из buff в ostream;
     Put и write позволяют выводить неформатированные двоичные
данные в объект ostream.  Put выводит один символ, а write мо-
жет  послать  любое  количество символов из указанного буфера.
Write полезна,  когда Вы хотите вывести необработанные данные,
которые  могут  включать нули.  (Заметим,  что запись двоичных
данных требует,  чтобы файл был  открыт  в  двоичном  режиме.)
Обычное  извлечение строки не будет работать до тех пор,  пока
строка не будет завершена нулем.
     Входная версия put называется get:
     char ch;
     cin.get(ch);  //захватывает следующий символ из
                   //cin независимо от того пробел
                   //это или нет
     Другая версия  get  позволяет Вам захватывать любое коли-
чество необработанных,  двоичных символов из istream до задан-
ного максимума и помещать их в заданный буфер (так же, как и в
случае с write, файлы должны быть открыты в двоичном режиме):
    istream& istream::get(char *buff, int max, int term='\n');
    //читает символы до максимального количества из istream, а
    //затем  помещает  их  в  buff.  Прекращает  чтение,  если
    //прочитан
    //символ, указанный в term.
     Можно установить term равным определенному конечному сим-
волу (по умолчанию - это символ новой строки),  в котором  get
будет прекращать работу,  если он будет достигнут прежде,  чем
max символов будет передано в buff.

                      Ввод/вывод с диска

     Библиотека iostream  включает много классов,  порожденных
из streambuf,  ostream и istream,  предоставляя таким  образом
широкий выбор методов ввода/вывода файлов.  Класс filebuf нап-
ример,  поддерживает ввод/вывод через дескрипторы файлов с по-
мощью  функций  элементов для открытия,  закрытия и поиска.  В
противоположность этому,  класс stdiobuf поддерживает ввод/вы-
вод  через stdio FILE структуры,  разрешая некоторую совмести-
мость, когда необходимо смешивать коды на С и С++.
     Наиболее часто используемыми классами для начинающих  яв-
ляются ifstream (порожденный из Istream),  ofstream (порожден-
ный из ostream) и fstream (порожденный из iostream).  Все  они
поддерживают форматированный файл ввода/вывода, используя объ-
екты filebuf.  Ниже приведен простой пример,  который копирует
существующий дисковый файл в другой заданный файл:
    Примечание. Этот код записан в DCOPY.CPP.
/* DCOPY.CPP -- Пример из Главы 4 Начального руководства */

/* DCOPY исходный файл / файл назначения                    *
 * копирует существующий исходный файл в файл назначения    *
 * Если последний существует, то он перезаписывается;       *
 * если не существует, DCOPY создаст его, если это возможно *
 */

#include <iostream.h>
#include <process.h>    // для exit()
#include <fstream.h>    // для ifstream, ofstream

main(int argc, char* argv[])  // доступ к аргументам командной
                              // строки
{
   char ch;
   if (argc != 3)      // проверка числа аргументов
   {
      cerr << "USAGE: dcopy file1 file2\n";
      exit(-1);
   }

   ifstream source;    // объявить входной и выходной потоки
   ofstream dest;

   source.open(argv[1],ios::nocreate); // должен быть исходный
                                       // файл
   if (!source)
   {
      cerr << "Cannot open source file " << argv[1] <<
       " for input\n";
      exit(-1);
   }
   dest.open(argv[2]);   // файл назначения будет создан, если
// не он найден или создан/перезаписан, если найден
   if (!dest)
   {
      cerr << "Cannot open destination file " << argv[2] <<
      " for output\n";
      exit(-1);
   }

   while (dest && source.get(ch)) dest.put(ch);

   cout << "DCOPY completed\n";

   source.close();        // закрыть оба потока
   dest.close();
}
     Во-первых заметим, что #include <fstream> также заставля-
ет обращаться к iostream.h. DCOPY использует стандартный метод
обращения к аргументам командной строки, чтобы проверить задал
ли пользователь два используемых файла.  Когда этот список ар-
гументов  используется  функцией main,  аргумент argc содержит
количество аргументов  командной  строки  (включая  имя  самой
программы),  а строки argv[1] и argv[2] содержат два введенных
имени файла.  Типичный вызов этой программы в командной строке
выглядит следующим образом:
     dcopy letter.spr letter.bak
     Чтобы  увидеть  как работает DCOPY, просмотрите следующие
     строки:
     ifstream source;                //объявляет входной поток
                                     //(объект ifstream)
     ...
     open.source(argv[1],ios::nocreate);      // исходный файл
                                        // должен существовать
     Объявление активизирует констрактор ifstream  (класс  для
обработки потоков входных файлов),  чтобы создать объект пото-
ка, называемый source. Мы должны создать буфер файла и связать
поток и буфер с реальным,  физическим файлом, прежде чем можно
будет использовать source.  Обе  задачи  выполняются  функцией
элементов  open  в ifstream.  Функции open необходима строка с
именем файла и,  необязательно, один или два аргумента для то-
го,  чтобы задать режим и права защиты.  Имя файла здесь зада-
ется как argv[1] ,  то есть,  исходный файл,  задаваемый в ко-
мандной строке.
     Более лаконичной  альтернативой вышеприведенному объявле-
нию является:
     ifstream source(argv[1],ios::nocreate); //исходный файл
                                       //должен существовать
     //это предложение создает source и открывает файл
     Аргумент режима ios::nocreate  говорит  функции  open  не
создавать  файл,  если названный файл не найден.  Для DCOPY мы
явно хотим открыть файл,  чтобы прекратить выполнение програм-
мы, если исходный файл с заданным именем отсутствует на диске.
Позднее мы увидим, что возможны аргументы других режимов. Если
файл argv[1] не может быть открыт по какой - то причине (обыч-
но из-за того, что файл не найден), значению source присваива-
ется  ноль  (ложь),  поэтому (!source) проверяется на значение
истина,  что приводит к появлению сообщения об  ошибке,  затем
выходу из программы.
     Фактически, можно  определить  возможную  причину неудачи
при открытии исходного файла,  проверив значения битов ошибки,
заданных  в  stream state.  Функции элементов eof,  fall и bad
проверяют различные биты ошибки  и  возвращают  значение  true
(истина),  если эти биты установлены.  Альтернативно,  rdstate
возвращает состояние ошибок в int и можно затем проверить, ка-
кие  биты установлены.  Eof (конец файла) по существу не явля-
ется ошибкой,  но его нужно проверять и выполнять действия  до
тех пор, пока поток не сможет иметь доступ за пределами конеч-
ного символа.  Заметим,  что когда поток находится в состоянии
ошибки (включая eof) дальнейший ввод/вывод не допустим.  Функ-
ция clear предоставляется для очистки некоторых или всех  оши-
бочных  битов,  разрешая Вам возобновить работу с файлом после
очистки нефатальной ситуации.
     Вернемся к DCOPY.CPP ;  если с исходным файлом все в  по-
рядке,  мы  затем  пытаемся открыть файл назначения с объектом
ofstream,  dest. Что касается выходных файлов, определенная по
умолчанию  ситуация  заключается в том,  что файл будет созда-
ваться, если он не существует; если он существует, то он будет
очищаться и создаваться заново как пустой файл.  Можно модифи-
цировать это поведение, добавляя второй аргумент mode к объяв-
лению dest. Например:
     ofstream dest (argv[2],ios::app│ios::nocreate);
будет пытаться открыть dest в режиме добавления и будет завер-
шаться неудачей, если dest не будет найдено. В режиме добавле-
ния  данные из исходного файла будут добавляться в конец dest,
оставляя прежнее содержание без изменения. К другим флагам ре-
жимов, перечисленным в классе ios (обратите внимание на опера-
тор области действия в ios::app) относятся  ate  (поиск  конца
файла);  in (открытие для ввода,  используемого с fstreams,так
как они могут открываться и для input и для output); out (отк-
рытие для вывода,  также используется с fstreams); trunс (отб-
расывается содержание файла,  если он  существует);  noreplace
(неудача, если файл существует).
     Когда оба файла открыты, фактическое копирование выполня-
ется в типично сжатой манере С.  Рассмотрим булевское  выраже-
ние, проверяемое циклом while:
     (dest && source.get(ch))
     Примечание. Когда С проверяет (x && y),  y проверяться не
будет,  если х окажется false. Так как dest менее вероятно бу-
дет  иметь  значение  false по сравнению с source.get(ch),  то
можно переставить их местами.
     Мы видим,  что dest будет проверяться на  значение  true,
пока  не произойдет ошибки.  Аналогично,  вызов source.get(ch)
будет проверяться на значение true,  пока не произойдет ошибки
чтения или пока не будет достигнут конец файла. При отсутствии
"аппаратных" ошибок, цикл будет читать символы из sourse и по-
мещать  их  в  dest,  пока  ситуация  "конец файла" не сделает
source равным false.
     Есть еще  много  особенностей   ввода/вывода   файлов   в
iostream библиотеке.  Также iostream может помочь Вам с форма-
тированием в памяти,  когда потоки находятся в оперативной па-
мяти. Специальные классы, например, strstreambuf, предоставля-
ются для манипуляции потоками в памяти.

    Ввод/вывод для типов данных определенных пользователем

     Реальное преимущество потоков С++ заключается в легкости,
с  которой  Вы  можете  совместить >> и << для управления вво-
дом/выводом  Ваших  персональных  типов   данных.   Рассмотрим
простую структуру данных, которую Вы можете объявить:
     struct emp {
        char *name;
        int dept;
        long sales;
     };
     Чтобы совместить << для вывода объектов типа emp, Вам не-
обходимо следующее определение:
     ostream& operator << (ostream& str, emp& e)
     {
     str <<  setw(25)  <<  e.name << ":  Department " << setw(6)
     << e.dept << tab << "Sales $" << e.sales << '\n';
     return str;
     }
     Обратите внимание на то, что функция - оператор << должна
возвращать  ostream&,  ссылку  на  ostream,  так что Вы можете
подсоединить Вашу новую функцию << подобно предварительно  оп-
ределенному оператору вставки. Теперь Вы можете вывести объек-
ты типа emp следующим образом:
     #include <iostream.h>
     #include <iomanip.h>    //не забывайте это!
     ...
     emp jones = {"S. Jones", 25, 1000};
     cout << jones;
получив вывод на дисплей
     S. Jones: Department 25 Sales $1000
     Заметили ли Вы манипулятор tab в определении << ?  Это не
стандартный манипулятор, а манипулятор, определенный пользова-
телем:
     ostream& *tab(ostream& str) {
        return str << '\t';
     }
     Конечно это является тривиальным, а тем не менее делается
для получения более удобочитаемого кода.
     Программу ввода  для  emp  можно написать сходным образом
используя перекрытие >>.  Это остается в  качестве  упражнения
для читателя.

                         Куда теперь?

     Предложением для  Вашего  первого  проекта С++ может быть
расширение модуля FIGURES,  приведенного ранее (Вы имеете  его
на своем диске).  Без сомнения для этого достаточны точки, ок-
ружности и дуги. Создайте объекты для линий, прямоугольников и
квадратов. Когда Вы почувствуете себя более уверенно, создайте
объект секторной диаграммы, используя связанный список индиви-
дуальных рисунков секторов.
     Одной из   наиболее  сложных  задач  является  реализация
классов для управления относительной  позицией.  Относительная
позиция - это смещение от некоторой базовой точки,  выражаемое
как положительная или отрицательная разность.  Точка в относи-
тельных  координатах - 17,42 находится на 17 пикселов влево от
базовой точки и на 42 пиксела вниз от этой же  базовой  точки.
Относительные позиции необходимы для эффективного комбинирова-
ния фигур в отдельные большие по размеру фигуры,  так как ком-
бинации  из  многих фигур не могут всегда связываться в каждой
точке основания фигуры. Лучше определить поле RX и RY в допол-
нение к точке основания X,Y и иметь окончательную позицию объ-
екта на экране как сумму его точки основания  и  относительных
координат.
     Когда Вы хорошо ознакомились с С++, начинайте строить его
концепции  в  Вашем  ежедневном   программировании.   Возьмите
несколько  из  Ваших  наиболее пригодных существующих утилит и
переосмыслите их в терминах С++.  Попробуйте увидеть классы  в
Вашем "винегрете" библиотек функций,  затем перепишите функции
в форме классов. Вы обнаружите, что библиотеки классов гораздо
легче повторно использовать в будущих проектах. Очень немногое
из Вашего начального капиталовложения в  программирование  Вам
никогда  не  понадобится.  Вам  редко понадобится переписывать
класс.  Если он будет служить так как  нужно,  то  используйте
его.  Если в нем чего-то не хватает, то расширьте его. Однако,
если он работает хорошо, то нет причины выбрасывать что-нибудь
из него.

                          Заключение

     С++ является прямым ответом на сложность современных при-
менений,  сложность,  которая часто приводит  многих  програм-
мистов  в  отчаяние.  Наследование и инкапсуляция - это крайне
эффективные способы для управления сложностью.  С++ обуславли-
вает  рациональный порядок для структур программного обеспече-
ния что,  подобно схеме таксономии,  обуславливает порядок без
навязывания ограничений.
     Добавьте к  этому  обещание  расширяемости  и  повторного
использования существующего кода,  и Вы будете иметь не только
комплект инструментов - Вы будете иметь инструменты для созда-
ния новых инструментов!


