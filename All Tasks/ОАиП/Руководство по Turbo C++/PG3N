                           ГЛАВА 3.
                             C++.

     С является подмножеством C++. Это означает, что Вы можете
компилировать С программы под C++,  но не можете компилировать
программы  C++  под С,  если программа использует конструкции,
уникальные для C++.  Некоторые ситуации  требуют  специального
рассмотрения. Одна функция func, объявленная в С дважды с раз-
личными типами аргументов, приведет к ошибке дублирования име-
ни. В C++ однако func будет интерпретироваться как перегружен-
ная функция - верно это или нет, зависит от других условий.
     Хотя C++  вводит новые ключевые слова и операторы для об-
работки классов,  некоторые возможности  C++  не  относятся  к
классам.  Мы вначале рассмотрим эти аспекты C++, поскольку они
могут использоваться независимо от классов,  а  затем  обсудим
особенности классов и механизм классов.

                           Ссылки.

     Тип ссылок C++ тесно связан с типом указателя. Тип ссылок
C++ создает алиас для объекта и позволяет Вам  передать  аргу-
менты  в функцию по ссылке.  Традиционный С передает аргументы
только по значению. В C++ Вы можете передать аргументы по зна-
чению или по ссылке.

                       Простые ссылки.

     Для объявления ссылки вне функции используется &:
     int i = 0;
     int &ir = i;     // ir - алиас для i
     ir = 2;          // аналогично i = 2
     Здесь создается lvalue ir,  как алиас для i, обеспечивая,
что инициализатор того же типа,  что и ссылка.  Любые операции
над ir будут давать тот же эффект,  что и операции над i. Нап-
ример ir = 2 присваивает 2 в i и &ir возвращает адрес i.

                      Аргументы ссылок.

     & может так же использоваться для  объявления  параметров
ссылочного типа внутри функции:
     void func1(int i);
     void func2(int &ir);
     ...
     int sum = 3;
     func1(sum);    // sum передается по значению
     func2(sum);    // sum передается по ссылке
     Аргумент sum, передаваемый по ссылке может быть изменен с
помощью func2. func1, с другой стороны, делает копию аргумента
сам (передается по значению),  так что sum не может быть изме-
нен в func1.
     Когда действительный аргумент Х передается  по  значению,
соответствующий  формальный аргумент функции получает копию Х.
Любые изменения в этой копии внутри тела функции не отражаются
на значении Х. Конечно функция может вернуть значение, которое
может быть использовано для изменения Х,  но функция не  может
прямо изменить параметр, передаваемый по значению.
     Традиционный способ изменения Х в С  использует  действи-
тельный аргумент &X,  адрес Х,  а не сам Х. Хотя &X передается
по значению, функция может обратиться к Х через копию &X. Даже
если функции не требуется изменить Х, полезно (хотя может при-
вести к опасным сторонним эффектам)  передавать  &X  особенно,
если Х - это большая структура данных.  Передача Х по значению
приводит к дорогому копированию структуры данных.
     Сравним 3 реализации функции treble:
                           Реализация 1
     int treble_1(n)
     {
       return 3*n;
     }
     ...
     int x, i = 4;
     x = treble_1(i);    // х = 12, i = 4
     ...
                           Реализация 2
     void treble_2(int* np)
     {
       *np = (*np)*3;
     }
     ...
     treble_2(int &i);    // i = 12

                           Реализация 3
     void treble_3(int& n);   // n - ссылочный тип
     {
       n = 3*n;
     }
     ...
     treble_3(i);             // i = 36
     Объявление формального аргумента type& t (или эквивалент-
но type &t) устанавливает t как тип "ссылка на тип". Так, ког-
да treble _3 вызывается с аргументом i и используется для ини-
циализации формального аргумента n,  следовательно n действует
как алиас для i, поэтому n = 3*n так же присваивает 3*i в i.
     Если инициализатор  -  это  константа или объект с типом,
отличающимся от ссылочного типа, Borland C++ создает временный
объект, для которого ссылка действует как алиас:
     int& ir = 6;    // создает временный объект типа int со
                        // значением 6
     float f;
     int& ir2 = f;   // создает временный объект типа int; f
                       // преобразуется до присваивания
     ir2 = 2.0       // ir2 сейчас = 2, но f не изменяется
     Автоматическое создание временных объектов позволяет пре-
образование ссылочных типов, когда формальные и действительные
аргументы различных (и не совместимых по присваиванию)  типов.
При  передаче  по  значению  проблемы  преобразования  меньше,
поскольку копия действительного аргумента может быть  действи-
тельно изменена до присваивания формальному аргументу.

                   Оператор сферы действия.

     Оператор сферы действия (или разрешения) :: позволяет Вам
обращаться к глобальному (или времени  действия  файла)  имени
даже если оно скрыто локальным переобъявлением этого имени:
     int i;               // глобальная i
     ...
     void func(void);
       {
         int i=0;         // локальное i скрывает глобальную
         i=3;             // это локальная i
         ::i = 4;         // это i - глобальное i
         printf (*%d*, i);  // выводит 3
       }
     Оператор ::  так же используется с классами, как обсужда-
ется ниже.
     Примечание. Этот код работает и в том случае,  если "гло-
бальная" i является статической переменной файлового уровня.

                   Операторы new и delete.

     Операторы new и delete выполняют динамическое распределе-
ние  и освобождение памяти аналогично стандартным библиотечным
функциям malloc и free.
     Упрощенный синтаксис
     указатель-на-имя = new имя <инициализатор>;
     delete указатель-на-имя;
     имя может быть  любого  типа,  за  исключением  "функция,
возвращающая ..." (однако указатель на функцию разрешен).
     new создает объект типа "имя",  распределяя (если возмож-
но) sizeof(имя) байт в свободной памяти (так же называемой ку-
ча). Время действия нового объекта начинается с точки создания
и  заканчивается  или  по  освобождению этой памяти оператором
delete, или окончанием программы.
     При успешном выполнении new возвращает указатель на новый
объект.  null указатель говорит об ошибке (такой, как недоста-
ток  или  фрагментированность  памяти кучи).  Как с malloc Вам
требуется проверять указатель на null до работы с новым объек-
том. Однако в отличие от malloc new вычисляет размер "имя" без
явного использования оператор sizeof.  Более того,  указатель,
возвращаемый new,  имеет правильный тип "указатель на "имя"" и
явное приведение типа не требуется.
     name *nameptr;     // name - любой нефункциональный тип
     ...
     if (!(nameptr = new name)) {
       errmsg("недостаточно памяти для имени");
       exit (1);
     }
     ...
     delete nameptr;    // разрушает name и освобождает
                        // sizeof(name) байт
     Примечание. new, являясь ключевым словом, не требует про-
тотипа.

                      Обработка ошибок.

     Можно задать функцию, которая будет вызываться при неуда-
че работы оператора new (возвращен 0). Чтобы сказать оператору
new    о    новой    функции-обработчике    ошибок,   вызовите
set_new_handler и предоставьте указатель на новый  обработчик.
Прототип для set_new_handler имеет следующий вид (из new.h):
     void (*set_new_handler( void (*) () )) ();
     set_new_handler возвращает  предыдущий обработчик и изме-
няет функцию _new_handler так,  что она указывает на новый об-
работчик, определенный Вами.

                   Оператор new и массивы.

     Если "имя"  -  это массив,  указатель,  возвращаемый new,
указывает на первый элемент массива.  При создании  с  помощью
new  многомерного массива,  должны быть заданы все размерности
массива:
     mat_ptr = new int[3][10][12];    // верно
     mat_ptr = new int [3][][12];     // неверно
     mat_ptr = new int [][10][12];    // неверно

                       ::operator new.

     При работе с объектами типа не-класс new работает,  вызы-
вая стандартную библиотечную программу ::operator new.  С объ-
ектом класс типа "имя" может быть определен оператор, называе-
мый имя::operator new.  new,  примененное к объекту типа класс
"имя",  вызывает  соответствующую имя::operator new,  если она
есть; иначе используется стандартная ::operator new.

                Оператор new и инициализаторы.

     Еще одно отличие new от malloc в том,  что он может иметь
инициализатор.  При  отсутствии  явных инициализаторов объект,
созданный new содержит случайные данные.  Объект, распределен-
ный через new и отличный от массива,  может быть инициализиро-
ван указанием выражения в ():
     int_ptr = new int(3);
     Массив классов с констрактором инициализируется констрак-
тором по умолчанию. Оператор new, определенный пользователем с
требуемой инициализацией,  имеет ключевое значение в констрак-
торах C++ в объектах типа класс.

                           Классы.

     Классы C++ являются расширением к предопределенным типам.
Каждый класс представляет уникальный набор объектов и операций
(методов) и преобразований для создания манипуляции и разруше-
ния этих объектов. Порожденные классы могут быть объявлены как
наследующие  элементы  от  одного или более базовых (или роди-
тельских) классов.
     В C++  структуры и объединения рассматриваются как классы
с определенным по умолчанию доступом.
     Упрощенное объявление класса
     класс имя-класса <:список-баз> {<список-элементов>}
     где класс - class, struct или union.
     Необязательный список баз - это список  базовых  классов,
из  которых наследует объекты и методы класс имя-класса.  Если
указаны  базовые  классы,  имя-класса  называется  порожденным
классом. Список баз имеет указатели доступа по умолчанию и до-
полнительно перекрывающие,  которые могут модифицировать права
доступа порожденного класса к элементам базового класса.
     Необязательный список элементов объявляет элементы класса
(данные и функции) с указателями доступа, которые устанавлива-
ют, какие функции могут обращаться к каким элементам.

                         Имя класса.

     Имя класса - это любой идентификатор,  уникальный  внутри
его  сферы действия.  Имя для структур,  классов и объединений
может быть пропущено.

                         Тип класса.

     Объявление создает уникальный типа класса имя-класса. Это
позволяет  Вам в дальнейшем объявлять объекты (или экземпляры)
этого типа класса и объекты,  производные из этого типа (такие
как указатели, ссылки, массивы классов и т.д.):
     class X {...};
     X x, *xr, *xptr, xarray[10];
// 4 объекта: тип Х, ссылка на Х, указатель на Х и массив Х

     staruct Y { ... };
     Y y, &yr, *yptr, yarray[10];
       // в Си будет
       // структура Y y, &yr, *yptr, yarray[10]

     union Z { ... };
     Z z, &zr, *zptr, zarray[10];
     Примечание: Различие между объявлением структур и объеди-
нений С и C++:  ключевые слова struct и union обязательны в С,
а  в C++ они необходимы только когда имена классов Y и Z скры-
ты.

                 Сфера действия имени класса.

     Имя класса имеет локальную сферу  действия  с  некоторыми
особенностями,  характерными для классов. Сфера действия имени
классов начинается с точки объявления и заканчивается при зак-
рытии блока.  Имя класса скрывает любой класс,  объект,  пере-
числение или функцию с тем же именем  в  его  сфере  действия.
Если имя класса объявлено в сфере действия,  содержащей объяв-
ления объекта,  функции или перечисления с тем  же  именем,  к
классу можно ссылаться только с использованием сложного указа-
теля типа.  Это означает,  что с  именем  класса  должны  быть
использованы ключевые слова class, struct или union. Например
     staruct S { ... };

     int S(struct S *Sptr);

     void func(void)
     {
       S t                  // неверно: нет ключевого слова,
                            // и функция S в сфере действия
       struct S s;          // верно: ключевое слово struct
       S(&s);               // верно: это вызов функции
     }
     C++ разрешает неполное объявление класса:
     class X;
     struct Y;
     union Z;
     Неполное объявление  разрешает ссылки на имена классов X,
Y или Z до полного определения  классов.  Конечно,  Вы  должны
сделать полное объявление класса до объявления и использования
объектов.

                     Объекты типа класс.

     Объекты типа класс могут быть присвоены (если копирование
не имеет ограничений), переданы как аргументы в функцию, возв-
ращены функцией (с некоторыми  исключениями),  и  т.д.  Другие
операции  над объектами типа класс и его элементами могут быть
определены пользователем рядом способов,  включая функции-эле-
менты  и  дружественные  функции,  переопределение стандартных
функций и операторов при их использовании с объектами  опреде-
ленного  класса.  Операторы и функции,  которые ограничены для
объектов определенного класса или группы  классов,  называются
функции-элементы для этого класса. C++ предоставляет механизм,
с помощью которого функция или оператор могут  вызываться  для
выполнения  различных  задач  в зависимости от типов или числа
аргументов или операндов.

                   Список элементов класса.

     Необязательный список элементов - это  последовательность
объявлений данных (любого типа,  включая перечисление, битовые
поля и др. классы), а также объявлений и определений функций с
возможными  указателями класса памяти и модификаторов доступа.
Эти объекты называются элементами класса. Указатели класса па-
мяти auto, extern и register не разрешены. Элементы могут быть
объявлены с указателем класса памяти static.

                      Функции-элементы.

     Функция, объявленная без указателя friend,  известна  как
функция-элемент этого класса. Функции, объявленные с модифика-
тором friend, называются дружественными функциями.
     Одно и  то же имя может быть использовано для более,  чем
одной функции при условии, что они отличаются типом или числом
аргументов.

                     Ключевое слово this.

     Нестатические функции-элементы воздействуют на объект ти-
па класс, с которым они вызваны. Например, если х - это объект
класса  Х и f - это функция-элемент Х,  то вызов функции х.f()
воздействует на х.  Аналогично,  если xptr - это указатель  на
объект  Х,  вызов функции xptr->f() воздействует на *xptr.  Но
откуда f знает на какой х воздействовать?  C++ предоставляет с
f указатель на х, называемый this. this передается как скрытый
аргумент во всех вызовах нестатических функций элементов.
     Ключевое слово this - это локальная переменная, доступная
в теле любой нестатической  функции-элементе.  this  не  нужно
объявлять и она редко явно используется в определении функции.
Однако она используется неявно внутри функции  при  ссылках  к
элементам. Если вызывается х.f(y), где y - это элемент Х, this
устанавливается в &x и y устанавливается в this->y,  что экви-
валентно x.y.

                       inline функции.

     Вы можете  объявить функцию-элемент внутри класса и опре-
делить ее где-либо. Альтернативно Вы можете объявить и опреде-
лить функцию -элемент внутри класса. В этом случае она называ-
ется inline функция.
     Borland C++ иногда не вызывает функцию,  а заменяет вызов
функции компилированным кодом тела функции.  Этот процесс, на-
зываемый  расширением inline тела функции,  не воздействует на
сферу действия тела функции или ее аргументов. inline расшире-
ние не всегда возможно.  Указатель inline говорит компилятору,
что Вы хотите получить inline расширение. Если задан указатель
класса register, компилятор может игнорировать inline.
     Явный или неявный запрос inline выгодно использовать  для
небольших,  часто используемых функций, таких как функции-опе-
раторы,  которые реализуют  перегрузку  операторов.  Например,
следующее объявление класса
     int i;           // глобальное int

     class X {
     public:
       char func(void) { return i; }   // по умолчанию inline
       char* i;
     }
     эквивалентно:
     inline char* X::func(void)  { return i; }
     func определена  "вне"  класса с явным указателем inline.
i, возвращаемое из func, - это char* i из класса Х.

                    Статические элементы.

     При объявлении данных и функций класса можно использовать
указатель класса памяти static. Такие элементы называются ста-
тическими элементами и отличаются от нестатических  элементов.
Для  нестатических  элементов  существуют  различные копии для
каждого объекта класса;  для статических элементов  существует
только  одна  копия  и Вы можете обращаться к ним без указания
конкретного объекта класса.  Если х - это статический  элемент
класса Х,  к нему можно обратиться как Х::х (даже если ни один
объект класса Х еще не создан).  Можно обратиться к х, исполь-
зуя  обычные  операторы доступа к элементам.  Например,  y.х и
yptr->x,  где y - объект класса Х и yptr - указатель на объект
класса  Х,  хотя выражения y и yptr не вычислены.  Статическую
функцию-элемент можно вызвать  с  или  без  специального  син-
таксиса:
     class X {
       int member_int;
     public:
       static void func(int i, X* ptr);
     };

     void g(void);
     {
       X obj;           // ошибка, если нет глобальной func()
       func(1, &obj);   // вызывает статическую func() из Х
       obj.func(1, &obj);
     }
     Поскольку статическая функция-элемент может быть  вызвана
без конкретного объекта, она не имеет указателя this. Это при-
водит к тому,  что статическая функция-элемент не может  обра-
титься к нестатическим элементам без явного указания объекта с
помощью "." или "->". Например с объявлениями предыдущего при-
мера func может быть определена:
     void X::func(int i, X* ptr)
     {
       member_int = i;       // к какому объекту относится
                             // member_int ? Ошибка
       ptr->member_int = i   // верно, сейчас мы знаем
     }
     В отличие от inline функций,  статическая функция-элемент
глобального  класса имеет внешнее редактирование.  Статическая
функция-элемент не может быть виртуальной.  Не разрешается за-
давать  статическую  и  нестатическую  функцию-элемент с одним
именем и с одинаковыми типами аргументов.
     Объявление статических   элементов  данных  в  объявлении
класса не является определением, поэтому для распределения па-
мяти и инициализации должно быть использовано определение.
     Статические элементы класса, объявленные локально в функ-
ции, - не редактируемые и не могут быть инициализированы. Ста-
тические элементы глобального класса могут быть  инициализиро-
ваны  как  обычные  глобальные  объекты,  но  только  в  сфере
действия файла.  Статические элементы подчиняются обычным пра-
вилам доступа к элементам класса за исключением того,  что они
могут инициализироваться.
     class X {
       ...
       static int x;
       ...
     };
     int X::x = 1;
     Главное использование  статических элементов - это сохра-
нение общей информации для всех  объектов  класса,  такой  как
число  созданных объектов или последний используемый ресурс из
пула,  разделяемого всеми объектами этого класса.  Статические
элементы так же используются для:
     - сокращения числа видимых глобальных имен.
     - того, чтобы сделать очевидным, какие статические объек-
ты логически принадлежат какому классу.
     - установления контроля доступа к их именам.

                   Сфера действия элемента.

     Выражение Х::func()  в  примере  из  предыдущего  раздела
использует имя класса Х с модификатором сферы действия, указы-
вающим,  что func несмотря на то,  что определена вне класса в
действительности функция-элемент Х и существует  внутри  сферы
действия Х.  Влияние Х::  расширяется на тело определения. Это
объясняет,  почему i,  возвращаемое  func,  ссылается  к  Х::i
(char* i из Х),  а не к глобальной int i. Без модификатора Х::
функция func будет использоваться как обычная функция, возвра-
щающая глобальное int i.
     Все функции-элементы  находятся  в  сфере   действия   их
класса, даже если определены вне класса.
     На элементы-данные класса Х  можно  ссылаться,  используя
операторы выбора,  "." и "->".  (Как и в структурах С).  Функ-
ции-элементы можно также вызывать, используя операторы выбора.
Например
     class X {

     public:
       int i;
       char name[20];
       X *ptr1;
       X *ptr2;
       void Xfunc(char*data, X* left, X* right);
     };
     void f(void);
     {
       X x1, x2, *xptr=&x1;
       x1.i = 0;
       x2.i = x1.i;
       xptr-> = 1;
       x1.Xfunc("stan", *x2, xptr);
     Если m - это элемент или базовый элемент класса Х,  выра-
жение Х::m называется квалифицированным именем;  оно имеет тот
же тип,  что и m и является lvalue,  если m - lvalue.  Главное
здесь то, что даже если имя класса Х скрыто другим типом, ква-
лифицированное имя Х::m будет обращаться к правильному элемен-
ту класса m.
     Элементы класса не могут быть добавлены  в  класс  другой
частью  Вашей  программы.  Класс  Х не может содержать объекты
класса Х,  но может содержать указатели или ссылки на  объекты
класса Х (аналогично структурам и объединениям С).

               Управление доступом к элементам.

     Элементы класса получают атрибуты доступа либо по умолча-
нию (в зависимости от ключевого слова  класса  или  размещения
объявления),   либо  используя  один  из  указателей  доступа:
public, private, protected. Смысл этих атрибутов:
     public
     Элемент может использоваться любой функцией.
     private
     Элемент может использоваться только  функциями-элементами
и дружественными классами, в которых они объявлены.
     protected
     То же,  что и для private, но дополнительно элемент может
использоваться функциями-элементами и дружественными классами,
производными от объявленного класса, но только в объектах про-
изводного типа.  (Производные классы описываются  в  следующем
разделе).
     Примечание: На объявление дружественных функций не влияют
указатели доступа.
     Элементы класса по умолчанию private и Вам требуется явно
указывать public или protected для перекрытия этого умолчания.
     Элементы структуры по умолчанию public и Вы можете перек-
рыть его указателями private или protected.
     Элементы объединения по умолчанию public;  это  не  может
быть  изменено.  Использование указателей доступа с элементами
объединения не разрешается.
     Модификатор доступа   (по  умолчанию  или  перекрывающий)
действует на все последующие  объявления  элементов,  пока  не
встретится другой модификатор доступа. Например
     class X {
       int i;     // Х::i по умолчанию private
       char ch;   // то же
     public:
       int j;     // эти 2 public
       int k;
     protected:
       int l;     // Х::l - protected
     };

     struct Y {
       int i;     // Y::y по умолчанию public
     private:
       int j;     // Y::j - private
     public:
       int k;     // Y::k - public
     };

     union Z {
       int i;   // public по умолчанию; другим быть не может
       double d;
     };
     Указатели доступа могут быть перечислены и  сгруппированы
в любой удобной последовательности.

           Доступ к базовым и производным классам.

     Когда Вы  объявляете  производный  класс  D,  Вы  задаете
список базовых классов B1, B2,...:
     класс D:список-баз{<список-элементов>}
     D наследует все элементы этих базовых классов.  Переопре-
деленные  элементы  базового  класса наследуются и к ним можно
обратиться,  используя перекрытие сферы.  D может использовать
только public и protected элементы из его базовых классов. Ка-
ким образом D видит атрибуты доступа наследуемых элементов?  D
может захотеть использовать public элемент из базового класса,
но это сделает его private вне необходимых функций.  Решение в
использовании указателей доступа в списке-баз.
     При объявлении D Вы можете использовать указатель доступа
public или private перед именем класса в списке-баз.
     class D : public B1, private B2, ... {
     ...
     }
     Примечание: protected  нельзя  использовать в списке-баз.
Объединения не имеют базовых классов и  объединения  не  могут
использоваться как базовые классы.
     Эти модификаторы не изменяют  атрибутов  доступа  базовых
элементов как их видит базовый класс,  хотя они могут изменить
атрибуты доступа базовых элементов для производного класса.
     По умолчанию  используется  private,  если D - объявление
class, и public, если D - объявление struct.
     Производный класс  наследует атрибуты доступа из базового
класса:
     public базовый-класс
     public элементы базового класса становятся public элемен-
тами  производного класса.  protected элементы базового класса
становятся protected элементами производного  класса.  private
элементы базового класса остаются private для базового класса.
     private базовый-класс
     Оба public  и  protected  элементы базового класса стано-
вятся private элементами производного класса. private элементы
базового  класса  остаются  private  элементами  для  базового
класса.
     В обоих  случаях заметьте,  что private элементы базового
класса остаются недоступными для функций элементов производно-
го  класса,  если только не было указано friend при объявлении
базового класса. Например
     class X : A {     // по умолчанию для класса - private A
     ...
     }
           // класс Х производный от класса А

     class Y : B, public C {   // перекрывает умолчание для С
     ...
     }
       // класс Y - производный (множественное наследование)
       // от В и С

     struct S : D {   // по умолчанию public
     ...              // S производная от D
     }
     struct T : private D, E {    // перекрывает умолчание для D
     ...                          // Е - по умолчанию public
     }
       // класс Т - производный (множественное наследование)
       // от D и Е
     Действие указателя доступа в списке баз  можно  изменить,
используя  квалифицированное имя в public или protected объяв-
лении производного класса. Например
     class B {
       int a;     // private по умолчанию
     public:
       int b, c;
       int Bfunc(void);
     };

     class X : private B {  // a, b, c, Bfunc - private в X
       int d;

     public:
       B::c;     // С было pprivate, сейчас public
       int e;
       int Xfunc(void);
     };

     int Efunc(X& x);
     Функция Еfunc может использовать только общие имена c,  e
и Xfunc.
     Функция Хfunc в Х, который объявляется от private В, име-
ет доступ к
     - установленным в public с
     - "личными к Х" элементам из В:b и Вfunc
     - к private и public элементам Х: d, e, Xfunc
     Однако Xfunc  не  может обращаться к private элементу B -
а.

                 Виртуальные базовые классы.

     При многократном наследовании базовый класс не может быть
указан более одного раза в производном классе:
     class B { ... };
     class D : B, B { ... };   // неверно
     Однако базовый класс может быть косвенно передан в произ-
водный класс более одного раза:
     class X : public B { ... }
     class Y : public B { ... }

     class Z : public X, public Y { ... }    // верно
     В этом случае каждый объект класса Z будет  иметь  2  по-
добъекта  класса В.  Если это приводит к проблемам,  с базовым
классом может быть указано ключевое слово virtual:
     class X : virtual public B { ... }
     class Y : virtual public B { ... }
     class Z : public X, public Y { ... }
     Сейчас В - виртуальный базовый  класс  и  класс  Z  имеет
только один подобъект класса В.

               Дружественные классы и функции.

     friend F класса Х - это функция или класс,  который, хотя
не является функцией-элементом Х, имеет полные права доступа к
private и protected элементам Х. В остальных отношениях F нор-
мальная функция с соответствующей сферой действия, объявлением
и определением.
     Поскольку F не элемент Х и не  в  сфере  действия  Х,  ее
нельзя  вызвать с помощью операторов выбора х.F и xptr->F (где
х - объект типа Х и xptr - указатель на Х).
     Если указатель  friend используется с объявлением или оп-
ределением функции внутри класса Х, она становится дружествен-
ной к Х.
     Дружественные функции,   определенные   внутри    класса,
используют  те же inline правила,  что и функции-элементы.  На
дружественные функции не влияет их положение внутри класса или
любые указатели доступа. Например
     class X {
       int i;    // private в X
       friend void friend_func(X*, int);
        // friend_func - не private, хотя
        //объявлена в private части
     public:
       void member_func(int);
     };

       // определения; заметим, что обе функции обращаются к
       // private int i
     void friend_func(X* xptr, int a)  { xptr->i = a; }
     void X::member_func(int a)  { i = a; }

     X obj;

     friend_func(&xobj, 6);
     xobj.member_func(6);
     Вы можете сделать все  функции  класса  Y  дружественными
классу Х одним объявлением:
     class Y;          // неполное объявление
     class X {
       friend Y;
       int i;
       void member_funcX();
     };

     class Y; {             // полное объявление
       void friend_X1(X&);
       void friend_X2(X*);
       ...
     };
     Функции, объявленные в Y,  дружественные к Х, хотя объяв-
лены без указателя friend. Они могут обращаться к private эле-
ментам Х, таким как i или member_funcX.
     Возможно так же определить функцию-элемент класса Х, дру-
жественной классу Y:
     class X {
       ...
       void member_funcX();
     }

     class Y {
       int i;
       friend void X::member_funcX();
       ...
     };
     Дружественность классов нетранзитивна: Х, дружественный к
Y и Y,  дружественный к Z не означает, что Х будет дружествен-
ный к Z. Однако дружественность наследуется.

                 Констракторы и дестракторы.

     Существует несколько специальных функций элементов, кото-
рые определяют,  как объекты класса  создаются,  инициализиру-
ются,  копируются и разрушаются.  Констракторы и дестракторы -
наиболее важны из них.  Они  имеют  большинство  характеристик
обычных  функций-элементов:  Вы  объявляете  и  определяете их
внутри класса или объявляете внутри класса и  определяете  вне
его, но они имеют некоторые уникальные особенности.
     1. Они не имеют объявления возвращаемого  значения  (даже
не используют void).
     2. Они не могут наследоваться,  хотя  производные  классы
могут вызвать констракторы и дестракторы базового класса.
     3. Констракторы, как большинство функций C++, могут иметь
аргументы по умолчанию или использовать списки инициализации.
     4. Дестракторы могут быть virtual, а констракторы - нет.
     5. Вы не можете взять их адресов.
     main()
     {
       ...
       void *ptr = base::base;   // неверно
       ...
     }
     6. Констракторы  и   дестракторы   могут   генерироваться
Borland C++,  если они не были явно определены; они так же вы-
зываются во многих случаях без явных вызовов в Вашей  програм-
ме. Любые констракторы и дестракторы, сгенерированные компиля-
тором, будут public.
     7. Вы  не  можете вызвать констрактор так,  как вызываете
обычную функцию. Дестрактор можно вызвать, если Вы используете
полностью квалифицированное имя.
     {
     ...
       X *p;
     ...
       p->X::~X();   // верный вызов дестрактора
       X::X();       // неверный вызов констрактора
     ...
     }
     8. Компилятор автоматически вызывает констракторы и дест-
ракторы при определении и удалении объектов.
     9. Констракторы и дестракторы могут вызывать оператор new
и delete, если требуется распределение объекта.
     10. Объект с  констрактором  или  дестрактором  не  может
использоваться как элемент объединения.
     Если класс Х имеет 1 или более констракторов, один из них
вызывается каждый раз, когда Вы определяете объект х класса Х.
Констрактор создает х и инициализирует его.  Дестрактор выпол-
няет обратный процесс,  разрушая объект, созданный констракто-
ром.
     Констрактор так же вызывается,  когда создается локальный
или временный объект класса;  дестрактор вызывается при выходе
из сферы действия объекта.

                        Констракторы.

     Констракторы отличаются  от других функций-элементов тем,
что они имеют то же самое имя,  что и класс,  к  которому  они
принадлежат.  Когда  объект этого класса создается или копиру-
ется, неявно вызывается соответствующий констрактор.
     Констракторы для  глобальных переменных вызываются до вы-
зова функции main. Когда используется директива начального ко-
да   pragma  для  инсталяции  функций,  выполняемых  до  main,
констракторы глобальных переменных выполняются до  этих  функ-
ций.
     Локальные объекты создаются  как  только  сфера  действия
этих переменных становится активной.  Констрактор так же вызы-
вается при создании временного объекта класса.
     class X
     {
     public:
       X();      // констрактор класса Х
     };
     Констрактор класса Х не может использовать  Х  как  аргу-
мент:
     class X {
     ...
     public:
       X(X);   // неверно
     }
     Параметры констрактора могут быть любого типа за исключе-
нием класса, элементом которого он является. Констрактор может
принимать в качестве параметра ссылку на свой класс;  при этом
он называется констрактором копирования.  Констрактор, который
не  использует параметры,  называется констрактором по умолча-
нию.

                  Констрактор по умолчанию.

     Констрактор по умолчанию для класса Х -  это  констрактор
без аргументов:  Х::Х().  Если нет констрактора, определенного
пользователем  для  данного  класса,  Borland  C++  генерирует
констрактор  по  умолчанию.  При  объявлении,  таком  как Х х,
констрактор по умолчанию создает объект Х.
     ВАЖНО! Как и все функции,  констракторы могут иметь аргу-
менты по умолчанию. Например констрактор
     X::X(int, int = 0)
     может использовать 1 или 2 аргумента.  При вызове с одним
аргументом  пропущенный  второй аргумент устанавливается в int
0. Аналогично, констрактор
     X::X(int = 5, int = 6)
     может использовать 2, 1 или без аргументов с соответству-
ющими умолчаниями. Однако констрактор Х::Х() не использует ар-
гументов и не должен быть смешан с Х::Х(int = 0),  который мо-
жет использовать 1 или 0 аргументов.
     Будьте осторожны во избежание неопределенности при вызове
констрактора.  В  следующем примере констрактор по умолчанию и
констрактор с целым параметром могут привести  к  неопределен-
ности:
     class X
     {
     public:
       X();
       X(int i = 0);
     };

     main()
     {
       X one(10);    // верно, использует X::X(int)
       X two;        // неверно, неопределено, вызывает
                     // X::X() или X::X(int = 0)
     ...
       return 0;
     }

                   Констрактор копирования.

     Констрактор копирования для класса Х -  это  констрактор,
который   может  быть  вызван  с  одним  аргументом,  типа  Х:
X::X(const X&) или X::X(const X&, int = 0). В констракторе ко-
пирования так же разрешены аргументы по умолчанию. Констракто-
ры копирования  вызываются  при  копировании  объекта  класса,
обычно  когда  Вы  объявляете с инициализацией другим объектом
класса:
     X x = y
     Borland C++ генерирует констрактор копирования для класса
Х, если он не определен в классе Х.

                  Перекрытие констракторов.

     Констракторы могут  быть  перекрыты,  позволяя  создавать
объекты в зависимости от значений, используемых от инициализа-
ции.
     class X
     {
       int integer_part;
       double double_part;
     public:
       X(int i)
       X(double d)
     };

     main()
     {
       X one(10);     // вызывает X::X(int) и устанавливает
                      // integer_part в 10
       X one(3.14);   // вызывает X::X(double) и устанавливает
                      // double_part в 3.14
     ...
       return 0;
     }

                Порядок вызова констракторов.

     В случае,  когда  класс  имеет  один  или  более  базовых
классов,  констракторы базовых классов вызываются до констрак-
тора производного класса. Констракторы базовых классов вызыва-
ются в порядке их объявления.
     Например для
       class Y { ... }
       class X : public Y { ... }
       X one;
констракторы вызываются в порядке:
       Y();  // констрактор базового класса
       X();  // констрактор производного класса
     Для случая нескольких базовых классов
       class X : public Y, public Z
       X one;
констракторы вызываются в порядке объявления:
       Y();  // констракторы базового класса идут первыми
       Z();
       X();
     Констракторы для  виртуальных  базовых классов вызываются
до любых невиртуальных базовых классов. Если иерархия содержит
множество виртуальных базовых классов,  констракторы виртуаль-
ных базовых классов вызываются в порядке их объявления.  Любые
невиртуальные  базовые констракторы вызываются до констрактора
производного класса.
     Если виртуальный класс произведен из невиртуального базо-
вого класса,  констрактор невиртуального базового класса будет
вызываться до констрактора виртуального базового класса. Код
     class X : public Y, virtual public Z
     X one;
приводит к порядку:
     Z();   // инициализация виртуального базового класса
     Y();   // невиртуальный базовый класс
     X();   // производный класс
Более сложный пример:
     class base;
     class base2;
     class level1 : public base2, virtual public base;
     class level2 : public base2, virtual public base;
     class toplevel : public level1, virtual public level2;
     toplevel view;
Порядок следования констракторов будет следующий:
     base();
     base2();
     level2();
     base2();
     level1();
     toplevel();
     В случае,  если иерархия классов содержит  несколько  эк-
земпляров виртуального базового класса,  констрактор этого ба-
зового класса вызывается только один раз. Однако, если сущест-
вует  виртуальный и невиртуальный образцы базового класса,  то
констрактор вызывается 1 раз для всех виртуальных экземпляров,
и  затем  по одному разу для каждого невиртуального экземпляра
этого базового класса.
     Констракторы для  элементов  массива вызываются в порядке
увеличения индекса.

                    Инициализация класса.

     Объект класса с только public элементами и без  констрак-
торов  или без базовых классов (например структура) может ини-
циализироваться  списком  инициализаторов.  Если  класс  имеет
констрактор,  его  объекты  должны быть либо инициализированы,
либо иметь констрактор по  умолчанию.  Последнее  используется
для неявной инициализации объектов.
     Объекты с констракторами могут  быть  инициализированы  с
помощью  списка  выражений в ().  Этот список используется как
список аргументов констрактора.  Альтернативно можно использо-
вать  "=" с одним значением.  Значение может быть типа первого
аргумента констрактора этого класса,  и в этом случае либо нет
дополнительных  аргументов,  либо  оставшиеся  аргументы имеют
значение по умолчанию. Значение может быть объектом этого типа
класса.  В первом случае для создания объекта вызывается соот-
ветствующий констрактор.  В последнем случае для инициализации
объекта вызывается констрактор копирования.
     class X
     {
       int i;
     public:
       X();
       X(int x);
       X(const X&);
     };

     main()
     {
       X one;         // вызывается констрактор по умолчанию
       X two(1);      // используется констрактор X::X(int)
       X three = 1;   // вызывается X::X(int)
       X four = one;  // вызывается X::X(const X&) для копирования
       X five(two);   // вызывается X::X(const X&)
     }
     Констрактор может  назначать значения его элементам двумя
способами.  Он может получать значения в качестве параметров и
выполнять присваивание элементам внутри тела констрактора:
     class X
     {
       int a, b;
     public:
       X(int i, int j)  { a = i, b = j }
     };
     Или он может использовать список  инициализации  до  тела
функции:
     class X
     {
       int a, b;
     public:
       X(int i, int j) : a(i), b(j) {}
     };
     В обоих случаях инициализация Х х(1,2) назначает значение
1  в  х::а и 2 в х::b.  Второй способ со списком инициализации
обеспечивает механизм для передачи значений в констракторы ба-
зовых классов.
     class base1
     {
       int x;
     public:
       base1(int i) { x = i; }
     };

     class base2
     {
       int x;
     public:
       base2(int i) : x(i) {}
     };

     class top : public base1, public base2
     {
       int a, b;
     public:
       top(int i, int j) : base1(i*5), base2(j+1), a(i)  { b = j; }
     };
     Примечание: Констракторы базового класса должны быть объ-
явлены как public или как protected,  чтобы их можно было выз-
вать из производного класса.
     С этой иерархией классов объявление top one(1,  2) приве-
дет к инициализации base1 = 5 и base2 = 3.  Можно использовать
смешанные способы инициализации.
     Как описано выше базовые классы инициализируются в поряд-
ке объявления. Затем инициализируются элементы так же в поряд-
ке объявления независимо от списка инициализации.
     class X
     {
       int a, b;
     public:
       X(int i, j) : a(i), b(a+j)  {}
     };
     С этим классом объявление Х х(1, 1) приводит к присваива-
нию 1 в х::а и 2 в х::b.
     Констракторы базовых классов вызываются до констракторов,
элементов производных классов. Значения производного класса не
могут быть изменены и они не воздействуют на создание базового
класса.
     class base
     {
       int x;
     public:
       base(int i) : x(i) {}
     };

     class derived : base
     {
       int a;
     public:
       derived(int i) : a(i*10), base(a)  {} // Посмотрите!
     };            // базовый будет передан без инициализации
     Вызов d(1) не воздействует на значение 10 для элемента  х
базового класса.  Значение,  переданное в констрактор базового
класса, неопределено.
     Когда Вы  хотите  использовать  список инициализации в не
inline констракторе, не помещайте список в определение класса.
Вместо этого разместите его в точке определения функции.
     derived::derived(int i) : a(i)
     {
     ...
     }

                         Дестракторы.

     Дестрактор для класса вызывается для освобождения элемен-
тов объекта до разрушения самого  объекта.  Дестрактор  -  это
функция-элемент,  чье имя - это имя класса с предшествующей ~.
Дестрактор не может иметь параметров и объявляется без возвра-
щаемого типа.
     class X
     {
     public:
       ~X();   // дестрактор для класса Х
     };
     Если для класса явно не определен дестрактор,  компилятор
генерирует его.

                 Когда вызывается дестрактор.

     Дестрактор неявно вызывается при выходе из сферы действия
переменной.  Дестракторы  для локальных переменных вызываются,
когда блок,  в котором они объявлены становится неактивным.  В
случае  глобальных переменных дестракторы вызываются как часть
процедуры выхода после main.
     При выходе из сферы действия указателя на объект дестрак-
тор неявно не вызывается. Это означает, что для разрушения та-
кого объекта должен быть вызван оператор delete.
     Дестракторы вызываются в  точно  противоположном  порядке
вызова соответствующих констракторов.

             atexit, #pragma exit и дестракторы.

     Все глобальные объекты активны до тех пор,  пока выполня-
ется код процедур выхода. Локальные переменные, включая объяв-
ленные  в  main,  разрушаются при выходе из их сферы действия.
Порядок выполнения в конце программы следующий:
     - Выполняются функции atexit в порядке их вставки.
     - Функции #pragma exit выполняются в  порядке  приоритета
их кода.
     - Вызываются дестракторы для глобальных переменных.

                     exit и дестракторы.

     Когда Вы вызываете exit из программы, дестракторы для лю-
бых  локальных  переменных в текущей сфере действия не вызыва-
ются. Глобальные переменные разрушаются как обычно.

                     abort и дестракторы.

     Если Вы вызвали в программе abort, дестракторы не вызыва-
ются даже для переменных с глобальной сферой действия.
     Дестракторы могут быть так же явно  вызваны  в  одном  из
двух случаев: косвенно через вызов delete или прямо, используя
полностью квалифицированное имя дестрактора. Вы можете исполь-
зовать delete для разрушения объектов,  которые были распреде-
лены с использованием new.  Явный вызов дестрактора  необходим
только для объектов, распределенных с определенным адресом че-
рез вызов new.
     class X {
     ...
       ~X();
     ...
     };

     void* operator new(size_t size, void *ptr)
     {
       return ptr;
     }

     char buffer[sizeof(X)];

     main()
     {
       X* pointer = new X;
       X* exact_pointer;

       exact_pointer = new(&buffer) X;    // указатель
                             // инициализируется адресом буфера

     ...
       delete pointer;          // используется для разрушения
                                // указателя
       exact_pointer->X::~X();  // для освобождения используется
                                // прямой вызов
     }

                   Виртуальные дестракторы.

     Дестрактор может быть объявлен как виртуальный.  Это поз-
воляет указателю на объект базового класса вызвать  правильный
дестрактор в случае,  если указатель в действительности ссыла-
ется на объект производного класса.  Дестрактор класса, произ-
водного  от класса с виртуальным дестрактором,  тоже виртуаль-
ный.
     class color
     {
     public:
       virtual ~color();  // виртуальный дестрактор для color
     };

     class red : public color
     {
     public:
       ~red();          // виртуальный дестрактор для red
     };

     class brightred : public red
     {
     public
       ~brightred();  // виртуальный дестрактор для brightred
     }
Предыдущие утверждения и следующие объявления
     color *palette[3];

     palette[0] = new red;
     palette[1] = new brightred;
     palette[2] = new color;
приводят к результату
     delete palette[0];  // дестрактор для red вызывается за
                         // дестрактором для color

     delete palette[1];  // вызывается дестрактор для brightred

     delete palette[2];  // вызывается дестрактор для color

     Однако в случае,  если нет дестракторов,  объявленных как
виртуальные,  delete  palette[0],  delete  palette[1],  delete
palette[2] будут вызывать только дестрактор для класса  color.
При этом будут некорректно разрушаться 2 первых элемента,  ко-
торые в действительности имеют типы red и brightred.

                   Перегруженные операторы.

     C++ позволяет  Вам  переопределить  действия  большинства
операторов  так,  чтобы  они выполняли специальные функции при
использовании с объектами определенного класса.  Как с  перег-
рузкой  функции C++,  компилятор различает различные функции в
зависимости от контекста вызова:  числа и типа аргументов  или
операндов.
     Все операторы, описанные в разделе "Описание операторов",
могут быть перегружены, за исключением
     .  .*  ::  ?:
     Препроцессорные символы  #  и ## так же не могут быть пе-
регружены.
     Ключевое слово "оператор", следующее за символом операто-
ра,  называется именем функции оператора; оно используется как
имя  обычной  функции  при определении нового (перегруженного)
действия оператора.
    Функция оператора, вызванная с аргументами, ведет себя так
же,  как оператор работает со своими операндами  в  выражении.
Функция  оператора не может изменить число аргументов или пра-
вила приоритета и ассоциативности (см.  таблицу 2.3), примени-
мые  к  использованию  обычного  оператора.  Рассмотрим  класс
complex:
     class complex {
       double real, imag;  // по умолчанию private
     public:
       ...
       complex()  { real = imag = 0;  }  // inline констрактор
       complex(double r, double i = 0) {
         real = r; imag = i;
       }
       ...
     }
     Мы можем  легко  определить  функцию  для  сложения комп-
лексных чисел.
     complex AddComplex(complex c1, complex c2);
но было бы более привычным написать
     complex c1(0,1), c2(1,0), c3
     c3 = c1 + c2;
чем
     c3 = AddComplex(c1, c2);
     Оператор + легко перегружается включением следующего объ-
явления в класс complex:
     friend complex operator +(complex c1, complex c2)
и его определением
     complex operator +(complex c1, complex c2)
     {
       return complex(c1.real + c2.real, c1.imag + c2.imag);
     }
     Примечание. Этот  класс был выдуман для иллюстрации.  Это
не тот класс complex,  который находится в библиотеке  времени
выполнения.

                      Функция-оператор.

     Функции-операторы могут быть вызваны напрямую, хотя обыч-
но они вызываются косвенно  при  использовании  перегруженного
оператора:
     c3 = c1.operator+(c2); // То же самое, что и с3 = с1 + с2
     В отличие от new и delete, которые имеют собственные пра-
вила,  функция оператор должна быть либо нестатической функци-
ей-элементом  или  иметь,  по  крайней  мере,  1 аргумент типа
класс.  Функции операторы =,  (),  [], -> должны быть нестати-
ческими функциями-элементами.

           Перегруженные операторы и наследование.

     За исключением  функции  оператора  присваивания =() (см.
"Перегруженный оператор присваивания") все перегруженные функ-
ции операторы для класса Х наследуются классами,  производными
от Х со стандартными правилами  разрешения  для  перегруженных
функций. Если Х - это базовый класс для Y, перегруженная функ-
ция-оператор для Х может быть в будущем перегружена для Y.

                 Перегруженные new и delete.

     Операторы new и delete могут быть перегружены для  созда-
ния альтернативных программ управления памятью кучи.  Оператор
new,  определенный пользователем,  должен возвращать  void*  и
использовать size_t как первый аргумент.  Оператор delete, оп-
ределенный пользователем, должен иметь возвращаемый тип void и
void* как первый аргумент;  второй аргумент типа size_t необя-
зателен (тип size_t определен в stdlib.h). Например
     #include <stdlib.h>

     class X {
       ...
     public:
       void* operator new(size_t size)
       void operator delete(void* p)
       X()   {  /* инициализация */ }
       X(char ch)  {  /* инициализация */ }

       ~X()  {  /* освобождение */ }
       ...
     };
     Аргумент size  дает  размер   создаваемого   объекта,   а
newalloc  и newfree - это пользовательские функции распределе-
ния и освобождения памяти.  Вызов констрактора  и  дестрактора
для объектов класса Х (или объектов класса,  производных от Х,
которые не имеют собственных перегруженных  операторов  new  и
delete)  производится соответствующими определенными пользова-
телем X::operator new() и X::operator delete().
     X::operator new  и  X::operator  delete - это статические
элементы Х вне зависимости от того,  объявлены они как  static
или нет, и не могут быть виртуальными функциями.
     Внутри сферы действия Х можно  использовать  стандартные,
предопределенные  операторы new и delete либо с помощью опера-
тора глобальной сферы действия (::operator  new  и  ::operator
delete), либо неявно при создании и разрушении объектов класса
не типа Х и не производных от Х. Например, Вы можете использо-
вать  стандартные  new  и delete при определении перегруженных
версий:
     void* X::operator new(size_t s)
     {
       void* ptr = new char[s];  // вызов стандартного new
       ...
       return ptr;
     }

     void X::operator delete(void* ptr)
     {
       ...
       delete (void*) ptr;   // вызов стандартного delete
     }
     Необходимость аргумента size в том,  что класс, производ-
ный из Х,  наследует Х::operator new. Размер объекта производ-
ного класса может значительно отличаться от базового класса.

                Перекрытие унарных операторов.

     Вы можете  перегрузить  унарные  постфиксные и префиксные
операторы, объявляя нестатическую функцию-элемент без аргумен-
тов или объявляя не функцию-элемент,  использующую 1 аргумент.
Если @представляет унарный оператор,  то @x и x@ могут интерп-
ретироваться либо как x.operator@(),  либо как operator@(x), в
зависимости от объявления. Если объявлены обе формы, неопреде-
ленность разрешается в соответствии с используемым стандартным
аргументом.
     Требуется осторожность при перегрузке ++ и --,  поскольку
использование постфикса и префикса нельзя отличить внутри  пе-
регруженной функции. Например
     class X {
       ...
       X operator ++()  { /* тело программы увеличения */}
     }
     ...
     X x, y;
     y = ++x;

               Перегрузка бинарных операторов.

     Вы можете перегрузить бинарный оператор,  объявляя неста-
тическую функцию-элемент,  использующую 1 аргумент, или объяв-
ляя не функцию-элемент (обычно friend),  использующую 2  аргу-
мента. Если @ представляет бинарный оператор, то x@y могут ин-
терпретироваться   либо   как   x.operator@(y),    либо    как
operator@(x,  y)  в зависимости от объявления.  Если объявлены
обе  формы,  неопределенность  разрешается  в  соответствии  с
используемым стандартным аргументом.

              Перегрузка оператора присваивания.

     Оператор присваивания = может быть перегружен объявлением
только нестатической функции-элемента. Например
     class String {
       ...
       String& operator = (String& str);
       ...
       String (String&);
       ~String();
     }
     Этот код  с  определением  String::operator=()  позволяет
присваивание строк str1=str2 как в других языках. В отличии от
других функций операторов,  функция оператор  присваивания  не
может  наследоваться  производными  классами.  Если для любого
класса Х нет пользовательского определения оператора =, опера-
тор = определяется по умолчанию как соответствующее присваива-
ние элементов класса Х:
     X& X::operator = (const X& source)
     {
     ...
     }

             Перекрытие оператора вызова функции.

     Вызов функции
     первичное-выражение(<список-выражений>)
     рассматривается как бинарный оператор с  операндами  пер-
вичное-выражение  и список-выражений (возможно пустой).  Соот-
ветствующий оператор функции - это operator(). Эта функция мо-
жет  быть определена пользователем для класса Х (и всех произ-
водных классов) только с помощью нестатической функции-элемен-
та.  Вызов х(arg1, arg2), где х - объект класса Х; интерпрети-
руется как x.operator()(arg1, arg2).

               Перекрытие оператора индексации.

     Аналогично операции индексации
     первичное-выражение[выражение]
     рассматривается как бинарный оператор с  операндами  пер-
вичное-выражение и выражение .  Соответствующий оператор функ-
ции - это operator[].  Эта функция может быть определена поль-
зователем  для  класса Х (и всех производных классов) только с
помощью нестатической функции-элемента.  Выражение х[y], где х
- объект класса Х; интерпретируется как x.operator[](y).

       Перекрытие оператора доступа к элементу класса.

     Доступ к элементу класса
     первичное-выражение -> выражение
     рассматривается как унарный оператор.  Функция operator->
должна быть нестатической функцией-элементом.  Выражение x->m,
где    х    -    объект   класса   Х,   интерпретируется   как
(x.operator->())->m,  поэтому функция operator->() должна либо
возвращать указатель на объект класса,  либо возвращать объект
класса, для которого определен operator->.

                     Виртуальные функции.

     Виртуальные функции позволяют производным классам исполь-
зовать  различные  версии  функции базового класса.  Вы можете
объявить виртуальную функцию в базовом классе,  используя клю-
чевое слово virtual, затем переопределить ее в любом производ-
ном классе даже если число и тип аргументов то же самое. Пере-
определенная  функция перекрывает функцию базового класса.  Вы
можете так же объявить  функцию  int  Base::Fun  (int)  и  int
Derived::Fun (int) даже когда они не виртуальные. Версия базо-
вого класса доступна в объектах производного класса через  пе-
рекрытие сферы действия.  Если они виртуальные, любая функция,
связанная с действительным типом объекта, доступна.
     Примечание. Виртуальные функции могут быть только элемен-
тами-функциями.
     Для виртуальных  функций Вы не можете изменить только тип
функции. Запрещено переопределять виртуальную функцию так, что
она  отличается только возвращаемым типом.  Если две функции с
одним именем имеют разные аргументы,  C++ рассматривает их как
различные, игнорируя механизм виртуальной функции.
     Если базовый класс В содержит виртуальную  функцию  vf  и
класс D,  производный от В,  содержит функцию vf того же типа,
то, если vf вызывается для объекта d или D, производится вызов
D::vf, даже если доступ производится через указатель или ссыл-
ку на В. Например
     struct B {
       virtual void vf1();
       virtual void vf2();
       virtual void vf3();
       void f();
     };
     class D : public B {
       virtual void vf1();   // указатель virtual верен, но
                             // необязателен
       void vf2(int);

       char vf3();           // неверно
       void f();
     };

     void extf()
     {
       D d;
       B* bp = &d;            // стандартное преобразование из
                              // D* в B*
       bp->vf1();             // вызов D::vf1
       bp->vf2();             // вызов B::vf2
       bp->f();               // вызов B::f
     }
     Перекрывающая функция  vf1 в D автоматически виртуальная.
Указатель virtual может быть использован в объявлении перекры-
вающей функции в производном классе, но его использование нео-
бязательно.
     Интерпретация вызова  виртуальной функции зависит от типа
объекта, для которого она вызывается; для вызова невиртуальной
функции  интерпретация  зависит только от указателя или ссылки
на объект, для которого она вызывается.
     Примечание: Виртуальные  функции  должны  быть элементами
того же класса и они не могут  быть  статическими  элементами.
Виртуальная функция может быть friend другого класса.
     Виртуальная функция в базовом классе,  как  все  элементы
функции базового класса,  должна быть определена или,  если не
определена, объявлена как "чистая":
     class B {
     virtual void vf(int)=0;   // =0 означает "чистая"
     В классе,  производном из базового класса,  каждая чистая
функция должна быть определена или объявлена как  чистая  (см.
следующий раздел "Абстрактные классы").
     Если виртуальная функция определена в базовом классе,  ее
необязательно переопределять в производном классе.  Вызовы бу-
дут просто вызывать базовую функцию.
     За гибкость виртуальных функций требуется платить: каждый
объект в производном классе обращается по указателю в  таблицу
функций  для  выбора  корректной  во время выполнения (позднее
связывание).

                     Абстрактные классы.

     Абстрактный класс - это класс с,  по крайней мере,  одной
"чистой" виртуальной функцией. Виртуальная функция указывается
как "чистая" с помощью указателя "чистой" функции.
     Абстрактный класс может использоваться только как базовый
класс для  других  классов.  Нельзя  создать  объект  базового
класса. Абстрактный класс нельзя использовать как тип аргумен-
та или как тип возврата функции.  Однако  Вы  можете  объявить
указатель  на  абстрактный класс.  Ссылки на абстрактный класс
разрешены при условии, что временный объект не требует инициа-
лизации. Например:
  class shape {       // абстрактный класс
    point center;
    ...
  public:
    where()
    move(point p)
    virtual void rotate(int) = 0;//чистая виртуальная функция
    virtual void draw(int) = 0;  //чистая виртуальная функция
    virtual void hilite(int) = 0;//чистая виртуальная функция
    ...
  }
  shape x;//ошибка, попытка создать объект абстрактного класса

    shape* sptr;  // указатель на абстрактный класс
    shape f();    // ошибка, абстрактный класс не может быть
                  // типом возврата

  int g(shape s); // ошибка, абстрактный класс не может быть
                  // типом аргумента функции

  shape& h(shape&); // ссылка на абстрактный класс, как
                   // возвращаемое значение или аргумент функции
     Предположим, что D - это производный класс из абстрактно-
го  класса В (его непосредственный базовый класс).  Для каждой
"чистой" виртуальной функции pvf в В, D должен либо обеспечить
определение pvf, либо объявить pvf как "чистую".
     Например, используя классы предыдущего примера:
     class circle : public shape {  // circle производный от
                                    // абстрактного класса

       int radius;                  // private

     public:
       void rotate(int)  { }
       void draw();
       void hilite() = 0;
     }
     Функции-элементы могут   быть   вызваны  из  констрактора
абстрактного класса,  но вызов  "чистой"  виртуальной  функции
прямо  или  косвенно  из такого констрактора приведет к ошибке
времени выполнения.

                     Сфера действия C++.

     Лексические правила сферы действия для C++,  в отличие от
сферы  действия  классов,  соответствуют  правилам для С с той
оговоркой,  что C++, в отличие от С, допускает объявление дан-
ных  и функций в любом месте,  где могут появляться операторы.
Эта гибкость требует осторожности при интерпретации  "включаю-
щей сферы действия" и "точки объявления".

                    Сфера действия класса.

     Имя М  элемента класса Х имеет сферу действия класса "ло-
кальную к Х"; и может использоваться только в следующих ситуа-
циях:
     - в функции-элементе Х
     - в таких выражениях, как х.М, где х - объект класса Х
     - в таких выражениях,  как xptr->M, где xptr - это указа-
тель на объект класса Х
     - в таких выражениях, как Х::М или D::M, где D - это про-
изводный класс класса Х
     - в опережающих ссылках внутри класса, элементом которого
является М.
     Имена классов,  перечислений  или  typedef,   объявленные
внутри класса Х, или имена функций, объявленных дружественными
к Х,  не являются элементами Х; их имена просто имеют включаю-
щую сферу действия.

                        Скрытые имена.

     Имя может  быть  скрыто явным объявлением того же имени в
включающем блоке или в классе. К скрытому элементу класса мож-
но  обратиться,  используя модификатор сферы действия с именем
класса:  Х::М.  К скрытому имени сферы действия файл (глобаль-
ное) можно обратиться с помощью унарного оператора ::,  напри-
мер ::g.  Имя класса Х может быть скрыто именем объекта, функ-
ции  или  перечисления,  объявленного внутри сферы действия Х,
вне зависимости от порядка объявления имен.  Однако к скрытому
имени  класса Х можно обратиться,  предваряя Х соответствующим
ключевым словом: class, struct или union.
     Точка объявления  для  имени х начинается непосредственно
после его полного объявления,  но до его инициализатора,  если
он есть.

               Суммарные правила действия C++.

     Следующие правила применимы ко всем именам, включая имена
typedef и классов при условии,  что C++ разрешает эти имена  в
данном контексте:
     1. Имя проверяется на неоднозначность.  Если  внутри  его
сферы   действия  однозначность  не  обнаружена,  инициируется
последовательность доступа.
     2. Если  нет ошибки управления доступом,  тестируется тип
объекта, функции, класса, typedef и т.д.
     3. Если имя используется вне функции или класса или пред-
варено унарным оператором доступа сферы действия  ::,  и  если
имя  неквалифицировано  бинарным оператором ::  или оператором
выбора элемента . и ->, то это имя должно быть глобальным объ-
ектом, функцией или перечислением.
     4. Если имя n появляется в форме Х::n,  х.n (где х - объ-
ект типа Х или ссылка на Х) или ptr->n (где ptr - указатель на
Х),  то n - это имя элемента Х или элемент класса, из которого
производится Х.
     5. Любое имя, которое не используется в статической функ-
ции-элементе,  должно  быть  объявлено в блоке,  в котором оно
встретилось или во включающем блоке,  или быть глобальным име-
нем.  Объявление  локального  имени n скрывает объявления n во
включающих блоках и глобальное объявление n. Имена в различных
сферах действия не перекрываются.
     6. Любое  имя,  не  используемое  в  нестатической  функ-
ции-элементе класса Х,  должно быть объявлено в блоке, в кото-
ром оно встретилось или во включающем блоке,  или быть элемен-
том класса Х,  или базового класса Х, или быть глобальным име-
нем.  Объявление локального имени n скрывает объявления  n  во
включающих  блоках функции-элементы класса и глобальные объяв-
ления n. Объявление имени элемента скрывает объявления того же
имени в базовых классах.
     7. Имя аргумента функции в определении функции имеет сфе-
ру действия самого внешнего блока этой функции.  Имя аргумента
функции в неопределяющем объявлении  функции  не  имеет  сферы
действия.  Сфера  действия аргумента по умолчанию определяется
точкой объявления этого аргумента,  но он не имеет  доступа  к
локальным переменным или нестатическим элементам класса. Аргу-
менты по умолчанию вычисляются в каждой точке вызова.
     8. Инициализатор   констрактора   вычисляется   в   сфере
действия самого внешнего блока этого констрактора так,  что он
может ссылаться к именам аргументов констрактора.
