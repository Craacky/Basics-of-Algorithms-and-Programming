                           ГЛАВА 2.

                   СПРАВОЧНИК МЕНЮ И ОПЦИЙ.

     Этот глава содержит описание каждого элемента меню и диа-
логового окна.  Она организована в порядке, в котором меню по-
являются на экране.  Информацию по запуску и  выходу  из  IDE,
использованию  опций командной строки IDE и общей информации о
работе IDE см. в главе 1.
┌─────────────────────────────────────────────────────────────────┐
│ Ё File Edit Search Run Compile Debug Project Options Window Help│
└─┬──┬─────┬───────┬──┬────┬───────┬────┬─────────┬───────┬───────┤
  │  │     │       │  │    │       │    │         │       └──────┐│
  │  │     │       │  │    │       │    │      ┌──┴───────────┐  ││
  │  │     │       │  │    │       │    │      │Compiler     >├─┐││
  │  │     │       │  │    │       │    │      │Transfer...   │ │││
  │  │     │       │  │    │       │    │      │Make...       │ │││
  │  │     │       │  │    │       │    └─────┐│Linker...     │ │││
  │  │     └──────┐│  │    │       └────────┐ ││Application...│ │││
  │  └───────────┐││  │    └───────────────┐│ ││Debugger...   │ │││
┌─┴─────────────┐│││┌─┴───────────────────┐││ ││Directories...│ │││
│About...       │││││Run           Ctrl-F9│││ │├──────────────┤ │││
│Clear desktop  │││││Program reset Ctrl-F2│││ ││Environment  >├┐│││
│Repaint desktop│││││Go to cursor       F4│││ │├──────────────┤││││
├───────────────┤││││Trace into         F7│││ ││Save...       │││││
│Transfer items │││││Step over          F8│││ │└──────────────┘││││
└───────────────┘││││Arguments...         │││ └┐             ┌─┘│││
                ┌┘││└─────────────────────┘│└─┐│┌────────────┴─┐│││
┌───────────────┴┐││┌──────────────────────┴─┐│││Preferences...││││
│Open...      F3 ││││Compile to OBJ C:MYF.OBJ││││Editor...     ││││
│New             ││││Make EXE file  C:MYF.EXE││││Mouse...      ││││
│Save         F2 ││││Link EXE file           ││││Desktop...    ││││
│Save as...      ││││Build all               │││└──────────────┘│││
│Save all        │││├────────────────────────┤││      ┌─────────┘││
│                ││││Remove massages         │││┌─────┴─────────┐││
│Change dir...   │││└────────────────────────┘│││Code generation│││
│Print           │││                          │││Entry/Exit Code│││
│Get info...     │││                          │││C++ options... │││
│DOS shell       │││                          │││Optimizations..│││
│Quit      Alt-X │││                          │││Source...      │││
└────────────────┘││                          │││Messages...    │││
                ┌─┘│                      ┌───┘││Names...       │││
┌───────────────┴─┐│┌─────────────────────┴───┐│└───────────────┘││
│Undo      Alt-Bsp│││Inspect...         Alt-F4││     ┌───────────┘│
│Redo             │││Evaluate/Modify   Ctrl-F4││ ┌───┴──────────┐ │
├─────────────────┤││Call stack...     Ctrl-F3│└┐│Size/Move     │ │
│Cut     Shift-Del│││Watches                > ├┐││Zoom     F5   │ │
│Copy     Ctrl-Ins│││Toggle breakpoint Ctrl-F8││││Tile          │ │
│Paste   Shift-Ins│││Breakpoints...           ││││Cascade       │ │
│Copy example     ││└─────────────────────────┘│││Next     F6   │ │
│Show clipboard   ││                     ┌─────┘││Close   Alt-F3│ │
├─────────────────┤│    ┌────────────────┴──┐   │├──────────────┤ │
│Clear    Ctrl-Del││    │Add watch...Ctrl-F7│   ││Message       │ │
└─────────────────┘│    │Delete watch       │   ││Output        │ │
                   │    │Edit watch...      │   ││Watch         │ │
┌──────────────────┴───┐│Remove all watches │   ││User screen   │ │
│Find...               │└───────────────────┘   ││Register      │ │
│Replace...            │┌───────────────────┐   ││Project       │ │
│Search again          ││Open project...    │   ││Project notes │ │
│Go to line number...  ││Close project      ├───┘├──────────────┤ │
│Previous error  Alt-F7││                   │    │List    Alt-0 │ │
│Next error      Alt-F8││Add item...        │    └──────────────┘ │
│Locate function       ││Delete item        │            ┌────────┘
└──────────────────────┘│Local options...   │┌───────────┴─────────┐
                        │Include files...   ││Contents             │
                        └───────────────────┘│Index    Shift-F1    │
                                             │Topic search Ctrl-F1 │
                                             │Previous topic Alt-F1│
                                             │Help on help         │
                                             └─────────────────────┘

                     Ё (системное) меню.
     ┌─────┐ ┌──────────┐
     │ Alt │ │ ПРОБЕЛ   │
     └─────┘ └──────────┘
     Ё меню появляется в левом углу полосы меню.  Alt-ПРОБЕЛ -
это наикратчайший путь попасть туда. Если Вы войдете в это ме-
ню,  то увидите несколько общих системных команд (About, Clear
Desktop, Repaint Desktop) и имена программ, которые Вы устано-
вили с помощью команды Options/Transfer (Опции/Переход).

                            About.

     Первой командой  меню является команда About.  При выборе
этой команды появится диалоговое окно,  которое покажет инфор-
мацию  о  версии Borland C++.  Для закрытия этого окна нажмите
Esc или OK (или нажмите Enter).

                        Clear Desktop.

     Выберите Ё/Clear Desktop для закрытия всех окон и  очище-
ния всех архивных списков. Эта команда полезна в начале нового
проекта.

                       Repaint Desktop.

     Выберите Ё/Repaint  Desktop  для  того,  чтобы  заставить
Borland  C++ перерисовать экран.  Это может стать необходимым,
например,  в случаях,  когда память для резидентной  программы
оставляет слева блуждающие символы на экране, или возможно пе-
реключение экрана отключено (Options/Debug/Display  swapping),
а Вы осуществляете пошаговое продвижение по программе.

                       Transfer items.

     Здесь появляются  все программы,  которые Вы установили с
помощью диалогового окна  Transfer  (Options/Transfer).  Чтобы
запустить  одну  из этих программ,  выберите ее имя из Ё меню.
Для того чтобы установить программы, появляющиеся в этом меню,
выберите Options/Transfer.
     Если Вы установили более  одной  программы  с  одинаковой
буквой  сокращения  в этом меню,  то по этому сокращению будет
выбрана программа,  стоящая первой в этом списке.  Второй эле-
мент можно выбрать путем его отметки или посредством использо-
вания клавиш со стрелками для перемещения к нему и последующим
нажатием Enter.

                          Меню File.
     ┌─────┐┌─────┐
     │ Alt ││  F  │.
     └─────┘└─────┘
     Меню File  позволяет  открывать и создавать файлы с прог-
раммами в окнах редактора.  Это меню позволяет также сохранять
изменения,  выполнять  другие  файловые функции,  осуществлять
временный выход в DOS и выходить совсем.

                           Open F3.

     File/Open команда  (Файл/Открыть)  показывает  диалоговое
окно  с  выбором программных файлов для их открытия в окне ре-
дактора. Ниже показано, как выглядит это диалоговое окно:

╔═[■]═════════════ Load a File ═════════════════╗
║ ┌──────────────────────────────┐              ║
║ │Name                          │              ║
║ │ *.*                       │∙││ [ Open ]     ║
║ └──────────────────────────────┘              ║
║  Files                                        ║
║   A.            │ TC.EXE         [ Replace ]  ║
║   A.C           │ TC000A.SWP                  ║
║   B.            │ TCCONFIG.TC                 ║
║   BGIDEMO.OBJ   │ TCDEF.DPR                   ║
║   C.            │ TCDEF.DSK                   ║
║   CD.BAK        │ TCHELP.TCH     [ Cancel ]   ║
║   CD.C          │ TCZIP.ZIP                   ║
║   EGAVGA.BGI    │ TDCONFIG.TD                 ║
║                                  [ Help ]     ║
║                                               ║
║ E:\BORLANDC\*.*                               ║
║ A.                 2050  Jan 5,1991  10:55am  ║
╚═══════════════════════════════════════════════╝
     Диалоговое окно содержит окно ввода, список файлов, кноп-
ки,  помеченные как Open (Открыть), Replace (Заменить), Cancel
(Отказ)  и Help (Справочная информация),  и информационную па-
нель,  описывающую выбранный файл.  Теперь Вы можете выполнять
любое из следующих действий:
     - Наберите полное имя файла и выберите Replace (заменить)
или Open (открыть).  Open загружает файл в новое окно редакто-
ра.  При выборе Replace окно редактора должно  быть  активным;
содержимое окна заменяется выбранным файлом.
     - Наберите имя файла со  спецификатором  (знаком  вопроса
или звездочкой),  что фильтрует список файлов в соответствии с
Вашими спецификациями.
     - Нажимайте  ∙ для выбора спецификации файла из архивного
списка файловых спецификаций, который Вы ввели ранее.
     - Просмотрите содержимое различных справочников путем вы-
бора имен справочников из списка файлов.
     Окно ввода  позволяет  набрать  точное  имя файла или имя
файла со стандартными спецификаторами DOS (* или ?) для  филь-
трации имен,  появляющихся в окне архивного списка. При наборе
полного имени и нажатии Enter,  Borland C++ откроет его.  (При
введении имени файла,  которое Borland C++ найти не может,  он
автоматически создает и открывает новый файл с этим именем).
     Если Вы  нажимаете  ∙  при мерцании курсора в окне ввода,
ниже окна появится архивный  список.  Этот  список  показывает
последние восемь имен файлов,  которые Вы вводили. Выбор имени
осуществляется посредством двойного его отмечания или  выбором
с помощью клавиш со стрелками и нажатием Enter.
     Как только Вы набрали или выбрали требуемый файл, отметь-
те Open кнопку (выберите Cancel в том случае, если Вы изменили
свое решение).  Также можно нажать Enter,  как только файл был
выбран, или можно дважды отметить имя файла.
     Примечание. Если Вы выбрали Replace вместо Open,  то выб-
ранный файл заменит файл в активном окне редактора вместо отк-
рытия нового окна.

                Использование окна File list.

     Окно списка файлов показывает имена всех файлов в текущем
справочнике, соответствующих спецификациям в окне ввода, пока-
зывает родительский справочник и все подсправочники. Нажимайте
окно списка или нажимайте Tab до тех пор, пока имя окна списка
не высветится.  Для выбора имени файла можно нажимать ° и ∙, а
затем нажать Enter для его открытия.  Можно также дважды отме-
тить в окне имя любого файла для его открытия. Для того, чтобы
видеть все имена,  нужно делать скроллинг.  Если имеется более
одной клетки с именами, можно использовать также Ў и ў.
     Примечание. Можно  также  набирать строчные буквы для по-
иска имен файлов и прописные буквы для поиска имен  справочни-
ков.
     Панель файловой информации внизу  диалогового  окна  File
показывает имя пути,  имя файла,  дату,  время и размер файла,
который был выбран в окне списка.  (Заметим,  что ни один эле-
мент этой панели нельзя выбрать). По мере передвижения по окну
списка эта панель постоянно обновляется.

                         New (Новый).

     File/New команда позволяет открыть новое окно редактора с
именем  по умолчанию NONAMExx.  (xx - число от 00 до 99).  Эти
NONAME файлы  используются  как  временные  буферы  редактора;
Borland  C++  предлагает назвать NONAME файл,  когда Вы хотите
его сохранить.

                      Save (Сохранить).
     ┌────┐
     │ F2 │.
     └────┘
     File/Save команда сохраняет файл,  находящийся в активном
окне редактора,  на диск.  (Этот элемент меню недоступен, если
нет активного окна редактора).  Если файл имеет имя по умолча-
нию (NONAME00.C или подобное),  Borland C++ откроет диалоговое
окно Save Editor File (Сохранить редактируемый файл) для того,
чтобы  позволить  Вам  переименовать и сохранить его в текущем
справочнике или на другом устройстве.  Это диалоговое окно по-
добно окну,  открывающемуся для Save As (сохранить как) коман-
ды, описанной дальше.

                  Save As (Сохранить  как).

     File/Save As команда позволяет  сохранить  файл,  находя-
щийся в активном окне редактора,  под другим именем,  в другом
справочнике,  на другом устройстве.  После выбора этой команды
можно увидеть Save File As диалоговое окно:

╔═[█]════════════ Save File As ═════════════════╗
║┌───────────────────────────────┐              ║
║│ Save File As                  │              ║
║└───────────────────────────────┘  [  OK  ]    ║
║┌────────────┬──────────────┐                  ║
║│ Files      │              │                  ║
║│  A.C       │              │                  ║
║│  CD.C      │              │                  ║
║│  BGI\      │              │                  ║
║│  INCLUDE\  │              │                  ║
║│  ..\       │              │                  ║
║│            │              │     [ Cancel ]   ║
║│            │              │                  ║
║│            │              │                  ║
║│            │              │     [ Help ]     ║
║└────────────┴──────────────┘                  ║
║ E:\BORLANDC\*.C                               ║
║ A.C                1467  Jan 4,1991  11:29am  ║
╚═══════════════════════════════════════════════╝
     Наберите новое имя,  необязательно с устройством и  спра-
вочником, и нажмите или выберите ОК. Все окна, содержащие этот
файл, обновятся с этим новым именем.

                  Save All (Сохранить все).

     File/Save All команда работает точно так же, как Save ко-
манда,  за исключением того, что она сохраняет содержание всех
модифицированных файлов,  а не только файл,  находящийся в ак-
тивном  окне редактора.  Эта команда недоступна,  если ни одно
окно редактора не открыто.

               Change Dir (Сменить справочник).

     File/Change Dir команда  позволяет  задать  устройство  и
справочник  как текущий.  Текущий справочник - это справочник,
который Borland C++ использует для сохранения файлов и их  по-
иска.     (При    использовании    относительных    путей    в
Options/Directories (Опции /Справочники), они относятся только
к текущему справочнику).
     Диалоговое окно Change Directory выглядит следующим обра-
зом:

╔═[█]═══════ Change Directory ════════════╗
║┌─────────────────────────────────┐      ║
║│ Directory Name                  │      ║
║│  E:\TEMP                    │∙│ │      ║
║└─────────────────────────────────┘      ║
║┌ Directory Tree───────────┐  [ OK ]     ║
║│   Drives                 │             ║
║│   └─┬E:\                 │             ║
║│     └─┬TC                │ [ Chdir ]   ║
║│       └┬─BGI             │             ║
║│        └─INCLUDE         │             ║
║│                          │ [ Revert ]  ║
║│                          │             ║
║│                          │             ║
║│                          │  [ Help ]   ║
║└──────────────────────────┘             ║
╚═════════════════════════════════════════╝

     Существует два способа смены справочников:
     - Набрать путь нового справочника и нажать Enter, или
     - Выбрать  требуемый  справочник  в  дереве  справочников
(если Вы используете клавиатуру,  нажмите Enter, чтобы сделать
справочник  текущим),  а затем выберите ОК или нажмите Esc для
выхода из диалогового окна.
     При выборе ОК изменения будут сделаны,  а диалоговое окно
исчезнет.  При выборе ChDir кнопки окно списка Directory  Tree
сменится  на  выбранный  справочник и покажет подсправочники в
высвеченном справочнике (нажмите Enter или дважды отметьте за-
пись,  дающую Вам тот же результат). Если Вы изменили свое ре-
шение по выбранному справочнику и хотите вернуться к  предыду-
щему (и Вы еще не вышли из диалогового окна),  выберите Revert
кнопку.

                       Print (печать).

     File/Print команда позволяет печатать содержание активно-
го  окна редактора.  Borland C++ расширяет табуляции (заменяет
символы табуляции соответствующим количеством пробелов) и  за-
тем посылает их на печатающее устройство DOS.  Эта команда не-
доступна,  если активное окно нельзя распечатать.  Используйте
Ctrl-K P для печатания только текста.

               Get Info (Получить информацию).

     File/Get Info  команда  показывает информацию по текущему
файлу.

╔═[█]═══════════════════ Information ════════════════════════╗
║                                                            ║
║  Current directory : E:\BORLANDC                           ║
║  Current file      : E:\BORLANDC\A.C                       ║
║  Extended memory in use       : 0                          ║
║  Expanded memory (EMS) in use : 0                          ║
║                                                            ║
║  Lines compiled: 0             No program loaded.          ║
║  Total warnings: 0             Program exit code:          ║
║  Total errors  : 0             Available memory: 391K      ║
║  Total time: 0.0 ms            Last step time: 0.0 ms      ║
║                                                            ║
║                         [ OK ]             [ Help ]        ║
║                                                            ║
╚════════════════════════════════════════════════════════════╝

     Это информация только для просмотра;  нельзя менять уста-
новки в этом окне.  Следующая таблица расскажет,  что означает
каждая строка в окне получения информации и где можно изменить
при желании установки:
______________________________________________________________

 Установка                        Значение
______________________________________________________________

Текущий справочник             Справочник по умолчанию
Текущий файл                   Файл в активном окне
Использование extended памяти  Количество extended памяти, за-
                               резервированной   Borland  C++;
                               показывает 0,  если  IDE  нахо-
                               дится в защищенном режиме
Использование expanded памяти  Количество expanded памяти, за-
                               резервированной Borland C++
Откомпилировано строк          Число откомпилированных строк
Всего предупреждений           Число выданных предупреждений
Всего ошибок                   Число сгенерированных ошибок
Программа загружена            Состояние отладки
Код завершения программы       Код завершения  DOS   последней
                               завершенной программы
Доступная память               Количество свободной (640K) па-
                               мяти  DOS.  В режиме защиты это
                               значение  равно  числу   байтов
                               extended памяти
Время последнего шага          Количество времени, потраченно-
                               го на последний шаг отладки
______________________________________________________________

              DOS Shell (временный выход в DOS).

     File/DOS Shell   команда   позволяет   временно  покинуть
Borland C++ для введения команды DOS или программы.  Для возв-
рата в Borland C++, наберите EXIT и нажмите Enter.
     Вы можете столкнуться с тем,  что во время отладки  будет
недостаточно памяти для выполнения этой команды. В этом случае
завершите сеанс отладки посредством выбора  Run/Program  Reset
(CtrlF2).
     Предупреждение: Не  инсталируйте  никакие  TSR  программы
(такие,  как SideKick), если временно вышли в DOS, так как па-
мять может стать нераспределяемой.
     Примечание. В  режиме  двойного монитора командная строка
DOS появится на экране Borland C++,  а не на пользовательском.
Это  позволяет  Вам  переключиться на DOS без нарушения вывода
своей программы.  Поскольку вывод Вашей программы допустим  на
одном мониторе системы,  Window/User Screen и Alt-F5 недоступ-
ны.
     Можно также  использовать  элементы  перехода  в  Ё  меню
(системном) для быстрого переключения на другую программу  без
выхода из Borland C++.

                        Quit (Выход).
     ┌─────┐ ┌─────┐
     │ Alt │ │  X  │.
     └─────┘ └─────┘
     File/Quit команда приводит к выходу из Borland C++,  уда-
ляет его из памяти и возвращает Вас в  командную  строку  DOS.
Если Вы не сохранили какие-то изменения, то Borland C++ запра-
шивает, хотите ли Вы их сохранить перед выходом.

                       Меню редактора.
     ┌─────┐ ┌─────┐
     │ Alt │ │  E  │.
     └─────┘ └─────┘
     Меню редактора позволяет вырезать, копировать и вставлять
текст в окне редактора. Если Вы сделали ошибки, то можете вер-
нуться к предыдущему варианту изменений.  Можно также  открыть
окно  кармана для просмотра и редактирования его содержимого и
копировать текст из окон Message и Output.
     Перед использованием  большинства  команд  этого меню Вам
необходимо знать,  как выбирать текст (потому что  большинство
действий  редактора  применяются  к выбранному тексту).  Выбор
текста означает его высвечивание. Можно выбирать текст и с по-
мощью клавиатуры,  и с помощью мышки;  принцип одинаков,  хотя
действия отличаются.
     С помощью клавиатуры можно использовать следующие методы:
     - Нажатие Shift во время нажатия клавиш со стрелками;
     - Чтобы  выбрать  текст  с  помощью  клавиатуры,  нажмите
Ctrl-K B для отметки начала блока.  Затем передвиньте курсор к
концу блока и нажмите Ctrl-K K.
     - Чтобы выбрать отдельное  слово,  передвиньте  курсор  к
слову и нажмите Ctrl-K T.
     - Чтобы выбрать отдельную строку, нажмите Ctrl-K L.
     С помощью мышки:
     - Чтобы выбрать текст с помощью мышки,  тащите  указатель
мышки над требуемым текстом. Если же необходимо продолжить вы-
бор за краем окна, тащите мышку в нужную сторону, и окно авто-
матически будет сдвигаться.
     - Для выбора отдельной строки дважды отметьте ее.
     - Для  выбора  текста  строка за строкой,  нажмите кнопку
мышки и тащите мышку по тексту.
     - Чтобы расширить или уменьшить выбранный кусок, одновре-
менно нажмите Shift и клавишу мышки в любом месте документа.
     Как только текст выбран,  команды в меню редактора стано-
вятся доступными, а карман становится полезным.
     Карман является  чудом  после вырезания и вставки текста.
Это специальное окно в Borland C++,  которое хранит текст, ко-
торый был удален или скопирован,  так что можно вставить его в
любом месте.  Карман работает в тесном взаимодействии с коман-
дами редактора.
     Далее приводится объяснение каждой команды меню  редакто-
ра.

            Undo (Возврат к предыдущему варианту).
    ┌───┐ ┌──────┐
    │ALT│ │ПРОБЕЛ│
    └───┘ └──────┘
     Команда Edit/Undo  восстанавливает  файл в текущем окне в
том виде,  в каком он находился перед самой недавней  командой
редактора или перемещением курсора.  Над операциями, над кото-
рыми можно сделать "откат", существуют ограничения. Undo вста-
вит любые символы,  которые были удалены, удаляет любые симво-
лы,  которые были вставлены,  заменяет любые символы,  которые
были перекрыты и возвращает курсор к предшествующей позиции.
     Откат по операциям с блоками восстанавливает маркеры бло-
ка по значениям, предшествующим операции. Undo не изменяет ка-
кие-либо установки опций,  имеющих  общее  влияние.  Например,
если Вы использовали клавишу Ins для изменения режима с Insert
на Overwrite,  а затем выбрали Undo, Вы не вернетесь обратно в
режим Insert.  Однако если Вы удалили символ,  переключились в
режим Overwrite,  а затем выбрали Undo,  только что  удаленный
символ будет вставлен. Эффект действия, которое было выполнено
(удаление символа), отменяется независимо от установки режима.
     Изменение глобальных  опций  редактирования может сделать
действие Undo отличным от того,  которое Вы ожидали. Например,
если  Вы нажали Tab,  изменили значение Tab Width в диалоговом
окне Editor Options,  а затем выбрали Undo, то курсор вернется
к старому положению табуляции (основанной на конкретных значе-
ниях в буфере Undo). Как только Вы начнете набирать текст, од-
нако, курсор передвинется к новому положению табуляции.
     Опция Group  Undo  в  диалоговом  окне   Editor   Options
(Options/Environment/Editor) влияет на выполнение команда Undo
и Redo.

                            Redo.

     Команда Edit/Redo отменяет эффект самой недавней  команды
Undo.  Команда  Redo оказывает действие немедленно сразу после
команды Undo или другой команды Redo.  Серия команд Redo отме-
няет действия серии команд Undo.

                       Cut (вырезать).
     ┌───────┐ ┌─────┐
     │ Shift │ │ Del │.
     └───────┘ └─────┘
     Edit/Cut команда  удаляет  выбранный текст из документа и
помещает этот текст в карман.  Можно вставить этот текст в лю-
бой  другой документ (или в другое место в этом же самом доку-
менте) посредством  выбора  команды  Paste  (вставить).  Текст
остается  в  кармане,  так  что  можно вставлять один и тот же
текст много раз.

                      Copy (копировать).
     ┌───────┐ ┌─────┐
     │ Ctrl  │ │ Ins │.
     └───────┘ └─────┘
     Edit/Copy команда оставляет выбранный  текст  нетронутым,
но  помещает  его  точную копию в карман.  Можно вставить этот
текст в любой другой документ посредством выбора команды Paste
(вставить).  Можно  также скопировать текст из окна справочной
информации:  с клавиатуры,  используйте  Shift  и  клавиши  со
стрелками;  с мышкой,  нажмите и тащите текст,  который хотите
скопировать.  Если окно Output или Message является  активным,
когда  Вы  выбрали  Edit/Copy,  то  все содержание буфера окна
(включая невидимые элементы) копируется в карман.

                      Paste (вставить).
     ┌───────┐ ┌─────┐
     │ Shift │ │ Ins │.
     └───────┘ └─────┘
     Edit/Paste команда вставляет текст из кармана  в  текущем
окне в позицию, указанную курсором. Текст, который вставляется
в настоящий момент,  в окне кармана помечен как текущий  блок.
Нельзя делать вставку в окно Output или Message.

              Copy Example (скопировать пример).

     Edit/Copy Example  команда копирует текст с выбранным ра-
нее примером из текущего окна справочной информации в  карман.
Примеры уже заранее определены как блоки, так что не нужно по-
мечать требуемый пример как блок.

              Show Clipboard (показать карман).

     Edit/Show Clipboard команда открывает окно кармана, кото-
рый  хранит текст,  вырезанный и скопированный из других окон.
Текст,  который является текущим выбранным (высвеченным) - это
текст, который Borland C++ использует при выборе команды Paste
(вставить).
     Можно считать  окно  кармана архивным списком вырезаний и
копирований.  Можно редактировать карман так, чтобы текст, ко-
торый нужно вставить, точно соответствовал требуемому. При вы-
боре команды Paste (вставить),  Borland C++ использует выбран-
ный текст из кармана.
     Окно кармана похоже на любое другое окно редактора; можно
передвигать его, изменять размер, осуществлять скроллинг и ре-
дактировать его содержание.  Единственное отличие окна кармана
возникает при вырезании или копировании текста.  Когда Вы выб-
рали текст в окне кармана и затем выбрали команду  Cut  (выре-
зать) или Copy (копировать),  выбранный текст немедленно появ-
ляется внизу окна.  (Помните, что любой текст, который был вы-
резан  или  скопирован,  добавляется в конец кармана - так что
можно позднее его вставить).
     Примечание. Обычно содержание кармана сохраняется в тече-
ние сеанса работы,  хотя Вы можете управлять  этим,  используя
Options/Environment/Desktop.

                      Clear (очистить).
     ┌──────┐ ┌─────┐
     │ Ctrl │ │ Del │
     └──────┘ └─────┘
     Edit/Clear команда  удаляет  выбранный текст,  не помещая
его в карман.  Это означает,  что нельзя вставить этот  текст,
как  в  случае  выбора команд Cut (вырезать) или Copy (копиро-
вать).  Текст,  удаленный с помощью этой команды, не восстано-
вим. Можно очистить сам карман, выбрав весь текст в кармане, а
затем команду Edit/Clear.

                         Меню поиска.
     ┌──────┐┌─────┐
     │ Alt  ││  S  │
     └──────┘└─────┘
     Меню поиска позволяет осуществлять поиск текста, объявле-
ния функции и месторасположение ошибок в Ваших файлах.

                        Find  (поиск).

     ┌──────┐ ┌─────┐ ┌─────┐
     │ Alt  │ │  S  │ │  F  │
     └──────┘ └─────┘ └─────┘
     Search/Find команда показывает  диалоговое  окно  поиска,
позволяющее Вам набрать текст, который Вы хотите найти и уста-
новить опции,  влияющие на поиск.  (Ctrl-Q F  является  другим
сокращением этой команды).

╔═[█]═══════════════════ Find ════════════════════════╗
║ ┌─────────────────────────────────────────────────┐ ║
║ │Text to Find                                  │∙││ ║
║ └─────────────────────────────────────────────────┘ ║
║  Options                    Direction               ║
║   [X] Case sensitive         (.) Forward            ║
║   [ ] Whole words only       ( ) Backward           ║
║   [X] Regular expression                            ║
║                                                     ║
║  Scope                      Origin                  ║
║   (.) Global                 (.) From cursor        ║
║   ( ) Selected text          ( ) Entire scope       ║
║                                                     ║
║                   [  OK  ]  [ Cancel ]   [ Help ]   ║
║                                                     ║
╚═════════════════════════════════════════════════════╝

     Диалоговое окно поиска содержит несколько кнопок:
                   ┌──────────────────────┐
                   │ [ ]  Case  sensitive │
                   └──────────────────────┘
           (различение  прописных и строчных букв).
     Включайте эту  кнопку  в том случае,  если хотите,  чтобы
Borland C++ различал прописные и строчные буквы.

                 ┌─────────────────────────┐
                 │ [ ]  Whole  words  only │
                 └─────────────────────────┘
                    (только  целые слова).
     Включайте эту кнопку в том  случае,  если  хотите,  чтобы
Borland  C++ искал только целые слова (то есть,  строка должна
иметь знаки пунктуации или знаки символа пробела с обеих  сто-
рон).

                  ┌────────────────────────┐
                  │ [ ] Regular expression │
                  └────────────────────────┘
                   (регулярное выражение).
     Включайте эту  кнопку  в том случае,  если хотите,  чтобы
Borland C++ распознавал спецификаторы,  аналогичные используе-
мым в GREP, в строке поиска. Спецификаторами являются ^, $, .,
*, +, [], \. Они означают следующее:
     ^ - в начале строки означает начало строки.
     $ - в конце выражения означает конец строки.
     . - означает любой символ.
     * - Символ,  сопровождаемый  звездочкой,  означает  любое
         число повторений (включая нуль) этого символа. Напри-
         мер, bo* означает bot, b, boo, и даже be.
     + - Символ,  сопровождаемый знаком плюса,  означает любое
         число повторений этого символа (но не  нуль).  Напри-
         мер, bo+ означает bot или boo, но не be или b.
    [] - Символы в квадратных скобках означают  какой-то  один
         символ, стоящий в этих скобках. Например, [bot] озна-
         чает или b, или o, или t.
   [^] -  этот знак в квадратных скобках в начале строки озна-
         чает Not.  Таким образом,  [^bot] означает любой сим-
         вол, кроме b, o или t.
   [-] - внутри квадратных скобок означает диапазон  символов.
         Например, [b-o] означает любой символ от b до o.
     \ - перед символом спецификатора говорит  Borland  C++  о
         том,  что нужно рассматривать этот символ как литеру,
         а не как спецификатор. Например, \^ означает ^, а на-
         чало строки.
     Введите строку в окне ввода и выберите ОК для начала  по-
иска,  а для отказа от поиска выберите Cancel.  Если Вы хотите
ввести строку, которую уже искали, нажмите ∙, чтобы посмотреть
архивный список и осуществить из него выбор.
     Можно также выбрать слово, на котором стоит курсор в окне
редактора  и использовать его в окне поиска посредством просто
вызова Find из Search меню. Можно брать дополнительные символы
из текста путем нажатия клавиши Ў.

    ┌────────────┐
    │Direction   │
    │(.) Forward │
    │( ) Backward│
    └────────────┘
     Отметьте зависимые кнопки Direction,  для того чтобы  ре-
шить, в каком направлении будет осуществляться поиск - начиная
с начала (устанавливаемого с помощью Origin зависимых  кнопок)
или нет.

   ┌──────────────────┐
   │ Scope            │
   │ (.) Global       │
   │ ( ) Selected text│
   └──────────────────┘
     Выберите кнопки,  для того чтобы определить,  в какой об-
ласти  файла  осуществлять  поиск.  Можно  выбрать  весь  файл
(Global) или только выбранный текст.

    ┌────────────────┐
    │Origin          │
    │(.) From Cursor │
    │( ) Entire Scope│
    └────────────────┘
     Выберите кнопку,  чтобы определить, где начинается поиск.
Когда выбрана Entire Scope (целая область), то зависимые кноп-
ки  Direction  определяют,  в начале или в конце выбранной об-
ласти начнется поиск. Диапазон области можно выбрать с помощью
Scope (область) зависимых кнопок.

                     Replace (заменить).
     ┌──────┐ ┌─────┐ ┌─────┐
     │ Ctrl │ │  Q  │ │  A  │
     └──────┘ └─────┘ └─────┘
     Search/Replace команда выводит диалоговое окно, позволяю-
щее набирать образец текста для поиска и  образец  текста,  на
который его надо заменить.

╔═[█]══════════════════ Replace ══════════════════════╗
║  ┌─────────────────────────────────────────────┬─┬┐ ║
║  │ Text to Find                                │∙││ ║
║  ├─────────────────────────────────────────────┼─┼┤ ║
║  │   New Text                                  │∙││ ║
║  └─────────────────────────────────────────────┴─┴┘ ║
║  Options                    Direction               ║
║   [X] Case sensitive         (.) Forward            ║
║   [ ] Whole words only       ( ) Backward           ║
║   [X] Regular expression                            ║
║   [X] Prompt on replace                             ║
║                                                     ║
║  Scope                      Origin                  ║
║   (.) Global                 (.) From cursor        ║
║   ( ) Selected text          ( ) Entire scope       ║
║                                                     ║
║   [  OK  ]  [ Change All ]  [ Cancel ]   [ Help ]   ║
║                                                     ║
╚═════════════════════════════════════════════════════╝

     Диалоговое окно замены содержит несколько зависимых и не-
зависимых кнопок - многие из них идентичны кнопкам диалогового
окна поиска,  описанного ранее.  Дополнительная кнопка, Prompt
on replace (подсказка для замены),  управляет  подсказкой  для
каждой замены.
     Наберите строку поиска и строку замены в  окнах  ввода  и
выберите  OK  или Change All (заменить все) для начала поиска,
или нажмите Cancel для отказа.  Если Вы хотите ввести  строку,
использованную  ранее,  нажмите стрелку вниз для просмотра ар-
хивного списка и выбора в нем.
     Если Borland  C++ находит заданный текст,  он спрашивает,
хотите ли Вы произвести замену. При выборе OK он находит и за-
меняет  только  первый  образец  элемента  поиска.  При выборе
Changе All (заменить все),  он заменяет все вхождения, как это
определено с помощью Direction (направление),  Scope (область)
и Origin (начало) кнопок.
     Как и в диалоговом окне поиска,  можно выбрать слово,  на
котором стоит курсор в окне редактора и использовать его в ок-
не  ввода Text to find (текст для поиска) простым вызовом Find
или Replace (найти или заменить) из Search menu (меню поиска).
Вы  можете  добавить текст из окна редактора с помощью стрелки
вправо.

               Search Again  (повторный поиск).
     ┌──────┐ ┌─────┐
     │ Ctrl │ │  L  │
     └──────┘ └─────┘
     Search/Search Again команда повторяет последнюю Find  или
Replace команду. Все установки, которые были сделаны в послед-
нем диалоговом окне (Find или Replace) остаются действительны-
ми при выборе Search Again.

         Goto line number  (идти  к  строке  номер).

     Search/Goto line  number  команда выдает подсказку номера
строки, которую Вы хотите найти. Диалоговое окно выглядит сле-
дующим образом:
╔═[█]═════ Go to Line Number ══════════════╗
║                                          ║
║ ┌──────────────────────┐┌───────────┐    ║
║ │Enter New Line Number ││           ││∙│ ║
║ └──────────────────────┘└───────────┘    ║
║                                          ║
║  [ OK ]     [  Cancel  ] [ Help ]        ║
║                                          ║
╚══════════════════════════════════════════╝

     Borland C++  показывает  текущий  номер  строки  и  номер
столбца в нижнем левом углу каждого окна редактора.

             Previous Error  (предыдущая ошибка).
     ┌─────┐ ┌────┐
     │ Alt │ │ F7 │
     └─────┘ └────┘
     Search/Previous Error  команда передвигает курсор к месту
расположения предыдущей ошибки или предупреждению. Эта команда
доступна только в том случае, если в окне сообщений есть сооб-
щения, которые имеют соответствующие номера строк. Эти сообще-
ния генерируются компилятором или программами, которые исполь-
зуют фильтр сбора сообщений.

               Next Error  (следующая  ошибка).
     ┌─────┐ ┌────┐
     │ Alt │ │ F8 │
     └─────┘ └────┘
     Search/Next Error  команда  передвигает  курсор  к  месту
расположения следующей ошибки или сообщения с предупреждением.
Эта команда доcтупна только в том случае,  если в окне сообще-
ний  есть  сообщения,  которые  имеют  соответствующие  номера
строк.  Эти сообщения генерируются командами компилятора и пе-
рехода, которые используют фильтр сбора сообщений.

             Locate function  (найти   функцию).

     Search/Locate function  команда  выводит диалоговое окно,
позволяющее ввести имя функции для поиска. Эта команда доступ-
на только во время сеанса отладки.

╔═[█]═══════ Locate Function ═════════╗
║                                     ║
║┌───────────────┐                    ║
║│ Function Name │                    ║
║├───────────────┴──────────────┐     ║
║│ main                         ││∙│  ║
║└──────────────────────────────┘     ║
║                                     ║
║   [ OK ]    [ Cancel ]   [ Help ]   ║
║                                     ║
╚═════════════════════════════════════╝
     Введите имя функции или нажмите "∙" для выбора  имени  из
архивного списка. В противоположность Find команде, эта коман-
да находит объявление функции, а не пример ее использования.

                      Run меню (запуск).
     ┌─────┐ ┌────┐
     │ Alt │ │ R  │
     └─────┘ └────┘
     Команды меню запуска запускают Вашу программу,  а так  же
начинают и заканчивают сеансы отладки.

                        Run (запуск).
     ┌──────┐ ┌────┐
     │ Ctrl │ │ F9 │
     └──────┘ └────┘
     Run/Run команда запускает Вашу программу, используя пара-
метры,  которые  Вы  передали  в   нее   с   помощью   команды
Run/Arguments.  Если  со времени последней компиляции исходный
код был модифицирован, она так же вызовет менеджер проекта для
перекомпиляции  и  редактирования  Вашей программы.  (Менеджер
проекта - это средство построения программ, объединенное с ин-
тегрированной средой;  см. главу 4 "Управление мультифайловыми
проектами" для получения более подробной информации).
     Если Вы  не  хотите отлаживать свою программу,  Вы можете
компилировать и редактировать ее с  зависимой  кнопкой  Source
debugging,  установленной  в None (что позволяет Вам выполнять
компиляцию программы быстрее) или в Standalone (что дает прог-
рамме  больше памяти для запуска) в Option/Debugger диалоговом
окне.  Если Вы компилируете свою программу с этой  независимой
кнопкой,  установленной в On, то результирующий выполнимый код
будет содержать отладочную информацию, которая повлияет на по-
ведение Run/Run команды следующим образом:
     Если Вы не модифицировали исходный код со времени послед-
ней компиляции,
     - Run/Run команда приведет к запуску Вашей  программы  до
следующей точки прерывания, или к концу, если точки прерывания
не были установлены.
     Если со времени последней компиляции исходный код был мо-
дифицирован,
     - если Вы уже сделали несколько шагов по своей программе,
используя Run/Step Over или Run/Trace into  commands,  Run/Run
выдаст подсказку,  хотите ли Вы сделать перекомпиляцию в своей
программе:
     - Если Вы ответите ДА, менеджер проекта перекомпилирует и
отредактирует Вашу программу, и установит ее запуск с начала.
     - Если  Вы ответите НЕТ,  то Ваша программа запустится до
следующей точки прерывания или до конца, если точки прерывания
не были установлены.
     - если Вы не находитесь в активном сеансе отладки, менед-
жер  проекта перекомпилирует Вашу программу и установит ее за-
пуск с начала.
     Примечание: Если  Вы  хотите использовать все возможности
Borland C++, сделайте Source Debugging установку в On.
     Нажатие Ctrl-Break  приводит  к прекращению выполнения на
следующей исходной строке Вашей программы. Если Borland C++ не
может найти исходную строку,  второе нажатие Ctrl-Break завер-
шит программу и приведет к возвращению в интегрированную  усо-
вершенствованную среду.
     Нельзя запускать и отлаживать приложения  Windows  внутри
IDE.  При попытке сделать это Вы получите ошибочное диалоговое
окно.

           Program reset (перезагрузка программы).
     ┌──────┐ ┌────┐
     │ Ctrl │ │ F2 │
     └──────┘ └────┘
     Run/Program reset команда прекращает текущий сеанс отлад-
ки,  освобождает память, размещенную под Вашу программу и зак-
рывает все  открытые  файлы,  используемые  Вашей  программой.
Используйте эту команду, когда Вы работаете в режиме отладки и
не хватает памяти для запуска программ перехода или временного
выхода в DOS.

               Go to Cursor (идти до курсора).
     ┌─────┐
     │ F4  │
     └─────┘
     Run/Goto cursor команда запускает программу до строки, на
которой стоит курсор в текущем  окне  редактора.  Если  курсор
стоит  на строке,  которая не содержит выполнимое утверждение,
команда выдаст предупреждение.  Run/Goto cursor команда  может
так же начать сеанс отладки.
     Goto cursor не устанавливает постоянную точку прерывания,
но она позволяет программе останавливаться на постоянной точке
прерывания,  если она встретила  эту  точку  прерывания  перед
строкой, на которой стоит курсор. Если это произошло, Вы долж-
ны выбрать команду Goto cursor опять.
     Используйте Goto  cursor команду для того,  чтобы перейти
на ту часть Вашей программы,  которую  Вы  хотите  отлаживать.
Если  Вы  хотите остановить свою программу на определенном ут-
верждении каждый раз,  когда она достигает этой точки, устано-
вите на этой строке точку прерывания.
     Заметим, что если Вы установили курсор  на  строке  кода,
которая не выполнима, Ваша программа будет выполняться до сле-
дующей точки прерывания или до конца, если точка прерывания не
встретится. Вы всегда можете использовать Ctrl-Break для прек-
ращения работы программы.

                 Trace into (трассировка в).
     ┌─────┐
     │ F7  │
     └─────┘
     Run/Trace into команда запускает Вашу программу утвержде-
ние за утверждением.  Когда она достигает вызова функции,  она
выполняет каждое утверждение внутри функции, вместо выполнения
функции как одного шага (см.  Run/Step over). Если утверждение
не содержит вызова функций,  доступных отладчику,  Trace  into
остановится на следующем выполнимом утверждении.
     Используйте Trace into команду  для  перемещения  позиции
выполнения к функции,  вызываемой функцией,  которую Вы сейчас
отлаживаете.  См.  следующий раздел для  иллюстрации  различий
между Trace into и Step over командами.
     Если утверждение содержит вызов функции, доступной отлад-
чику, Trace into останавливается в начале определения функции.
Последующая Trace into или Step over команда выполняет утверж-
дения в определении функции. Когда отладчик оставляет функцию,
он возобновляет вычисление утверждения,  которое содержит  вы-
зов; Например,
       if (func1() && func2());
       do-something();
     Когда выполнение дойдет  до  утверждения  if,  F7  начнет
трассировку  в  func1;  по  возвращении  из  func1,  F7 начнет
трассировку в func2.  F8 перешагнет через func2 и  остановится
на do-something.
     Примечание. Trace Into команда распознает только функции,
определенные в исходном файле, откомпилированном с двумя опци-
ями, установленными в On:
     - в  Code  Generation диалоговом окне (Options/Compiler),
       Debug Info в OBJs независимая кнопка должна быть  вклю-
       чена;
     - Source Debuging зависимые кнопки должны быть установле-
       ны в On (в Options/Debugging диалоговом окне).

                          Step over.
     ┌─────┐
     │ F8  │
     └─────┘
     Run/Step over  команда  выполняет следующие утверждения в
текущей функции.  Она не выполняет трассировку внутрь  вызовов
функций нижнего уровня, даже если они доступны отладчику.
     Используйте Step over для выполнения функции,  которую Вы
сейчас отлаживаете, как одно утверждение за один момент време-
ни без входа внутрь других функций.
     Ниже приведем  пример  различия  между  Run/Trace  into и
Run/Step over. Здесь приведены первые 12 строк программы, заг-
руженные в окно редактора:
     int findit(void)                    /*  Line 1  */
     {
        return(2);
     }
     void main(void)                     /*  Line 6  */
     {
        int i, j;

        i = findit();                    /*  Line 10  */
        printf("%d/n",i);                /*  Line 11  */
        j = 0; . . .                     /*  Line 12  */
     findit - это определенная пользователем функция в модуле,
который был откомпилирован с отладочной информацией. Предполо-
жим, что Вы находитесь на 10 строке Вашей программы. Для того,
чтобы попасть на строку 10,  поместите курсор на 10  строку  и
либо нажмите F4, либо выберите Run/Goto cursor.
     - Если Вы сейчас выберете Run/Trace into, то Вы перейдете
на  первую строку findit функции (первая строка Вашей програм-
мы), позволяя Вам совершать шаги внутри функции.
     - Если  Вы выберете Run/Step over,  то findit функция вы-
полнится, а возвращенное значение будет присвоено i. Вы окаже-
тесь на строке 11.
     Если Вы находились на 11 строке в Вашей программе,  то не
будет  разницы,  какую  команду Вы выберете;  Run/Trace into и
Run/Step over обе выполнят printf функцию и переместят  курсор
на строку 12. Это произойдет потому, что printf функция не со-
держит отладочную информацию.

                          Параметры.

     Run/Arguments команда позволяет  Вам  передать  выполняю-
щейся  программе параметры командной строки точно так же,  как
Вы их набрали в командной строке DOS.  Команды  переназначения
DOS будут игнорироваться.
     При выборе этой команды появится диалоговое окно с  одним
окном ввода.
╔═[█]══════════════ Program Arguments ══════════════════╗
║                                                       ║
║ ┌─────────┐                                           ║
║ │Arguments│                                           ║
║ ├─────────┴──────────────────────────────────────┬─┐  ║
║ │                                                │∙│  ║
║ └────────────────────────────────────────────────┴─┘  ║
║                                                       ║
║                     [  OK  ]   [ Cancel ]  [ Help ]   ║
║                                                       ║
╚═══════════════════════════════════════════════════════╝
     Примечание: Здесь нужно ввести только параметры, а не имя
программы.
     Параметры имеют значение только когда программа стартует.
Если Вы уже завершили отладку и хотите изменить параметры,  то
Вы можете выбрать Program reset для запуска программы с новыми
параметрами.

                        Меню Compile.
     ┌─────┐ ┌───┐
     │ Alt │ │ C │
     └─────┘ └───┘
     Используйте команды меню Compile для компиляции  программ
в  активном  окне  или для того,  чтобы сделать make или build
своего проекта.  Для того,  чтобы использовать Compile,  Make,
Build и Link команды, нужно иметь открытый файл в активном ок-
не редактора или заданный проект (для  make,  build  и  link).
Например,  если Вы открыли Message или Watch окно,  эти выборы
будут недоступны.

            Compile to OBJ (компилировать в OBJ).
     ┌─────┐ ┌────┐
     │ Alt │ │ F9 │
     └─────┘ └────┘
     Compile/Compile to OBJ команда компилирует активный  файл
редактора (.C или .CPP файл в .OBJ файл).  Меню всегда показы-
вает имя создаваемого файла; например,
     ┌─────────────────┐     ┌────────────────┐
     │ Compile to OBJ  │     │ C:EXAMPLE.OBJ  │
     └─────────────────┘     └────────────────┘
     Когда Borland C++ компилирует,  появляется окно  статуса,
показывающее результаты компиляции.  Когда компиляция/редакти-
рование завершается,  нажмите любую клавишу, чтобы удалить это
окно.  Если происходит какая-нибудь ошибка или предупреждение,
окно сообщений становится активным и показывает первую ошибку.

              Make EXE  file  (делать EXE файл).
       F9

     Compile/Make EXE  file  команда вызывает менеджер проекта
для создания .EXE файла.  Меню всегда показывает имя создавае-
мого .EXE файла; например
      ┌────────────────┐     ┌────────────────┐
      │ Make EXE file  │     │ C:EXAMPLE.EXE  │
      └────────────────┘     └────────────────┘
     .EXE имя  файла получается из одного или двух имен в сле-
дующем порядке:
     - имя   проектного   файла  (.PRJ),  заданное  с  помощью
Project/Open project команды;
     - имя файла в активном окне редактора (если проект не за-
дан,  Вы  возьмете  проект  по  умолчанию,   заданный   файлом
TCDEF.DPR).
     Compile/Make EXE file перекомпилирует  только  те  файлы,
которые не являются текущими.
     Примечание: Более подробную информацию по менеджеру  про-
екта  смотрите  в главе 4 "Управление мультифайловыми проекта-
ми".

            Link EXE  file  (связать  EXE  файл).

     Compile/Link EXE file команда берет текущий .OBJ  и  .LIB
файлы (либо заданные по умолчанию,  либо файлы, заданные в те-
кущем проектном файле) и редактирует их,  не делая  Make;  это
создает новый
.EXE файл.

              Build All   (компилировать  все).

     Compile/Build All команда перекомпилирует все файлы Ваше-
го проекта независимо от их даты.
     Эта команда подобна команде Compile/Make EXE file за иск-
лючением того, что она не имеет условий. Она выполняет следую-
щие шаги:
     1. Удаляет  соответствующий  откомпилированный файл заго-
ловка (.SYM), если он существует.
     2. Удаляет  всю  скрытую информацию по автозависимостям в
проекте.
     3. Устанавливает  дату и время всех проектных .OBJ файлов
     в 0.
     4. Выполняет Make.
     Таким образом,  если  Вы  прервали  Build   All   команду
посредством нажатия Ctrl-Break,  или получили ошибку, прервав-
шую компиляцию,  Вы можете продолжить ее  там,  где  она  была
прервана, простым выбором Compile/Make EXE File.

             Remove Messages (удалить сообщения).

     Compile/Remove Messages  команда удаляет все сообщения из
окна сообщений.

                    Debug меню (отладки).
     ┌──────┐ ┌────┐
     │ Alt  │ │ D  │
     └──────┘ └────┘
     Команды меню отладки управляют всеми возможностями интег-
рированного  отладчика.  Можно изменить установки по умолчанию
для этих команд в Options/Debugger диалоговом окне.
     Нельзя запускать  и  отлаживать приложения Windows внутри
IDE.  При попытке сделать это Вы получите ошибочное диалоговое
окно.  Нужно запускать их под Microsoft Windows и использовать
Turbo Debugger для Windows.

                  Inspect (инспектирование).
     ┌──────┐ ┌─────┐
     │ Alt  │ │ F4  │
     └──────┘ └─────┘
     Debug/Inspect команда открывает окно инспектора, позволя-
ющее  просматривать и изменять значения элементов данных.  Тип
инспектируемого элемента определяет тип информации,  представ-
ленной в окне. В Borland C++ можно инспектировать простые (по-
рядковые) типы данных,  такие как char или unsigned long, ука-
затели, массивы, структуры, типы, объединения и функции.
     Есть два способа открытия окна инспектора:
     - Можно  поместить  курсор на элемент данных,  который Вы
хотите инспектировать, и нажать Alt-F4.
     - Можно   так  же  выбрать  Debug/Inspect  для  появления
Inspector диалогового окна,  затем набрать имя элемента, кото-
рый Вы хотите инспектировать.  Альтернативно,  можно поместить
курсор на выражение, выбрать Debug/Inspect, и, находясь в этом
диалоговом окне, нажимать Ў, для того чтобы ввести все выраже-
ние. Нажмите Enter для его инспектирования.
     Чтобы закрыть Inspector окно, убедитесь, что окно активно
и нажмите Esc или выберите Window/Close.
     Здесь приведены несколько дополнительных операций инспек-
ции, которые можно выполнить:
     - Подинспекция.  Когда Вы находитесь в Inspector окне, Вы
можете  инспектировать  конкретные  элементы  для   отдельного
просмотра. Когда элемент инспектируется, строка статуса выдает
сообщение "Inspect".  Для того чтобы "подинспектировать"  эле-
мент,  передвиньте  курсор  к  требуемому  элементу  и нажмите
Enter.
     - Модификация элементов инспектора: Когда элемент инспек-
тора можно модифицировать,  строка статуса  показывает  "Alt-M
Modify Field". Передвиньте курсор к требуемому элементу и наж-
мите Alt-M;  диалоговое окно выдаст подсказку для введения но-
вого значения.
     - Диапазон-инспекция:  Когда Вы инспектируете  конкретные
элементы,  вы  можете изменить диапазон показываемых значений.
Например, можно сделать диапазон-инспекцию указателей на пере-
менные,  потому что Borland C++ не знает количество элементов,
на которые ссылается указатель (например,  в случае  массива).
Можно делать диапазон-инспекцию, когда строка статуса содержит
сообщение "Set index range" и команду Alt-I.
     Следующие разделы  коротко описывают восемь возможных ти-
пов окон инспектора.

               Окна инспектора для целых типов.

     Окна инспектора  для  целых  типов  показывают   значение
простых элементов данных, таких как
     char x=4;
     unsigned long y=123456L;
     Такие окна инспектора имеют только одну  строку  информа-
ции,  следующую  за верхней строкой (которая обычно показывает
адрес переменной,  хотя она может содержать  слово  "constant"
или другую информацию, в зависимости от того, что Вы инспекти-
руете).  Слева  появляется  тип  скалярной  переменной  (char,
unsigned  long  и  так далее),  а справа появляется ее текущее
значение. Значение может быть представлено в десятичном, шест-
надцатиричном  или  обоих  представлениях.  Обычно  оно идет в
десятичном представлении,  а шестнадцатиричное следует в круг-
лых  скобках  (используя стандартный шестнадцатиричный префикс
Си: 0x).
     Если показываемая переменная имеет тип char,  также пока-
зывается эквивалентный символ.  Если текущее значение не имеет
соответствующего печатного символа, то это значение показывает
обратный слэш (\), сопровождаемый шестнадцатиричным значением.
Это  значение символа появляется перед десятичным или шестнад-
цатиричным значениями.

               Окна инспектора для указателей.

     Окна инспектора для указателей показывают  значения  эле-
ментов данных,  указывающих на другие элементы данных,  напри-
мер:
     char *p = "abc";
     int *ip = 0;
     int **ipp = &ip;
     Окна инспектора для указателей обычно имеют верхнюю стро-
ку,  которая  содержит  адрес  переменной,  за которой следует
строка с информацией.
     Слева появляется  [0],  указывающий  первый член массива.
Справа появляется значение элемента, на который указывает ука-
затель.  Если значение представляет собой сложный элемент дан-
ных, такой как структура или массив, то их можно посмотреть по
мере возможности, со значениями, заключенными в фигурные скоб-
ки ({ и }).
     Если указатель  имеет тип char и должен указывать на сим-
вольную строку, завершенную нулем, то появляется больше инфор-
мации,  показывающей  значение  каждого  элемента в символьном
массиве.  Слева каждой строки появляется индекс массива  ([1],
[2]  и  так  далее),  а справа появляется значение,  каким оно
должно выглядеть в скалярном окне инспектора.  В этом  случае,
вся  строка также показывается в верхней строке,  вместе с ад-
ресом переменной указателя и адресом  строки,  на  которую  он
указывает.

                 Окна инспектора для массива.

     Окна инспектора для массива показывают значения элементов
массивов данных, таких как:
     long thread [3] [4] [5];
     char message[] = "eat these words";
     Здесь есть  строка  для  каждого элемента массива.  Слева
каждой строки появляется индекс элемента массива. Справа появ-
ляется значение элемента, на который ссылается указатель. Если
значение представляет собой сложный элемент данных,  такой как
структура   или  массив,  то  показывается  такая  его  часть,
насколько возможно,  со значениями,  заключенными  в  фигурные
скобки ({ и }).

         Окна инспектора для структур и объединений.

     Окна инспектора  для  структур  и  объединений показывают
значения элементов структур и данных объединений. Например,
     struct date {
        int year;
        char month;
        char day;
     } today;

     union {
        int small;
        long large;
     } holder;
     Структуры и  объединения  показываются в одинаковых окнах
инспектора.  То,  что Вы смотрите структуру  или  объединение,
можно отличить по заголовку окна инспектора.  Эти окна инспек-
тора имеют много элементов после адреса,  так как они являются
элементами структуры или объединения. Каждая строка показывает
имя элемента слева и его  значение  справа  в  формате,  соот-
ветствующем типу данных С.

                 Окна инспектора для функций.

     Окна инспектора для функций показывают тип,  возвращаемый
функцией,  как часть заголовка. Каждый параметр в вызове функ-
ции появляется после адреса памяти вверху списка.
     Окна инспектора для функций сообщают информацию о вызыва-
емых параметрах, возвращаемом типе данных и соглашениях вызова
для функции.

                 Окна инспектора для класса.

     Окна инспектора  для  класса  (или   объекта)   позволяют
инспектировать детали переменных класса. Окно показывает имена
и значения для элементов и методов, заданных классом.
     Окно можно разделить на две части горизонтально,  с верх-
ней частью,  перечисляющей поля данных или элементы класса,  и
нижней,  перечисляющей  имена функций-элементов и адреса функ-
ций.  Нажмите Tab для перехода из одной части окна  инспектора
для класса в другую.
     Если высвеченное поле данных представляет собой класс или
указатель  на  класс,  нажмите Enter,  это откроет другое окно
инспектора для класса для высвеченного  типа.  Таким  способом
можно быстро просмотреть сложные вложенные структуры классов с
минимальным количеством нажатия клавиш.

                Окна инспектора для констант.

     Окна инспектора для констант точно  такие  же,  как  окна
инспектора  для  порядковых типов,  только они не содержат ад-
ресов и их нельзя модифицировать.

                  Окна инспектора для типа.

     Окна инспектора для типа позволяют показывать  тип  поля.
Это  окно инспектора для типа для каждого вида окон инспектора
для экземпляров,  описанных выше.  Различие состоит в том, что
инспектора экземпляров показывают значение поля,  а инспектора
типа показывают тип поля.

            Evaluate/Modify (Вычислить/Изменить).
     ┌──────┐ ┌────┐
     │ Ctrl │ │ F4 │
     └──────┘ └────┘
     Debug/Evaluate/ Modify команда вычисляет  переменную  или
выражение,  показывает ее значение, и, если это возможно, поз-
воляет его изменить. Команда открывает диалоговое окно, содер-
жащее три поля:  Expression (выражение),  Result (результат) и
New Value (новое значение).  Ниже приведен пример  диалогового
окна:

╔═[█]═════════════ Evaluate and Modify ═════════════════╗
║                                                       ║
║  Expression                                           ║
║  ┌──────────────────────────────────┬─┐               ║
║  │                                  │∙│  [ Evaluate ] ║
║  └──────────────────────────────────┴─┘               ║
║  Result                                               ║
║  ┌────────────────────────────────────┐               ║
║  │                                    │  [  Modify  ] ║
║  └────────────────────────────────────┘               ║
║  New Value                                            ║
║  ┌──────────────────────────────────┬─┐               ║
║  │                                  │∙│  [  Cancel  ] ║
║  └──────────────────────────────────┴─┘               ║
║                                                       ║
║                                          [   Help   ] ║
╚═══════════════════════════════════════════════════════╝

     Примечание. Evaluate кнопка задана по умолчанию;  если  с
помощью табуляции Вы попадете в New Value поле,  Modify кнопка
будет задана по умолчанию.
     Expression поле показывает выражение, по умолчанию состо-
ящее из слова, на котором стоит курсор в окне редактора. Можно
вычислить выражение по умолчанию,  нажав Enter, или отредакти-
ровать или заменить его.  Можно также нажимать Ў, чтобы расши-
рить  выражение  по умолчанию путем копирования дополнительных
символов из окна редактора.
     Можно вычислить любое действительное выражение С, которое
не содержит:
     - вызовов функций;
     - символов или макросов, заданных с #define;
     - локальных или статических переменных,  не находящихся в
       области действия, в которой выполняется функция.
     Если отладчик  может  вычислить выражение,  он показывает
его значение в Result поле.  Если выражение относится к  пере-
менной или простому элементу данных,  то можно подвести курсор
к New Field полю и ввести выражение как новое значение.
     Для закрытия диалогового окна нажмите Esc.  Если Вы изме-
нили содержание New Field поля,  но не выбрали Modify,  то от-
ладчик  проигнорирует  New Field поле при закрытии диалогового
окна.
     Используйте выражение   повтора  для  просмотра  значений
последовательных элементов данных. Например, для массива цело-
численного типа, названного xarray,
     - xarray[0],5 покажет пять последовательных целых в деся-
       тичном представлении;
     - xarray[0],5x покажет пять последовательных целых  чисел
       в шестнадцатиричном представлении.
     Выражение, используемое  с  повторением   счета,   должно
представлять собой простой элемент данных. Отладчик рассматри-
вает элемент данных как первый элемент массива, если он не яв-
ляется указателем,  и как указатель на массив в противном слу-
чае.
     Debug/Evaluate/Modify команда  показывает каждый тип зна-
чения в соответствующем формате.  Например, она показывает int
как целое в десятичном представлении, а массив как указатель в
шестнадцатиричном представлении. Для того, чтобы получить дру-
гой формат для показа, поставьте после выражения запятую, а за
ней один из спецификаторов формата, приведенных в таблице 1.3.

                  Call Stack (стек  вызова).
     ┌──────┐ ┌─────┐
     │ Ctrl │ │ F3  │
     └──────┘ └─────┘
     Debug/Call Stack команда открывает диалоговое  окно,  со-
держащее  стек  вызова.  Call Stack окно показывает последова-
тельность функций,  вызванных Вашей программой,  для получения
выполняемой  сейчас  функции.  Внизу  стека находится main,  а
вверху выполняемая сейчас функция.
     Каждая запись  стека  показывает  имя вызванной функции и
значения передаваемых в нее параметров.
     Вначале высвечивается запись вверху стека. Для того, что-
бы посмотреть текущую строку по любой другой функции  в  стеке
вызова,  выберите  имя  функции и нажмите Enter.  Курсор пере-
местится к строке, содержащей вызов функции, стоящей выше ее в
стеке.
     Примечание. Компиляция  с  отключенной  опцией   Standard
Stack Frame (O/C/Code Generation) приведет к тому,  что вызовы
некоторых функций будут опущены в стеке вызовов. Оверлеи будут
иметь такой же эффект.
     Например, предположим,  что стек вызовов имеет  следующий
вид:
     func2()
     func1()
     main()
     Это говорит о том, что main вызвала func1, а func1 вызва-
ла func2. Если Вы хотите посмотреть выполнение строки с func1,
можете выбрать func1 в стеке вызовов,  и нажать Enter. Код для
func1 появится в окне редактора, а курсор установится на вызо-
ве func2.
     Для того,  чтобы вернуться к текущей  строке  выполняемой
сейчас функции (то есть, к позиции выполнения), выберите самую
верхнюю функцию в стеке вызовов и нажмите Enter.

                         Таблица 1.3.
  Спецификаторы формата, распознаваемые отладчиком в выражениях.
______________________________________________________________

Символ                              Функция
______________________________________________________________
  С      Символ. Показывает  специальные символы для управляю-
         щих символов (ASCII от 0 до 31);  по умолчанию, такие
         символы   изображаются   с   помощью  соответствующих
         Esc-последовательностей Си (\n,  \t и т.д.). Применя-
         ется к символам и строкам.
  S      Строка. Показывает управляющие символы (ASCII от 0 до
         31)  как  ASCII  значения,  используя соответствующие
         Esc-последовательности Си.  Так как это формат показа
         строк  и  символов  задан  по умолчанию,  то он имеет
         смысл только в соединении со спецификатором М.
  D      Десятичное представление.  Показывает все целочислен-
         ные значения в десятичном представлении.  Применяется
         к простым целочисленным выражениям,  а также к масси-
         вам и структурам, содержащим целые числа.
H или X  Шестнадцатиричное представление. Показывает все цело-
         численные значения в шестнадцатиричном  представлении
         с префиксом 0х. Применяется как к простым целочислен-
         ным выражениям, как и к массивам и структурам, содер-
         жащим целые числа.
  Fn     Числа с плавающей точкой.  Показывает n значащих цифр
         (n  -  целое  число от 2 до 18).  По умолчанию задано
         значение 7.  Применяется только к значениям  чисел  с
         плавающей точкой.
  M      Pаспечатка содержимого памяти.  Показывает содержимое
         памяти,  начиная с адреса указанного выражения. Выра-
         жение должно представлять собой конструкцию, действи-
         тельную  в левой части оператора присваивания,  т.е.,
         конструкцию,  означающую адрес в памяти;  в противном
         случае М спецификатор будет игнорироваться.
         По умолчанию, каждый байт переменной изображается как
         две цифры в шестнадцатиричном представлении. Добавле-
         ние  спецификатора  D к М приведет к тому,  что байты
         будут изображаться в десятичном представлении. Добав-
         ление  спецификаторов H или Х,  приведет к тому,  что
         байты   будут   изображаться   в    шестнадцатиричном
         представлении. S или С спецификаторы приведут к тому,
         что переменные будут изображаться в виде строк (с или
         без специальных символов).  Число показываемых байтов
         по умолчанию соответствует размеру переменной, но мо-
         жет  быть  использован повторяющийся счет для задания
         точного числа байтов.
  P      Указатель. Показывает указатели в формате  seg:ofs  с
         дополнительной информацией об адресе,  на который они
         указывают,  а не в аппаратно-ориентированном  формате
         seg:ofs,  заданном по умолчанию. Характерно, что этот
         спецификатор сообщает область памяти,  в которой раз-
         мещен  сегмент,  и имя переменной по адресу смещения,
         если это возможно. Имеются следующие области памяти:

      Область памяти                  Cообщение оценки

   000:0000-0000:03FF           Таблица вектора прерываний
   000:0400-0000:04FF           Область данных BIOS
   000:0500-Borland C++          MS-DOS/TSR
   Borland C++ - пользователь-  Borland C++
   ская программа PSP
   Пользовательская программа    Пользовательский процесс
   PSP                           PSP
   Пользовательская программа-   Имя статической пользова-
   вершина RAM памяти            тельской переменной, если
                                 адрес попал вне памяти,
                                 размещенной под переменные;
                                 В противном случае ничего.
   А000:0000-AFFF:FFFF           EGA/VGA видео RAM
   B000:0000-B7FF:FFFF           RAM монохромного дисплея
   B800:0000-BFFF:FFFF           RAM цветного дисплея
   C000:0000-EFFF:FFFF           EMS страницы/адаптер
                                  BIOS ROM
   F000:0000-FFFF:FFFF           BIOS ROM
   R     Структура/объединение. Показывает  как  имена  полей,
         так и их значения, например, {X:1, Y:10, Z:5}. Приме-
         няется только к структурам и объединениям.
______________________________________________________________

                               Просмотр.

     Debug/Watches команда выводит  меню  команд,  управляющих
пользованием  точек  просмотра.  Выражения для просмотра можно
запоминать    до     следующего     сеанса     работы;     см.
Options/Environment/Desktop.  Следующие  разделы описывают ко-
манды меню.

                Add Watch (добавить просмотр).
     ┌──────┐ ┌─────┐
     │ Ctrl │ │ F7  │
     └──────┘ └─────┘
     Add Watch команда вставляет выражение  просмотра  в  окно
смотра.
     При выборе этой команды отладчик открывает диалоговое ок-
но и выдает подсказку для ввода выражения просмотра. Выражени-
ем по умолчанию является слово,  на котором стоит курсор в те-
кущем окне редактора.  Имеется также архивный список,  который
можно использовать для быстрого ввода выражения,  использован-
ного ранее.
     Если вы верно набрали выражение и нажали  Enter  или  ОК,
отладчик  добавляет  выражение  и  его текущее значение в окно
просмотра.  Если окно просмотра является активным, можно вста-
вить новое выражение для просмотра посредством нажатия Ins.

              Delete Watch (отменить просмотр).

     Delete Watch   команда   удаляет  текущее  выражение  для
просмотра из окна просмотра.
     Окно просмотра  должно быть активным в момент использова-
ния этой команды.  Текущее значение для просмотра  выбирается,
если окно просмотра активно.
     Чтобы удалить выражение для просмотра,  не являющееся те-
кущим,  нужно  выбрать требуемое выражение для просмотра и на-
жать либо Del, либо Ctrl-Y.

            Edit Watch (Редактирование просмотра).

     Edit Watch команда позволяет редактировать текущее  выра-
жение  для  просмотра  в  окне  просмотра.  Доступен  архивный
список, позволяющий экономить время для набивки.
     При выборе этой команды отладчик открывает диалоговое ок-
но,  содержащее копию текущего выражения для просмотра. Редак-
тируйте выражение и нажмите Enter.  Отладчик заменяет первона-
чальную версию выражения отредактированной версией.
     Можно также редактировать выражение для просмотра вне ок-
на просмотра, выбрав это выражение и нажав Enter.

         Remove All Watchs (отменить все просмотры).

     Remove All  Watchs  команда  удаляет  все  выражения  для
просмотра из окна просмотра.

      Toggle Breakpoint (переключить точку прерывания).
     ┌──────┐ ┌────┐
     │ Ctrl │ │ F8 │
     └──────┘ └────┘
     Debug/Toggle Breakpoint  команда позволяет установить или
очистить безусловную точку прерывания на  строке,  на  которой
стоит курсор.  Когда точка прерывания установлена, она помеча-
ется посредством высвечивания.  Точки прерывания можно  запом-
нить  до  следующего  сеанса  работы посредством использования
Options/Environment/Desktop. Более подробная информация о точ-
ках прерывания содержится в следующем разделе.

               Breakpoints (точки прерывания).

     Debug/Breakpoints команда открывает диалоговое окно, поз-
воляющее  управлять  использованием  точек  прерывания  -  как
условных, так и безусловных. Это диалоговое окно выглядит сле-
дующим образом:
╔═[█]═══════════════════ Breakpoints ═════════════════════════════╗
║                                                                 ║
║ ┌──────────────────────────────────────────────────────────────┐║
║ │Breakpoint List           Line#  Condition          Pass      │║
║ │┌──────────────────────────────────────────────────────────┐^ │║
║ ││                                                          │█ │║
║ │└──────────────────────────────────────────────────────────┘Ё │║
║ │                                                            Ё │║
║ │                                                            Ё │║
║ │                                                            Ё │║
║ │                                                            Ё │║
║ │                                                            v │║
║ └──────────────────────────────────────────────────────────────┘║
║                                                                 ║
║ [ OK ] [ Edit ] [ Delete ] [ View ] [ At ] [ Cancel ] [ Help ]  ║
║                                                                 ║
╚═════════════════════════════════════════════════════════════════╝
     Диалоговое окно показывает все установленные точки преры-
вания,  номера  их  строк  и  условия.  Условие имеет архивный
список,  позволяющий выбрать условие точки прерывания, исполь-
зованное ранее.
     Можно удалить  точки  прерывания   из   своей   программы
посредством   выбора  кнопки  Delete  (удалить).  Можно  также
просмотреть исходный текст,  где есть установленные точки пре-
рывания,  посредством выбора кнопки View (просмотр).  View пе-
редвигает курсор к выбранной точке прерывания.  Эта команда не
выполняет  Ваш  код;  она  только перемещает курсор к активной
точке прерывания в окне редактора.
     Выберите Edit  кнопку для добавления новой точки прерыва-
ния.  При редактировании точки прерывания это диалоговое  окно
перекроется другим:
╔═[█]════════ Breakpoint Modify/New ═════════════╗
║                                                ║
║ ┌──────────┐                                   ║
║ │Condition │                                   ║
║ ├──────────┴──────────────────┐                ║
║ │                             ││∙│ [ Modify ]  ║
║ └─────────────────────────────┘                ║
║ ┌───────────┐                                  ║
║ │Pass Count │                                  ║
║ ├───────────┴─────────────────┐                ║
║ │                             │    [  New   ]  ║
║ └─────────────────────────────┘                ║
║ ┌───────────┐                                  ║
║ │File Name  │                                  ║
║ ├───────────┴─────────────────┐                ║
║ │ E:\BORLANDC\CD.C            │    [ Cancel ]  ║
║ └─────────────────────────────┘                ║
║ ┌────────────┐                                 ║
║ │Line Number │                                 ║
║ ├────────────┴────────────────┐                ║
║ │ 1                           │    [  Help ]   ║
║ └─────────────────────────────┘                ║
╚════════════════════════════════════════════════╝
     Опять же, здесь есть номер строки и условия установленных
точек прерывания. Используйте Pass Count кнопку для того, что-
бы установить,  сколько раз надо миновать точку прерывания пе-
ред остановкой.  At кнопка позволяет задать точку прерывания в
конкретной функции (Вы должны находиться в режиме отладки  для
доступа к этой кнопке).
     Это диалоговое окно также имеет кнопку New (новый), кото-
рая позволяет вводить информацию для новой точки прерывания, и
кнопка Modify (модифицировать), которая открывает окно устано-
вок.
     Ваша программа остановится как только встретит точку пре-
рывания в процессе выполнения. Когда программа остановится, Вы
окажетесь на строке,  содержащей точку прерывания. (Высвечива-
ние точки прерывания перекроется строкой курсора; оно появится
снова, когда курсор передвинется).
     Когда редактируется исходный файл,  каждая точка прерыва-
ния "приклеивается" к строке, на которой она установлена. Точ-
ки прерывания теряются только в следующих случаях:
     - Вы удалили исходную строку, на которой была установлена
       точка прерывания;
     - Вы очистили точку прерывания с помощью  команды  Toggle
       Breakpoint.
     Borland C++ пытается отследить точки  прерывания  в  двух
случаях:
     - Если Вы редактируете файл, содержащий точки прерывания,
       и не сохраняете отредактированную версию этого файла;
     - Если Вы редактируете файл, содержащий точки прерывания,
       а затем продолжаете текущий сеанс отладки, не делая пе-
       рекомпиляцию программы. (Borland C++ выдаст подсказку -
       предупреждение  "Source  modified,  rebuild?" (исходный
       текст изменен, перекомпилировать?)).
     Перед компиляцией  исходного файла можно установить точку
прерывания на любой строке,  даже на пустой строке или коммен-
тарии. При компиляции и выполнении файла, Borland C++ проверя-
ет все установленные точки прерывания и дает возможность  уда-
лить, игнорировать или изменить неправильные точки прерывания.
При отладке файла Borland C++ знает, какие строки содержат вы-
полнимые утверждения, и выдаст предупреждение в случае попытки
установить неправильные точки прерывания.
    Можно установить безусловные точки прерывания,  не входя в
диалоговое  окно,  посредством  выбора  команды   Debug/Toggle
Breakpoint.

                        Меню Project.
    ┌──────┐┌───┐
    │  Alt ││ P │
    └──────┘└───┘
     Меню Project  (проектное) содержит все команды управления
проектом для:
     - создания проекта;
     - добавления или удаления файлов из проекта  (примеры  по
использованию  менеджера  проекта  см.  в  главе 4 "Управление
мультифайловыми проектами";
     - задания программы,  с которой будет транслироваться Ваш
исходный файл;
     - установления опций для файлов проекта;
     - задания того,  какие опции перекрытия командной  строки
использовать для программы-транслятора;
     - задания того,  какой  результирующий  объектный  модуль
должен быть вызван,  где он должен находиться,  является ли он
оверлейным, и должен ли он содержать отладочную информацию;
     - просмотра  включенных файлов для заданного файла в про-
     екте.
     Примечание. Если  у  Вас  имеются проектные файлы Turbo C
2.0, то можно преобразовать их в формат Borland C++, используя
автономную утилиту PRJCNVT. Более детально этот вопрос освещен
в UTIL.DOC.

                Open Project (открыть проект).

     Команда Open Project показывает Load Project File  диало-
говое  окно (загрузить проектный файл),  позволяющее выбрать и
загрузить проект или создать новый проект, набрав его имя.

╔═[█]══════════ Load Project File ══════════════╗
║┌───────────────────────────┐                  ║
║│ Load Project File         │                  ║
║└─┬─────────────────────────┴──┐               ║
║  │*.PRJ                       │    [ OK ]     ║
║  └────────────────────────────┘               ║
║ ┌───────────────┬──────────────┐              ║
║ │Files          │              │              ║
║ │               │              │              ║
║ │               │              │              ║
║ │ BGI\          │              │              ║
║ │ INCLUDE\      │              │              ║
║ │ ..\           │              │              ║
║ │               │              │              ║
║ │               │              │              ║
║ │               │              │ [ Cancel]    ║
║ │               │              │              ║
║ │                              │              ║
║ │ <█ЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁ>│ [ Help  ]    ║
║ └──────────────────────────────┘              ║
║┌─────────────────────────────────────────────┐║
║│E:\BORLANDC\*.PRJ                            │║
║│                                             │║
║│BGI           Directory Oct 19,1990   3:22pm │║
║└─────────────────────────────────────────────┘║
╚═══════════════════════════════════════════════╝

     Это диалоговое  окно  позволяет выбрать имя файла подобно
File/Open диалоговому окну.  Файл,  который Вы выберете, будет
использоваться  как  проектный файл,  который является файлом,
содержащим всю информацию, необходимую для построения выполни-
мого  кода Вашего проекта.  Borland C++ использует имя проекта
при создании файлов .EXE и .MAP. Типичный проектный файл имеет
расширение .PRJ.

               Close Project (закрыть проект).

     Выберите Project/Close  Project,  если  Вы хотите удалить
свой проект и вернуться к проекту по умолчанию (TCDEF.DPR).

                 Add Item (добавить элемент).

     Выберите Project/Add Item, если Вы хотите добавить файл к
проектному списку.  Это вызовет появление диалогового окна Add
Item to Project List (добавить элемент к  проектному  списку),
которое выглядит следующим образом:

╔═[█]══════ Add Item to Project List ═══════════╗
║┌───────┐                                      ║
║│ Name  │                                      ║
║└─┬─────┴──────────────────────┐               ║
║  │*.C                         ││∙│   [ Add ]  ║
║  └────────────────────────────┘               ║
║ ┌───────────────┬──────────────┐              ║
║ │Files          │              │              ║
║ │ MYPROG.C      │              │              ║
║ │ CIRCLE.C      │              │              ║
║ │ FORWARD.C     │              │              ║
║ │ HELLO.C       │              │              ║
║ │               │              │ [ Done  ]    ║
║ │               │              │              ║
║ │                              │              ║
║ │ <█ЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁ>│ [ Help  ]    ║
║ └──────────────────────────────┘              ║
║┌─────────────────────────────────────────────┐║
║│E:\BORLANDC\*.C                              │║
║│BGI                     Oct 19,1990   3:22pm │║
║└─────────────────────────────────────────────┘║
╚═══════════════════════════════════════════════╝
     Это диалоговое окно заполняется так же,  как и диалоговое
окно Load File (File/Open).  Выбор кнопки Add помещает текущий
высвеченный  файл из списка Files в проектное окно.  Выбранный
файл  добавляется  к  файловому  списку  проектного  окна  не-
посредственно  сразу  за высвеченной полосой в проектном окне.
Высвеченная полоса продвигается всякий раз при добавлении фай-
ла. (Когда проектное окно активно, можно нажать Ins для добав-
ления файла).

                Delete Item (удалить элемент).

     Выберите Project/Delete Item,  если хотите убрать файл из
проектного  окна.  Когда проектное окно активно,  для удаления
файла можно нажать Del.

               Local Options (локальные опции).

     Local Options команда открывает диалоговое окно,  которое
выглядит следующим образом:

╔══│█│══════════════  Override Options  ══════════════════╗
║                                                         ║
║  Project Item: CIRCLE.CPP                               ║
║                                                         ║
║ ┌─────────────────────┐                                 ║
║ │ Command Line Options│                                 ║
║ │                     └───────────────┐                 ║
║ │                                     │ │∙│             ║
║ └─────────────────────────────────────┘                 ║
║ ┌─────────────────────┐                                 ║
║ │ Output Path         │                    [  OK  ]     ║
║ │                     └───────────────┐                 ║
║ │CIRCLE.OBJ                           │                 ║
║ └─────────────────────────────────────┘                 ║
║ ┌─────────────────────────┐                             ║
║ │ Project File Translators│                [ Cancel ]   ║
║ │                         └───────────┐                 ║
║ │Ў  Turbo C++ Integrated Compiler ў  ^│                 ║
║ │  ~Turbo Assembler                  █│                 ║
║ │                                    Ё│                 ║
║ │                                    Ё│    [ Help ]     ║
║ │                                    Ё│                 ║
║ │                                    v│                 ║
║ └─────────────────────────────────────┘                 ║
║  [ ] Overlay this module                                ║
║  [ ] Exclude debug information                          ║
║  [ ] Exclude from link                                  ║
╚═════════════════════════════════════════════════════════╝
     Диалоговое окно  Override  Options  (перекрывающие опции)
позволяет включить перекрывающие опции  командной  строки  для
конкретного  модуля проекта-файла.  Также оно позволяет задать
определенный  путь  и  имя  для  объектного  файла  и  выбрать
транслятор для модуля.
     Примечание. Не поддерживаются следующие  опции  командной
строки: c, Efilename, lpathname, L и Ix, M, Q, y.
     В списке Project File Translators появляются все програм-
мы,  инсталлированные  в  диалоговом окне Transfer (переход) с
включенной опцией Translator.

                     ┌────────────────────────┐
                     │[ ] Overlay this module │
                     └────────────────────────┘
     Включите опцию  Overlay this Module,  если хотите,  чтобы
выбранный модуль или  библиотека  (или  элемент  проекта)  был
оверлейным.  Этот элемент является локальным для одного файла.
Он недопустим,  если независимая кнопка Overlay Support  (под-
держка   оверлеев)   не   включена   (в   Options/Compile/Code
Generation).

                  ┌──────────────────────────────┐
                  │[ ] Exclude debug information │
                  └──────────────────────────────┘
     Включите опцию Exlude debug information, если хотите пре-
дотвратить попадание отладочной информации, содержащейся в мо-
дуле, в файл .EXE.
     Используйте этот переключатель в уже  отлаженных  модулях
больших  программ.  Вы можете изменить модули,  в которых есть
отладочная информация,  простым переключением  этой  кнопки  и
последующим редактированием (компиляция не требуется).

                      ┌──────────────────────┐
                      │[ ] Exclude from link │
                      └──────────────────────┘
     Используйте Exclude from Link опцию (исключить из  редак-
тирования),  если Вы хотите, чтобы редактор связей не захваты-
вал этот модуль.

              Include Files (включенные файлы).

     Выберите Project/Include Files для показа диалогового ок-
на;  делайте это в том случае,  если хотите посмотреть,  какие
файлы включены в файл, который выбран из проектного окна. Если
Вы находитесь в проектном окне, можете нажать ПРОБЕЛ для пока-
за диалогового окна Include  Files.  Эта  команда  невозможна,
если проект еще не построен.
     Диалоговое окно Include Files выглядит следующим образом:

╔══│█│══════════ Include Files ═════════════════════╗
║                                                   ║
║   Include files for CIRCLE.CPP                    ║
║                                                   ║
║   ┌───────────────────────────────────┐  [ View ] ║
║   │Include Files      Location        │           ║
║   │                                   │           ║
║   │GRAPHICS.H         ..\INCLUDE     ^│           ║
║   │POINT.H            .              █│ [ Cancel ]║
║   │CONIO.H            ..\INCLUDE     Ё│           ║
║   │                                  Ё│           ║
║   │                                  Ё│   [ Help ]║
║   │                                  Ё│           ║
║   │                                  v│           ║
║   └───────────────────────────────────┘           ║
╚═══════════════════════════════════════════════════╝
     После того, как компиляция файла завершилась, о файле на-
капливается информация (заметим,  что проектное окно имеет ин-
формацию о размере кода).  В этом состоянии,  менеджер проекта
также знает, к каким модулям относятся включенные файлы. Можно
просмотреть включенные файлы активного окна редактора в диало-
говом окне Include Files. Из окна Project Manager нажмите ПРО-
БЕЛ  для показа диалогового окна.  Из окна редактора войдите в
Project меню и выберите Include Files.  Можно делать скроллинг
по  списку  файлов.  Действием  по умолчанию является просмотр
выбранного файла, поэтому нажатие Enter помещает этот включен-
ный файл в окно редактора.

                        Меню Options.
     ┌──────┐┌───┐
     │  Alt ││ O │
     └──────┘└───┘
     Меню Options  содержит команды,  позволяющие посмотреть и
изменить различные установки по умолчанию в Borland C++. Боль-
шинство из команд меню приводит к появлению диалогового окна.

                    Compiler (компилятор).

     Options/Compiler команда выводит меню, которое предостав-
ляет несколько опций для установки, влияющих на компиляцию ко-
да. Следующие разделы описывают эти команды.

              Code Generation (генерация кода).

     Code Generation команда выводит диалоговое окно. Установ-
ки в этом окне говорят компилятору делать объектный код  опре-
деленными методами. Это диалоговое окно выглядит следующим об-
разом:

╔═[█]════════════ Code Generation ═════════════════╗
║ ┌─────┐         ┌───────┐                        ║
║ │Model│         │Options│                        ║
║ └┬────┴────────┐└┬──────┴─────────────────────┐  ║
║  │( ) Tiny     │ │[X] Treat enums as ints     │  ║
║  │(.) Small    │ │[ ] Word alignment          │  ║
║  │( ) Medium   │ │[ ] Duplicate strings merged│  ║
║  │( ) Compact  │ │[ ] Unsigned characters     │  ║
║  │( ) Large    │ │[ ] Precompiled headers     │  ║
║  │( ) Huge     │ │                            │  ║
║  └─────────────┘ └────────────────────────────┘  ║
║                                                  ║
║ Assume SS equals DS                              ║
║  (.) Default for memory model                    ║
║  ( ) Never                                       ║
║  ( ) Always                                      ║
║                                                  ║
║ ┌─────────────────────────────────────────────┐  ║
║ │Defines                                      │  ║
║ └─────────────────────────────────────────────┘  ║
║                                                  ║
║ [ More...]     [ OK ]    [ Cancel ]   [ Help ]   ║
╚══════════════════════════════════════════════════╝
     Далее приведено значение различных кнопок:
     Model кнопки  определяют,  какую  модель памяти Вы хотите
использовать. Выбранная модель памяти определяет метод адреса-
ции памяти по умолчанию.  Заданной по умолчанию моделью памяти
является Small. Для получения большей информации о моделях па-
мяти  обратитесь  к главе 4 "Модели памяти,  числа с плавающей
точкой и оверлеи" в руководстве программиста. Существуют неко-
торые ограничения по тому,  какие модели памяти можно наиболее
эффективно использовать для различных типов  выполнимого  кода
Windows; рассмотрение этих ограничений приведено в главе 3.
     Опции управляют различными установками генерации кода  по
умолчанию.
     - Включение опции Treat enums as ints  приводит  к  тому,
что  компилятор  всегда размещает целое слово.  Если эта опция
выключена,  то компилятор размещает байт со  знаком  или  без,
если  минимальное и максимальное значения вычисления оба нахо-
дятся в диапазоне от 0 до  255  или  от  -128  до  127,  соот-
ветственно.
     - Word Alignment  кнопка  (когда  она  включена)  говорит
Borland  C++ о выравнивании несимвольных данных (только струк-
тур и объединений) по четным адресам. Когда эта опция отключе-
на,  Borland C++ использует побайтное выравнивание, где данные
(только структуры и объединения) могут выравниваться по четным
или нечетным адресам,  в зависимости от того,  какой следующий
адрес является доступным.
     Выравнивание по  словам  увеличивает скорость,  с которой
процессоры 8086 и 80286 вызывают и хранят данные.
     - Кнопка Duplicate Strings Merged во включенном состоянии
говорит Borland C++ о слиянии двух строк,  когда одна  из  них
соответствует  другой.  Это  приводит к созданию меньших прог-
рамм,  но может привести к ошибкам при модификации одной стро-
ки.
     - Кнопка Unsiged Characters во включенном состоянии гово-
рит Borland C++ обрабатывать все сhar объявления,  как если бы
они имели unsigned char тип. Эта кнопка по умолчанию включена.
     - Включайте  опцию  Precompiled Headers,  если Вы хотите,
чтобы IDE генерировала и использовала откомпилированные  заго-
ловки.  Откомпилированные  заголовки  могут  заметно увеличить
скорость компиляции, хоть они и требуют значительное количест-
во пространства на диске.  Когда эта опция отключена (по умол-
чанию), IDE не будет ни генерировать, ни использовать откомпи-
лированные  заголовки.  Откомпилированные заголовки хранятся в
файле PROJECTNAME.SYM.
     Если включены  зависимые кнопки Default For Memory Model,
то будет ли сегмент стека (SS) равен сегменту данных (DS), за-
висит от используемой модели памяти. Обычно компилятор предпо-
лагает, что SS равен DS в очень маленькой, небольшой и средней
моделях памяти (кроме DLLs).  Описание того,  что предполагает
компилятор для каждой модели памяти и для приложений Windows и
DLLs, см. в главе 3 "Построение приложений Windows".
     Если включена зависимая кнопка Never, то компилятор будет
предполагать, что SS не равен DS.
     Если включена зависимая кнопка Always,  то компилятор бу-
дет предполагать,  что SS равен DS.  Это приведет к тому,  что
IDE заменит модуль запуска C0Fx.OBJ на C0x.OBJ для того, чтобы
поместить стек в сегмент данных.
     Используйте Defines окно ввода для ввода макроопределений
для препроцессора.  Можно разделить несколько определений точ-
кой с запятой (;); например,
     TESTCODE; PROGCONST=5
     Значения могут быть присвоены с необязательным знаком ра-
венства (=).
     Ведущие и заключающие пробелы удаляются, но пробелы внут-
ри остаются нетронутыми. Если Вы хотите включить точку с запя-
той в макрос,  то Вы должны поместить обратный слэш (\)  перед
этим знаком.
     Диалоговое окно Code Generation имеет кнопку More,  кото-
рая  вызывает  диалоговое  окно Advanced Code Generation.  Оно
выглядит следующим образом:
╔═[█]════════ Advanced Code Generation ═════════════╗
║ ┌───────────────┐                                 ║
║ │Floating Point │ ┌─────────────────────────────┐ ║
║ └┐              │ │Options                      │ ║
║  │( ) None      │ └┐                            │ ║
║  │( ) Emulation │  │[X] Generate underbars      │ ║
║  │( ) 8087      │  │[ ] Line numbers debug info │ ║
║  │( ) 80287     │  │[X] Debug info in OBJs      │ ║
║  └──────────────┘  │[X] Fast floating point     │ ║
║ ┌────────────────┐ │[ ] Fast huge pointers      │ ║
║ │Instruction Set │ │[ ] Generate COMDEFs        │ ║
║ └┐               │ │[ ] Automatic far data      │ ║
║  │( ) 8088/8086  │ └────────────────────────────┘ ║
║  │( ) 80186      │                                ║
║  │(.) 80286      │  Far Data Threshold < 32767 >  ║
║  └───────────────┘                                ║
║                [  OK  ]   [ Cancel ]   [ Help ]   ║
╚═══════════════════════════════════════════════════╝
     Кнопки Floating Point позволяют Вам решить, каким образом
Borland C++ будет обрабатывать числа с плавающей точкой.
     - Выберите None, если Вы не используете числа с плавающей
точкой.  (Если Вы выбрали None,  но используете  вычисления  с
плавающей точкой в своей программе,  то получите ошибку редак-
тирования).
     - Выберите Emulation,  если Вы хотите,  чтобы Borland C++
проверил,  имеет ли Ваш компьютер сопроцессор 80х87 (и исполь-
зовал его, если это нужно). Если его нет, Borland C++ эмулиру-
ет 80х87.
     - Выберите  8087  для  генерации прямого встроенного кода
8087. Зависимые кнопки Instruction Set позволяют выбрать набор
команд  CPU  для генерации кода.  По умолчанию задается кнопка
8088/8086 кнопка, которая работает со всеми PC.
     - Во  включенном состоянии опция Generate Underbars гово-
рит Borland C++ автоматически добавлять  символ  подчеркивания
(_) перед каждым глобальным идентификатором (т.е.  функциями и
глобальными переменными).  Если происходит  редактирование  со
стандартными библиотеками, эта кнопка должна быть включена.
     - Кнопка Line Numbers Debug Info во включенном  состоянии
включает  номера строк в файл .MAP (для использования символи-
ческим отладчиком).  Это увеличивает размер объектного файла и
файла .MAP,  но не влияет на скорость выполнения программы. По
умолчанию она отключена.
     Поскольку компилятор должен группировать вместе общий код
из составных строк исходного текста во время оптимизации пере-
хода  или  должен  изменить  порядок строк (что делает трудным
отслеживание номеров строк),  то необходимо убедиться  в  том,
что  кнопка  Jump Optimization (Options/Compiler/Optimization)
выключена, если Вы включаете эту кнопку.
     - Кнопка Debug Info in OBJs проверяет,  включена ли отла-
дочная информация в объектные (.OBJ) файлы.  По умолчанию  эта
кнопка включена, это необходимо как в интегрированном отладчи-
ке, так и в автономном отладчике Turbo Debugger.
     Эта опция  позволяет  редактировать  и  создавать большие
объектные файлы.  Эта опция не влияет на скорость  выполнения,
но  влияет  на скорость компиляции.  Мы рекомендуем,  чтобы Вы
включали эту опцию. Если Вы хотите иметь отладочную информацию
с этой включенной опцией, то отключите отладочную информацию в
Options/Debugging,  или, что еще лучше, отредактируйте с отла-
дочной информацией,  а затем используйте TDSTRIP -s, чтобы от-
делить файл .TDS для отладки.  О файле TDSTRIP можно прочитать
в файле UTIL.DOC.
     - Кнопка Fast  Floating  Point  позволяет  оптимизировать
операции  с плавающей точкой,  не считаясь с явным или неявным
преобразованием типов.  Когда эта опция выключена,  компилятор
следует строгим правилам ANSI в соответствии с преобразования-
ми с плавающей точкой.
     - Опция  Fast  Huge  Pointers  нормализует huge указатели
только тогда, когда происходит циклический возврат от начала к
концу  сегмента  в  части  смещения сегмента.  Это значительно
ускоряет  вычислений  выражений  huge  указателей,  но  должно
использоваться с осторожностью, так как может привести к проб-
лемам в огромных массивах,  если элементы  массива  пересекают
границы сегмента.
     - Включенная опция Generate COMDEFs позволяет  появляться
определению переменной в файлах заголовков, пока она не иници-
ализирована.  Таким  образом,  такое   определение   как   int
SomeArray[256]; может появиться в файле заголовка, который по-
том включается в многие модули,  а компилятор будет  генериро-
вать  его  как  общую  переменную  (как  запись  COMDEF,  а не
PUBDEF).  Редактор затем сгенерирует только один образец пере-
менной, так что не будет ошибки редактора дублирования опреде-
ления.
     - Опция  Automatic  Far  Data и опция Far Data Threshold,
набранная  в  окошке,  работают   вместе.   Включенная   опция
Automatic  Far Data приводит к тому,  что компилятор автомати-
чески генерирует дальние объекты; Far Data Threshold < 32767 >
задает размер части,  необходимой для выполнения команды. Если
Automatic Far Data выключена,  то значение  размера  игнориру-
ется.
     Примечание. Если используется очень маленькая,  небольшая
или средняя модели памяти, то эта опция игнорируется.

                       Entry/Exit Code.

     Когда Вы компилируете программу С или С++ для Windows или
DOS,  компилятору нужно знать, какой вид заголовка и окончания
создавать для каждой функции модуля.
     Если программа предполагается для Windows,  то компилятор
генерирует  заголовок  и окончание,  отличающиеся от тех,  что
создаются для DOS. Из-за этого Вы должны использовать диалого-
вое  окно Entry/Exit Code Generation для установки подходящего
приложения.  Если   Вы   используете   диалоговое   окно   Set
Application Options, то установки в диалоговом окне Entry/Exit
Code Generation уже будут скорректированы для типа  выбранного
Вами приложения.
     Это диалоговое окно также позволит выбрать соглашения вы-
зова  для установки пары опций стека.  Все опции влияют на то,
какой код генерируется для вызовов функций и возвратов.

╔═[█]════════ Entry/Exit Code Generation════════════╗
║                                                   ║
║ Prolog/Epilog Code Generation                     ║
║   (.) DOS Standart                                ║
║   ( ) DOS Overlay                                 ║
║   ( ) Windows all functions exportable            ║
║   ( ) Windows explicit functions exported         ║
║   ( ) Windows smart callbacks                     ║
║   ( ) Windows DLL all functions exportable        ║
║   ( ) Windows DLL explicit functions exported     ║
║                                                   ║
║ Calling Convention   Stack Options                ║
║   (.) C              [X] Standart stack frame     ║
║   ( ) Pascal         [ ] Test stack overflow      ║
║                                                   ║
║                [  OK  ]   [ Cancel ]   [ Help ]   ║
╚═══════════════════════════════════════════════════╝
     Примечание. Можно установить код заголовка/окончания  для
DOS ИЛИ Windows, то не для обоих сразу.
     Если Вы хотите  установить  код  заголовка/окончания  для
приложения  DOS,  Вам  необходимо выбрать DOS Standart или DOS
Overlay.
     - Включите зависимую кнопку DOS Standart,  чтобы компиля-
тор генерировал код, который может быть ненадежным для оверле-
ев.  Используйте  эту опцию,  если Вы не собираетесь создавать
оверлейное приложение.
     - Включите зависимую кнопку DOS Overlay, чтобы компилятор
генерировал надежный оверлейный код.  Используйте  эту  опцию,
если Вы собираетесь создавать оверлейное приложение.
     Если Вы хотите  установить  код  заголовка/окончания  для
приложения Windows, Вам необходимо выбрать одну их пяти опций.
     - Windows All Functions Exportable является наиболее  об-
щим типом выполнимого кода Windows, хоть может быть и не самым
эффективным. Она предполагает, что все функции могут быть выз-
ваны ядром Windows или другими модулями и генерирует необходи-
мую информацию для каждой функции,  нуждается в  этом  функция
или  нет.  Файл определения модуля будет управлять тем,  какая
функция действительно была экспортирована.
     - Используйте Windows Explicit Functions Exported, если у
Вас есть функции, которые не могут быть вызваны ядром Windows;
не  нужно  генерировать  информацию  кода заголовка/окончания,
совместимую с экспортом,  для  этих  функций.  Ключевое  слово
_export  говорит компилятору,  какие функции будут экспортиро-
ваться: только дальние функции с _export будут переданы в спе-
циальный код заголовка/окончания Windows.
     - Включите кнопку Windows Smart Callbacks для выбора  ра-
зумных обратных вызовов Borland C++.
     Компилятор должен предполагать,  что DS=SS для всех функ-
ций в модуле. Более того, Вы должны НЕ включать кнопку Windows
Smart Callbacks для модуля,  который будет компилироваться под
huge моделью памяти.
     - Включите кнопку Windows DLL  All  Functions  Exportable
для  создания  файла .OBJ,  который отредактируется как DLL со
всеми экспортируемыми функциями.
     - Включите кнопку Windows DLL Explicit Functions Exported
создания файла .OBJ,  который отредактируется как DLL с  конк-
ретными  функциями,  которые  точно будут экспортироваться.  В
других отношениях она точно такая же,  что и Windows  Explicit
Functions Exported.
     Опция Calling Convention заставляет компилятор  генериро-
вать или последовательность вызова Си,  или последовательность
вызова Паскаль для вызовов функций. Различие между соглашения-
ми  вызова  Си  и  Паскаль состоит в методах обработки очистки
стека,  числе и порядке параметров,  использовании регистра  и
префиксе внешних идентификаторов.
     ВАЖНО! Не изменяйте эту опцию,  если Вы не очень  опытный
программист и не прочитали главу 9 "Интерфейс с языком ассемб-
лер" в руководстве программиста.
     - Кнопка Standart Stack Frame во включенном состоянии ге-
нерирует стандартную структуру стека (стандартные вход в функ-
цию  и  код завершения).  Это полезно при отладке - упрощается
процесс обратного прохождения по стеку вызванных подпрограмм.
     Если исходный файл откомпилирован с этой опцией в состоя-
нии Off,  то любой файл, который не использует локальные пере-
менные и не имеет параметров, компилируется с сокращенным вво-
дом и кодом возврата.  Это делает код короче и быстрее,  но не
дает команде Debug/Call Stack "посмотреть" функцию.  Таким об-
разом,  эта опция должна быть всегда включена,  если  исходный
файл компилируется для отладки.
     - Кнопка Test Stack Overflow во включенном состоянии  ге-
нерирует  код с проверкой переполнения стека во время выполне-
ния.  Хотя это занимает место и время в программе,  зато может
стать спасителем,  т.к. ошибку переполнения стека очень трудно
отследить.

                         С++ Options.

     С++ Options команда выводит диалоговое  окно,  содержащее
установки,  которые  говорят  компилятору делать объектный код
определенными методами при использовании C++.

╔═[█]══════════════ C++ Options═════════════════════╗
║                                                   ║
║ C++ Virtual Tables   Use C++ Compiler             ║
║   (.) Smart            (.) CPP extension only     ║
║   ( ) Local            ( ) C++ always             ║
║   ( ) External                                    ║
║   ( ) Public                                      ║
║                                                   ║
║ Options                                           ║
║   [X] Out-of-line inline functions                ║
║   [ ] Far virtual tables                          ║
║                                                   ║
║                [  OK  ]   [ Cancel ]   [ Help ]   ║
╚═══════════════════════════════════════════════════╝
     Зависимые кнопки  С++  Virtual Tables позволяют управлять
виртуальными таблицами C++ и расширением  inline  функций  при
отладке.
     - Выбор Smart опции генерирует виртуальные таблицы C++ (и
не  расширенные  inline  функции)  так,  что в программу будет
включен только один образец данной  виртуальной  таблицы  (или
inline функции).  Это создает наименьший по размеру и наиболее
эффективный код,  но  использует  .OBJ  (и  .ASM)  расширения,
доступные  только  с TLINK 3.0 и TASM 2.0 (или более новыми их
версиями).
     - Выбор Local опции генерирует локальные виртуальные таб-
лицы (и не расширенные inline функции) таким образом, что каж-
дый  модуль  получает свою личную копию каждой используемой им
виртуальной таблицы (и inline функции);  эта опция  использует
только стандартные .OBJ (и .ASM) конструкции, но создает боль-
шие выполнимые коды.
     - Выбор  External опции генерирует внешние ссылки на вир-
туальные таблицы;  один или более модулей,  составляющих прог-
рамму,  должны быть откомпилированы с Public опцией,  для того
чтобы дать определения для виртуальных таблиц.
     - Выбор  Public  опции  генерирует  общие определения для
виртуальных таблиц.
     Зависимые кнопки  Use  C++ Compiler говорит Borland C++ о
том,  всегда ли компилировать Ваши программы как код  C++  или
компилировать  Ваш  код  как  код  Си  за исключением файлов с
расширением .CPP.
     - Используйте  кнопку Out-Of-Line Inline Functions,  если
Вы хотите  трассировать  или  установить  точки  прерывания  в
inline функциях.
     - Опция Far Virtual Tables приводит к созданию  виртуаль-
ных  таблиц  в сегменте кода,  а не в сегменте данных и делает
указатели виртуальных таблиц полными  32-битовыми  указателями
(последнее выполняется автоматически, если используется модель
памяти huge).
     Существуют две  основные  причины  для использования этой
опции: удалить виртуальные таблицы из сегмента данных, который
может стать полным, и чтобы иметь возможность разделить объект
(классов с виртуальными  функциями)  между  модулями,  которые
используют различные сегменты данных (например, DLL и выполни-
мый код,  использующий DLL).  Нужно компилировать все  модули,
которые  могут разделить объекты либо полностью с этой опцией,
либо полностью без нее.  Можно достигнуть такого  же  эффекта,
используя    модификаторы   huge   или   _export   на   основе
класс-за-классом.

                 Optimizations (оптимизация).

     Optimizations команда показывает диалоговое  окно.  Уста-
новки в этом окне говорят компилятору делать объектный код оп-
ределенными методами для оптимизации размера или скорости. Это
диалоговое окно выглядит следующим образом:

╔═[█]══════ Optimization Options ══════════╗
║                                          ║
║  Optimization Options                    ║
║   [X] Register optimization              ║
║   [X] Jump optimization       [  OK  ]   ║
║                                          ║
║  Register Variables                      ║
║   ( ) None                               ║
║   ( ) Register keyword       [ Cancel ]  ║
║   (.) Automatic                          ║
║                                          ║
║  Optimize For                            ║
║   ( ) Size                   [  Help ]   ║
║   (.) Speed                              ║
╚══════════════════════════════════════════╝
     Независимые кнопки  Optimizations  Options  влияют на то,
как произойдет оптимизация Вашего кода.
     - Register  Optimization подавляет перезагрузку регистров
путем запоминания содержимого регистров и повторного использо-
вания их настолько часто, насколько это возможно.
     Будьте осторожны, используя эту опцию, поскольку компиля-
тор не может обнаружить,  было ли значение модифицировано неп-
рямо с помощью указателя.
     - Jump  Optimization  уменьшает  размер  кода посредством
исключения излишних команд перехода и переорганизации циклов и
утверждений с переключателем.
     ВАЖНО! Когда эта опция  включена,  в  последовательностях
трассировки  и пошагового прохождения в интегрированном отлад-
чике может возникнуть путаница,  так как там могут быть строки
исходного  кода,  связанные  с  конкретной последовательностью
сгенерированного кода.  Для  улучшения  результата  пошагового
прохождения при отладке отключите эту опцию.
     Зависимые кнопки Register Variables подавляют или  делают
невозможным использование регистровых переменных.
     При выборе кнопки Automatic регистровые переменные  авто-
матически предназначаются для Вас. При выборе кнопки None ком-
пилятор не использует регистровые переменные даже в  том  слу-
чае,  если был использован ключевое слово register. При выборе
кнопки Register Keyword компилятор использует регистровые  пе-
ременные  только  в том случае,  если Вы использовали ключевое
слово register и регистр доступен. (Более подробную информацию
см. в главе 6 "Управление памятью").
     Вообще, можно   держать   эту   опцию   установленной   в
Automatic, если Вы не используете интерфейс с ассемблерным ко-
дом, не поддерживающим регистровые переменные.
     Кнопки Optimize  For позволяют изменить стратегию генера-
ции кода Borland C++.  Обычно компилятор оптимизирует  размер,
выбирая минимально возможную последовательность кода. Компиля-
тор может также оптимизировать скорость, выбирая самую быструю
последовательность для данной задачи. Когда Вы создаете прило-
жения Windows, Вы захотите оптимизировать скорость.

                    Source (исходный код).

     Source команда показывает диалоговое  окно.  Установки  в
этом окне говорят компилятору ожидать определенные типы исход-
ного кода. Диалоговое окно выглядит следующим образом:

╔═[█]═════════ Source Options ═════════════╗
║                                          ║
║  Source Options               [  OK  ]   ║
║   [ ] Nested comments                    ║
║                                          ║
║  Keywords                                ║
║   (.) Borland C++            [ Cancel ]  ║
║   ( ) ANSI                               ║
║   ( ) UNIX V                             ║
║   ( ) Kernighan and Ritchie              ║
║                              [  Help  ]  ║
║  Identifier Length  32                   ║
╚══════════════════════════════════════════╝
     Независимая кнопка Nested Comments позволяет делать  вло-
женные комментарии в исходных файлах Borland C++.  В стандарт-
ных реализациях Си вложенные комментарии не разрешаюся,  и они
не переносимы.
     Зависимые кнопки Keyword говорят компилятору, как распоз-
навать ключевые слова в Ваших программах.
     - Выбор  Borland  C++  говорит  компилятору  распознавать
расширенные  ключевые  слова Borland C++,  включая near,  far,
huge,  asm,  cdecl, pascal, interrupt, _es, _export, _ds, _cs,
_ss,  и регистровые псевдопеременные (_AX, _BX и т.д.). Полный
список содержится в главе 1  "Словарная  грамматика"  в  руко-
водстве программиста.
     - Выбор ANSI говорит компилятору распознавать только ANSI
ключевые слова и обрабатывать любые расширенные ключевые слова
Borland C++ как обычные идентификаторы.
     - Выбор  UNIX  V  говорит компилятору распознавать только
UNIX V ключевые слова и обрабатывать любые расширенные  ключе-
вые слова Borland C++ как обычные идентификаторы.
     - Выбор Kernighan и Ritchie говорит компилятору распозна-
вать  только K&R ключевые слова и обрабатывать любые расширен-
ные ключевые слова Borland C++ как обычные идентификаторы.
     Используйте окно  ввода  Identifier  Length  для  задания
числа (n) значащих символов в  идентификаторе.  Кроме  Borland
C++,  который  распознает идентификаторы неограниченной длины,
все идентификаторы обрабатываются как отличные от других толь-
ко  в том случае,  если отличаются первые n символов.  Это от-
носится к переменным,  именам макросов препроцессора и  именам
элементов  структуры.  Число находится в диапазоне от 1 до 32;
по умолчанию задано 32.

                    Messages (сообщения).

     Messages команда показывает диалоговое окно,  позволяющее
установить несколько опций,  влияющих на сообщения компилятора
об ошибках в интегрированной среде.
     Здесь приведен пример полного диалогового окна:

╔═[█]═════ Compiler Messages ═════════╗
║                                     ║
║       Errors: Stop After  25        ║
║     Warnings: Stop After  100       ║
║         [X] Display warnings        ║
║                                     ║
║     [  Portability...     ]         ║
║     [  ANSI violations... ]         ║
║     [  C++ warnings...    ]         ║
║     [  Frequent errors... ]         ║
║                                     ║
║  [  OK  ]   [ Cancel ]   [ Help ]   ║
╚═════════════════════════════════════╝
     - Errors (ошибки):  опция Stop After (остановиться после)
приводит к остановке компилятора после  обнаружения  заданного
числа ошибок.  По умолчанию задано 25, но Вы можете ввести лю-
бое число от 0 до 255. (Введение 0 приведет к тому, что компи-
лятор продолжит работу до конца файла).
     - Warnings (предупреждения):  опция Stop  After  (остано-
виться после) приводит к остановке компилятора после обнаруже-
ния заданного числа предупреждений.  По умолчанию задано  100,
но Вы можете ввести любое число от 0 до 255.  (Введение 0 при-
ведет к тому,  что компилятор продолжит работу до конца  файла
или до тех пор, пока не произойдет предельное число ошибок).
     - Опция Display  Warnings  (показать  предупреждения)  во
включенном  состоянии  означает,  что  могут быть выведены ка-
кие-либо или все следующие типы предупреждений:
         - Предупреждения о переносимости;
         - ANSI нарушения;
         - Предупреждения C;
         - Частые ошибки.
     Когда эта опция отключена, ни одно из этих предупреждений
выводиться не будет.
     При выборе  кнопки Portability в диалоговом окне Compiler
Messages появляется другое диалоговое окно,  позволяющее  сде-
лать особые установки в этой категории. Это окно выглядит сле-
дующим образом:

╔═[█]═══════════ Portability Warnings ════════════════╗
║                                                     ║
║   [X] Non-portable pointer conversion               ║
║   [X] Non-portable pointer comparison               ║
║   [X] Constant out of range in comparison           ║
║   [ ] Constant is long                              ║
║   [ ] Conversion may lose significant digits        ║
║   [ ] Mixing pointers to signed and unsigned char   ║
║                                                     ║
║                   [ OK ]    [ Cancel ]   [ Help ]   ║
╚═════════════════════════════════════════════════════╝
     Включите предупреждения,  которые хотите просматривать, и
выключите те предупреждения,  которые просматривать не хотите.
Выберите ОК для возврата в диалоговое окно Compiler Messages.
     При выборе  кнопки  ANSI  Violations  в  диалоговом  окне
Compiler Messages появляется другое диалоговое окно, позволяю-
щее  делать  установки  для этой категории.  Это окно выглядит
следующим образом:

╔═[█]════════════ ANSI Violations ═════════════════╗
║                                                  ║
║   [X] Void functions may not return a value      ║
║   [X] Both return and return of a value used     ║
║   [X] Suspicious pointer conversion              ║
║   [X] Undefined structure 'ident'                ║
║   [X] Redefinition of 'ident' is not identical   ║
║   [X] Hexadecimal value more than three digits   ║
║                                                  ║
║ [ More... ]    [ OK ]    [ Cancel ]   [ Help ]   ║
╚══════════════════════════════════════════════════╝
     Включите предупреждения,  которые хотите просматривать, и
выключите те предупреждения,  которые просматривать не хотите.
Выберите ОК для возврата в диалоговое окно Compiler Messages.
     При выборе  кнопки More ANSI Violations в диалоговом окне
ANSI Violations появляется другое диалоговое окно с установка-
ми,  которые можно делать в этой категории.  Это окно выглядит
следующим образом:

╔═[█]═══════════════ More ANSI Violations ════════════════════╗
║                                                             ║
║   [X] Case bypasses initialization of a local variable      ║
║   [X] Goto bypasses initialization of a local variable      ║
║   [X] Untyped bit field assumed signed int                  ║
║   [X] 'ident' declared as both external and static          ║
║   [X] Declare 'ident' prior to use in prototype             ║
║   [X] Division by zero                                      ║
║   [X] Initializing 'ident' with 'ident'                     ║
║   [ ] This initialization is only partially bracketed       ║
║                                                             ║
║                          [  OK  ]   [ Cancel ]   [ Help ]   ║
╚═════════════════════════════════════════════════════════════╝
     Включите или выключите эти предупреждения точно  так  же,
как в вышеописанных диалоговых окнах,  и выберите ОК для возв-
рата в диалоговое окно ANSI Violations.
     При выборе кнопки C++ Warnings в диалоговом окне Compiler
Messages появляется другое диалоговое окно,  позволяющее  сде-
лать установки в этой категории.  Это диалоговое окно выглядит
так:

╔═[█]════════════════════ C++ Warnings ════════════════════════╗
║                                                              ║
║   [X] Assignment to 'this' is obsolete                       ║
║   [X] Base initialization without a class name               ║
║   [X] Functions containing 'ident' are not expanded inline   ║
║   [X] Function 'ident' should have a prototype               ║
║   [X] 'ident' is both a structure tag and a name             ║
║   [X] Temporary used to initialize 'ident'                   ║
║   [X] Temporary used for parameter 'ident'                   ║
║   [X] The constant member 'ident' is not initialized         ║
║   [X] This style of function definition is now obsolete      ║
║   [X] Use of 'overload' is now unnecessary and obsolete      ║
║   [X] Obsolete syntax, use '::' instead                      ║
║   [X] Assigning 'ident' to 'ident'                           ║
║   [X] 'ident' hides virtual function 'ident'                 ║
║   [X] Non-const function 'ident' called for const object     ║
║                                                              ║
║                         [  OK  ]   [  Cancel  ]   [ Help ]   ║
╚══════════════════════════════════════════════════════════════╝
     Включите предупреждения,  которые хотите просматривать, и
выключите те предупреждения,  которые просматривать не хотите.
Выберите ОК для возврата в диалоговое окно Compiler Messages.
     При выборе  кнопки  Frequent  Errors  в  диалоговом  окне
Compiler Messages появляется другое диалоговое окно, позволяю-
щее сделать установки в этой категории.  Это  диалоговое  окно
выглядит так:
╔═[█]════════════════ Frequent Errors ════════════════════╗
║                                                         ║
║   [X] Function should return a value                    ║
║   [X] Unreachable code                                  ║
║   [X] Code has no effect                                ║
║   [ ] Possible use of 'ident' before definition         ║
║   [X] 'ident' is assigned a value which is never used   ║
║   [X] Parameter 'ident' is never used                   ║
║   [X] Possibly incorrect assignment                     ║
║                                                         ║
║      [ More... ]   [  OK  ]   [ Cancel ]   [ Help ]     ║
╚═════════════════════════════════════════════════════════╝
     Включите предупреждения,  которые хотите просматривать, и
выключите те предупреждения,  которые просматривать не хотите.
Выберите ОК для возврата в диалоговое окно Compiler Messages.
     Выбор кнопки More приводит к появлению  диалогового  окна
More Frequent Errors, которое выглядит следующим образом:
╔═[█]═════════════════ More Frequent Errors ═════════════════════╗
║                                                                ║
║   [ ] Superfluous & with function                              ║
║   [ ] 'ident' declared but never used                          ║
║   [ ] Ambiguous operators need parentheses                     ║
║   [ ] Structure passed by value                                ║
║   [ ] No declaration for function 'ident'                      ║
║   [ ] Call to function with no prototype                       ║
║   [X] Restarting compile using assembly                        ║
║   [ ] Unknown assembler instruction                            ║
║   [X] Function definition cannot be a typedef'ed declaration   ║
║   [X] Ill formed pragma                                        ║
║   [ ] Array variable 'ident' is near                           ║
║                                                                ║
║                              [ OK ]    [ Cancel ]   [ Help ]   ║
╚════════════════════════════════════════════════════════════════╝
     Включите предупреждения,  которые хотите просматривать, и
выключите те предупреждения,  которые просматривать не хотите.
Выберите ОК для возврата в диалоговое окно Frequent Errors.

                        Names (имена).

     Names команда вызывает диалоговое окно, позволяющее изме-
нять имена сегментов,  групп и классов, заданные по умолчанию,
для  кодов,  данных  и разделов BSS.  Не изменяйте установки в
этой команде, если вы не очень опытный программист и не прочи-
тали главу 6 "Управление памятью" в руководстве программиста.
     Диалоговое окно выглядит следующим образом:

╔═[█]═════════════════ Segment Names ═════════════════════╗
║                                                         ║
║ ┌──────────────┐┌────────┐  ┌────────────────┐┌────────┐║
║ │Code Segment  ││*       │  │ BSS Segment    ││*       │║
║ └──────────────┘└────────┘  └────────────────┘└────────┘║
║ ┌──────────────┐┌────────┐  ┌────────────────┐┌────────┐║
║ │Code Group    ││*       │  │ BSS Group      ││*       │║
║ └──────────────┘└────────┘  └────────────────┘└────────┘║
║ ┌──────────────┐┌────────┐  ┌────────────────┐┌────────┐║
║ │Code Class    ││*       │  │ BSS Class      ││*       │║
║ └──────────────┘└────────┘  └────────────────┘└────────┘║
║ ┌──────────────┐┌────────┐  ┌────────────────┐┌────────┐║
║ │Data Segment  ││*       │  │Far Data Segment││*       │║
║ └──────────────┘└────────┘  └────────────────┘└────────┘║
║ ┌──────────────┐┌────────┐  ┌────────────────┐┌────────┐║
║ │Data Group    ││*       │  │Far Data Group  ││*       │║
║ └──────────────┘└────────┘  └────────────────┘└────────┘║
║ ┌──────────────┐┌────────┐  ┌────────────────┐┌────────┐║
║ │Data Class    ││*       │  │Far Data Class  ││*       │║
║ └──────────────┘└────────┘  └────────────────┘└────────┘║
║                                                         ║
║                 [  OK  ]   [ Cancel ]   [  Help  ]      ║
╚═════════════════════════════════════════════════════════╝

                     Transfer (переход).

     Options/Transfer команда  позволяет  добавить  и  удалить
программы в Ё меню. Затем можно выбирать элементы из этого ме-
ню  для выполнения другой программы без выхода из Borland C++.
Возврат в Borland C++ происходит только после выхода из  прог-
раммы,  в которую Вы перешли. Transfer команда показывает диа-
логовое окно, которое выглядит так:
╔═[█]═══════════ Transfer ═══════════════╗
║                                        ║
║┌─────────────────────────┐             ║
║│ Program Titles          │             ║
║├─────────────────────────┤ [   OK   ]  ║
║│  ~GREP                ^ │             ║
║│  ~Turbo Assembler     █ │ [ Edit   ]  ║
║│  Turbo ~Debugger      Ё │             ║
║│  ~Resource Compiler   Ё │ [ Delete ]  ║
║│  ~Import Librarian    Ё │             ║
║│                       Ё │ [ Cancel ]  ║
║│                       Ё │             ║
║│                       Ё │ [  Help  ]  ║
║│                       Ё │             ║
║│                       v │             ║
║└─────────────────────────┘             ║
╚════════════════════════════════════════╝
     Transfer диалоговое окно имеет два раздела:
     - список Program Titles;
     - Transfer кнопку.
     Раздел Program Titles перечисляет короткие описания прог-
рамм,  которые были инсталированы и готовы к выполнению. Можно
просмотреть  все  окно  со  списком  (со  скроллингом),  чтобы
посмотреть все доступные программы.
     Transfer кнопки  позволяют  редактировать и удалять имена
программ,  в которые Вы можете перейти, также как и отказаться
от любых изменений,  сделанных в списке перехода.  Здесь также
имеется кнопка справочной информации для получения большей ин-
формации  об  использовании  диалогового окна перехода.  Далее
приведено краткое сообщение о каждой кнопке.

                     Кнопка Edit (редактора).

     Выберите кнопку Edit для пополнения или изменения  списка
Program  Titles,  появляющегося в Ё меню.  Edit кнопка выводит
диалоговое окно New/Modify Transfer Item.
     Если Вы находитесь на элементе перехода при выборе кнопки
Edit, то окна ввода в диалоговом окне Modify/New автоматически
заполняются по этому элементу; в противном случае они пусты.

╔═[█]══════════════ Modify/New Transfer Item ══════════════════╗
║                                                              ║
║ ┌───────────────┐                                            ║
║ │Program Title  └───────────────┐          Hot key           ║
║ │ ~GREP                         │           ( ) Unassigned   ║
║ └───────────────────────────────┘           (.) Shift F2     ║
║ ┌───────────────┐                           ( ) Shift F3     ║
║ │Program Path   └───────────────┐           ( ) Shift F4     ║
║ │ grep                          │           ( ) Shift F5     ║
║ └───────────────────────────────┘           ( ) Shift F6     ║
║ ┌───────────────┐                           ( ) Shift F7     ║
║ │Command Line   └───────────────────────┐   ( ) Shift F8     ║
║ │ -n+ $MEM(64) $NOSWAP $PROMPT $CAP MSG│   ( ) Shift F9     ║
║ └───────────────────────────────────────┘   ( ) Shift F10    ║
║                                                              ║
║   [ ] Translator                                             ║
║         [ New ]      [ Modify ]   [ Cancel ]   [ Help ]      ║
╚══════════════════════════════════════════════════════════════╝
     Используя Modify/New  диалоговое  окно,  нужно  выполнить
следующие  шаги  для добавления нового файла в диалоговое окно
Transfer:
     1. Наберите  короткое описание программы,  которую Вы до-
бавляете в окно  ввода  Program  Title.  (Заметим,  что  когда
используется  транслятор  в  проекте,  он  должен  точно соот-
ветствовать названию программы перехода).
     Заметим, что  если Вы хотите в своей программе иметь сок-
ращения для клавиатуры (такие как S в Save команде или t в Cut
команде),  Вы  должны  включить  в имя знак тильды (~).  Любой
знак,  следующий за тильдой, выделен жирным шрифтом или особым
цветом  в  Ё меню,  указывая на то,  что Вы можете нажать этот
ключ для выбора программы из меню.
     2. С помощью табуляции перейдите к Program Path и набери-
те имя программы,  которое может включать полный путь програм-
мы,  но  это не обязательно.  (Если Вы не набрали полный путь,
будут найдены программы только в текущем справочнике или прог-
раммы по Вашему обычному пути DOS).
     3. С помощью табуляции перейдите к окну  Command  Line  и
наберите любые параметры или макро-команды, которые хотите пе-
редать в программу.  Макро-команды всегда начинаются со  знака
доллара ($) и набираются прописными буквами. Например, если Вы
набрали $CAP EDIT, весь вывод программы будет направлен в спе-
циальное окно редактора в Borland C++.
     Примечание. Подробное  описание  этого  мощного   макроса
смотрите в следующем разделе "Макросы перехода".
     4. Если Вы хотите назначить горячие  клавиши,  с  помощью
табуляции  перейдите  к  опциям Hot Key и назначьте сокращение
для этой программы.  Сокращения перехода  должны  состоять  из
Shift плюс функциональная клавиша.  Нажатия клавиш, уже назна-
ченные, появляются в списке, но являются недоступными.
     Примечание. Этот шаг необязателен.
     5. Теперь отметьте или выберите New кнопку для добавления
этой программы к списку.
     Для модификации существующей программы перехода подведите
к  ней  курсор  в  списке  Program  Titles  в  диалоговом окне
Transfer и затем выберите Edit кнопку.  После выполнения изме-
нений  в диалоговом окне Modify/New Transfer,  выберите кнопку
Modify.
     Независимая кнопка  Translator  позволяет поместить прог-
рамму перехода в список Project File Translators (список,  ко-
торый можно увидеть при выборе команды Project/Local Options).
Включите эту опцию,  если хотите добавить программу  перехода,
которая используется для построения части Вашего проекта.

                     Кнопка Delete (удалить).

     Delete кнопка  удаляет  текущую  выбранную  программу  из
списка в Ё меню.

                         Макросы перехода.

     Усовершенствованная интегрированная среда распознает  оп-
ределенные имена макросов в строке параметров диалогового окна
Modify/New Transfer Item. Существуют три вида макросов: состо-
яние, имя файла и инструкция.
     Расширение макросов состояния зависит от  состояния  усо-
вершенствованной  интегрированной  среды.  Макросами состояния
являются
     $COL      $ERRNAME
     $CONFIG   $INC
     $DEF      $LIB
     $ERRCOL   $LINE
     $ERRLINE  $PRJNAME
     Макросы имен файлов являются  на  самом  деле  функциями,
позволяющими  добавлять  части  спецификаций имен файлов.  Они
позволяют строить новые спецификации имен файлов из существую-
щих имен файлов. Например, можно передать в TDUMP макрос так:
     $DIR($EXENAME)$NAME($EDNAME).OBJ
     Этот макрос дает путь справочника вывода, имя файла толь-
ко в активном окне редактора и неявное расширение.  Если теку-
щим  справочником является C:\WORK,  справочником вывода TEST,
активное окно редактора содержит MYPROG.C,  то  TDUMP  получит
параметр C:\WORK\TEST\MYPROG.OBJ.
     Макросами имен файлов являются:
     $DIR        $EXT()
     $DRIVE()    $NAME()
     $EDNAME     $OUTNAME
     $EXENAME
     Макросы инструкций  говорят  интегрированной среде выпол-
нять некоторые действия или делать некоторые  установки.  Мак-
росами инструкций являются:
     $CAP EDIT           $PROMPT
     $CAP MSG(filter)    $RC
     $DEP()              $SAVE ALL
     $IMPLIB             $SAVE CUR
     $MEM(kb to reserve) $SAVE PROMPT
     $NOSWAP             $TASM

     $CAP EDIT:  Этот макрос говорит интегрированной среде пе-
ренаправить вывод программы в стандартный файл  вывода.  После
завершения программы перехода создастся новое окно редактора и
отобразится захваченный вывод.  Захваченный вывод находится  в
специальном окне редактора, имеющем заголовок Transfer Output.
     Для корректной работы $CAP EDIT программа перехода должна
писать стандартный вывод DOS.
     $CAP MSG(filter):  Захватывает  вывод  программы  в  окне
Message,  используя  filter  как  программу фильтрации DOS для
преобразования вывода программы в формат окна Message.
     Существуют четыре программы фильтрации для этого макроса:
TASM2MSG.EXE для  Turbo  Assembler  (TASM),  GREP2MSG.EXE  для
GREP,  IMPL2MSG.EXE  для  IMPLIB  и  RC2MSG.EXE  для  Resource
Compiler.  Есть также и исходные коды для этих программ  филь-
трации,  так  что  можно написать свои собственные фильтры для
других программ перехода, которые Вы инсталируете.
     Любая программа,  которая имеет построчно-ориентированный
вывод сообщений (номер файла  и  строки),  может  использовать
этот макрос.
     $COL: Номер колонки текущего  редактора.  Если  активного
окна в редакторе нет, то строка устанавливается равной 0.
     $CONFIG: Заполняет имя файла текущим файлом конфигурации.
Если файл конфигурации не задан,  то эта строка будет нулевой.
Этот макрос предназначается для использования программами, ко-
торые имеют обращение или модифицируют файл конфигурации. Кро-
ме работы с именем файла,  этот макрос приводит  к  сохранению
текущей конфигурации (если она была изменена) и ее перезагруз-
ке при возврате управления в интегрированную усовершенствован-
ную среду.
     Используйте этот макрос с компилятором Turbo Editor Macro
Language (TEML).  Можно редактировать файл ввода TEML в редак-
торе и затем вызвать Turbo Editor Macro Compile (TEМC) для об-
работки файла ввода.  Когда файл конфигурации перезагружается,
то будут действовать новые или измененные  команды  редактора.
При  инсталяции TEMC как элемента перехода используйте следую-
щую командную строку:
     $EDNAME $CONFIG
     Предполагается, что текущее окно редактора содержит  файл
ввода TEML, который будет обрабатываться.
     Примечание. TEML - это паскалеподобный язык,  который со-
держит много встроенных примитивных команд редактора.
     $DEF: Хранит содержание окна "Defines"  диалогового  окна
"Options/Compiler/Code  Generation".  Используйте  этот макрос
для задания директив определения внешнего транслятора.
     $DEP(): Этот  макрос  обеспечивает  способность автомати-
чески делать build для исходного кода, являющегося частью про-
екта,  если один из компонентов исходного кода был модифициро-
ван.  Например,  предположим,   что   исходный   Windows   код
MYAPP1.RES для приложения MYAPP1.EXE состоит из следующих фай-
лов:
     - MYAPP1.RC (исходный файл ресурсов)
     - MYAPP1.H (файл заголовка для MYAPP1.EXE)
     - MYAPP1.ICO  (изображение  для MYAPP1.EXE,  включенное в
MYAPP1.RC)
     - MYAPP1.BMP  (битовый образ,  используемый с MYAPP1.EXE,
включенный в MYAPP1.RC)
     Чтобы обеспечить,  что  MYAPP1.RES получит перекомпиляцию
всякий раз,  когда обновится одна из компонент, нужно добавить
следующие   зависимости  в  поле  Options  в  диалоговом  окне
Project/Local Options для MYAPP1.RC:
       $DEP(MYAPP1.H MYAPP1.ICO MYAPP1.BMP)
     При выборе Compile/Make менеджер  проекта  сканирует  для
макроса  $DEP  и проверяет,  все ли данные неявные зависимости
старше,  чем результирующий файл MYAPP.RES.  Если это не  так,
менеджер проекта перекомпилирует MYAPP.RC.
     Можно дать неявные зависимости любому компилируемому эле-
менту  проекта.  Только  поместите  файлы,  от которых зависит
исходный код, в круглые скобки, разделив их пробелами, запяты-
ми или точкой с запятой. Если автозависимость включена, то не-
явные зависимости будут проверены после всех автозависимостей.
     $DIR(): Справочник параметров файла, полный путь.
     $DRIVE(): Устройство файловых параметров, в форме D:.
     $EDNAME: Заполняет  имя файла именем файла в активном ре-
дакторе. Если в редакторе нет активного окна, то это будет ну-
левая строка.
     $ERRCOL: Номер столбца текущей ошибки в  файле  $ERRNAME.
Если сообщений нет, то эта строка будет нулевой.
     $ERRLINE: Номер строки текущей ошибки в  файле  $ERRNAME.
Если сообщений нет, то эта строка будет нулевой.
     $ERRNAME: Заполняет имя файла именем  файла,  на  который
ссылаются выбранные сообщения в окнe Message.  Она будет нуле-
вой строкой,  если нет сообщений или текущее выбранное сообще-
ние не ссылается на файл.
     $EXENAME: Имя  файла  программы  (включая  путь  вывода),
основанное  на  имени проекта или,  если проект не задан,  имя
.EXE файла, который будет создаваться из активного окна редак-
тора.  Расширением  имени файла будет .DLL,  если задана опция
Windows DLL Linker.
     $EXT(): Расширение файлового параметра; он включает точку
(например, .CPP).
     $IMPLIB: Выполняет  IMPLIB.  Этот  макрос  расширяется до
$NOSWAP $CAP MSG (IMPL2MSG)
$DRIVE($EXENAME)$DIR(EXENAME)$NAME($EXEAME).LIB $EXENAME|def_name
Если включена  зависимая   кнопка   Use   DLL   File   Exports
(Options/Make/Generate  Import Library),  то $EXENAME является
частью расширения. Если включена зависимая кнопка Use DEF File
Exports, то используется имя файла DEF в проекте (представлен-
ное def_name).
     $INC: Содержимое окна  ввода  Options/Directories/Include
Directories.
     $LIB: Содержимое окна  ввода  Options/Directories/Library
Directories.
     $LINE: Номер  строки  текущего редактора.  Если активного
окна в редакторе нет, строка устанавливается в 0.
     $MEM(Kb для  резерва):  Этот макрос говорит IDE,  сколько
памяти дать программе  перехода.  Интегрированная  среда  дает
столько  памяти,  сколько возможно;  либо заданное количество,
либо максимально доступное, смотря что из них меньше. Вы полу-
чите ошибку, если память не будет задана.
     $NAME(): Часть имени файлового параметра; точки не содер-
     жит.
     $NOSWAP: Этот макрос говорит интегрированной среде не пе-
реключаться на пользовательский экран.  Он выводит окно, пока-
зывающее,  какая программа перехода  выполняется.  Используйте
этот макрос вместе с $CAP.
     $OUTNAME: Этот макрос расширяется до пути и имени  файла,
которое  появляется  в окне ввода Project/Local Options Output
Path (в активном окне редактора). Например, если проект содер-
жит STARS.C, то по умолчанию в окне ввода Output Path появится
STARS.OBJ.  Поэтому если STARS.C находится в активном окне ре-
дактора,  то $OUTNAME расширяется до STARS.OBJ.  Если Вы отре-
дактировали  окно  ввода  так,   что   оно   стало   содержать
..\MOON.XYZ,  то $OUTNAME расширится до ..\MOON.XYZ. Этот мак-
рос полезен, если Вы обозначаете модули для своих определенных
пользователем   трансляторов.   Например,   можно   определить
транслятор TLIB и установить командную строку
  TLIB MYLIB +$OUTNAME
которая добавляет объектный модуль файла в активном  окне  ре-
дактора к библиотеке MYLIB.
     $PRJNAME: Текущий проектный файл.  Нулевая  строка,  если
проект не задан.
     $PROMPT: Этот макрос говорит интегрированной среде  пока-
зывать  расширенную  строку параметров перед вызовом программы
перехода.  Командная строка будет передана в таком  виде,  как
была  показана  в диалоговом окне.  Это позволяет изменять или
добавлять строку перед ее передачей. Позиция $PROMPT команды в
командной строке определяет, что показывается в диалоговом ок-
не Prompt.  Можно поместить постоянные параметры  в  командной
строке посредством размещения их перед $PROMPT. Например, /с в
     /c $PROMPT dir
     является константой  и не показывается в диалоговом окне,
а dir можно редактировать перед выполнением команды.
     $RC: Этот   макрос   предопределен  для  использования  с
Resource Compiler. Так как Resource Compiler может быть вызван
по  двум  различным причинам,  то $RC расширяется по разному в
зависимости от того,  компилируете ли Вы .RC файл в .RES  файл
или связываете файл
.RES в выполнимый файл.
     В любом   случае,   для  того  чтобы  изменить  поведение
Resource Compiler:
     - Во время компиляции файла .RC, измените командную стро-
ку в Project/Local Options для файла .RC в менеджере проекта.
     - При связывании файла .RES в .EXE или .DLL, измените оп-
ции в Options/Transfer/Resource Compiler.
     ЕСЛИ ВЫ КОМПИЛИРУЕТЕ ФАЙЛ .RC В ФАЙЛ .RES,  ТО $RC расши-
ряется следующим образом:
$SAVE CUR $NOSWAP $CAP MSG(RC2MSG) -R -I$INC -F0 $OUTNAME $EDNAME
     ЕСЛИ ВЫ СВЯЗЫВАЕТЕ ФАЙЛ .RES В ФАЙЛ .EXE, ТО $RC расширя-
ется следующим образом:
     $NOSWAP $CAP MSG(RC2MSG) res_name $EXENAME
     Переменная res_name   определяется   одним  из  следующих
способов, по порядку:
     1. Если  в  проекте  есть  файл  с  расширением .RES,  то
res_name будет этим файлом.
     2. Если  в проекте нет файла с расширением .RES,  но ЕСТЬ
файл с расширением .RC,  то res_name - это имя,  данное с  по-
мощью $OUTNAME для файла .RC.
     3. Если не выполняется ни одно из вышеперечисленных усло-
вий  (подразумевая,  что  файлы  не  явялются  ресурсами),  то
res_name является пустым.
     $SAVE ALL:  Этот  макрос  говорит интегрированной усовер-
шенствованной среде сохранять все измененные файлы во всех ок-
нах редактора без подсказки.
     $SAVE CUR:  Этот макрос говорит  интегрированной  усовер-
шенствованной  среде сохранять файл в текущем редакторе,  если
он был изменен.  Это приводит к тому,  что вызванная программа
будет использовать последнюю версию исходного файла.
     $SAVE PROMPT: Этот макрос говорит интегрированной усовер-
шенствованной среде выдавать подсказку, когда в окнах редакто-
ра есть несохраненные файлы.  Вас спросят, хотите ли Вы сохра-
нить несохраненные файлы.
     $TASM: Этот  макрос  предопределен  для  использования  с
Borland Assembler. Он использует TASM2MSG программу фильтрации
для задержки TASM сообщений.  $TASM существенно сокращает сле-
дующее:
$NOSWAP $SAVE CUR $CAP MSG(TASM2MSG) $EDNAME, $OUTNAME
     WRITEMSG(filename): Этот  макрос копирует содержание окна
Message в заданный файл ASCII. Транслятор может делать грамма-
тический разбор и поступать с сообщениями, как требуется. Нап-
ример,  WRITEMSG(C:\MESSAGES.TXT) пишет в файл MESSAGES.TXT  в
Вашем корневом справочнике.

                    Выполнение команд DOS.

     Если Вы  хотите запустить команды DOS изнутри IDE,  можно
просто установить макрос перехода, кторый позволит Вам сделать
это. Только добавьте этот элемент перехода:
      command /c $MEM(128) $PROMPT
     Когда Вы вызовете этот элемент перехода,  появится диало-
говое окно и подскажет Вам сделать ввод для DOS.  Так как  ко-
манда $PROMPT появляется в строке позднее, то текст command /c
не будет показан в диалоговом окне ввода.  Это  позволяет  Вам
набрать только dir, chkdsk, del *.* и любую команду DOS, кото-
рую Вы хотите запустить.

           Установка памяти для программ перехода.

     Различные программы испытывают разную потребность в памя-
ти.  Например, GREP можно запустить с очень маленькой памятью,
в то время как многие популярные редакторы требуют  200-300  К
для хорошей работы.
     Если Вы используете $MEM макрос,  то  можете  задать  (на
основе программа-за-программой),  сколько памяти даст интегри-
рованная усовершенствованная среда  программам  перехода.  Чем
меньше памяти будет дано программе перехода, тем быстрее прои-
зойдет переход в и из программы.
     Может быть несколько случаев,  когда интегрированная усо-
вершенствованная среда не сможет дать столько памяти,  сколько
Вы затребуете. Когда такое происходит, интегрированная усовер-
шенствованная среда дает столько памяти, сколько может. Бывают
определенные  состояния  в интегрированной усовершенствованной
среде,  которые требуют больше памяти,  чем в других  случаях;
например,  во  время отладки программы интегрированная усовер-
шенствованная среда возьмет больше ресурсов,  чем без отладки.
Используйте  Program  Reset (Ctrl-F2) для освобождения памяти,
взятой под отладку.
     В случаях,  когда Вам хочется, чтобы интегрированная усо-
вершенствованная среда дала всю свою  память,  задайте  просто
большое  число,  например  640К.  Сколько памяти Вы получите в
действительности,  зависит от того,  сколько памяти было в мо-
мент запуска Borland C++.

                            Make.

     Options/Make команда показывает диалоговое окно, позволя-
ющее установить условия для управления проектом.  Оно выглядит
так:
╔═[█]════════════ Make ════════════════╗
║                                      ║
║  Break Make On                       ║
║   (.) Warnings                       ║
║   ( ) Errors                         ║
║   ( ) Fatal errors                   ║
║   ( ) Link                           ║
║                                      ║
║  Generate Import Library             ║
║   ( ) No                             ║
║   ( ) Use DLL file exports           ║
║   ( ) Use DEF file exports           ║
║                                      ║
║   [X] Check auto-dependencies        ║
║                                      ║
║   [ OK ]    [ Cancel ]   [ Help]     ║
╚══════════════════════════════════════╝
     Используйте зависимые  кнопки  Break  Make On для задания
условий, прекращающих построение проекта. По умолчанию услови-
ем остановки является ошибка во время компиляции файла.
     Кнопки Generate Import Library управляют тем, как и когда
выполняется IMPLIB во время процесса MAKE.  Опция Use DLL File
Exports генерирует  библиотеку  импорта,  которая  состоит  из
экспорта в DLL. Use DEF File Exports генерирует библиотеку им-
порта из экспорта в файле DEF.  Если включена одна из этих оп-
ций,  MAKE  вызывает IMPLIB,  после того,  как редактор создал
DLL.  Эта опция управляет тем, как будет расширен макрос пере-
хода $IMPLIB.
     Когда опция  Check  Autodependencies  включена,  менеджер
проекта  автоматически  проверяет зависимости для каждого .OBJ
файла на диске,  имеющего соответствующий .С исходный  файл  в
проектном списке.
     Менеджер проекта открывает .OBJ файл и просматривает  ин-
формацию о файлах, включенных в исходный код. Такая информация
всегда помещается в .OBJ файл как Borland C++,  так и  Borland
C++ в режиме командной строки при компиляции исходного модуля.
Затем каждый файл,  использованный для построения .OBJ  файла,
проверяется  на  дату  и время по сравнению с датой и временем
информации в .OBJ файле.  Если даты различаются,  .С  исходный
файл перекомпилируется. Это вызывает autodependency check (ав-
тозависимую проверку). Если эта опция отключена, такой провер-
ки файлов производиться не будет.
     После успешного завершения компиляции исходного  файла  С
проектный  файл содержит достоверную информацию о зависимостях
для этого файла.  Как только достоверная информация была поме-
щена  в  проектный  файл,  менеджер проекта начинает выполнять
проверку автозависимости, используя эту информацию. Это гораз-
до быстрее, чем чтение каждого файла .OBJ.

                   Linker (редактирование).

     Options/Linker команда  позволяет сделать несколько уста-
новок,  влияющих на редактирование.  Linker команда  открывает
диалоговое окно, которое выглядит следующим образом:
╔═[█]══════════════════ Linker ═══════════════════════╗
║                                                     ║
║  Map File               Options                     ║
║   (.) Off                [ ] Initialize segments    ║
║   ( ) Segments           [X] Default libraries      ║
║   ( ) Publics            [X] Graphics library       ║
║   ( ) Detailed           [ ] Warn duplicate symbols ║
║                          [X] "No stack" warning     ║
║  Output                  [X] Case-sensitive link    ║
║   (.) Standart DOS EXE   [ ] Case-sensitive exports ║
║   ( ) Overlaid DOS EXE   [ ] Pack code segments     ║
║   ( ) Windiws EXE                                   ║
║   ( ) Windows DLL        Code Pack Size   8192      ║
║                       Segment Alignment   512       ║
║                                                     ║
║             [  OK  ]   [ Cancel ]  [ Help ]         ║
╚═════════════════════════════════════════════════════╝
     Это диалоговое окно имеет несколько зависимых и независи-
мых кнопок. Следующие разделы кратко описывают каждую из них.
     Используйте Map File зависимые  кнопки  для  выбора  типа
создаваемого файла .MAP.  Для установок, отличных от Off, файл
.MAP помещается в справочник вывода, заданный в диалоговом ок-
не  Options/  Directories.  Установкой  по умолчанию для файла
.MAP является Off.
     Используйте зависимые  кнопки Output для установки своего
типа приложения.  Standard DOS EXE создает обычный  выполнимый
код, который выполняется под управлением DOS. Overlaid DOS EXE
создает выполнимый код, который допустим при работе с оверлея-
ми. Windows EXE создает приложение Windows, а Windows DLL соз-
дает динамическую библиотеку редактора Windows.
     Включенная кнопка  Initialize  Segments говорит редактору
связей инициализировать неинициализированные сегменты.  (Этого
обычно не требуется и делает Ваши .EXE файлы больше).
     Когда происходит редактирование модулей, созданных компи-
лятором,  отличным от Borland C++, другой компилятор может по-
местить в объектный файл список библиотек, заданных по умолча-
нию.
     Если опция Default Libraries  включена,  редактор  связей
пытается найти все неопределенные подпрограммы как в этих биб-
лиотеках,  так и  в  библиотеках  по  умолчанию,  предлагаемых
Borland  C++.  Если эта опция отключена,  редактор связей осу-
ществляет поиск только в библиотеках по умолчанию,  предлагае-
мых Borland C++ и игнорирует все умолчания в .OBJ файлах.
     Опция Graphics Library управляет  автоматическим  поиском
BGI графической библиотеки. Когда эта опция включена (по умол-
чанию),  то можно строить и выполнять  графические  программы,
состоящие из одного файла, без использования проектного файла.
Отключение этой опции повышает скорость редактирования связей,
потому что редактор связей не делает поиска в файле BGI графи-
ческой библиотеки.
     Примечание. Можно  отключить  эту  опцию  и  даже строить
программы,  которые используют BGI графику,  добавляя имя  BGI
графической  библиотеки  (GRAPHICS.LIB)  к  своему  проектному
списку.
     Опция Warn Duplicate Symbols определяет,  будет ли редак-
тор связей выдавать предупреждение об уже встреченных символах
в .LIB файлах.
     Опция "No Stack" Warning определяет,  будет  ли  редактор
связей генерировать сообщение "No stack".
     Примечание. Является обычным для программы,  генерируемой
по  очень  маленькой  модели,  показывать это сообщение,  если
сообщение не отключено.
     Опция Case-Sensitive  Link определяет,  будет ли редактор
связей зависеть от регистра.  Обычно  эта  опция  должна  быть
включена, т.к. С и С++ - это язык, ориентированный на регистр.
     Опция Case-Sensitive Exports.  По умолчанию редактор свя-
зей  игнорирует  регистр  имен  в разделах IMPORTS и EXPORTS в
файле определений модуля. Если Вы хотите, что бы редактор свя-
зей различал регистры относительно этих имен, включите эту оп-
цию.  Вероятно эта опция будет полезной только тогда, когда вы
попытаетесь экспортировать функции необратного вызова из DLL -
как в экспортируемых С++ функциях-элементах.  Эта опция необя-
зательна  для обычных функций обратного вызова Windows (объяв-
ленных FAR PASCAL).
     Опция Pack code segments применяется только в приложениях
Windows и DLL. Когда эта опция включена, редактор пытается ми-
нимизировать  число  сегментов  кода путем упаковки нескольких
сегментов кода вместе; обычно это повышает производительность.
Эта опция никогда не создает сегменты размером больше 64К.
     Окно ввода Code Pack Size. Можно изменить размер упаковки
кода  по умолчанию на число от 1 до 65536 с помощью этого окна
ввода.
     С помощью  окна  ввода  Segment Aligment можно установить
выравнивание сегментов.  Заметим, что коэффициент выравнивания
будет  автоматически  округлен до ближайшей степени двух (если
Вы ввели 650,  он автоматически округлится до 1024). Возможные
числа, которые можно ввести, должны лежать в диапазоне от 2 до
65535.

           Диалоговое окно Set Application Options.

     Это диалоговое окно обеспечивает самый легкий и  надежный
способ для установки компиляции и редактирования связей выпол-
нимого кода DOS или Windows.  Для использования этого диалого-
вого окна просто нажмите одну из кнопок.  Borland C++ проверит
и,  если необходимо, изменит некоторые из установок в диалого-
вых  окнах  Code  Generation,  Entry/Exit  Code  Generation  и
Linker.  Используйте это диалоговое окно только для  начальной
установки.
╔═[█]════════════════Set Application Options═══════════════════╗
║                Current Settings                              ║
║                                                              ║
║          Linker output      Standart DOS EXE                 ║
║          Prolog/Epilog      DOS Standart                     ║
║                  Model      Small                            ║
║    Assume SS equals DS      Default for memory model         ║
║           Graphics lib      Yes                              ║
║                                                              ║
║[ DOS Standart ] [ DOS Overlay ] [Windows App] [Windows DLL ] ║
║                                                              ║
║           [  OK  ]     [  Cancel  ]  [  Help  ]              ║
╚══════════════════════════════════════════════════════════════╝
     Каждая из  стандартных  опций  для приложений и библиотек
выполняет набор задач.  Вы можете выбрать только одну  кнопку.
При нажатии кнопки обновятся текущие поля установок.
     DOS Standard:
     - нажимает зависимую кнопку Small memory model в диалого-
вом окне Code Generation;
     - отключает опцию Assume SS not Equal DS в диалоговом ок-
не Code Generation;
     - нажимает зависимую кнопку DOS Standard в диалоговом ок-
не Entry/Exit Code Generation;
     - нажимает зависимую кнопку Standard DOS.EXE в диалоговом
окне Linker;
     - включает  опцию  Graphics  Library  в  диалоговом  окне
     Linker.
     DOS Overlay:
     - нажимает зависимую кнопку Medium memory model в  диало-
говом окне Code Generation;
     - отключает опцию Assume SS not Equal DS в диалоговом ок-
не Code Generation;
     - нажимает зависимую кнопку DOS Overlay в диалоговом окне
Entry/Exit Code Generation;
     - нажимает зависимую кнопку Overlaid DOS.EXE в диалоговом
окне Linker;
     - включает  опцию  Graphics  Library  в  диалоговом  окне
     Linker.
     Windows  App:
     - нажимает зависимую кнопку Small memory model в диалого-
вом окне Code Generation;
     - отключает опцию Assume SS not Equal DS в диалоговом ок-
не Code Generation;
     - нажимает   зависимую   кнопку   Windows  All  Functions
Exportable в диалоговом окне Entry/Exit Code Generation;
     - нажимает зависимую кнопку Windows.EXE в диалоговом окне
Linker;
     - отключает  опцию  Graphics  Library  в  диалоговом окне
     Linker.
     Windows DLL:
     - нажимает зависимую кнопку Compact
     memory model в диалоговом
окне Code Generation;
     - включает опцию Assume SS not Equal DS в диалоговом окне
Code Generation;
     - нажимает  зависимую  кнопку  Windows  DLL All Functions
Exportable в диалоговом окне Entry/Exit Code Generation;
     - отключает  опцию  Graphics  Library  в  диалоговом окне
Linker.

                     Debugger (отладчик).

     Options/Debugger команда  позволяет   сделать   несколько
установок,  влияющих на интегрированный отладчик.  Эта команда
открывает диалоговое окно, которое выглядит следующим образом:

╔═[█]══════════════════ Debugger ══════════════════════╗
║                                                      ║
║  Source Debugging   Inspectors                       ║
║   (.) On             [X] Show inherited    [ OK ]    ║
║   ( ) Standalone     [X] Show methods                ║
║   ( ) None                                           ║
║                      ( ) Show decimal    [ Cancel ]  ║
║  Display Swapping    ( ) Show hex                    ║
║   (.) None           (.) Show both                   ║
║   ( ) Smart       ┌───────────────────┐   [ Help ]   ║
║   ( ) Always      │ Program Heap Size │              ║
║                   │  64     K bytes   │              ║
║                   └───────────────────┘              ║
╚══════════════════════════════════════════════════════╝
Следующие разделы описывают содержание этого окна.
     Зависимые кнопки  Source  Debugging определяют,  будет ли
отладочная информация включена в выполнимый файл и  как  будет
выполняться .EXE под Borland C++.
     Программы, отредактированные с этой опцией, установленной
в  On  (по умолчанию),  можно отлаживать как в интегрированном
отладчике, так и в автономном отладчике Turbo Debugger. Перек-
лючите ее обратно в On,  если хотите отлаживаться в интегриро-
ванной усовершенствованной среде.
     Если эту опцию установить в Standalone, то программы мож-
но будет отлаживать только в Turbo Debugger,  хотя выполняться
они могут все еще в Borland C++.
     При установлении этой опции в None нельзя  будет  отлажи-
вать программы ни в одном отладчике,  т.к. отладочная информа-
ция не будет помещена в .EXE файл.
     Зависимые кнопки  Display  Swapping позволяют установить,
когда интегрированному отладчику изменять  окна  просмотра  во
время выполнения программы.
     Если установить Display Swapping в None,  то отладчик  не
будет изменять экран вообще.  Нужно использовать эту установку
для части отладки кода,  где совершенно определенно нет вывода
на экран.
     При выполнении программы в режиме отладки с установкой по
умолчанию  Smart  отладчик  ищет в коде,  который выполняется,
места, где будет генерироваться вывод на экран. Если код дела-
ет вывод на экран (или вызов функции), то происходит изменение
экрана с экрана интегрированной усовершенствованной  среды  на
экран пользователя на время,  достаточное для вывода,  а затем
изменяется обратно.  В противном случае  изменения  экрана  не
происходит.
     Примечание. Знайте, что при быстрой смене экрана:
     - Он  изменяется при любом вызове функции,  даже если эта
функция не делает вывода на экран;
     - В  некоторых  ситуациях  экран  интегрированной усовер-
шенствованной среды может быть модифицирован без замены;  нап-
ример, если на экран пишет подпрограмма, вызывающая прерывание
таймера.
     При установлении  кнопки Display Swapping в Always отлад-
чик будет изменять экран всякий раз при  выполнении  утвержде-
ния. Нужно выбрать эту опцию, если поверх экрана интегрирован-
ной усовершенствованной среды будет писать Ваша  выполняющаяся
программа.
     Примечание. При отладке в режиме двойного монитора  (т.е.
с  использованием опции /d в командной строке Borland C++) вы-
вод своей программы можно видеть на одном  мониторе,  а  экран
Borland C++ - на другом. В этом случае, Borland C++ никогда не
изменяет экран и установка Display Swapping ни на что не  вли-
яет.
     Независимая кнопка   Inspectors,   включенная   в    Show
Inherited,  говорит  интегрированному отладчику показывать все
функции и методы элемента -  были  ли  они  определены  внутри
инспектируемого класса или были порождены от основного класса.
Когда эта опция отключена, будут показаны только поля, опреде-
ленные в типе инспектируемого объекта.
     Включенная опция Show  Methods  говорит  интегрированному
отладчику   показывать  функции-элементы  при  инспектировании
класса.
     Включите зависимые кнопки Show Decimal, Show Hex или Show
Both,  для управления представлением  значений  при  показе  в
Inspectors.  По умолчанию в состоянии On находится кнопка Show
Both.
     Можно использовать окно ввода Program Heap Size для ввода
количества памяти,  которую Borland C++ назначит программе при
ее отладке.  Действительное количество памяти, которую Borland
C++ попытается дать программе, равно размеру выполнимого обра-
за плюс количество памяти, которое Вы зададите здесь.
     Значением по умолчанию для размера кучи  программы  явля-
ется 64 Кб.  Можно увеличить это значение, если Ваша программа
использует динамически размещенные объекты.
     Примечание. Имеет  смысл  увеличивать  размер кучи только
при работе с большими моделями данных.

                  Directories (справочники).

     Options/Directories команда  позволяет  сказать   Borland
C++,  где искать файлы,  необходимые для компиляции,  редакции
связей и куда вывести двоичный файл и файл .MAP.
     Эта команда открывает диалоговое окно, содержащее три ок-
на ввода. Оно выглядит следующим образом:

╔═[█]══════════════════ Directories ══════════════════════╗
║ ┌────────────────────┐                                  ║
║ │Include Directories │                                  ║
║ │                    └─────────────────────────┐        ║
║ │ E:\TC\INCLUDE                                │        ║
║ └──────────────────────────────────────────────┘        ║
║ ┌────────────────────┐                                  ║
║ │Library Directories │                                  ║
║ │                    └─────────────────────────┐        ║
║ │ E:\TC\LIB                                    │        ║
║ └──────────────────────────────────────────────┘        ║
║ ┌──────────────────────────────────────────────┐        ║
║ │Output Directory                              │        ║
║ └──────────────────────────────────────────────┘        ║
║                                                         ║
║                      [  OK  ]   [ Cancel ]  [  Help ]   ║
╚═════════════════════════════════════════════════════════╝
     Ниже показано, для чего предназначено каждое окно ввода:
     - Окно ввода Include Directories задает  справочник,  со-
держащий включаемые файлы.  Стандартные включаемые файлы - это
файлы в угловых скобках (<>) в утверждении #include (например,
#include<myfile.h>).  Эти  справочники  также используются для
поиска файлов, на которые ссылается Includes, если они не най-
дены  в текущем справочнике.  Разрешаются несколько имен спра-
вочников, разделенных точкой с запятой.
     Окно ввода Library Directoties устанавливает справочники,
которые содержат объектные файлы начального кода  Borland  C++
(CO?.OBJ) и файлы библиотеки времени выполнения (.LIB файлы) и
другие библиотеки, которые может использовать Ваш проект. Раз-
решается  введение  нескольких имен справочников,  разделенных
точкой с запятой.
     - Окно ввода Output Directory задает справочник,  который
будет хранить Ваши .OBJ,  .EXE и .MAP файлы.  Borland C++ ищет
этот  справочник,  когда  делает компиляцию или выполнение или
проверяет дату и время файлов .OBJ и .EXE.  Если ввода в  этом
окне не было, файлы будут храниться в текущем справочнике.
     Используйте следующие директивы при введении  имен  спра-
вочников в этих окнах ввода:
     - Нужно разделять составные имена пути справочника  (если
это разрешено) точкой с запятой (;). Можно использовать макси-
мум 127 символов (включая пробелы).
     - Пробелы  перед и после точки с запятой разрешаются,  но
не требуются.
     - Разрешаются  относительные  и  абсолютные  имена путей,
включая имена путей,  относящихся к фиксированной  позиции  на
устройстве, отличного от текущего. Например,
     C:\C\LIB;C:C\MYLIBS;A:TC\MATHLIBS;A:..\VIDLIBS

                     Environment (среда).

     Options/Environment команда позволяет  сделать  установки
для  среды.  Эта  команда открывает меню,  позволяющее выбрать
установки из опций Preferences, Editor, Mouse и Desktop.
     Диалоговое окно выглядит следующим образом:
╔═[█]══════════════ Preferences ══════════════════╗
║                                                 ║
║  Screen Size           Auto Save                ║
║   ( ) 25 lines          [X] Editor files        ║
║   (.) 43/50 lines       [X] Environment         ║
║                         [X] Desktop             ║
║  Source Tracking        [X] Project             ║
║   (.) New window                                ║
║   ( ) Current window    [ ] Save old messages   ║
║                                                 ║
║              [  OK   ]  [ Cancel ]   [ Help ]   ║
╚═════════════════════════════════════════════════╝
     Зависимые кнопки Screen Size позволяют установить,  будет
ли экран интегрированной усовершенствованной  среды  иметь  25
строк или 43/50 строк.
     В зависимости  от  типа  видеоадаптера  Вашего  PC  будут
доступны одна или две кнопки.
     При установке 25 строк (по умолчанию) Borland C++ исполь-
зует 25 строк и 80 столбцов. Для систем с монохромным дисплеем
или Color Graphics Adapter (CGA) доступен только  этот  размер
экрана.
     Если Ваш персональный компьютер имеет EGA или  VGA  адап-
тер,  можно  использовать  опцию 43/50 строк.  Интегрированная
усовершенствованная среда показывает 43 строки и 80  столбцов,
если имеется EGA адаптер, и 50 строк на 80 столбцов, если име-
ется VGA адаптер.
     При пошаговом прохождении или просмотре исходного кода из
окна Message интегрированная усовершенствованная среда  откры-
вает новое окно,  как только она встретит файл, который не был
еще загружен.  Selecting Current Window приводит к  тому,  что
интегрированная  усовершенствованная среда заменяет содержание
самого верхнего окна редактора новым  файлом  вместо  открытия
нового окна редактора.
     Если Editor Files включена в опции Auto Save, и если файл
был изменен со времени последнего сохранения,  Borland C++ ав-
томатически сохраняет исходный файл,  как  только  Вы  выбрали
Run/Run (или любую другую команду отладки/запуска) или File/OS
Shell команду.
     Когда включена опция Environment,  все установки, сделан-
ные в этом диалоговом окне, автоматически сохранятся при выхо-
де из Borland C++.
     Когда включена опция Desktop,  Borland C++ управляет тем,
будет  ли  сохраняться  конфигурация при выходе и будет ли она
восстанавливаться при возврате в Borland C++.
     Когда включена  опция Project,  Borland C++ сохраняет все
установки проекта,  автозависимости и установки модуля при вы-
ходе и восстанавливает их при возврате в Borland C++.
     Когда включена опция Save Old Messages,  Borland C++ сох-
раняет все сообщения об ошибках в текущем окне Message, добав-
ляя любые сообщения при последующей компиляции в это окно. При
компиляции  файла любые сообщения для этого файла удаляются из
окна Message, а новые сообщения добавляются в конец. Сообщене-
ния не сохраняются от одного сеанса работы до следующего.  При
отключении этой кнопки Borland C++ автоматически очищает сооб-
щения  перед  компиляцией  или  переходом,  использующими окно
Message.
     При выборе Editor в меню Environment появляются опции, из
которых можно осуществить выбор.
┌───────────────────────────┐
│  Editor Options           │
│   [X] Create backup files │
│   [X] Insert mode         │
│   [X] Autoindent mode     │
│   [X] Use tab character   │
│   [X] Optimal fill        │
│   [X] Backspace unindents │
│   [X] Cursor through tabs │
│   [ ] Group undo          │
│   [X] Persisten blocks    │
└───────────────────────────┘
     Диалоговое окно  Editor Options имеет несколько независи-
мых кнопок, управляющих обработкой текста в окнах редактора.
     - При  включенной  кнопке Create Backup Files (по умолча-
нию) Borland C++ автоматически создает копию исходного файла в
окне  редактора,  если Вы выберете File/Save и дает этой копии
файла расширение .BAK.
     - При выключенной опции Insert Mode любой текст, набирае-
мый в окнах редактора,  будет перекрывать существующий  текст.
Когда эта опция включена,  набираемый текст вставляется (сдви-
гая вправо).  Нажатие Ins включает Insert режим при  работе  в
окне редактора.
     - Когда включена опция Autoindent Mode,  нажатие Enter  в
окне редактора устанавливает курсор под первый непустой символ
в первой непустой строке.  Это поможет Вам сделать  код  Вашей
программы более читаемым.
     - Когда включена опция Use  Tab  Character,  Borland  C++
вставляет  символ табуляции (ASCII 9) при нажатии клавиши Tab.
Если эта опция отключена,  Borland C++ заменяет табуляцию про-
белами.  Если есть какие-либо строки с символами, предшествую-
щие текущей строке,  то курсор  установится  на  первый  соот-
ветствующий столбец символов, следующий за ближайшим пробелом.
Если такого "следующего" пробела нет, то курсор установится на
конец строки.  После конца строки каждое нажатие Tab определя-
ется установкой Tab Size.
     - При включении опции Optimal Fill,  Borland C++ начинает
каждую строку абзаца с минимально возможным количеством симво-
лов,  используя табуляцию и пробелы по мере необходимости. Это
приводит к созданию строк с меньшим количеством символов,  чем
при отключенной опции Optimal Fill.
     - Когда включена опция Backspace  Unindents  (по  умолча-
нию), а курсор стоит на пустой строке или первом непустом сим-
воле строки,  Клавиша ПРОБЕЛ выравнивает строку до уровня  без
отступов.
     - При включенной опции Cursor Through  Tabs,  клавиши  со
стрелками передвинут курсор к середине табуляции;  в противном
случае курсор перепрыгнет несколько столбцов,  пока не устано-
вится под табуляцией.
     - Когда опция Group Undo отключена, выбор Edit/Undo отме-
няет  действие  одной  команды  редактора или нажатие клавиши.
Например,  если Вы набрали ABC,  то  потребуется  три  команды
Undo, чтобы удалить сначала С, потом В, потом А.
     Если эта опция включена, то Undo отменяет действие преды-
дущей команды и всех непосредственно предшествующих команд та-
кого же типа.  Типы команд,  которые можно  группировать,  это
вставка,  удаление,  затирание  символа и перемещения курсора.
Например, если Вы набрали АВС, то команда Undo удалит АВС.
     В целях группирования вставка возврата каретки рассматри-
вается как вставка,  сопровождаемая перемещением курсора. Нап-
ример,  если  Вы нажали Enter,  а затем набрали АВС,  то выбор
Undo удалит АВС,  а повторный выбор Undo переместит  курсор  к
новому  возврату  каретки.  Выбор Edit/Redo в этой точке пере-
местит курсор к следующей строке.  Другой вызов  Redo  вставит
АВС.
     - Когда включена опция Persisten blocks  (по  умолчанию),
то отмеченные блоки ведут себя так,  как они ведут себя всегда
в продуктах Borland C и С++.  Когда эта опция отключена, отме-
ченные блоки ведут себя иначе в следующих примерах:
     1. Нажатие клавиши Del или ПРОБЕЛ удаляет полностью  выб-
ранный текст.
     2. Вставляемый текст (нажатие символа,  вставка из карма-
на) заменит полностью выбранный текст на вставляемый текст.
     3. Передвижение  курсора  из  блока  отключает  выделение
текста.
     При включении опции Use Tab Character в  этом  диалоговом
окне  и нажатии Tab,  Borland C++ вставляет символ табуляции в
файл и передвигает курсор к следующему знаку  табуляции.  Окно
ввода Tab Size позволяет установить,  сколько символов до сле-
дующего знака табуляции будет пропущено. Допустимыми значения-
ми являются значения от 2 до 16; по умолчанию задано 8.
     Чтобы изменить способ,  которым табуляция изображается  в
файле, просто измените значение размера табуляции на требуемый
размер.  Borland C++ пересчитает все табуляции в этом файле  с
учетом того размера,  который был выбран. Можно сохранить этот
новый размер табуляции в файле конфигурации посредством выбора
команды Options/Save Options.
     Default Extension окно ввода  позволяет  сказать  Borland
C++, какое расширение использовать по умолчанию при компиляции
и загрузке исходного кода.  Изменение этого расширения не вли-
яет на архивные списки в текущей конфигурации.
     При выборе Mouse из меню Environment, показывается диало-
говое окно Mouse Options, содержащее все установки для мышки.
╔═[█]══════════════ Mouse Options ═══════════════════╗
║                                                    ║
║  Right Mouse Button   Mouse Double Click           ║
║   ( ) Nothing          Fast      Test       Slow   ║
║   (.) Topic search    <ЁЁЁЁЁЁ█ЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁЁ>  ║
║   ( ) Go to cursor                                 ║
║   ( ) Breakpoint       [ ] Reverse mouse buttons   ║
║   ( ) Inspect                                      ║
║   ( ) Evaluate                                     ║
║   ( ) Add watch                                    ║
║                                                    ║
║                 [  OK  ]    [ Cancel ]   [ Help ]  ║
╚════════════════════════════════════════════════════╝
     Зависимые кнопки Right Mouse Button определяют эффект на-
жатия  правой клавиши мышки (или левой клавиши,  если включена
опция Reverse Mouse  Buttons).  По  умолчанию  задается  Topic
Search.
     Ниже приведен список,  что будет  делать  правая  клавиша
мышки, если Вы выберете установку, отличную от Nothing:

     Topic Search           подобно Help/Topic Search
     Go to Cursor           подобно Run/Go to Cursor
     Breakpoint             подобно Debug/Toggle Breakpoint
     Inspect                подобно Debug/Inspect
     Evaluate               подобно Debug/Evaluate
     Add Watch              подобно Debug/Watches/Add Watch
     В окне  Mouse Double Click можно изменить передвигающуюся
отметку на полосе управления для  настройки  скорости  двойной
отметки мышкой, используя клавиши со стрелками.
     Перемещение отметки ближе к Fast  означает,  что  Borland
C++  требует  более  короткого  времени  между  отметками  для
распознавания двойной отметки.  Перемещение  отметки  ближе  к
Slow означает,  что Borland C++ будет распознавать двойную от-
метку,  даже если между отметками прошло достаточно много вре-
мени.
     Если Вы хотите поэкспериментировать с различными установ-
ками, можете дважды отметить кнопку Test, находящуюся выше по-
лосы. Она высветится при успешной двойной отметке.
     При включении  кнопки  Reverse  Mouse  Buttons,  активной
кнопкой мышки становится самая правая вместо самой левой.  За-
метим однако,  что кнопки на самом деле не переключатся до тех
пор, пока не будет выбрана кнопка OK.
     В зависимости от того,  как Вы держите мышку, правая кла-
виша мышки может быть более удобна для использования,  чем ле-
вая.

                           Desktop.
    ┌──────────────────────┐
    │Desktop Preferences   │
    │ [X] History lists    │
    │ [X] Clipboard        │
    │ [ ] Watch expressions│
    │ [ ] Breakpoints      │
    └──────────────────────┘
     Диалоговое окно  Desktop  позволяет установить,  будут ли
сохраняться между сеансами работы архивные списки,  содержимое
кармана,  выражения для просмотра и точки прерывания. Архивные
списки и содержимое кармана сохраняются по умолчанию; посколь-
ку  выражения  для просмотра и точки прерывания могут потерять
свое значение между сеансами, они не сохраняются по умолчанию.
Можно  изменить эти умолчания посредством включения или отклю-
чения соответствующих опций.

                      Save (сохранить).

     Options/Save команда выводит диалоговое окно, позволяющее
сохранить  установки,  сделанные  в  диалоговых  окнах  Find и
Replace (из меню Search) и в меню Options (включая все  диало-
говые окна,  являющиеся частью этих команд) для элементов IDE,
Desktop и Project.  Опции хранятся в трех файлах, представляю-
щих каждую из этих категорий.
     Если Borland C++ не находит эти файлы, он ищет их в спра-
вочнике  для  выполнимых кодов (из которого запускаются ВC.EXE
или ВСХ.ЕХЕ).

                     Меню Window (окно).

     Window меню  содержит  команды  управления  окном.  Боль-
шинство из окон,  которые Вы откроете из этого меню, имеют все
стандартные элементы окна такие, как окна скроллинга, закрыва-
ющую кнопку и кнопки масштабирования.
     Внизу меню Window появляется команда Window/List. Выбери-
те  эту  команду  для получения списка как всех открытых окон,
так и всех недавно закрытых.  (Последнее закрытое окно появля-
ется  со словом сlosed перед ним;  выберите его для повторного
открытия).

                          Size/Move.
    ┌──────┐ ┌───┐
    │ Ctrl │ │F5 │
    └──────┘ └───┘
     Выберите Window/Size/Move для изменения размера или пози-
ции активного окна.
     При выборе этой команды  активное  окно  передвигается  в
соответствии с нажатием клавиш со стрелками.  Когда окно нахо-
дится в требуемом месте,  нажмите Enter.  Также можно передви-
гать окно путем волочения за заголовок.
     Если одновременно с нажатием клавиш со стрелками Вы  наж-
мете  Shift,  то  можете изменить размер окна.  При достижении
требуемого размера нажмите Enter.  Если окно имеет уголок  для
изменения размеров, можно тащить за этот уголок или любой дру-
гой угол для изменения размеров окна.

                            Zoom.
     ┌────┐
     │ F5 │
     └────┘
     Выберите Window/Zoom для того, чтобы сделать активное ок-
но  максимального  размера.  Если  окно  уже было увеличено до
максимума,  можете выбрать эту команду для восстановления пре-
дыдущего  размера  окна.  Можно  также дважды отметить в любом
месте верхней строки окна (за исключением мест, где есть знач-
ки) для того, чтобы увеличить или уменьшить окно.

                            Tile.

     Выберите Window/Tile для того, чтобы разместить на экране
все открытые окна подобно черепице.

                           Cascade.

     Выберите Window/Cascade для того, чтобы во вложенном виде
разместить на экране все открытые окна.

                            Next.
    ┌────┐
    │ F6 │
    └────┘
     Выберите Window/Next  для  того,  чтобы  сделать активным
следующее окно, которое станет самым верхним открытым окном.

                            Close.
      ┌───┐┌───┐
      │Alt││ F3│
      └───┘└───┘
     Выберите Window/Close для закрытия активного окна.  Можно
также  отметить  закрывающую  кнопку  в левом верхнем углу для
закрытия окна.

                           Message.

     Выберите Window/Message для открытия окна Message  и  для
его активизации.  Message окно показывает сообщения об ошибках
и предупреждениях,  которые можно использовать для ссылки, или
можно выбрать их и получить соответствующее месторасположение,
высвеченное в окне редактора.  Когда  сообщение  ссылается  на
файл, который не является загруженным, можно нажать ПРОБЕЛ для
загрузки этого файла. Можно также показать вывод программы пе-
рехода в этом окне.
     Когда в окне Message выбрана ошибка, нажмите Enter, чтобы
посмотреть  месторасположение  этой  ошибки в окне редактора и
чтобы сделать окно редактора  активным  в  месте  расположения
ошибки.
     Чтобы закрыть это окно,  отметьте закрывающую кнопку  или
выберите Window/Close.

                            Ouput.

     Выберите Window/Output для открытия окна вывода и его ак-
тивизации. Окно Output показывает текст любой командной строки
DOS и любой текст, сгенерированный Вашей программой (не графи-
ческий).
     Окно Output является удобным во время отладки, потому что
можно посмотреть свой исходный код,  переменные и вообще  весь
вывод.   Это   особенно   полезно,  когда  в  диалоговом  окне
Options/Environment установлено 43/50 строк,  а  Вы  запустили
программу  в  стандартном  25- строчном режиме.  В этом случае
можно видеть почти весь вывод программы и  еще  иметь  избыток
строк для просмотра своего исходного кода и переменных.
     Если Вы захотите увидеть текст своей программы на  полном
экране  -  или если Ваша программа генерирует графику - вместо
этой команды выберите команду Window/User Screen.
     Чтобы закрыть  это окно,  отметьте закрывающую кнопку или
выберите Window/Close.

                            Watch.

     Выберите Window/Watch для открытия окна Watch (просмотра)
и для его активизации. Окно Watch показывает выражения и изме-
нения их значений так, что Вы можете видеть, как Ваша програм-
ма вычисляет ключевые значения.
     Используйте команды в меню Debug/Watches для добавления и
удаления элементов просмотра из этого окна.  Обратитесь к раз-
делу по этому меню для получения информации о том, как исполь-
зовать окно Watch.
     Чтобы закрыть это окно,  отметьте закрывающую кнопку  или
выберите Window/Close.

                         User Screen.
     ┌─────┐ ┌──┐
     │ Alt │ │F5│
     └─────┘ └──┘
     Выберите Window/User  Screen  для  просмотра вывода своей
программы на полном экране.  Если Вы хотите  посмотреть  вывод
своей программы в окне Borland C++, выберите вместо нее коман-
ду Window/Output. Для возврата в интегрированную среду отметь-
те любую клавишу.

                          Register.

     Выберите Window/Register для открытия окна Register и его
активизации.
     Register окно  показывает регистры CPU и используется при
отладке встроенных модулей ASM и TASM в своем проекте.
     Чтобы закрыть  это окно,  отметьте закрывающую кнопку или
выберите Window/Close.

                           Project.

     Выберите Window/Project для открытия окна Project, позво-
ляющего  просмотреть  файлы,  используемые  для создания Вашей
программы.

                            Notes.

     Выберите Window/Notes для  написания  некоторых  деталей,
создания  списка "что сделать" или для перечисления любой дру-
гой информации о своих проектных файлах.

                            List.

     Выберите Window/List для получения списка  всех  открытых
окон. Этот список содержит имена всех текущих открытых файлов,
а также последних восьми файлов,  которые были открыты в  окне
редактора, а затем закрыты. Последний закрытый файл появляется
в списке со стоящим перед ними словом сlosed.
     При выборе  уже  открытого  файла из этого списка Borland
C++ выводит окно на передний план и активизирует его.  При вы-
боре закрытого файла из этого списка Borland C++ открывает за-
ново файл в окне редактора, имеющего такой же размер и находя-
щегося в том же месте,  где и закрытое окно. Курсор устанавли-
вается в месте своего последнего положения.
     ┌───┐┌───┐
     │Alt││ 0 │
     └───┘└───┘
     Нажмите Alt-0 для появления полного списка всех  открытых
окон и окон редактора, которые были закрыты.

                          Help меню.

     Help меню  (справочной информации) дает доступ к встроен-
ной справочной информации в специальном окне.  Справочная  ин-
формация  имеется  по  всем  аспектам  интегрированной среды и
Borland C++. (Также, в строке статуса появляются подсказки для
меню в одну строку и диалоговых окон, когда бы ни была выбрана
команда).
     Для открытия   Help  окна  выполните  одно  из  следующих
действий:
     - Нажмите F1 в любой момент времени (находясь в любом ди-
алоговом окне или при выборе любой команды меню).
     - Когда  окно редактора активно,  а курсор стоит под сло-
вом,  нажмите Ctrl-F1 для получения справочной  информации  по
языку.
     - Отметьте кнопку Help,  когда она появится в строке ста-
туса или в диалоговом окне.
     Для закрытия окна Help, нажмите Esc или закрывающую кноп-
ку, или выберите команду Window/Close. Можно держать окно Help
в другом окне во время работы,  если окно Help не было открыто
из  диалогового  окна или не была нажата клавиша F1 при выборе
команды меню.  (Если Вы нажмете клавишу F6 или  клавишу  мышки
для другого окна, когда находитесь в Help, окно Help останется
на экране).
     Help экраны  часто  содержат  ключевые слова (высвеченный
текст),  которые можно выбрать для получения большей  информа-
ции. Нажмите Tab для перехода к ключевому слову; нажмите Enter
для получения более подробной справочной информации.  (Альтер-
нативным  способом  является подведение курсора к высвеченному
ключевому слову и нажатие Enter). С мышкой, можно дважды отме-
тить  любое  ключевое слово для открытия справочного текста по
этому элементу.
     Примечание. При  получении справочной информации в диало-
говом окне или меню нельзя изменять размер окна или копировать
в карман.  В этом случае, Tab используется для управления диа-
логовым окном, а не для перехода к ключевому слову.
     Вы можете  нажать  Ctrl-F1  на  любом слове для получения
справочной информации.  Если слово не найдено, выполняется по-
иск вперед по оглавлению и показывается ближайший соответству-
ющий текст.
     Когда окно  Help  активно,  можно  копировать  из  окна и
вставлять этот текст в окно редактора.  Выберите сначала текст
(используя Shift плюс стрелку вправо,  стрелку влево,  стрелку
вверх, стрелку вниз), выберите Edit/Copy, перейдите в Edit ок-
но и выберите команду Edit/Paste.
     Чтобы выбрать текст в  окне  Help,  тащите  за  требуемый
текст или, когда встанете на начало блока, нажимайте ShiftЎ,ў,
°,∙ для пометки блока.
     Можно также копировать заранее выбранные примеры программ
из  экрана  подсказки  посредством  выбора  команды  Edit/Copy
Example.

                          Contents.

     Команда Help/Contents открывает окно Help с основной таб-
лицей содержания.  Из этого окна можно перейти к любой  другой
части системы справочной информации.
     ┌──┐
     │F1│
     └──┘
     Можно получить   подсказку   по   справочной   информации
посредством нажатия F1,  когда окно Help активно.  Можно также
получить этот экран, отметив строку статуса.

                            Index.

     Help/Index команда открывает диалоговое окно,  показываю-
щее полный список ключевых слов справочной информации  (специ-
ально высвеченный текст на экране справочной информации,  поз-
воляющий быстро передвигаться к соответствующему экрану).
     Можно сделать  скроллинг списка или поиск вперед по этому
списку посредством нажатия букв на клавиатуре.  Например,  для
того чтобы посмотреть наличие информации по "printing",  можно
набрать p r i.  Когда Вы наберете р,  курсор прыгнет на первое
ключевое слово, начинающееся на р. Когда Вы наберете r, курсор
прыгнет на первое ключевое слово, начинающееся на pr. Когда Вы
наберете i,  курсор прыгнет на первое ключевое слово, начинаю-
щееся на pri, и так далее.
     Когда Вы найдете интересующее Вас ключевое слово, выбери-
те его,  установив под ним курсор и нажав Enter.  (Можно также
отметить дважды клавишу мышки).
     Примечание. Для выбора ключевого слова можно использовать
клавишу табуляции.

                        Topic Search.
     ┌────┐┌───┐
     │Ctrl││ F1│
     └────┘└───┘
     Help/Topic Search  команда показывает справочную информа-
цию по языку и по текущему выбранному элементу.
     Чтобы получить справочную информацию по языку, установите
курсор под элементом в окне редактора и выберите Topic Search.
Можно  получить справочную информацию по таким элементам,  как
имена функций,  (printf, например), файлы оглавлений, зарезер-
вированные  слова  и т.д.  Если справочной информации по этому
элементу нет, то оглавление справочной информации покажет бли-
жайший соответствующий элемент.

                       Previous Topic.
     ┌───┐┌────┐
     │Alt││ F1 │
     └───┘└────┘
     Help/Previous Topic  команда  открывает окно Help и вновь
показывает текст, который вы просматривали последний раз.
     Borland C++  позволяет  просмотреть 20 предыдущих экранов
подсказки.  Можно также отметить строку статуса для  просмотра
последнего экрана справочной информации.

                         Help on Help
   ┌─────┐
   │  F1 │
   └─────┘
     Help/Help on Help команда открывает текстовый экран,  по-
ясняющий,  как  пользоваться  системой  справочной  информации
Borland  C++.  Если Вы уже находитесь в системе справочной ин-
формации, можно вызвать этот экран нажатием F1.
