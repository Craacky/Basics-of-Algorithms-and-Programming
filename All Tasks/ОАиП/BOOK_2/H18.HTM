<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Программирование на языке СИ</title>
</head>

<body bgcolor="#FFF5EE" text="#000000" link="#FF0000"
vlink="#A52A2A" alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h4><a name="18">1.8. Директивы
Препроцессора</a></h4>

<p>Директивы препроцессора
представляют собой инструкции,
записанные в тексте программы на
СИ, и выполняемые до трансляции
программы. Директивы препроцессора
позволяют изменить текст
программы, например, заменить
некоторые лексемы в тексте,
вставить текст из другого файла,
запретить трансляцию части текста
и т.п. Все директивы препроцессора
начинаются со знака #. После
директив препроцессора точка с
запятой не ставятся. </p>

<h4><a name="181">1.8.1. Директива #</a>include</h4>

<p>Директива #include включает в текст
программы содержимое указанного
файла. Эта директива имеет две
формы: </p>

<pre>
              #include &quot;имя файла&quot;
              #include <имя файла>
</pre>

<p>Имя файла должно соответствовать
соглашениям операционной системы и
может состоять либо только из имени
файла, либо из имени файла с
предшествующим ему маршрутом. Если
имя файла указано в кавычках, то
поиск файла осуществляется в
соответствии с заданным маршрутом,
а при его отсутствии в текущем
каталоге. Если имя файла задано в
угловых скобках, то поиск файла
производится в стандартных
директориях операционной системы,
задаваемых командой PATH. </p>

<p>Директива #include может быть
вложенной, т.е. во включаемом файле
тоже может содержаться директива
#include, которая замещается после
включения файла, содержащего эту
директиву. </p>

<p>Директива #include широко
используется для включения в
программу так называемых
заголовочных файлов, содержащих
прототипы библиотечных функций, и
поэтому большинство программ на СИ
начинаются с этой директивы. </p>

<h4><a name="182">1.8.2. Директива #define</a></h4>

<p>Директива #define служит для замены
часто использующихся констант,
ключевых слов, операторов или
выражений некоторыми
идентификаторами. Идентификаторы,
заменяющие текстовые или числовые
константы, называют именованными
константами. Идентификаторы,
заменяющие фрагменты программ,
называют макроопределениями,
причем макроопределения могут
иметь аргументы. </p>

<p>Директива #define имеет две
синтаксические формы: </p>

<pre>
       #define  идентификатор текст
       #define  идентификатор (список параметров) текст
</pre>

<p>Эта директива заменяет все
последующие вхождения
идентификатора на текст. Такой
процесс называется
макроподстановкой. Текст может
представлять собой любой фрагмент
программы на СИ, а также может и
отсутствовать. В последнем случае
все экземпляры идентификатора
удаляются из программы. </p>

<p>Пример: </p>

<pre>
      #define WIDTH 80
      #define LENGTH (WIDTH+10)
</pre>

<p>Эти директивы изменят в тексте
программы каждое слово WIDTH на число
80, а каждое слово LENGTH на выражение
(80+10) вместе с окружающими его
скобками. </p>

<p>Скобки, содержащиеся в
макроопределении, позволяют
избежать недоразумений, связанных
с порядком вычисления операций.
Например, при отсутствии скобок
выражение t=LENGTH*7 будет
преобразовано в выражение t=80+10*7, а
не в выражение t=(80+10)*7, как это
получается при наличии скобок, и в
результате получится 780, а не 630. </p>

<p>Во второй синтаксической форме в
директиве #define имеется список
формальных параметров, который
может содержать один или несколько
идентификаторов, разделенных
запятыми. Формальные параметры в
тексте макроопределения отмечают
позиции на которые должны быть
подставлены фактические аргументы
макровызова. Каждый формальный
параметр может появиться в тексте
макроопределения несколько раз. </p>

<p>При макровызове вслед за
идентификатором записывается
список фактических аргументов,
количество которых должно
совпадать с количеством формальных
параметров. </p>

<pre>
     Пример:
     #define  MAX(x,y) ((x)&gt;(y))?(x):(y)
     Эта директива заменит фрагмент
                 t=MAX(i,s[i]);
     на фрагмент
                 t=((i)&gt;(s[i])?(i):(s[i]);
</pre>

<p>Как и в предыдущем примере,
круглые скобки, в которые заключены
формальные параметры
макроопределения, позволяют
избежать ошибок связанных с
неправильным порядком выполнения
операций, если фактические
аргументы являются выражениями. </p>

<pre>
  Например, при наличии скобок фрагмент
                 t=MAX(i&amp;j,s[i]||j);
  будет заменен на фрагмент
                t=((i&amp;j)&gt;(s[i]||j)?(i&amp;j):(s[i]||j);
  а при отсутствии скобок - на фрагмент
                t=(i&amp;j&gt;s[i]||j)?i&amp;j:s[i]||j;
  в котором условное выражение вычисляется в совершенно другом порядке.
</pre>

<h4>1.8.3. Директива #undef</h4>

<p>Директива #undef используется для
отмены действия директивы #define.
Синтаксис этой директивы следующий
#undef идентификатор </p>

<p>Директива отменяет действие
текущего определения #define для
указанного идентификатора. Не
является ошибкой использование
директивы #undef для идентификатора,
который не был определен
директивой #define. </p>

<p>Пример: </p>

<pre>
       #undef WIDTH
       #undef MAX
</pre>

<p align="center">Эти директивы отменяют
определение именованной константы
WIDTH и макроопределения MAX. </p>

<hr width="90%">

<p align="center">[ <a href="h17.htm">Назад</a> | <a
href="dir.htm">Оглавление </a>| <a href="h21.htm">Вперед</a>
] </p>

<p align="center">&nbsp;</p>
</body>
</html>
