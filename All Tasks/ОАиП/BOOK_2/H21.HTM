<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Программирование на языке СИ</title>
</head>

<body bgcolor="#FFF5EE" text="#000000" link="#FF0000"
vlink="#A52A2A" alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h2><a name="2">2. Организация списков и их
обработка</a></h2>

<h3><a name="21">2.1. Линейные списки</a></h3>

<h4><a name="211">2.1.1. Методы организации и
хранения линейных списков</a></h4>

<p>Линейный список - это конечная
последовательность однотипных
элементов (узлов), возможно, с
повторениями. Количество элементов
в последовательности называется
длиной списка, причем длина в
процессе работы программы может
изменяться. </p>

<p align="center">Линейный список F,
состоящий из элементов D1,D2,...,Dn,
записывают в виде
последовательности значений
заключенной в угловые скобки F=<D1,D2,...,Dn>, или
представляют графически (см.рис.12). </p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspasing="0">
    <tr>
        <td bgcolor="#C0C0C0"><pre>  D1  </pre>
        </td>
        <th><font face="wingdings">а</font> </th>
        <td bgcolor="#C0C0C0"><pre>  D2  </pre>
        </td>
        <th><font face="wingdings">а</font> </th>
        <td bgcolor="#C0C0C0"><pre>  D3  </pre>
        </td>
        <th><font face="wingdings">а</font> </th>
        <td>... </td>
        <th><font face="wingdings">а</font> </th>
        <td bgcolor="#C0C0C0"><pre>  Dn  </pre>
        </td>
    </tr>
    <tr>
        <th colspan="9">Рис.12. Изображение
        линейного списка.</th>
    </tr>
</table>
</center></div>

<p>Например, F1=<2,3,1>,F2=<7,7,7,2,1,12>, F3=<>. Длина списков F1,
F2, F3 равна соответственно 3,6,0. </p>

<p>При работе со списками на
практике чаще всего приходится
выполнять следующие операции: </p>

<p>- найти элемент с заданным
свойством; </p>

<p>- определить первый элемент в
линейном списке; </p>

<p>- вставить дополнительный элемент
до или после указанного узла; </p>

<p>- исключить определенный элемент
из списка; </p>

<p>- упорядочить узлы линейного
списка в определенном порядке. </p>

<p>В реальных языках
программирования нет какой-либо
структуры данных для представления
линейного списка так, чтобы все
указанные операции над ним
выполнялись в одинаковой степени
эффективно. Поэтому при работе с
линейными списками важным является
представление используемых в
программе линейных списков таким
образом, чтобы была обеспечена
максимальная эффективность и по
времени выполнения программы, и по
объему требуемой памяти. </p>

<p>Методы хранения линейных списков
разделяются на методы
последовательного и связанного
хранения. Рассмотрим простейшие
варианты этих методов для списка с
целыми значениями F=<7,10>. </p>

<p>При последовательном хранении
элементы линейного списка
размещаются в массиве d
фиксированных размеров, например,
100, и длина списка указывается в
переменной l, т.е. в программе
необходимо иметь объявления вида </p>

<pre>
              float d[100];   int l;
</pre>

<p>Размер массива 100 ограничивает
максимальные размеры линейного
списка. Список F в массиве d
формируется так: </p>

<pre>
               d[0]=7; d[1]=10; l=2;
</pre>

<p align="center">Полученный список
хранится в памяти согласно схеме на
рис.13. </p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td><pre>  l:  </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>  2   </pre>
        </td>
    </tr>
    <tr>
        <td><pre>  d:  </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>  7   </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>  10  </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>      </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>      </pre>
        </td>
        <td><pre>  ... </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>      </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>      </pre>
        </td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td><pre> [0]  </pre>
        </td>
        <td><pre> [1]  </pre>
        </td>
        <td><pre> [2]  </pre>
        </td>
        <td><pre> [3]  </pre>
        </td>
        <td>&nbsp;</td>
        <td><pre> [98] </pre>
        </td>
        <td><pre> [99] </pre>
        </td>
    </tr>
    <tr>
        <th colspan="8">Рис.13.
        Последовательное хранение
        линейного списка.</th>
    </tr>
</table>
</center></div>

<p>При связанном хранении в качестве
элементов хранения используются
структуры, связанные по одной из
компонент в цепочку, на начало
которой (первую структуру)
указывает указатель dl. Структура
образующая элемент хранения,
должна кроме соответствующего
элемента списка содержать и
указатель на соседний элемент
хранения. </p>

<p>Описание структуры и указателя в
этом случае может имееть вид: </p>

<pre>
       typedef struct snd   /* структура элемента хранения   */
       { float  val;        /* элемент списка                */
        struct snd *n ;     /* указатель на элемент хранения */
       } DL;
       DL *p;               /* указатель текущего элемента   */
       DL *dl;              /* указатель на начало списка    */
</pre>

<p>Для выделения памяти под элементы
хранения необходимо пользоваться
функцией malloc(sizeof(DL)) или calloc(l,sizeof(DL)).
Формирование списка в связанном
хранении может осуществляется
операторами: </p>

<pre>
       p=malloc(sizeof(DL));
       p-&gt;val=10;   p-&gt;n=NULL;
       dl=malloc(sizeof(DL));
       dl-&gt;val=7;   dl-&gt;n=p;
</pre>

<p>В последнем элементе хранения
(конец списка) указатель на
соседний элемент имеет значение NULL.
Получаемый список изображен на
рис.14. </p>

<p align="center"><img src="pictures/14.gif" width="280"
height="57"><br>
<b>Рис.14. Связное хранение линейного
списка.</b></p>

<h4><a name="212">2.1.2. Операции со списками
при последовательном хранении</a></h4>

<p>При выборе метода хранения
линейного списка следует
учитывать, какие операции будут
выполняться и с какой частотой,
время их выполнения и объем памяти,
требуемый для хранения списка. </p>

<p>Пусть имеется линейный список с
целыми значениями и для его
хранения используется массив d (с
числом элементов 100), а количество
элементов в списке указывается
переменной l. Реализация указанных
ранее операций над списком
представляется следующими
фрагментами программ которые
используют объявления: </p>

<pre>
          float d[100];
          int i,j,l;
     1) печать значения первого элемента (узла)
        if (i<0 || i>l) printf(&quot;\n нет элемента&quot;);
        else printf(&quot;d[%d]=%f &quot;,i,d[i]);
     2) удаление элемента, следующего за i-тым  узлом
        if (i&gt;=l) printf(&quot;\n нет следующего &quot;);
        l--;
        for (j=i+1;j<l;j++) d[j]="d[j+1];" 3) печать обоих соседей i-того узла if (i<="1" || i>=l) printf(&quot;\n нет соседа&quot;);
        else printf(&quot;\n %d  %d&quot;,d[i-1],d[i+1]);
     4) добавление нового элемента new за i-тым узлом
        if (i==l || i&gt;l) printf(&quot;\n нельзя добавить&quot;);
        else
        {    for (j=l; j&gt;i+1; j--) d[j+1]=d[j];
             d[i+1]=new; l++;
        }
     5) частичное упорядочение списка с элементами  К1,К2,...,Кl  в
     список K1',K2',...,Ks,K1,Kt&quot;,...,Kt&quot;, s+t+1=l так, чтобы K1'<K1 и Kj">= K1.

     { int t=1;
       float aux;
       for (i=2; i<=l; i++) if (d[i]<d[t]) { aux="d[i];" for (j="i;" j>=2; j--) d[j]=d[j-1];
               t++;
               d[i]=aux;
            }
     }
</pre>

<p>Схема движения индексов i,j,t и
значения aux=d[i] при выполнении
приведенного фрагмента программы
приведена на рис.15. </p>

<p align="center"><img src="pictures/15.gif" width="240"
height="156"><br>
<b>Рис.15. Движение индексов при
выполнении операций над списком в
последовательном хранении.</b></p>

<p>Количество действий Q, требуемых
для выполнения приведенных
операций над списком, определяется
соотношениями: для операций 1 и 2 - Q=1;
для операций 3,4 - Q=l; для операции 5 -
Q=l*l. </p>

<p>Заметим, что вообще операцию 5
можно выполнить при количестве
действий порядка l, а операции 3 и 4
для включения и исключения
элементов в конце списка, часто
встречающиеся при работе со
стеками, - при количестве действий 1.
</p>

<p>Более сложная организация
операций требуется при размещении
в массиве d нескольких списков, или
при размещении списка без привязки
его начала к первому элементу
массива. </p>

<h4><a name="213">2.1.3. Операции со списками
при связном хранении</a></h4>

<p>При простом связанном хранении
каждый элемент списка представляет
собой структуру nd, состоящую из
двух элементов: val - предназначен
для хранения элемента списка, n - для
указателя на структуру, содержащую
следующий элемент списка. На первый
элемент списка указывает указатель
dl. Для всех операций над списком
используется описание: </p>

<pre>
        typedef struct nd
          {  float val;
             struct nd * n;  }  ND;
        int i,j;
        ND * dl, * r, * p;
</pre>

<p>Для реализации операций могут
использоваться следующие
фрагменты программ: </p>

<p>1) печать значения i-го элемента </p>

<pre>
        r=dl;j=1;
        while(r!=NULL &amp;&amp; j++<i) r="r-">n ;
        if (r==NULL) printf(&quot;\n нет узла %d &quot;,i);
        else printf(&quot;\n элемент %d равен %f &quot;,i,r-&gt;val);
</pre>

<p>2) печать обоих соседей
узла(элемента), определяемого
указателем p (см. рис.16) </p>

<p align="center"><img src="pictures/16.gif" width="258"
height="32"><br>
<b>Рис.16. Схема выбора соседних
элементов.</b></p>

<pre>
        if((r=p-&gt;n)==NULL) printf(&quot;\n нет соседа справа&quot;);
        else  printf(&quot;\n  сосед  справа  %f&quot;,  r-&gt;val);
        if(dl==p) printf(&quot;\n нет соседа слева&quot; );
        else { r=dl;
               while( r-&gt;n!=p ) r=r-&gt;n;
               printf(&quot;\n левый сосед %f&quot;, r-&gt;val);
             }
</pre>

<p>3) удаление элемента, следующего
за узлом, на который указывает р (см.
рис.17) </p>

<p align="center"><img src="pictures/17.gif" width="186"
height="35"><br>
<b>Рис.17. Схема удаления элемента из
списка.</b></p>

<pre>
        if ((r=p-&gt;n)==NULL) printf(&quot;\n  нет  следующего&quot;);
        p-&gt;n=r-&gt;n; free(r-&gt;n);
</pre>

<p>4) вставка нового узла со
значением new за элементом,
определенным указателем р (см.
рис.18) </p>

<p align="center"><img src="pictures/18.gif" width="190"
height="40"><br>
<b>Рис.18. Схема вставки элемента в
список.</b></p>

<pre>
        r=malloc(1,sizeof(ND));
        r-&gt;n=p-&gt;n;   r-&gt;val=new;   p-&gt;n=r;
</pre>

<p>5) частичное упорядочение списка <K1, K2,..., Kl>
в последовательность значений <K1',...,Ks',K1,K1",...,Kt">,
s+t+1=l, так что K1'<K1,Kj">=K1; после
упорядочения указатель v указывает
на элемент K1' (см. рис.19) </p>

<p align="center"><img src="pictures/19.gif" width="281"
height="46"><br>
<b>Рис.19. Схема частичного
упорядочения списка.</b></p>

<pre>
        ND *v;
        float k1;
        k1=dl-&gt;val;
        r=dl;
        while( r-&gt;n!=NULL )
        { v=r-&gt;n;
           if (v-&gt;val<k1) { r->n=v-&gt;n;
               v-&gt;n=dl;
               dl=v;
             }
            else r=v;
        }
</pre>

<p>Количество действий, требуемых
для выполнения указанных операций
над списком в связанном хранении,
оценивается соотношениями: для
операций 1 и 2 - Q=l; для операций 3 и 4 -
Q=1; для операции 5 - Q=l. </p>

<h4><a name="214">2.1.4. Организация
двусвязных списков</a></h4>

<p>Связанное хранение линейного
списка называется списком с двумя
связями или двусвязным списком,
если каждый элемент хранения имеет
два компонента указателя (ссылки на
предыдущий и последующий элементы
линейного списка). </p>

<p>В программе двусвязный список
можно реализовать с помощью
описаний: </p>

<pre>
     typedef struct ndd
        { float val;      /* значение элемента                */
          struct ndd * n; /* указатель на следующий элемент   */
          struct ndd * m; /* указатель на предыдующий элемент */
          } NDD;
     NDD * dl, * p, * r;
</pre>

<p>Графическая интерпретация метода
связанного хранения списка F=<2,5,7,1> как
списка с двумя связями приведена на
рис.20. </p>

<p align="center"><img src="pictures/20.gif" width="334"
height="39"><br>
<b>Рис.20. Схема хранения двусвязного
списка.</b></p>

<p>Вставка нового узла со значением
new за элементом, определяемым
указателем p, осуществляется при
помощи операторов: </p>

<pre>
          r=malloc(NDD);
          r-&gt;val=new;
          r-&gt;n=p-&gt;n;
          (p-&gt;n)-&gt;m=r;
          p-&gt;=r;
</pre>

<p>Удаление элемента, следующего за
узлом, на который указывает p </p>

<pre>
          p-&gt;n=r;
          p-&gt;n=(p-&gt;n)-&gt;n;
          ( (p-&gt;n)-&gt;n )-&gt;m=p;
          free(r);
</pre>

<p>Связанное хранение линейного
списка называется циклическим
списком, если его последний
указывает на первый элемент, а
указатель dl - на последний элемент
списка. </p>

<p>Схема циклического хранение
списка F=<2,5,7,1> приведена на рис.21. </p>

<p align="center"><img src="pictures/21.gif" width="222"
height="35"><br>
<b>Рис.21. Схема циклического
хранения списка.</b></p>

<p>При решении конкретных задач
могут возникать разные виды
связанного хранения. </p>

<p>Пусть на входе задана
последовательность целых чисел
B1,B2,...,Bn из интервала от 1 до 9999, и
пусть Fi (1<i<9999) последовательность, получаемая упорядочиванием элементов списка <B1,B2,...,Bn> по возрастанию. Составить
процедуру для формирования Fn в
связанном хранении и возвращения
указателя на его начало. </p>

<p>При решении задачи в каждый
момент времени имеем упорядоченный
список Fi и при вводе элемента Bi+1
вставляем его в нужное место списка
Fi, получая упорядоченный список Fi+1.
Здесь возможны три варианта: в
списке нет элементов; число
вставляется в начало списка; число
вставляется в конец списка. Чтобы
унифицировать все возможные
варианты, начальный список
организуем как связанный список из
двух элементов <0,1000>. </p>

<p>Рассмотрим программу решения
поставленной задачи, в которой
указатели dl, r, p, v имеют следующее
значение: dl указывает начало
списка; p, v - два соседних узла; r
фиксирует узел, содержащий
очередное введенное значение in. </p>

<pre>
     #include<stdio.h>
     #include<stdlib.h>
     typedef struct str1
       { float val;
         struct str1 *n; }  ND;
     main()
      {  ND *arrange(void);
         ND *p;
         p=arrange();
         while(p!=NULL)
           {
            printf(&quot;\n %f &quot;,p-&gt;val);
            p=p-&gt;n;
           }
      }
     ND *arrange() /*   формирование упорядоченного списка */
      {  ND *dl, *r, *p, *v;
         float in=1;
         char *is;
         dl=malloc(sizeof(ND));
         dl-&gt;val=0;                  /*  первый элемент     */
         dl-&gt;n=r=malloc(sizeof(ND));
         r-&gt;val=10000; r-&gt;n=NULL;    /*  последний элемент  */
         while(1)
         {
            scanf(&quot; %s&quot;,is);
            if(* is=='q') break;
            in=atof(is);
            r=malloc(sizeof(ND));
            r-&gt;val=in;
            p=dl;
            v=p-&gt;n;
            while(v-&gt;val<in) { p="v;" v="v-">n;
            }
            r-&gt;n=v;
            p-&gt;n=r;
        }
        return(dl);
      }
</pre>

<h4><a name="215">2.1.5. Стеки и очереди</a></h4>

<p>В зависимости от метода доступа к
элементам линейного списка
различают разновидности линейных
списков называемые стеком,
очередью и двусторонней очередью. </p>

<p>Стек - это конечная
последовательность некоторых
однотипных элементов - скалярных
переменных, массивов, структур или
объединений, среди которых могут
быть и одинаковые. Стек
обозначается в виде: S=<S1,S2,...,Sn> и
представляет динамическую
структуру данных; ее количество
элементов заранее не указывается и
в процессе работы, как правило
изменяется. Если в стеке элементов
нет, то он называется пустым и
обозначается S=<>. </p>

<p>Допустимыми операциями над
стеком являются: </p>

<p>- проверка стека на пустоту S=<>, </p>

<p>- добавление нового элемента Sn+1 в
конец стека - преобразование &lt;
S1,...,Sn&gt; в &lt; S1,...,Sn+1&gt;; </p>

<p>- изъятие последнего элемента из
стека - преобразование &lt; S1,...,Sn-1,Sn&gt;
в &lt; S1,...,Sn-1&gt;; </p>

<p>- доступ к его последнему элементу
Sn, если стек не пуст. </p>

<p>Таким образом, операции
добавления и удаления элемента, а
также доступа к элементу
выполняются только в конце списка.
Стек можно представить как стопку
книг на столе, где добавление или
взятие новой книги возможно только
сверху. </p>

<p>Очередь - это линейный список, где
элементы удаляются из начала
списка, а добавляются в конце
списка (как обыкновенная очередь в
магазине). </p>

<p>Двусторонняя очередь - это
линейный список, у которого
операции добавления и удаления
элементов и доступа к элементам
возможны как вначале так и в конце
списка. Такую очередь можно
представить как
последовательность книг стоящих на
полке, так что доступ к ним возможен
с обоих концов. </p>

<p>Реализация стеков и очередей в
программе может быть выполнена в
виде последовательного или
связанного хранения. Рассмотрим
примеры организации стека этими
способами. </p>

<p>Одной из форм представления
выражений является польская
инверсная запись, задающая
выражение так, что операции в нем
записываются в порядке выполнения,
а операнды находятся
непосредственно перед операцией. </p>

<p>Например, выражение </p>

<pre>
                       (6+8)*5-6/2
</pre>

<p>в польской инверсной записи имеет
вид </p>

<pre>
                      6 8 + 5 * 6 2 / -
</pre>

<p>Особенность такой записи состоит
в том, что значение выражения можно
вычислить за один просмотр записи
слева направо, используя стек,
который до этого должен быть пуст.
Каждое новое число заносится в
стек, а операции выполняются над
верхними элементами стека, заменяя
эти элементы результатом операции.
Для приведенного выражения
динамика изменения стека будет
иметь вид </p>

<pre>
         S = <>;  <6>;  <6,8>;  <14>;  <14,5>;  <70>;
             <70,6>;  <70,6,2>;  <70,3>;  <67>.
</pre>

<p>Ниже приведена функция eval,
которая вычисляет значение
выражения, заданного в массиве m в
форме польской инверсной записи,
причем m[i]&gt;0 означает
неотрицательное число, а значения
m[i]<0 операции. В качестве кодировки операций сложения, вычитания, умножения и деления выбраны отрицательные числа 1, 2, 3, 4. Для организации последовательного хранения стека используется внутренний массив stack. Параметрами функции являются входной массив a и его длина l. <pre> float eval (float *m, int l) { int p,n,i; float stack[50],c;
for(i=0; i &lt; l ;i++) if ((n=m[i])<0) { c="st[p--];" switch(n) { case 1: stack[p]+="c;" break; case 2: stack[p]-="c;" break; case 3: stack[p]*="c;" break; case 4: stack[p]/="c;" } } else stack[++p]="n;" return(stack[p]); } </pre> </p>

<p>Рассмотрим другую задачу. Пусть
требуется ввести некоторую
последовательность символов,
заканчивающуюся точкой, и
напечатать ее в обратном порядке
(т.е. если на входе будет &quot;ABcEr-1.&quot;
то на выходе должно быть
&quot;1-rEcBA&quot;). Представленная ниже
программа сначала вводит все
символы последовательности,
записывая их в стек, а затем
содержимое стека печатается в
обратном порядке. Это основная
особенность стека - чем позже
элемент занесен в стек, тем раньше
он будет извлечен из стека.
Реализация стека выполнена в
связанном хранении при помощи
указателей p и q на тип, именованный
именем STACK. </p>

<pre>
  #include<stdio.h>
  typedef struct st           /* объявление типа STACK */
    { char ch;
      struct st *ps;   } STACK;
  main()
  {   STACK *p,*q;
      char a;
      p=NULL;
      do                      /*  заполнение стека    */
      { a=getch();
        q=malloc(sizeof(STR1));
         q-&gt;ps=p; p=q;
         q-&gt;ch=a;
      }  while(a!='.');
      do                      /*  печать стека        */
      { p=q-&gt;ps;free(q);q=p;
        printf(&quot;%c&quot;,p-&gt;ch);
      } while(p-&gt;ps!=NULL);
  }
</pre>

<h4><a name="216">2.1.6. Сжатое и индексное
хранение линейных списков</a></h4>

<p>При хранении больших объемов
информации в форме линейных
списков нежелательно хранить
элементы с одинаковым значением,
поэтому используют различные
методы сжатия списков. </p>

<p align="center">Сжатое хранение. Пусть в
списке B=<K1,K2,...,Kn> несколько элементов имеют
одинаковое значение V, а список B'=<K1',K2',...,Kn'>
получается из B заменой каждого
элемента Ki на пару Ki'=(i,Ki). Пусть
далее B&quot;=<K1",K2",...,Km"> - подсписок B',
получающийся вычеркиванием всех
пар Ki=(i,V). Сжатым хранением В
является метод хранения В&quot;, в
котором элементы со значением V
умалчиваются. Различают
последовательное сжатое хранение и
связанное сжатое хранение.
Например, для списка B=<C,X,Y,X,X,S,H,X,T>, содержащего
несколько узлов со значением Х,
последовательное сжатое и
связанное сжатое хранения, с
умалчиванием элементов со
значением Х, представлены на
рис.22,23. </p>
<div align="center"><center>

<table border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td bgcolor="#C0C0C0"><pre>  1,C  </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>  3,Y  </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>  6,S  </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>  7,H  </pre>
        </td>
        <td bgcolor="#C0C0C0"><pre>  9,T  </pre>
        </td>
    </tr>
    <tr>
        <th colspan="5">Рис.22.
        Последовательное сжатое
        хранение списка.</th>
    </tr>
</table>
</center></div>

<p align="center"><img src="pictures/23.gif" width="440"
height="43"><br>
<b>Рис.23. Связное сжатое хранение
списка.</b></p>

<p>Достоинство сжатого хранения
списка при большом числе элементов
со значением V заключается в
возможности уменьшения объема
памяти для его хранения. </p>

<p>Поиск i-го элемента в связанном
сжатом хранении осуществляется
методом полного просмотра, при
последовательном хранении -
методом бинарного поиска. </p>

<p>Преимущества и недостатки
последовательного сжатого и
связанного сжатого хранений
аналогичны преимуществам и
недостаткам последовательного и
связанного хранений. </p>

<p>Рассмотрим следующую задачу. На
входе заданы две
последовательности целых чисел M=<M1,M2,...,M10000>, N=<N1,N2,...,N10000>,
причем 92% элементов
последовательности М равны нулю.
Составить программу для вычисления
суммы произведений Mi * Ni, i=1,2,...,10000. </p>

<p>Предположим, что список М
хранится последовательно сжато в
массиве структур m с объявлением: </p>

<pre>
     struct
     { int nm;
       float val; }   m[10000];
</pre>

<p>Для определения конца списка
добавим еще один элемент с
порядковым номером m[j].nm=10001, который
называется стоппером (stopper) и
располагается за последним
элементом сжатого хранения списка
в массиве m. </p>

<p>Программа для нахождения искомой
суммы имеет вид: </p>

<pre>
   # include <stdio.h>
   main()
   { int i,j=0;
     float inp,sum=0;
     struct                           /* объявление  массива  */
     { int nm;                        /* структур             */
       float val;  }   m[10000];

     for(i=0;i<10000;i++) /* чтение списка M */ { scanf("%f",&inp); if (inp!="0)" { m[j].nm="i;" m[j++].val="inp;" } } m[j].nm="10001;" /* stopper */ for(i="0,j=0;" i<10000; i++) { scanf("%f",&inp); /* чтение списка N */ if(i="=m[j].nm)" /* вычисление суммы */ sum+="m[j++].val*inp;" } printf( "сумма произведений Mi*Ni равна %f",sum); } </pre>
</pre>

<p>Индексное хранение используется
для уменьшения времени поиска
нужного элемента в списке и
заключается в следующем. Исходный
список B = <K1,K2, ...,Kn> разбивается на несколько
подсписков В1,В2, ...,Вm таким образом,
что каждый элемент списка В
попадает только в один из
подсписков, и дополнительно
используется индексный список с М
элементами, указывающими на начало
списков В1,В2, ...,Вm. </p>

<p>Считается, что список хранится
индексно с помощью подсписков B1,B2,
...,Bm и индексного спискa X = <ADG1,ADG2,... ADGm>, где ADGj -
адрес начала подсписка Bj, j=1,M. </p>

<p>При индексном хранении элемент К
подсписка Bj имеет индекс j. Для
получения индексного хранения
исходный список В часто
преобразуется в список В' путем
включения в каждый узел еще и его
порядкового номера в исходном
списке В, а в j-ый элемент индексного
списка Х, кроме ADGj, может включаться
некоторая дополнительная
информация о подсписке Bj. Разбиение
списка В на подсписки
осуществляется так, чтобы все
элементы В, обладающие
определенным свойством Рj, попадали
в один подсписок Bj. </p>

<p>Достоинством индексного хранения
является то, что для нахождения
элемента К с заданным свойством Pj
достаточно просмотреть только
элементы подсписка Bj; его начало
находится по индексному списку Х,
так как для любого К,
принадлежащего Bi, при i не равном j
свойство Pj не выполняется. </p>

<p>В разбиении В часто используется
индексная функция G(K), вычисляющая
по элементу К его индекс j, т.е. G(K)=j.
Функция G обычно зависит от позиции
К, обозначаемой поз.K, в подсписке В
или от значения определенной части
компоненты К - ее ключа. </p>

<p>Рассмотрим список B=<K1,K2, ...,K9> с элементами </p>

<pre>
  К1=(17,Y),   K2=(23,H),    K3=(60,I),   K4=(90,S),    K5=(66,T),
  K6=(77,T),   K7=(50,U),    K8=(88,W),   K9=(30,S).
</pre>

<p>Если для разбиения этого списка
на подсписки в качестве индексной
функции взять Ga(K)=1+(поз.K-1)/3, то
список разделится на три подсписка:
</p>

<pre>
           B1a=<(17,Y),(23,H),(60,I)>,
           B2a=<(90,S),(66,T),(77,T)>,
           B3a=<(50,U),(88,W),(30,S)>.
</pre>

<p>Добавляя всюду еще и начальную
позицию элемента в списке,
получаем: </p>

<pre>
           B1a'=<(1,17,Y),(2,23,H),(3,60,I)>,
           B2a'=<(4,90,S),(5,66,T),(6,77,T)>,
           B3a'=<(7,50,U),(8,88,W),(9,30,S)>.
</pre>

<p>Если в качестве индексной функции
выбрать другую функцию
Gb(K)=1+(поз.K-1)%3, то получим списки: </p>

<pre>
           B1b&quot;=<(1,17,Y),(4,90,S),(7,50,U)>,
           B2b&quot;=<(2,23,H),(5,66,T),(8,88,U)>,
           B3b&quot;=<(3,60,I),(6,77,T),(9,30,S)>.
</pre>

<p>Теперь для нахождения узла K6
достаточно просмотреть только одну
из трех последовательностей
(списков). При использовании
функции Ga(K) это список B2a', а при
функции Gb(K) список B3b&quot;. </p>

<p>Для индексной функции Gc(K)=1+K1/100,
где K1 - первая компонента элемента
К, находим: </p>

<pre>
         B1=<(17,Y),(23,H),(60,I),(90,S)>,
         B2=<(66,T),(77,T)>,
         B3=<(50,U),(88,W)>,
         B4=<(30,S)>.
</pre>

<p>Чтобы найти здесь узел К с первым
компонентом-ключом К1=77, достаточно
просмотреть список B2. </p>

<p>При реализации индексного
хранения применяется методика А
для хранения индексного списка Х
(функция Ga(X) ) и методика C для
хранения подсписков B1,B2,...,Bm
(функция Gc(Bi)), т.е. используется, так
называемое, A-C индексное хранение. </p>

<p>В практике часто используется
последовательно-связанное
индексное хранение. Так как обычно
длина списка индексов известна, то
его удобно хранить
последовательно, обеспечивая
прямой доступ к любому элементу
списка индексов. Подсписки B1,B2,...,Bm
хранятся связанно, что упрощает
вставку и удаление
узлов(элементов). В частности,
подобный метод хранения
используется в ЕС ЭВМ для
организации, так называемых,
индексно-последовательных наборов
данных, в которых доступ к
отдельным записям возможен как
последовательно, так и при помощи
ключа. </p>

<p align="center">Последовательно-связанное
индексное хранение для
приведенного примера изображено на
рис.24, где X=<ADG1,ADG2,ADG3,ADG4>. </p>

<p align="center"><img src="pictures/24.gif" width="426"
height="191"><br>
<b>Рис.24. Последовательно-связанное
индексное хранение списка.</b></p>

<p>Рассмотрим еще одну задачу. На
входе задана последовательность
целых положительных чисел,
заканчивающаяся нулем. Составить
процедуру для ввода этой
последовательности и организации
ее последовательно-связанного
индексного хранения таким образом,
чтобы числа, совпадающие в двух
последних цифрах, помещались в один
подсписок. </p>

<p>Выберем в качестве индексной
функции G(K)=K%100+1, а в качестве
индексного списка Х - массив из 100
элементов. Следующая функция
решает поставленную задачу: </p>

<pre>
   #include <stdio.h>
   #include <stdlib.h>
   typedef struct nd
           {  float val;
              struct nd *n; }   ND;
   int index (ND *x[100])
   {  ND *p;
      int i,j=0;
      float inp;
      for (i=0; i<100; i++) x[i]="NULL;" scanf("%d",&inp); while (inp!="0)" { j++; p="malloc(sizeof(ND));" i="inp%100+1;" p->val=inp;
          p-&gt;n=x[i];
          x[i]=p;
          scanf(&quot;%d&quot;,&amp;inp);
      }
      return j;
   }
</pre>

<p>Возвращаемым значением функции
index будет число обработанных
элементов списка. </p>

<p>Для индексного списка также может
использоваться индексное хранение.
Пусть, например, имеется список B=<K1,K2,...,K10> с
элементами </p>

<pre>
   K1=(338,Z),  K2=(145,A),  K3=(136,H),  K4=(214,I),  K5 =(146,C),
   K6=(334,Y),  K7=(333,P),  K8=(127,G),  K9=(310,O),  K10=(322,X).
</pre>

<p align="center">Требуется разделить его
на семь подсписков, т.е. X=<X1,X2,...,X7> таким
образом, чтобы в каждый список
B1,B2,...,B7 попадали элементы,
совпадающие в первой компоненте
первыми двумя цифрами. Список Х, в
свою очередь, будем индексировать
списком индексов Y=<Y1,Y2,Y3>, чтобы в каждый
список Y1,Y2,Y3 попадали элементы из X,
у которых в первой компоненте
совпадают первые цифры. Если списки
B1,B2,...,B7 хранить связанно, а списки
индексов X,Y индексно, то такой
способ хранения списка B называется
связанно-связанным связанным
индексным хранением. Графическое
изображение этого хранения
приведено на рис.25. </p>

<p align="center"><img src="pictures/25.gif" width="407"
height="343"><br>
<b>Рис.25. Связанно-связанное
связанное индексное хранение
списка.</b></p>

<hr width="90%">
<div align="center"><center>

<pre>[ <a href="h18.htm">Назад</a> | <a href="dir.htm"> Оглавление </a> | <a
href="h22.htm">Вперед</a> ]</pre>
</center></div>
</body>
</html>
