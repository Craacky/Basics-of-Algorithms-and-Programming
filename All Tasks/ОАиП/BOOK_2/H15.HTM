<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Программирование на языке СИ</title>
</head>

<body bgcolor="#FFF5EE" text="#000000" link="#FF0000"
vlink="#A52A2A" alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h4><a name="151">1.5.1. Определение и вызов
функций</a></h4>

<p>Мощность языка СИ во многом
определяется легкостью и гибкостью
в определении и использовании
функций в СИ-программах. В отличие
от других языков программирования
высокого уровня в языке СИ нет
деления на процедуры, подпрограммы
и функции, здесь вся программа
строится только из функций. </p>

<p>Функция - это совокупность
объявлений и операторов, обычно
предназначенная для решения
определенной задачи. Каждая
функция должна иметь имя, которое
используется для ее объявления,
определения и вызова. В любой
программе на СИ должна быть функция
с именем main (главная функция),
именно с этой функции, в каком бы
месте программы она не находилась,
начинается выполнение программы. </p>

<p>При вызове функции ей при помощи
аргументов (формальных параметров)
могут быть переданы некоторые
значения (фактические параметры),
используемые во время выполнения
функции. Функция может возвращать
некоторое (одно !) значение. Это
возвращаемое значение и есть
результат выполнения функции,
который при выполнении программы
подставляется в точку вызова
функции, где бы этот вызов ни
встретился. Допускается также
использовать функции не имеющие
аргументов и функции не
возвращающие никаких значений.
Действие таких функций может
состоять, например, в изменении
значений некоторых переменных,
выводе на печать некоторых текстов
и т.п.. </p>

<p>С использованием функций в языке
СИ связаны три понятия -
определение функции (описание
действий, выполняемых функцией),
объявление функции (задание формы
обращения к функции) и вызов
функции. </p>

<p>Определение функции задает тип
возвращаемого значения, имя
функции, типы и число формальных
параметров, а также объявления
переменных и операторы, называемые
телом функции, и определяющие
действие функции. В определении
функции также может быть задан
класс памяти. </p>

<p>Пример: </p>

<pre>
     int rus (unsigned char r)
     {  if (r&gt;='А' &amp;&amp; c<=' ') return 1; else return 0; } </pre>
</pre>

<p>В данном примере определена
функция с именем rus, имеющая один
параметр с именем r и типом unsigned char.
Функция возвращает целое значение,
равное 1, если параметр функции
является буквой русского алфавита,
или 0 в противном случае. </p>

<p>В языке СИ нет требования, чтобы
определение функции обязательно
предшествовало ее вызову.
Определения используемых функций
могут следовать за определением
функции main, перед ним, или находится
в другом файле. </p>

<p>Однако для того, чтобы компилятор
мог осуществить проверку
соответствия типов передаваемых
фактических параметров типам
формальных параметров до вызова
функции нужно поместить объявление
(прототип) функции. </p>

<p>Объявление функции имеет такой же
вид, что и определение функции, с
той лишь разницей, что тело функции
отсутствует, и имена формальных
параметров тоже могут быть опущены.
Для функции, определенной в
последнем примере, прототип может
иметь вид </p>

<p>int rus (unsigned char r); или rus (unsigned char); </p>

<p>В программах на языке СИ широко
используются, так называемые,
библиотечные функции, т.е. функции
предварительно разработанные и
записанные в библиотеки. Прототипы
библиотечных функций находятся в
специальных заголовочных файлах,
поставляемых вместе с библиотеками
в составе систем программирования,
и включаются в программу с помощью
директивы #include. </p>

<p>Если объявление функции не
задано, то по умолчанию строится
прототип функции на основе анализа
первой ссылки на функцию, будь то
вызов функции или определение.
Однако такой прототип не всегда
согласуется с последующим
определением или вызовом функции.
Рекомендуется всегда задавать
прототип функции. Это позволит
компилятору либо выдавать
диагностические сообщения, при
неправильном использовании
функции, либо корректным образом
регулировать несоответствие
аргументов устанавливаемое при
выполнении программы. </p>

<p>Объявление параметров функции
при ее определении может быть
выполнено в так называемом
&quot;старом стиле&quot;, при котором в
скобках после имени функции
следуют только имена параметров, а
после скобок объявления типов
параметров. Например, функция rus из
предыдущего примера может быть
определена следующим образом: </p>

<pre>
        int rus (r)
        unsigned char r;
        { ...     /*  тело функции   */      ...  }
</pre>

<p>В соответствии с синтаксисом
языка СИ определение функции имеет
следующую форму: </p>

<pre>
   [спецификатор-класса-памяти] [спецификатор-типа] имя-функции
   ([список-формальных-параметров])
   {  тело-функции   }
</pre>

<p>Необязательный
спецификатор-класса-памяти задает
класс памяти функции, который может
быть static или extern. Подробно классы
памяти будут рассмотрены в
следующем разделе. </p>

<p>Спецификатор-типа функции задает
тип возвращаемого значения и может
задавать любой тип. Если
спецификатор-типа не задан, то
предполагается, что функция
возвращает значение типа int. </p>

<p>Функция не может возвращать
массив или функцию, но может
возвращать указатель на любой тип,
в том числе и на массив и на функцию.
Тип возвращаемого значения,
задаваемый в определении функции,
должен соответствовать типу в
объявлении этой функции. </p>

<p>Функция возвращает значение если
ее выполнение заканчивается
оператором return, содержащим
некоторое выражение. Указанное
выражение вычисляется,
преобразуется, если необходимо, к
типу возвращаемого значения и
возвращается в точку вызова
функции в качестве результата. Если
оператор return не содержит выражения
или выполнение функции завершается
после выполнения последнего ее
оператора (без выполнения
оператора return), то возвращаемое
значение не определено. Для
функций, не использующих
возвращаемое значение, должен быть
использован тип void, указывающий на
отсутствие возвращаемого значения.
Если функция определена как
функция, возвращающая некоторое
значение, а в операторе return при
выходе из нее отсутствует
выражение, то поведение вызывающей
функции после передачи ей
управления может быть
непредсказуемым. </p>

<p>Список-формальных-параметров -
это последовательность объявлений
формальных параметров, разделенная
запятыми. Формальные параметры -
это переменные, используемые
внутри тела функции и получающие
значение при вызове функции путем
копирования в них значений
соответствующих фактических
параметров.
Список-формальных-параметров может
заканчиваться запятой (,) или
запятой с многоточием (,...), это
означает, что число аргументов
функции переменно. Однако
предполагается, что функция имеет,
по крайней мере, столько
обязательных аргументов, сколько
формальных параметров задано перед
последней запятой в списке
параметров. Такой функции может
быть передано большее число
аргументов, но над дополнительными
аргументами не проводится контроль
типов. </p>

<p>Если функция не использует
параметров, то наличие круглых
скобок обязательно, а вместо списка
параметров рекомендуется указать
слово void. </p>

<p>Порядок и типы формальных
параметров должны быть одинаковыми
в определении функции и во всех ее
объявлениях. Типы фактических
параметров при вызове функции
должны быть совместимы с типами
соответствующих формальных
параметров. Тип формального
параметра может быть любым
основным типом, структурой,
объединением, перечислением,
указателем или массивом. Если тип
формального параметра не указан, то
этому параметру присваивается тип
int. </p>

<p>Для формального параметра можно
задавать класс памяти register, при
этом для величин типа int
спецификатор типа можно опустить. </p>

<p>Идентификаторы формальных
параметров используются в теле
функции в качестве ссылок на
переданные значения. Эти
идентификаторы не могут быть
переопределены в блоке, образующем
тело функции, но могут быть
переопределены во внутреннем блоке
внутри тела функции. </p>

<p>При передаче параметров в
функцию, если необходимо,
выполняются обычные
арифметические преобразования для
каждого формального параметра и
каждого фактического параметра
независимо. После преобразования
формальный параметр не может быть
короче чем int, т.е. объявление
формального параметра с типом char
равносильно его объявлению с типом
int. А параметры, представляющие
собой действительные числа, имеют
тип double. </p>

<p>Преобразованный тип каждого
формального параметра определяет,
как интерпретируются аргументы,
помещаемые при вызове функции в
стек. Несоответствие типов
фактических аргументов и
формальных параметров может быть
причиной неверной интерпретации. </p>

<p>Тело функции - это составной
оператор, содержащий операторы,
определяющие действие функции. </p>

<p>Все переменные, объявленные в
теле функции без указания класса
памяти, имеют класс памяти auto, т.е.
они являются локальными. При вызове
функции локальным переменным
отводится память в стеке и
производится их инициализация.
Управление передается первому
оператору тела функции и
начинается выполнение функции,
которое продолжается до тех пор,
пока не встретится оператор return или
последний оператор тела функции.
Управление при этом возвращается в
точку, следующую за точкой вызова, а
локальные переменные становятся
недоступными. При новом вызове
функции для локальных переменных
память распределяется вновь, и
поэтому старые значения локальных
переменных теряются. </p>

<p>Параметры функции передаются по
значению и могут рассматриваться
как локальные переменные, для
которых выделяется память при
вызове функции и производится
инициализация значениями
фактических параметров. При выходе
из функции значения этих
переменных теряются. Поскольку
передача параметров происходит по
значению, в теле функции нельзя
изменить значения переменных в
вызывающей функции, являющихся
фактическими параметрами. Однако,
если в качестве параметра передать
указатель на некоторую переменную,
то используя операцию разадресации
можно изменить значение этой
переменной. </p>

<p>Пример: </p>

<pre>
       /*    Неправильное использование параметров   */
       void change (int x, int y)
       {    int k=x;
                x=y;
                y=k;
       }
</pre>

<p>В данной функции значения
переменных x и y, являющихся
формальными параметрами, меняются
местами, но поскольку эти
переменные существуют только
внутри функции change, значения
фактических параметров,
используемых при вызове функции,
останутся неизменными. Для того
чтобы менялись местами значения
фактических аргументов можно
использовать функцию приведенную в
следующем примере. </p>

<p>Пример: </p>

<pre>
      /*     Правильное использование параметров   */
       void change (int *x, int *y)
       {  int k=*x;
             *x=*y;
             *y=k;
       }
</pre>

<p>При вызове такой функции в
качестве фактических параметров
должны быть использованы не
значения переменных, а их адреса </p>

<p>change (&amp;a,&amp;b); </p>

<p>Если требуется вызвать функцию до
ее определения в рассматриваемом
файле, или определение функции
находится в другом исходном файле,
то вызов функции следует
предварять объявлением этой
функции. Объявление (прототип)
функции имеет следующий формат: </p>

<p>[спецификатор-класса-памяти]
[спецификатор-типа] имя-функции
([список-формальных-параметров])
[,список-имен-функций]; </p>

<p>В отличие от определения функции,
в прототипе за заголовком сразу же
следует точка с запятой, а тело
функции отсутствует. Если
несколько разных функций
возвращают значения одинакового
типа и имеют одинаковые списки
формальных параметров, то эти
функции можно объявить в одном
прототипе, указав имя одной из
функций в качестве имени-функции, а
все другие поместить в
список-имен-функций, причем каждая
функция должна сопровождаться
списком формальных параметров.
Правила использования остальных
элементов формата такие же, как при
определении функции. Имена
формальных параметров при
объявлении функции можно не
указывать, а если они указаны, то их
область действия распространяется
только до конца объявления. </p>

<p>Прототип - это явное объявление
функции, которое предшествует
определению функции. Тип
возвращаемого значения при
объявлении функции должен
соответствовать типу
возвращаемого значения в
определении функции. </p>

<p>Если прототип функции не задан, а
встретился вызов функции, то
строится неявный прототип из
анализа формы вызова функции. Тип
возвращаемого значения
создаваемого прототипа int, а список
типов и числа параметров функции
формируется на основании типов и
числа фактических параметров
используемых при данном вызове. </p>

<p>Таким образом, прототип функции
необходимо задавать в следующих
случаях: </p>

<p>1. Функция возвращает значение
типа, отличного от int. </p>

<p>2. Требуется проинициализировать
некоторый указатель на функцию до
того, как эта функция будет
определена. </p>

<p>Наличие в прототипе полного
списка типов аргументов параметров
позволяет выполнить проверку
соответствия типов фактических
параметров при вызове функции
типам формальных параметров, и,
если необходимо, выполнить
соответствующие преобразования. </p>

<p>В прототипе можно указать, что
число параметров функции
переменно, или что функция не имеет
параметров. </p>

<p>Если прототип задан с классом
памяти static, то и определение
функции должно иметь класс памяти
static. Если спецификатор класса
памяти не указан, то
подразумевается класс памяти extern. </p>

<p>Вызов функции имеет следующий
формат: </p>

<p>адресное-выражение
([список-выражений]) </p>

<p>Поскольку синтаксически имя
функции является адресом начала
тела функции, в качестве обращения
к функции может быть использовано
адресное-выражение (в том числе и
имя функции или разадресация
указателя на функцию), имеющее
значение адреса функции. </p>

<p>Список-выражений представляет
собой список фактических
параметров, передаваемых в функцию.
Этот список может быть и пустым, но
наличие круглых скобок
обязательно. </p>

<p>Фактический параметр может быть
величиной любого основного типа,
структурой, объединением,
перечислением или указателем на
объект любого типа. Массив и
функция не могут быть использованы
в качестве фактических параметров,
но можно использовать указатели на
эти объекты. </p>

<p>Выполнение вызова функции
происходит следующим образом: </p>

<p>1. Вычисляются выражения в списке
выражений и подвергаются обычным
арифметическим преобразованиям.
Затем, если известен прототип
функции, тип полученного
фактического аргумента
сравнивается с типом
соответствующего формального
параметра. Если они не совпадают, то
либо производится преобразование
типов, либо формируется сообщение
об ошибке. Число выражений в списке
выражений должно совпадать с
числом формальных параметров, если
только функция не имеет
переменного числа параметров. В
последнем случае проверке подлежат
только обязательные параметры.
Если в прототипе функции указано,
что ей не требуются параметры, а при
вызове они указаны, формируется
сообщение об ошибке. </p>

<p>2. Происходит присваивание
значений фактических параметров
соответствующим формальным
параметрам. </p>

<p>3. Управление передается на первый
оператор функции. </p>

<p>4. Выполнение оператора return в теле
функции возвращает управление и
возможно, значение в вызывающую
функцию. При отсутствии оператора
return управление возвращается после
выполнения последнего оператора
тела функции, а возвращаемое
значение не определено. </p>

<p>Адресное выражение, стоящее перед
скобками определяет адрес
вызываемой функции. Это значит что
функция может быть вызвана через
указатель на функцию. </p>

<p>Пример: </p>

<p>int (*fun)(int x, int *y); </p>

<p>Здесь объявлена переменная fun как
указатель на функцию с двумя
параметрами: типа int и указателем на
int. Сама функция должна возвращать
значение типа int. Круглые скобки,
содержащие имя указателя fun и
признак указателя *, обязательны,
иначе запись </p>

<p>int *fun (intx,int *y); </p>

<p>будет интерпретироваться как
объявление функции fun возвращающей
указатель на int. </p>

<p>Вызов функции возможен только
после инициализации значения
указателя fun и имеет вид: </p>

<p>(*fun)(i,&amp;j); </p>

<p>В этом выражении для получения
адреса функции, на которую
ссылается указатель fun
используется операция
разадресации * . </p>

<p>Указатель на функцию может быть
передан в качестве параметра
функции. При этом разадресация
происходит во время вызова функции,
на которую ссылается указатель на
функцию. Присвоить значение
указателю на функцию можно в
операторе присваивания, употребив
имя функции без списка параметров. </p>

<p>Пример: </p>

<pre>
    double (*fun1)(int x, int y);
    double fun2(int k, int l);
       fun1=fun2;         /* инициализация указателя на функцию */
       (*fun1)(2,7);      /* обращение к функции                */
</pre>

<p>В рассмотренном примере
указатель на функцию fun1 описан как
указатель на функцию с двумя
параметрами, возвращающую значение
типа double, и также описана функция
fun2. В противном случае, т.е. когда
указателю на функцию присваивается
функция описанная иначе чем
указатель, произойдет ошибка. </p>

<p>Рассмотрим пример использования
указателя на функцию в качестве
параметра функции вычисляющей
производную от функции cos(x). </p>

<p>Пример: </p>

<pre>
   double proiz(double x, double dx, double (*f)(double x) );
   double fun(double z);
   int main()
   {
     double x;               /*  точка вычисления производной */
     double dx;              /*  приращение                   */
     double z;               /*  значение производной         */
     scanf(&quot;%f,%f&quot;,&amp;x,&amp;dx);  /*  ввод значений x и dx         */
     z=proiz(x,dx,fun);      /*  вызов функции                */
     printf(&quot;%f&quot;,z);         /*  печать значения производной  */
     return 0;
   }
   double proiz(double x,double dx, double (*f)(double z) )
   {         /* функция вычисляющая производную  */
      double xk,xk1,pr;
      xk=fun(x);
      xk1=fun(x+dx);
      pr=(xk1/xk-1e0)*xk/dx;
      return pr;
   }
   double fun( double z)
   {     /* функция от которой вычисляется производная  */
      return (cos(z));
   }
</pre>

<p>Для вычисления производной от
какой-либо другой функции можно
изменить тело функции fun или
использовать при вызове функции proiz
имя другой функции. В частности, для
вычисления производной от функции
cos(x) можно вызвать функцию proiz в
форме </p>

<p>z=proiz(x,dx,cos); </p>

<p>а для вычисления производной от
функции sin(x) в форме </p>

<p>z=proiz(x,dx,sin); </p>

<p>Любая функция в программе на
языке СИ может быть вызвана
рекурсивно, т.е. она может вызывать
саму себя. Компилятор допускает
любое число рекурсивных вызовов.
При каждом вызове для формальных
параметров и переменных с классом
памяти auto и register выделяется новая
область памяти, так что их значения
из предыдущих вызовов не теряются,
но в каждый момент времени доступны
только значения текущего вызова. </p>

<p>Переменные, объявленные с классом
памяти static, не требуют выделения
новой области памяти при каждом
рекурсивном вызове функции и их
значения доступны в течение всего
времени выполнения программы. </p>

<p>Классический пример рекурсии -
это математическое определение
факториала n! : </p>

<pre>
   n! = 1 при n=0;
        n*(n-1)!  при    n&gt;1 .
</pre>

<p>Функция, вычисляющая факториал,
будет иметь следующий вид: </p>

<pre>
       long fakt(int n)
       {
         return ( (n==1) ? 1 : n*fakt(n-1)  );
       }
</pre>

<p>Хотя компилятор языка СИ не
ограничивает число рекурсивных
вызовов функций, это число
ограничивается ресурсом памяти
компьютера и при слишком большом
числе рекурсивных вызовов может
произойти переполнение стека. </p>

<h4><a name="152">1.5.2. Вызов функции с
переменным числом параметров</a></h4>

<p>При вызове функции с переменным
числом параметров в вызове этой
функции задается любое требуемое
число аргументов. В объявлении и
определении такой функции
переменное число аргументов
задается многоточием в конце
списка формальных параметров или
списка типов аргументов. </p>

<p>Все аргументы, заданные в вызове
функции, размещаются в стеке.
Количество формальных параметров,
объявленных для функции,
определяется числом аргументов,
которые берутся из стека и
присваиваются формальным
параметрам. Программист отвечает
за правильность выбора
дополнительных аргументов из стека
и определение числа аргументов,
находящихся в стеке. </p>

<p>Примерами функций с переменным
числом параметров являются функции
из библиотеки функций языка СИ,
осуществляющие операции
ввода-вывода информации (printf,scanf и
т.п.). Подробно эти функции
рассмотрены во третьей части книги.
</p>

<p>Программист может разрабатывать
свои функции с переменным числом
параметров. Для обеспечения
удобного способа доступа к
аргументам функции с переменным
числом параметров имеются три
макроопределения (макросы) va_start,
va_arg, va_end, находящиеся в
заголовочном файле stdarg.h. Эти
макросы указывают на то, что
функция, разработанная
пользователем, имеет некоторое
число обязательных аргументов, за
которыми следует переменное число
необязательных аргументов.
Обязательные аргументы доступны
через свои имена как при вызове
обычной функции. Для извлечения
необязательных аргументов
используются макросы va_start, va_arg, va_end
в следующем порядке. </p>

<p>Макрос va_start предназначен для
установки аргумента arg_ptr на начало
списка необязательных параметров и
имеет вид функции с двумя
параметрами: </p>

<p>void va_start(arg_ptr,prav_param); </p>

<p>Параметр prav_param должен быть
последним обязательным параметром
вызываемой функции, а указатель
arg_prt должен быть объявлен с
предопределением в списке
переменных типа va_list в виде: </p>

<p>va_list arg_ptr; </p>

<p>Макрос va_start должен быть
использован до первого
использования макроса va_arg. </p>

<p>Макрокоманда va_arg обеспечивает
доступ к текущему параметру
вызываемой функции и тоже имеет вид
функции с двумя параметрами </p>

<p>type_arg va_arg(arg_ptr,type); </p>

<p>Эта макрокоманда извлекает
значение типа type по адресу,
заданному указателем arg_ptr,
увеличивает значение указателя
arg_ptr на длину использованного
параметра (длина type) и таким образом
параметр arg_ptr будет указывать на
следующий параметр вызываемой
функции. Макрокоманда va_arg
используется столько раз, сколько
необходимо для извлечения всех
параметров вызываемой функции. </p>

<p>Макрос va_end используется по
окончании обработки всех
параметров функции и устанавливает
указатель списка необязательных
параметров на ноль (NULL). </p>

<p>Рассмотрим применение этих
макросов для обработки параметров
функции вычисляющей среднее
значение произвольной
последовательности целых чисел.
Поскольку функция имеет переменное
число параметров будем считать
концом списка значение равное -1.
Поскольку в списке должен быть хотя
бы один элемент, у функции будет
один обязательный параметр. </p>

<p>Пример: </p>

<pre>
   #include <starg.h>
   int main()
   { int n;
     int sred_znach(int,...);
     n=sred_znach(2,3,4,-1);
                     /* вызов с четырьмя параметрами */
     printf(&quot;n=%d&quot;,n);
     n=sred_znach(5,6,7,8,9,-1);
                    /* вызов с шестью параметрами   */
     printf(&quot;n=%d&quot;,n);
     return (0);
   }

   int sred_znach(int x,...);
   {
      int i=0,  j=0,  sum=0;
      va_list uk_arg;
      va_start(uk_arg,x);  /*  установка указателя uk_arg на  */
                           /*  первый необязятельный параметр */
      if (x!=-1) sum=x;    /*  проверка на пустоту списка     */
      else return (0);
      j++;
      while ( (i=va_arg(uk_arg,int))!=-1)
                                   /* выборка очередного   */
      {                            /* параметра и проверка */
        sum+=i;                    /* на конец списка      */
        j++;
      }
      va_end(uk_arg);         /* закрытие списка параметров   */
      return (sum/j);
   }
</pre>

<h4><a name="153">1.5.3. Передача параметров
функции main</a></h4>

<p>Функция main, с которой начинается
выполнение СИ-программы, может быть
определена с параметрами, которые
передаются из внешнего окружения,
например, из командной строки. Во
внешнем окружении действуют свои
правила представления данных, а
точнее, все данные представляются в
виде строк символов. Для передачи
этих строк в функцию main
используются два параметра, первый
параметр служит для передачи числа
передаваемых строк, второй для
передачи самих строк. Общепринятые
(но не обязательные) имена этих
параметров argc и argv. Параметр argc
имеет тип int, его значение
формируется из анализа командной
строки и равно количеству слов в
командной строке, включая и имя
вызываемой программы (под словом
понимается любой текст не
содержащий символа пробел).
Параметр argv это массив указателей
на строки, каждая из которых
содержит одно слово из командной
строки. Если слово должно содержать
символ пробел, то при записи его в
командную строку оно должно быть
заключено в кавычки. </p>

<p>Функция main может иметь и третий
параметр, который принято называть
argp, и который служит для передачи в
функцию main параметров операционной
системы (среды) в которой
выполняется СИ-программа. </p>

<p>Заголовок функции main имеет вид: </p>

<p>int main (int argc, char *argv[], char *argp[]) </p>

<p>Если, например, командная строка
СИ-программы имеет вид: </p>

<p>A:\&gt;cprog working 'C program' 1 </p>

<p>то аргументы argc, argv, argp
представляются в памяти как
показано в схеме на рис.1. </p>

<pre>
     argc  [ 4  ]
     argv  [    ]--&gt; [    ]--&gt;   [A:\cprog.exe\0]
                     [    ]--&gt;   [working\0]
                     [    ]--&gt;   [C program\0]
                     [    ]--&gt;   [1\0]
                     [NULL]
     argp  [    ]--&gt; [    ]--&gt;   [path=A:\;C:\\0]
                     [    ]--&gt;   [lib=D:\LIB\0]
                     [    ]--&gt;   [include=D:\INCLUDE\0]
                     [    ]--&gt;   [conspec=C:\COMMAND.COM\]
                     [NULL]
     Рис.1. Схема размещения параметров командной строки
</pre>

<p>Операционная система
поддерживает передачу значений для
параметров argc, argv, argp, а на
пользователе лежит
ответственность за передачу и
использование фактических
аргументов функции main. </p>

<p>Следующий пример представляет
программу печати фактических
аргументов, передаваемых в функцию
main из операционной системы и
параметров операционной системы. </p>

<pre>
     Пример:
     int main ( int argc, char *argv[], char *argp[])
     {  int i=0;
        printf (&quot;\n Имя программы %s&quot;, argv[0]);
        for    (i=1; i&gt;=argc; i++)
        printf (&quot;\n аргумент %d равен %s&quot;, argv[i]);
        printf (&quot;\n   Параметры операционной системы:&quot;);
        while  (*argp)
          {  printf (&quot;\n %s&quot;,*argp);
             argp++;
          }
        return (0);
     }
</pre>

<p>Доступ к параметрам операционной
системы можно также получить при
помощи библиотечной функции geteuv, ее
прототип имеет следующий вид: </p>

<p>char *geteuv (const char *varname); </p>

<p>Аргумент этой функции задает имя
параметра среды, указатель на
значение которой выдаст функция
geteuv. Если указанный параметр не
определен в среде в данный момент,
то возвращаемое значение NULL. </p>

<p>Используя указатель, полученный
функцией geteuv, можно только
прочитать значение параметра
операционной системы, но нельзя его
изменить. Для изменения значения
параметра системы предназначена
функция puteuv. </p>

<p>Компилятор языка СИ строит
СИ-программу таким образом, что
вначале работы программы
выполняется некоторая
инициализация, включающая, кроме
всего прочего, обработку
аргументов, передаваемых функции
main, и передачу ей значений
параметров среды. Эти действия
выполняются библиотечными
функциями _setargv и _seteuv, которые
всегда помещаются компилятором
перед функцией main. </p>

<p>Если СИ-программа не использует
передачу аргументов и значений
параметров операционной системы,
то целесообразно запретить
использование библиотечных
функций _setargv и _seteuv поместив в
СИ-программу перед функцией main
функции с такими же именами, но не
выполняющие никаких действий
(заглушки). Начало программы в этом
случае будет иметь вид: </p>

<pre>
   _setargv()
    {  return ;    /* пустая функция */
    }
   -seteuv()
    {  return ;    /* пустая функция */
    }
   int main()
    {      /* главная функция без аргументов */
    ...
    ...
    renurn (0);
    }
</pre>

<p align="center">В приведенной программе
при вызове библиотечных функций
_setargv и _seteuv будут использованы
функции помещенные в программу
пользователем и не выполняющие
никаких действий. Это заметно
снизит размер получаемого exe-файла. </p>

<hr width="90%">
<div align="center"><center>

<pre>[ <a href="h14.htm">Назад</a> | <a href="dir.htm"> Оглавление </a> | <a
href="h16.htm">Вперед</a> ]</pre>
</center></div>
</body>
</html>
