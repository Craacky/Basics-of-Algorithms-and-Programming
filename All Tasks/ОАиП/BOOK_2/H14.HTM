<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Программирование на языке СИ</title>
</head>

<body bgcolor="#FFF5EE" text="#000000" link="#FF0000"
vlink="#A52A2A" alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h4><a name="14">1.4. Операторы</a></h4>

<p>Все операторы языка СИ могут быть
условно разделены на следующие
категории: </p>

<p>- условные операторы, к которым
относятся оператор условия if и
оператор выбора switch; </p>

<p>- операторы цикла (for,while,do while); </p>

<p>- операторы перехода (break, continue,
return, goto); </p>

<p>- другие операторы (оператор
&quot;выражение&quot;, пустой оператор). </p>

<p>Операторы в программе могут
объединяться в составные операторы
с помощью фигурных скобок. Любой
оператор в программе может быть
помечен меткой, состоящей из имени
и следующего за ним двоеточия. </p>

<p>Все операторы языка СИ, кроме
составных операторов,
заканчиваются точкой с запятой
&quot;;&quot;. </p>

<h4><a name="141">1.4.1. Оператор выражение</a></h4>

<p>Любое выражение, которое
заканчивается точкой с запятой,
является оператором. </p>

<p>Выполнение оператора выражение
заключается в вычислении
выражения. Полученное значение
выражения никак не используется,
поэтому, как правило, такие
выражения вызывают побочные
эффекты. Заметим, что вызвать
функцию, невозвращающую значения
можно только при помощи оператора
выражения. Правила вычисления
выражений были сформулированы
выше. </p>

<p>Примеры: </p>

<p>++ i; </p>

<p>Этот оператор представляет
выражение, которое увеличивает
значение переменной i на единицу. </p>

<p>a=cos(b * 5); </p>

<p>Этот оператор представляет
выражение, включающее в себя
операции присваивания и вызова
функции. </p>

<p>a(x,y); </p>

<p>Этот оператор представляет
выражение состоящее из вызова
функции. </p>

<h4><a name="142">1.4.2. Пустой оператор</a></h4>

<p>Пустой оператор состоит только из
точки с запятой. При выполнении
этого оператора ничего не
происходит. Он обычно используется
в следующих случаях: </p>

<p>- в операторах do, for, while, if в
строках, когда место оператора не
требуется, но по синтаксису
требуется хотя бы один оператор; </p>

<p>- при необходимости пометить
фигурную скобку. </p>

<p>Синтаксис языка СИ требует, чтобы
после метки обязательно следовал
оператор. Фигурная же скобка
оператором не является. Поэтому,
если надо передать управление на
фигурную скобку, необходимо
использовать пустой оператор. </p>

<p>Пример: </p>

<pre>
     int main ( )
     {
          :
           { if (...) goto a;    /* переход на скобку */
               { ...
               }
      a:;  }
           return 0;
       }
</pre>

<h4><a name="143">1.4.3. Составной оператор</a></h4>

<p>Составной оператор представляет
собой несколько операторов и
объявлений, заключенных в фигурные
скобки: </p>

<pre>
       {  [oбъявление]
           :
           оператор; [оператор];
           :
       }
</pre>

<p>Заметим, что в конце составного
оператора точка с запятой не
ставится. </p>

<p>Выполнение составного оператора
заключается в последовательном
выполнении составляющих его
операторов. </p>

<p>Пример: </p>

<pre>
        int main ()
        {
          int    q,b;
          double t,d;
            :
            if (...)
              {
                int    e,g;
                double f,q;
                :
               }
            :
            return (0);
        }
</pre>

<p>Переменные e,g,f,q будут уничтожены
после выполнения составного
оператора. Отметим, что переменная q
является локальной в составном
операторе, т.е. она никоим образом
не связана с переменной q
объявленной в начале функции main с
типом int. Отметим также, что
выражение стоящее после return может
быть заключено в круглые скобки,
хотя наличие последних
необязательно. </p>

<h4><a name="144">1.4.4. Оператор if</a></h4>

<p>Формат оператора: </p>

<p>if (выражение) оператор-1; [else
оператор-2;] </p>

<p>Выполнение оператора if
начинается с вычисления выражения. </p>

<p>Далее выполнение осуществляется
по следующей схеме: </p>

<p>- если выражение истинно (т.е.
отлично от 0), то выполняется
оператор-1. </p>

<p>- если выражение ложно (т.е. равно
0),то выполняется оператор-2. </p>

<p>- если выражение ложно и
отсутствует оператор-2 (в
квадратные скобки заключена
необязательная конструкция), то
выполняется следующий за if
оператор. </p>

<p>После выполнения оператора if
значение передается на следующий
оператор программы, если
последовательность выполнения
операторов программы не будет
принудительно нарушена
использованием операторов
перехода. </p>

<p>Пример: </p>

<pre>
                  if (i &lt; j)   i++:
                  else { j = i-3;   i++; }
</pre>

<p>Этот пример иллюстрирует также и
тот факт, что на месте оператор-1,
так же как и на месте оператор-2
могут находиться сложные
конструкции. </p>

<p>Допускается использование
вложенных операторов if. Оператор if
может быть включен в конструкцию if
или в конструкцию else другого
оператора if. Чтобы сделать
программу более читабельной,
рекомендуется группировать
операторы и конструкции во
вложенных операторах if, используя
фигурные скобки. Если же фигурные
скобки опущены, то компилятор
связывает каждое ключевое слово else
с наиболее близким if, для которого
нет else. </p>

<p>Примеры: </p>

<pre>
        int main ( )
         {
           int t=2, b=7, r=3;
             if (t&gt;b)
              {
                  if (b &lt; r)  r=b;
              }
             else r=t;
           return (0);
         }
</pre>

<p>В результате выполнения этой
программы r станет равным 2. </p>

<p>Если же в программе опустить
фигурные скобки, стоящие после
оператора if, то программа будет
иметь следующий вид: </p>

<pre>
        int main  ( )
         {
           int t=2,b=7,r=3;
           if ( a&gt;b )
               if ( b &lt; c ) t=b;
               else       r=t;
           return (0);
          }
</pre>

<p>В этом случае r получит значение
равное 3, так как ключевое слово else
относится ко второму оператору if,
который не выполняется, поскольку
не выполняется условие,
проверяемое в первом операторе if. </p>

<p>Следующий фрагмент иллюстрирует
вложенные операторы if: </p>

<pre>
     char ZNAC;
     int x,y,z;
       :
      if (ZNAC == '-') x = y - z;
      else  if (ZNAC == '+') x = y + z;
            else if (ZNAC == '*') x = y * z;
                  else if (ZNAC == '/') x = y / z;
                        else ...
</pre>

<p>Из рассмотрения этого примера
можно сделать вывод, что
конструкции использующие
вложенные операторы if, являются
довольно громоздкими и не всегда
достаточно надежными. Другим
способом организации выбора из
множества различных вариантов
является использование
специального оператора выбора switch. </p>

<h4><a name="145">1.4.5. Оператор switch</a></h4>

<p>Оператор switch предназначен для
организации выбора из множества
различных вариантов. Формат
оператора следующий: </p>

<pre>
     switch ( выражение )
     {   [объявление]
              :
           [ case  константное-выражение1]: [ список-операторов1]
           [ case  константное-выражение2]: [ список-операторов2]
              :
              :
           [ default: [ список операторов ]]
     }
</pre>

<p>Выражение, следующее за ключевым
словом switch в круглых скобках, может
быть любым выражением, допустимыми
в языке СИ, значение которого
должно быть целым. Отметим, что
можно использовать явное
приведение к целому типу, однако
необходимо помнить о тех
ограничениях и рекомендациях, о
которых говорилось выше. </p>

<p>Значение этого выражения
является ключевым для выбора из
нескольких вариантов. Тело
оператора smitch состоит из
нескольких операторов, помеченных
ключевым словом case с последующим
константным-выражением. Следует
отметить, что использование целого
константного выражения является
существенным недостатком, присущим
рассмотренному оператору. </p>

<p>Так как константное выражение
вычисляется во время трансляции,
оно не может содержать переменные
или вызовы функций. Обычно в
качестве константного выражения
используются целые или символьные
константы. </p>

<p>Все константные выражения в
операторе switch должны быть
уникальны. Кроме операторов,
помеченных ключевым словом case,
может быть, но обязательно один,
фрагмент помеченный ключевым
словом default. </p>

<p>Список операторов может быть
пустым, либо содержать один или
более операторов. Причем в
операторе switch не требуется
заключать последовательность
операторов в фигурные скобки. </p>

<p>Отметим также, что в операторе switch
можно использовать свои локальные
переменные, объявления которых
находятся перед первым ключевым
словом case, однако в объявлениях не
должна использоваться
инициализация. </p>

<p>Схема выполнения оператора switch
следующая: </p>

<p>- вычисляется выражение в круглых
скобках; </p>

<p>- вычисленные значения
последовательно сравниваются с
константными выражениями,
следующими за ключевыми словами case;
</p>

<p>- если одно из константных
выражений совпадает со значением
выражения, то управление
передается на оператор, помеченный
соответствующим ключевым словом
case; </p>

<p>- если ни одно из константных
выражений не равно выражению, то
управление передается на оператор,
помеченный ключевым словом default, а в
случае его отсутствия управление
передается на следующий после switch
оператор. </p>

<p>Отметим интересную особенность
использования оператора switch:
конструкция со словом default может
быть не последней в теле оператора
switch. Ключевые слова case и default в теле
оператора switch существенны только
при начальной проверке, когда
определяется начальная точка
выполнения тела оператора switch. Все
операторы, между начальным
оператором и концом тела,
выполняются вне зависимости от
ключевых слов, если только какой-то
из операторов не передаст
управления из тела оператора switch.
Таким образом, программист должен
сам позаботится о выходе из case, если
это необходимо. Чаще всего для
этого используется оператор break. </p>

<p>Для того, чтобы выполнить одни и
те же действия для различных
значений выражения, можно пометить
один и тот же оператор несколькими
ключевыми словами case. </p>

<p>Пример: </p>

<pre>
      int i=2;
      switch (i)
        {
         case 1: i += 2;
         case 2: i *= 3;
         case 0: i /= 2;
         case 4: i -= 5;
         default:      ;
     }
</pre>

<p>Выполнение оператора switch
начинается с оператора,
помеченного case 2. Таким образом,
переменная i получает значение,
равное 6, далее выполняется
оператор, помеченный ключевым
словом case 0, а затем case 4, переменная i
примет значение 3, а затем значение
-2. Оператор, помеченный ключевым
словом default, не изменяет значения
переменной. </p>

<p>Рассмотрим ранее приведенный
пример, в котором иллюстрировалось
использование вложенных
операторов if, переписанной теперь с
использованием оператора switch. </p>

<pre>
     char ZNAC;
     int x,y,z;
     switch (ZNAC)
     {
          case '+':  x = y + z;    break;
          case '-':  x = y - z;    break;
          case '*':  x = y * z;    break;
          case '/':  x = u / z;    break;
          default : ;
        }
</pre>

<p>Использование оператора break
позволяет в необходимый момент
прервать последовательность
выполняемых операторов в теле
оператора switch, путем передачи
управления оператору, следующему
за switch. </p>

<p>Отметим, что в теле оператора switch
можно использовать вложенные
операторы switch, при этом в ключевых
словах case можно использовать
одинаковые константные выражения. </p>

<p>Пример: </p>

<pre>
       :
     switch (a)
      {
        case 1: b=c; break;
        case 2:
            switch (d)
            {   case 0:  f=s;  break;
                case 1:  f=9;  break;
                case 2:  f-=9; break;
            }
         case 3: b-=c; break;
         :
      }
</pre>

<h4><a name="146">1.4.6. Оператор break</a></h4>

<p>Оператор break обеспечивает
прекращение выполнения самого
внутреннего из объединяющих его
операторов switch, do, for, while. После
выполнения оператора break
управление передается оператору,
следующему за прерванным. </p>

<h4><a name="147">1.4.7. Оператор for</a></h4>

<p>Оператор for - это наиболее общий
способ организации цикла. Он имеет
следующий формат: </p>

<p>for ( выражение 1 ; выражение 2 ;
выражение 3 ) тело </p>

<p>Выражение 1 обычно используется
для установления начального
значения переменных, управляющих
циклом. Выражение 2 - это выражение,
определяющее условие, при котором
тело цикла будет выполняться.
Выражение 3 определяет изменение
переменных, управляющих циклом
после каждого выполнения тела
цикла. </p>

<p>Схема выполнения оператора for: </p>

<p>1. Вычисляется выражение 1. </p>

<p>2. Вычисляется выражение 2. </p>

<p>3. Если значения выражения 2
отлично от нуля (истина),
выполняется тело цикла,
вычисляется выражение 3 и
осуществляется переход к пункту 2,
если выражение 2 равно нулю (ложь),
то управление передается на
оператор, следующий за оператором
for. </p>

<p>Существенно то, что проверка
условия всегда выполняется в
начале цикла. Это значит, что тело
цикла может ни разу не выполниться,
если условие выполнения сразу
будет ложным. </p>

<p>Пример: </p>

<pre>
       int main()
       { int i,b;
          for (i=1; i<10; i++) b="i*i;" return 0; } </pre>
</pre>

<p>В этом примере вычисляются
квадраты чисел от 1 до 9. </p>

<p>Некоторые варианты использования
оператора for повышают его гибкость
за счет возможности использования
нескольких переменных, управляющих
циклом. </p>

<p>Пример: </p>

<pre>
       int main()
       {  int top,  bot;
          char string[100],  temp;
          for ( top=0, bot=100 ; top &lt; bot ; top++, bot--)
          {  temp=string[top];
             string[bot]=temp;
          }
          return 0;
        }
</pre>

<p>В этом примере, реализующем
запись строки символов в обратном
порядке, для управления циклом
используются две переменные top и bot.
Отметим, что на месте выражение 1 и
выражение 3 здесь используются
несколько выражений, записанных
через запятую, и выполняемых
последовательно. </p>

<p>Другим вариантом использования
оператора for является бесконечный
цикл. Для организации такого цикла
можно использовать пустое условное
выражение, а для выхода из цикла
обычно используют дополнительное
условие и оператор break. </p>

<p>Пример: </p>

<pre>
       for (;;)
       { ...
         ...  break;
         ...
       }
</pre>

<p>Так как согласно синтаксису языка
Си оператор может быть пустым, тело
оператора for также может быть
пустым. Такая форма оператора может
быть использована для организации
поиска. </p>

<p>Пример: </p>

<p>for (i=0; t[i]<10 ; i++) ; <p>В данном примере
переменная цикла i принимает
значение номера первого элемента
массива t, значение которого больше
10. </p>

<h4><a name="148">1.4.8. Оператор while</a></h4>

<p>Оператор цикла while называется
циклом с предусловием и имеет
следующий формат: </p>

<p>while (выражение) тело ; </p>

<p>В качестве выражения допускается
использовать любое выражение языка
Си, а в качестве тела любой
оператор, в том числе пустой или
составной. Схема выполнения
оператора while следующая: </p>

<p>1. Вычисляется выражение. </p>

<p>2. Если выражение ложно, то
выполнение оператора while
заканчивается и выполняется
следующий по порядку оператор. Если
выражение истинно, то выполняется
тело оператора while. </p>

<p>3. Процесс повторяется с пункта 1. </p>

<p>Оператор цикла вида </p>

<p>for (выражение-1; выражение-2;
выражение-3) тело ; </p>

<p>может быть заменен оператором while
следующим образом: </p>

<pre>
           выражение-1;
           while (выражение-2)
           {  тело
              выражение-3;
           }
</pre>

<p>Так же как и при выполнении
оператора for, в операторе while
вначале происходит проверка
условия. Поэтому оператор while
удобно использовать в ситуациях,
когда тело оператора не всегда
нужно выполнять. </p>

<p>Внутри операторов for и while можно
использовать локальные переменные,
которые должны быть объявлены с
определением соответствующих
типов. </p>

<h4><a name="149">1.4.9. Оператор do while</a></h4>

<p>Оператор цикла do while называется
оператором цикла с постусловием и
используется в тех случаях, когда
необходимо выполнить тело цикла
хотя бы один раз. Формат оператора
имеет следующий вид: </p>

<p>do тело while (выражение); </p>

<p>Схема выполнения оператора do while : </p>

<p>1. Выполняется тело цикла (которое
может быть составным оператором). </p>

<p>2. Вычисляется выражение. </p>

<p>3. Если выражение ложно, то
выполнение оператора do while
заканчивается и выполняется
следующий по порядку оператор. Если
выражение истинно, то выполнение
оператора продолжается с пункта 1. </p>

<p>Чтобы прервать выполнение цикла
до того, как условие станет ложным,
можно использовать оператор break. </p>

<p>Операторы while и do while могут быть
вложенными. </p>

<p>Пример: </p>

<pre>
       int i,j,k;
       ...
       i=0;  j=0;  k=0;
       do { i++;
            j--;
            while (a[k] &lt; i)  k++;
           }
       while (i<30 && j<-30); </pre>

</pre>

<h4><a name="1410">1.4.10. Оператор continue</a></h4>

<p>Оператор continue, как и оператор break,
используется только внутри
операторов цикла, но в отличие от
него выполнение программы
продолжается не с оператора,
следующего за прерванным
оператором, а с начала прерванного
оператора. Формат оператора
следующий: </p>

<p>continue; </p>

<p>Пример: </p>

<pre>
       int main()
       {   int a,b;
           for (a=1,b=0; a<100; b+="a,a++)" { if (b%2) continue; ... /* обработка четных сумм */ } return 0; } </pre>
</pre>

<p>Когда сумма чисел от 1 до а
становится нечетной, оператор continue
передает управление на очередную
итерацию цикла for, не выполняя
операторы обработки четных сумм. </p>

<p>Оператор continue, как и оператор break,
прерывает самый внутренний из
объемлющих его циклов. </p>

<h4><a name="1411">1.4.11. Оператор return</a></h4>

<p>Оператор return завершает
выполнение функции, в которой он
задан, и возвращает управление в
вызывающую функцию, в точку,
непосредственно следующую за
вызовом. Функция main передает
управление операционной системе.
Формат оператора: </p>

<p>return [выражение] ; </p>

<p>Значение выражения, если оно
задано, возвращается в вызывающую
функцию в качестве значения
вызываемой функции. Если выражение
опущено, то возвращаемое значение
не определено. Выражение может быть
заключено в круглые скобки, хотя их
наличие не обязательно. </p>

<p>Если в какой-либо функции
отсутствует оператор return, то
передача управления в вызывающую
функцию происходит после
выполнения последнего оператора
вызываемой функции. При этом
возвращаемое значение не
определено. Если функция не должна
иметь возвращаемого значения, то ее
нужно объявлять с типом void. </p>

<p>Таким образом, использование
оператора return необходимо либо для
немедленного выхода из функции,
либо для передачи возвращаемого
значения. </p>

<p>Пример: </p>

<pre>
        int sum (int a, int b)
        {   renurn (a+b);    }
</pre>

<p>Функция sum имеет два формальных
параметра a и b типа int, и возвращает
значение типа int, о чем говорит
описатель, стоящий перед именем
функции. Возвращаемое оператором
return значение равно сумме
фактических параметров. </p>

<p>Пример: </p>

<pre>
     void prov (int a, double b)
     {  double c;
        if (a<3) return; else if (b>10) return;
             else { c=a+b;
                    if ((2*c-b)==11) return;
                   }
      }
</pre>

<p>В этом примере оператор return
используется для выхода из функции
в случае выполнения одного из
проверяемых условий. </p>

<h4><a name="1412">1.4.12. Оператор goto</a></h4>

<p>Использование оператора
безусловного перехода goto в
практике программирования на языке
СИ настоятельно не рекомендуется,
так как он затрудняет понимание
программ и возможность их
модификаций. </p>

<p>Формат этого оператора следующий:
</p>

<pre>
       goto имя-метки;
                  ...
       имя-метки: оператор;
</pre>

<p>Оператор goto передает управление
на оператор, помеченный меткой
имя-метки. Помеченный оператор
должен находиться в той же функции,
что и оператор goto, а используемая
метка должна быть уникальной, т.е.
одно имя-метки не может быть
использовано для разных операторов
программы. Имя-метки - это
идентификатор. </p>

<p align="center">Любой оператор в
составном операторе может иметь
свою метку. Используя оператор goto,
можно передавать управление внутрь
составного оператора. Но нужно быть
осторожным при входе в составной
оператор, содержащий объявления
переменных с инициализацией, так
как объявления располагаются перед
выполняемыми операторами и
значения объявленных переменных
при таком переходе будут не
определены. </p>

<hr width="90%">
<div align="center"><center>

<pre>[ <a href="h13.htm">Назад</a> | <a href="dir.htm"> Оглавление </a> | <a
href="h15.htm">Вперед</a> ]</pre>
</center></div>

<p align="center">&nbsp;</p>
</body>
</html>
