<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Программирование на языке СИ</title>
</head>

<body bgcolor="#FFF5EE" text="#000000" link="#FF0000"
vlink="#A52A2A" alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h3><a name="12">1.2. Типы Данных И Их
Объявление</a></h3>

<p>Важное отличие языка СИ от других
языков (PL1, FORTRAN, и др.) является
отсутствие принципа умолчания, что
приводит к необходимости
объявления всех переменных
используемых в программе явно
вместе с указанием соответствующих
им типов. </p>

<p>Объявления переменной имеет
следующий формат: </p>

<pre>
   [спецафикатор-класа-памяти]  спецификатор-типа
   описатель [=инициатор] [,описатель [= инициатор] ]...
</pre>

<p>Описатель - идентификатор простой
переменной либо более сложная
конструкция с квадратными
скобками, круглыми скобками или
звездочкой (набором звездочек). </p>

<p>Спецификатор типа - одно или
несколько ключевых слов,
определяющие тип объявляемой
переменной. В языке СИ имеется
стандартный набор типов данных,
используя который можно
сконструировать новые (уникальные)
типы данных. </p>

<p>Инициатор - задает начальное
значение или список начальных
значений, которые (которое)
присваивается переменной при
объявлении. </p>

<p>Спецификатор класса памяти -
определяется одним из четырех
ключевых слов языка СИ: auto, extern,
register, static, и указывает,каким образом
будет распределяться память под
объявляемую переменную, с одной
стороны, а с другой, область
видимости этой переменной, т.е., из
каких частей программы можно к ней
обратиться. </p>

<h4><a name="121">1.2.1 Категории типов
данных</a></h4>

<p>Ключевые слова для определения
основных типов данных </p>

<pre>
     Целые типы :                 Плавающие типы:
       char                         float
       int                          double
       short                        long  double
       long
       signed
       unsigned
</pre>

<p>Переменная любого типа может быть
объявлена как немодифицируемая.
Это достигается добавлением
ключевого слова const к
спецификатору-типа. Объекты с типом
const представляют собой данные
используемые только для чтения, т.е.
этой переменной не может быть
присвоено новое значение. Отметим,
что если после слова const
отсутствует спецификатор-типа, то
подразумевается спецификатор типа
int. Если ключевое слово const стоит
перед объявлением составных типов
(массив, структура, смесь,
перечисление), то это приводит к
тому, что каждый элемент также
должен являться немодифицируемым,
т.е. значение ему может быть
присвоено только один раз. </p>

<p>Примеры: </p>

<pre>
      const double A=2.128E-2;
      const B=286; (подразумевается const int B=286)
</pre>

<p>Примеры объявления составных
данных будут рассмотрены ниже. </p>

<h4><a name="122">1.2.2. Целый тип данных</a></h4>

<p>Для определения данных целого
типа используются различные
ключевые слова, которые определяют
диапазон значений и размер области
памяти, выделяемой под переменные
(табл. 6). </p>

<p><b>Таблица 6</b> </p>

<table border="1">
    <tr>
        <th>Тип</th>
        <th>Размер памяти в байтах</th>
        <th>Диапазон значений</th>
    </tr>
    <tr>
        <td align="center">char</td>
        <td align="center">1</td>
        <td align="center">от -128 до 127</td>
    </tr>
    <tr>
        <td align="center">int</td>
        <td align="center">Для IBM XT,AT,SX,DX 2</td>
        <td align="center">&nbsp;</td>
    </tr>
    <tr>
        <td align="center">short</td>
        <td align="center">2</td>
        <td align="center">от -32768 до 32767</td>
    </tr>
    <tr>
        <td align="center">long</td>
        <td align="center">4</td>
        <td align="center">от -2 147 483 648 до 2 147 483 647</td>
    </tr>
    <tr>
        <td align="center">unsigned shar</td>
        <td align="center">1</td>
        <td align="center">oт 0 до 255</td>
    </tr>
    <tr>
        <td align="center">unsigned int</td>
        <td align="center">Для IBM XT,AT,SX,DX 2</td>
        <td align="center">&nbsp;</td>
    </tr>
    <tr>
        <td align="center">unsigned short</td>
        <td align="center">2</td>
        <td align="center">от 0 до 65535</td>
    </tr>
    <tr>
        <td align="center">unsigned long</td>
        <td align="center">4</td>
        <td align="center">от 0 до 4 294 967 295</td>
    </tr>
</table>

<p>Отметим, что ключевые слова signed и
unsigned необязательны. Они указывают,
как интерпретируется нулевой бит
объявляемой переменной, т.е., если
указано ключевое слово unsigned, то
нулевой бит интерпретируется как
часть числа, в противном случае
нулевой бит интерпретируется как
знаковый. В случае отсутствия
ключевого слова unsigned целая
переменная считается знаковой. В
том случае, если спецификатор типа
состоит из ключевого типа signed или
unsigned и далее следует идентификатор
переменной, то она будет
рассматриваться как переменная
типа int. Например: </p>

<pre>
     unsigned int n;
     unsigned int b;
     int c;        (подразумевается  signed   int c  );
     unsigned d;   (подразумевается  unsigned int d  );
     signed f;     (подразумевается  signed   int f  ).
</pre>

<p>Отметим, что модификатор-типа char
используется для представления
символа (из массива представление
символов) или для объявления
строковых литералов. Значением
объекта типа char является код
(размером 1 байт), соответствующий
представляемому символу. Для
представления символов русского
алфавита, модификатор типа
идентификатора данных имеет вид
unsigned char, так как коды русских букв
превышают величину 127. </p>

<p>Следует сделать следующее
замечание: в языке СИ не определено
представление в памяти и диапазон
значений для идентификаторов с
модификаторами-типа int и unsigned int.
Размер памяти для переменной с
модификатором типа signed int
определяется длиной машинного
слова, которое имеет различный
размер на разных машинах. Так, на
16-ти разрядных машинах размер слова
равен 2-м байтам, на 32-х разрядных
машинах соответственно 4-м байтам,
т.е. тип int эквивалентен типам short int,
или long int в зависимости от
архитектуры используемой ПЭВМ.
Таким образом, одна и та же
программа может правильно работать
на одном компьютере и неправильно
на другом. Для определения длины
памяти занимаемой переменной можно
использовать операцию sizeof языка СИ,
возвращающую значение длины
указанного модификатора-типа. </p>

<p>Например: </p>

<pre>
     a = sizeof(int);
     b = sizeof(long int);
     c = sizeof(unsigned long);
     d = sizeof(short);
</pre>

<p>Отметим также, что восьмеричные и
шестнадцатеричные константы также
могут иметь модификатор unsigned. Это
достигается указанием префикса u
или U после константы, константа без
этого префикса считается знаковой. </p>

<p>Например: </p>

<pre>
  0xA8C   (int  signed   );
  01786l  (long signed   );
  0xF7u   (int  unsigned );
</pre>

<h4><a name="123">1.2.3. Данные плавающего
типа</a></h4>

<p>Для переменных, представляющих
число с плавающей точкой
используются следующие
модификаторы-типа : float, double, long double
(в некоторых реализациях языка long
double СИ отсутствует). </p>

<p>Величина с модификатором-типа float
занимает 4 байта. Из них 1 байт
отводится для знака, 8 бит для
избыточной экспоненты и 23 бита для
мантиссы. Отметим, что старший бит
мантиссы всегда равен 1, поэтому он
не заполняется, в связи с этим
диапазон значений переменной с
плавающей точкой приблизительно
равен от 3.14E-38 до 3.14E+38. </p>

<p>Величина типа double занимает 8 бит в
памяти. Ее формат аналогичен
формату float. Биты памяти
распределяются следующим образом: 1
бит для знака, 11 бит для экспоненты
и 52 бита для мантиссы. С учетом
опущенного старшего бита мантиссы
диапазон значений равен от 1.7E-308 до
1.7E+308. </p>

<p>Примеры: </p>

<pre>
     float f, a, b;
     double x,y;
</pre>

<h4><a name="124">1.2.4. Указатели</a></h4>

<p>Указатель - это адрес памяти,
распределяемой для размещения
идентификатора (в качестве
идентификатора может выступать имя
переменной, массива, структуры,
строкового литерала). В том случае,
если переменная объявлена как
указатель, то она содержит адрес
памяти, по которому может находится
скалярная величина любого типа. При
объявлении переменной типа
указатель, необходимо определить
тип объекта данных, адрес которых
будет содержать переменная, и имя
указателя с предшествующей
звездочкой (или группой звездочек).
Формат объявления указателя: </p>

<p>спецификатор-типа [ модификатор ] *
описатель . </p>

<p>Спецификатор-типа задает тип
объекта и может быть любого
основного типа, типа структуры,
смеси (об этом будет сказано ниже).
Задавая вместо спецификатора-типа
ключевое слово void, можно
своеобразным образом отсрочить
спецификацию типа, на который
ссылается указатель. Переменная,
объявляемая как указатель на тип
void, может быть использована для
ссылки на объект любого типа.
Однако для того, чтобы можно было
выполнить арифметические и
логические операции над
указателями или над объектами, на
которые они указывают, необходимо
при выполнении каждой операции
явно определить тип объектов. Такие
определения типов может быть
выполнено с помощью операции
приведения типов. </p>

<p>В качестве модификаторов при
объявлении указателя могут
выступать ключевые слова const, near, far,
huge. Ключевое слово const указывает,
что указатель не может быть изменен
в программе. Размер переменной
объявленной как указатель, зависит
от архитектуры компьютера и от
используемой модели памяти, для
которой будет компилироваться
программа. Указатели на различные
типы данных не обязательно должны
иметь одинаковую длину. </p>

<p>Для модификации размера
указателя можно использовать
ключевые слова near, far, huge. </p>

<p>Примеры: </p>

<pre>
   unsigned int * a; /* переменная  а  представляет собой указатель
                     на тип unsigned int (целые числа без знака) */
   double * x;       /* переменная  х  указывает  на  тип  данных с
                     плавающей  точкой  удвоенной  точности      */
   char * fuffer ;   /*  объявляется  указатель с именем fuffer
                      который указывает на  переменную типа char */
   double nomer;
   void *addres;
   addres = &amp; nomer;
   (double *)addres ++;
  /* Переменная addres объявлена как указатель на объект любого типа. Поэтому ей можно присвоить адрес любого объекта (&amp; - операция  вычисления адреса). Однако, как было отмечено выше, ни одна арифмитическая операция не может быть выполнена над указателем,  пока
  не будет явно определен тип данных,  на которые он указывает. Это
  можно сделать,  используя операцию приведения типа (double *) для
  преобразования addres к указателю на тип double, а затем увеличение адреса. */
    const * dr;
  /* Переменная  dr  объявлена как указатель на константное выражение, т.е. значение указателя может изменяться в процессе выполнения программы, а величина, на которую он указывает, нет. */
    unsigned char * const w = &amp;obj.
  /* Переменная w объявлена как константный указатель на данные типа char unsigned.  Это означает, что на протяжение всей программы
  w  будет указывать на одну и ту же область памяти.  Содержание же
  этой области может быть изменено. */
</pre>

<h4><a name="125">1.2.5. Переменные
перечислимого типа</a></h4>

<p>Переменная, которая может
принимать значение из некоторого
списка значений, называется
переменной перечислимого типа или
перечислением. </p>

<p>Объявление перечисления
начинается с ключевого слова enum и
имеет два формата представления. </p>

<p>Формат 1. enum
[имя-тега-перечисления]
{список-перечисления}
описатель[,описатель...]; </p>

<p>Формат 2. enum имя-тега-перечисления
описатель [,описатель..]; </p>

<p>Объявление перечисления задает
тип переменной перечисления и
определяет список именованных
констант, называемый
списком-перечисления. Значением
каждого имени списка является
некоторое целое число. </p>

<p>Переменная типа перечисления
может принимать значения одной из
именованных констант списка.
Именованные константы списка имеют
тип int. Таким образом, память
соответствующая переменной
перечисления, это память
необходимая для размещения
значения типа int. </p>

<p>Переменная типа enum могут
использоваться в индексных
выражениях и как операнды в
арифметических операциях и в
операциях отношения. </p>

<p>В первом формате 1 имена и
значения перечисления задаются в
списке перечислений.
Необязательное
имя-тега-перечисления, это
идентификатор, который именует тег
перечисления, определенный списком
перечисления. Описатель именует
переменную перечисления. В
объявлении может быть задана более
чем одна переменная типа
перечисления. </p>

<p>Список-перечисления содержит
одну или несколько конструкций
вида: </p>

<p>идентификатор [= константное
выражение] </p>

<p>Каждый идентификатор именует
элемент перечисления. Все
идентификаторы в списке enum должны
быть уникальными. В случае
отсутствия константного выражения
первому идентификатору
соответствует значение 0,
следующему идентификатору -
значение 1 и т.д. Имя константы
перечисления эквивалентно ее
значению. </p>

<p>Идентификатор, связанный с
константным выражением, принимает
значение, задаваемое этим
константным выражением.
Константное выражение должно иметь
тип int и может быть как
положительным, так и отрицательным.
Следующему идентификатору в списке
присваивается значение, равное
константному выражению плюс 1, если
этот идентификатор не имеет своего
константного выражения.
Использование элементов
перечисления должно подчиняться
следующим правилам: </p>

<p>1. Переменная может содержать
повторяющиеся значения. </p>

<p>2. Идентификаторы в списке
перечисления должны быть отличны
от всех других идентификаторов в
той же области видимости, включая
имена обычных переменных и
идентификаторы из других списков
перечислений. </p>

<p>3. Имена типов перечислений должны
быть отличны от других имен типов
перечислений, структур и смесей в
этой же области видимости. </p>

<p>4. Значение может следовать за
последним элементом списка
перечисления. </p>

<p>Пример: </p>

<pre>
     enum week { SUB = 0,    /*    0   */
                 VOS = 0,    /*    0   */
                 POND,       /*    1   */
                 VTOR,       /*    2   */
                 SRED,       /*    3   */
                 HETV,       /*    4   */
                 PJAT        /*    5   */
                 }   rab_ned ;
</pre>

<p>В данном примере объявлен
перечислимый тег week, с
соответствующим множеством
значений, и объявлена переменная
rab_ned имеющая тип week. </p>

<p>Во втором формате используется
имя тега перечисления для ссылки на
тип перечисления, определяемый
где-то в другом месте. Имя тега
перечисления должно относится к
уже определенному тегу
перечисления в пределах текущей
области видимости. Так как тег
перечисления объявлен где-то в
другом месте, список перечисления
не представлен в объявлении. </p>

<p>Пример: </p>

<p>enum week rab1; </p>

<p>В объявлении указателя на тип
данных перечисления и объявляемых
typedef для типов перечисления можно
использовать имя тега перечисления
до того, как данный тег
перечисления определен. Однако
определение перечисления должно
предшествовать любому действию
используемого указателя на тип
объявления typedef. Объявление без
последующего списка описателей
описывает тег, или, если так можно
сказать, шаблон перечисления. </p>

<h4><a name="126">1.2.6. Массивы</a></h4>

<p>Массивы - это группа элементов
одинакового типа (double, float, int и т.п.).
Из объявления массива компилятор
должен получить информацию о типе
элементов массива и их количестве.
Объявление массива имеет два
формата: </p>

<p>спецификатор-типа описатель
[константное - выражение]; </p>

<p>спецификатор-типа описатель [ ]; </p>

<p>Описатель - это идентификатор
массива . </p>

<p>Спецификатор-типа задает тип
элементов объявляемого массива.
Элементами массива не могут быть
функции и элементы типа void. </p>

<p>Константное-выражение в
квадратных скобках задает
количество элементов массива.
Константное-выражение при
объявлении массива может быть
опущено в следующих случаях: </p>

<p>- при объявлении массив
инициализируется, </p>

<p>- массив объявлен как формальный
параметр функции, </p>

<p>- массив объявлен как ссылка на
массив, явно определенный в другом
файле. </p>

<p>В языке СИ определены только
одномерные массивы, но поскольку
элементом массива может быть
массив, можно определить и
многомерные массивы. Они
формализуются списком
константных-выражений следующих за
идентификатором массива, причем
каждое константное-выражение
заключается в свои квадратные
скобки. </p>

<p>Каждое константное-выражение в
квадратных скобках определяет
число элементов по данному
измерению массива, так что
объявление двухмерного массива
содержит два
константных-выражения, трехмерного
- три и т.д. Отметим, что в языке СИ
первый элемент массива имеет
индекс равный 0. </p>

<p>Примеры: </p>

<pre>
     int a[2][3]; /* представлено в виде матрицы
                     a[0][0]  a[0][1] a[0][2]
                     a[1][0]  a[1][1] a[1][2]      */
     double b[10]; /* вектор из 10  элементов имеющих тип double */
     int w[3][3] = { { 2, 3, 4 },
                     { 3, 4, 8 },
                     { 1, 0, 9 } };
</pre>

<p>В последнем примере объявлен
массив w[3][3]. Списки, выделенные в
фигурные скобки, соответствуют
строкам массива, в случае
отсутствия скобок инициализация
будет выполнена неправильно. </p>

<p>В языке СИ можно использовать
сечения массива, как и в других
языках высокого уровня (PL1 и т.п.),
однако на использование сечений
накладывается ряд ограничений.
Сечения формируются вследствие
опускания одной или нескольких пар
квадратных скобок. Пары квадратных
скобок можно отбрасывать только
справа налево и строго
последовательно. Сечения массивов
используются при организации
вычислительного процесса в
функциях языка СИ, разрабатываемых
пользователем. </p>

<p>Примеры: </p>

<p>int s[2][3]; </p>

<p>Если при обращении к некоторой
функции написать s[0], то будет
передаваться нулевая строка
массива s. </p>

<p>int b[2][3][4]; </p>

<p>При обращении к массиву b можно
написать, например, b[1][2] и будет
передаваться вектор из четырех
элементов, а обращение b[1] даст
двухмерный массив размером 3 на 4.
Нельзя написать b[2][4], подразумевая,
что передаваться будет вектор,
потому что это не соответствует
ограничению наложенному на
использование сечений массива. </p>

<p>Пример объявления символьного
массива. </p>

<p>char str[] = &quot;объявление символьного
массива&quot;; </p>

<p>Следует учитывать, что в
символьном литерале находится на
один элемент больше, так как
последний из элементов является
управляющей последовательностью
'\0'. </p>

<h4><a name="127">1.2.7. Структуры</a></h4>

<p>Cтруктуры - это составной объект, в
который входят элементы любых
типов, за исключением функций. В
отличие от массива, который
является однородным объектом,
структура может быть неоднородной.
Тип структуры определяется записью
вида: </p>

<p>struct { список определений } </p>

<p>В структуре обязательно должен
быть указан хотя бы один компонент.
Определение структур имеет
следующий вид: </p>

<p>тип-данных описатель; </p>

<p>где тип-данных указывает тип
структуры для объектов,
определяемых в описателях. В
простейшей форме описатели
представляют собой идентификаторы
или массивы. </p>

<p>Пример: </p>

<pre>
            struct { double x,y; } s1, s2, sm[9];
            struct {  int   year;
                      char  moth, day; } date1, date2;
</pre>

<p>Переменные s1, s2 определяются как
структуры, каждая из которых
состоит из двух компонент х и у.
Переменная sm определяется как
массив из девяти структур. Каждая
из двух переменных date1, date2 состоит
из трех компонентов year, moth, day.
&gt;p&gt;Существует и другой способ
ассоциирования имени с типом
структуры, он основан на
использовании тега структуры. Тег
структуры аналогичен тегу
перечислимого типа. Тег структуры
определяется следующим образом: </p>

<p>struct тег { список описаний; }; </p>

<p>где тег является идентификатором.
</p>

<p>В приведенном ниже примере
идентификатор student описывается как
тег структуры: </p>

<pre>
     struct student { char name[25];
                      int  id, age;
                      char  prp;         };
</pre>

<p>Тег структуры используется для
последующего объявления структур
данного вида в форме: </p>

<p>struct тег список-идентификаторов; </p>

<p>Пример: </p>

<p>struct studeut st1,st2; </p>

<p>Использование тегов структуры
необходимо для описания
рекурсивных структур. Ниже
рассматривается использование
рекурсивных тегов структуры. </p>

<pre>
        struct node { int data;
                      struct node * next; }   st1_node;
</pre>

<p>Тег структуры node действительно
является рекурсивным, так как он
используется в своем собственном
описании, т.е. в формализации
указателя next. Структуры не могут
быть прямо рекурсивными, т.е.
структура node не может содержать
компоненту, являющуюся структурой
node, но любая структура может иметь
компоненту, являющуюся указателем
на свой тип, как и сделано в
приведенном примере. </p>

<p>Доступ к компонентам структуры
осуществляется с помощью указания
имени структуры и следующего через
точку имени выделенного
компонента, например: </p>

<pre>
          st1.name=&quot;Иванов&quot;;
          st2.id=st1.id;
          st1_node.data=st1.age;
</pre>

<h4><a name="128">1.2.8. Объединения (смеси)</a></h4>

<p>Объединение подобно структуре,
однако в каждый момент времени
может использоваться (или другими
словами быть ответным) только один
из элементов объединения. Тип
объединения может задаваться в
следующем виде: </p>

<pre>
     union {   описание элемента 1;
               ...
               описание элемента n; };
</pre>

<p>Главной особенностью объединения
является то, что для каждого из
объявленных элементов выделяется
одна и та же область памяти, т.е. они
перекрываются. Хотя доступ к этой
области памяти возможен с
использованием любого из
элементов, элемент для этой цели
должен выбираться так, чтобы
полученный результат не был
бессмысленным. </p>

<p>Доступ к элементам объединения
осуществляется тем же способом, что
и к структурам. Тег объединения
может быть формализован точно так
же, как и тег структуры. </p>

<p>Объединение применяется для
следующих целей: </p>

<p>- инициализации используемого
объекта памяти, если в каждый
момент времени только один объект
из многих является активным; </p>

<p>- интерпретации основного
представления объекта одного типа,
как если бы этому объекту был
присвоен другой тип. </p>

<p>Память, которая соответствует
переменной типа объединения,
определяется величиной,
необходимой для размещения
наиболее длинного элемента
объединения. Когда используется
элемент меньшей длины, то
переменная типа объединения может
содержать неиспользуемую память.
Все элементы объединения хранятся
в одной и той же области памяти,
начиная с одного адреса. </p>

<p>Пример: </p>

<pre>
     union {   char  fio[30];
               char  adres[80];
               int   vozrast;
               int   telefon;   } inform;
     union {   int ax;
               char al[2];      }   ua;
</pre>

<p>При использовании объекта infor
типа union можно обрабатывать только
тот элемент который получил
значение, т.е. после присвоения
значения элементу inform.fio, не имеет
смысла обращаться к другим
элементам. Объединение ua позволяет
получить отдельный доступ к
младшему ua.al[0] и к старшему ua.al[1]
байтам двухбайтного числа ua.ax . </p>

<h4><a name="129">1.2.9. Поля битов</a></h4>

<p>Элементом структуры может быть
битовое поле, обеспечивающее
доступ к отдельным битам памяти.
Вне структур битовые поля
объявлять нельзя. Нельзя также
организовывать массивы битовых
полей и нельзя применять к полям
операцию определения адреса. В
общем случае тип структуры с
битовым полем задается в следующем
виде: </p>

<pre>
     struct { unsigned идентификатор 1 :  длина-поля  1;
              unsigned идентификатор 2 :  длина-поля  2;    }
</pre>

<p>длинна - поля задается целым
выражением или константой. Эта
константа определяет число битов,
отведенное соответствующему полю.
Поле нулевой длинны обозначает
выравнивание на границу следующего
слова. </p>

<p>Пример: </p>

<pre>
      struct { unsigned a1 :  1;
               unsigned a2 :  2;
               unsigned a3 :  5;
               unsigned a4 :  2;  } prim;
</pre>

<p>Структуры битовых полей могут
содержать и знаковые компоненты.
Такие компоненты автоматически
размещаются на соответствующих
границах слов, при этом некоторые
биты слов могут оставаться
неиспользованными. </p>

<p>Ссылки на поле битов выполняются
точно так же, как и компоненты общих
структур. Само же битовое поле
рассматривается как целое число,
максимальное значение которого
определяется длиной поля. </p>

<h4><a name="1210">1.2.10. Переменные с
изменяемой структурой</a></h4>

<p>Очень часто некоторые объекты
программы относятся к одному и тому
же классу, отличаясь лишь
некоторыми деталями. Рассмотрим,
например, представление
геометрических фигур. Общая
информация о фигурах может
включать такие элементы, как
площадь, периметр. Однако
соответствующая информация о
геометрических размерах может
оказаться различной в зависимости
от их формы. </p>

<p>Рассмотрим пример, в котором
информация о геометрических
фигурах представляется на основе
комбинированного использования
структуры и объединения. </p>

<pre>
       struct figure {
                double area,perimetr;  /* общие компоненты       */
                int type;              /* признак компонента     */
                union                  /* перечисление компонент */
                     { double radius;  /* окружность             */
                       double a[2];    /* прямоугольник          */
                       double b[3];    /* треугольник            */
                      } geom_fig;
                      }  fig1, fig2  ;
</pre>

<p>В общем случае каждый объект типа
figure будет состоять из трех
компонентов: area, perimetr, type. Компонент
type называется меткой активного
компонента, так как он используется
для указания, какой из компонентов
объединения geom_fig является активным
в данный момент. Такая структура
называется переменной структурой,
потому что ее компоненты меняются в
зависимости от значения метки
активного компонента (значение type). </p>

<p>Отметим, что вместо компоненты type
типа int, целесообразно было бы
использовать перечисляемый тип.
Например, такой </p>

<pre>
      enum figure_chess { CIRCLE,
                          BOX,
                          TRIANGLE    } ;
</pre>

<p>Константы CIRCLE, BOX, TRIANGLE получат
значения соответственно равные 0, 1,
2. Переменная type может быть
объявлена как имеющая перечислимый
тип : </p>

<p>enum figure_chess type; </p>

<p>В этом случае компилятор СИ
предупредит программиста о
потенциально ошибочных
присвоениях, таких, например, как </p>

<p>figure.type = 40; </p>

<p>В общем случае переменная
структуры будет состоять из трех
частей: набор общих компонент,
метки активного компонента и части
с меняющимися компонентами. Общая
форма переменной структуры, имеет
следующий вид: </p>

<pre>
     struct { общие компоненты;
              метка активного компонента;
                union { описание компоненты 1 ;
                        описание компоненты 2 ;
                        :::
                         описание компоненты n ;
                        } идентификатор-объединения ;
             } идентификатор-структуры ;
</pre>

<p>Пример определения переменной
структуры с именем helth_record </p>

<pre>
     struct { /* общая информация */
               char  name [25];   /* имя       */
               int   age;         /* возраст   */
               char  sex;         /* пол       */
               /*   метка   активного   компонента  */
               /*   (семейное положение)            */
               enum merital_status ins;
               /* переменная часть */
               union  {   /* холост        */
                          /* нет компонент */
                        struct {  /* состоит в браке */
                                 char marripge_date[8];
                                 char spouse_name[25];
                                 int  no_children;
                                }  marriage_info;
                         /* разведен */
                         char date_divorced[8];
                       }   marital_info;
                } health_record;

       enum marital_status { SINGLE, /* холост   */
                            MARRIGO, /* женат    */
                            DIVOREED /* разведен */
                            } ;
</pre>

<p>Обращаться к компонентам
структуры можно при помощи ссылок: </p>

<pre>
  helth_record.neme,
  helth_record.ins,
  helth_record.marriage_info.marriage_date .
</pre>

<h4><a name="1211">1.2.11. Определение
объектов и типов</a></h4>

<p>Как уже говорилось выше, все
переменные используемые в
программах на языке СИ, должны быть
объявлены. Тип объявляемой
переменной зависит от того, какое
ключевое слово используется в
качестве спецификатора типа и
является ли описатель простым
идентификатором или же комбинацией
идентификатора с модификатором
указателя (звездочка), массива
(квадратные скобки) или функции
(круглые скобки). </p>

<p>При объявлении простой
переменной, структуры, смеси или
объединения, а также перечисления,
описатель - это простой
идентификатор. Для объявления
указателя, массива или функции
идентификатор модифицируется
соответствующим образом:
звездочкой слева, квадратными или
круглыми скобками справа. </p>

<p>Отметим важную особенность языка
СИ, при объявлении можно
использовать одновременно более
одного модификатора, что дает
возможность создавать множество
различных сложных описателей
типов. </p>

<p>Однако надо помнить, что
некоторые комбинации
модификаторов недопустимы: </p>

<p>- элементами массивов не могут
быть функции, </p>

<p>- функции не могут возвращать
массивы или функции. </p>

<p>При инициализации сложных
описателей квадратные и круглые
скобки (справа от идентификатора)
имеют приоритет перед звездочкой
(слева от идентификатора).
Квадратные или круглые скобки
имеют один и тот же приоритет и
раскрываются слева направо.
Спецификатор типа рассматривается
на последнем шаге, когда описатель
уже полностью проинтерпретирован.
Можно использовать круглые скобки,
чтобы поменять порядок
интерпретации на необходимый. </p>

<p>Для интерпретации сложных
описаний предлагается простое
правило, которое звучит как
&quot;изнутри наружу&quot;, и состоит из
четырех шагов. </p>

<p>1. Начать с идентификатора и
посмотреть вправо, есть ли
квадратные или круглые скобки. </p>

<p>2. Если они есть, то
проинтерпретировать эту часть
описателя и затем посмотреть
налево в поиске звездочки. </p>

<p>3. Если на любой стадии справа
встретится закрывающая круглая
скобка, то вначале необходимо
применить все эти правила внутри
круглых скобок, а затем продолжить
интерпретацию. </p>

<p>4. Интерпретировать спецификатор
типа. </p>

<p>Примеры: </p>

<pre>
          int    * ( * comp [10]) ();
           6     5   3   1    2    4
</pre>

<p>В данном примере объявляется
переменная comp (1), как массив из
десяти (2) указателей (3) на функции
(4), возвращающие указатели (5) на
целые значения (6). </p>

<pre>
          char  * ( * ( * var ) () ) [10];
            7   6   4   2  1     3     5
</pre>

<p>Переменная var (1) объявлена как
указатель (2) на функцию (3)
возвращающую указатель (4) на массив
(5) из 10 элементов, которые являются
указателями (6) на значения типа char. </p>

<p>Кроме объявлений переменных
различных типов, имеется
возможность объявить типы. Это
можно сделать двумя способами.
Первый способ - указать имя тега при
объявлении структуры, объединения
или перечисления, а затем
использовать это имя в объявлении
переменных и функций в качестве
ссылки на этот тег. Второй -
использовать для объявления типа
ключевое слово typedef. </p>

<p>При объявлении с ключевым словом
typedef, идентификатор стоящий на
месте описываемого объекта,
является именем вводимого в
рассмотрение типа данных, и далее
этот тип может быть использован для
объявления переменных. </p>

<p>Отметим, что любой тип может быть
объявлен с использованием
ключевого слова typedef, включая типы
указателя, функции или массива. Имя
с ключевым словом typedef для типов
указателя, структуры, объединения
может быть объявлено прежде чем эти
типы будут определенны, но в
пределах видимости объявителя. </p>

<p>Примеры: </p>

<pre>
        typedef double (* MATH)( );
          /* MATH - новое имя типа, представляющее указатель на
          функцию, возвращающую значения типа double           */
          MATH cos;
          /* cos  указатель на функцию, возвращающую
          значения типа  double                                 */
          /* Можно провести эквивалентное объявление            */
          double (* cos)( );

       typedef char FIO[40]
           /* FIO - массив из сорока символов                   */
       FIO person;
           /*  Переменная person  -  массив из сорока символов  */
           /*  Это  эквивалентно объявлению                     */
       char person[40];
</pre>

<p>При объявлении переменных и типов
здесь были использованы имена
типов (MATH FIO). Помимо этого, имена
типов могут еще использоваться в
трех случаях: в списке формальных
параметров, в объявлении функций, в
операциях приведения типов и в
операции sizeof (операция приведения
типа). </p>

<p>Именами типов для основных типов,
типов перечисления, структуры и
смеси являются спецификаторы типов
для этих типов. Имена типов для
типов указателя массива и функции
задаются при помощи абстрактных
описателей следующим образом: </p>

<p>спецификатор-типа
абстрактный-описатель; </p>

<p>Абстрактный-описатель - это
описатель без идентификатора,
состоящий из одного или более
модификаторов указателя, массива
или функции. Модификатор указателя
(*) всегда задается перед
идентификатором в описателе, а
модификаторы массива [] и функции () -
после него. Таким образом, чтобы
правильно интерпретировать
абстрактный описатель, нужно
начать интерпретацию с
подразумеваемого идентификатора. </p>

<p>Абстрактные описатели могут быть
сложными. Скобки в сложных
абстрактных описателе задают
порядок интерпретации подобно
тому, как это делалось при
интерпретации сложных описателей в
объявлениях. </p>

<h4><a name="1212">1.2.12. Инициализация
данных</a></h4>

<p>При объявлении переменной ей
можно присвоить начальное
значение, присоединяя инициатор к
описателю. Инициатор начинается со
знака &quot;=&quot; и имеет следующие
формы. </p>

<p>Формат 1: = инициатор; </p>

<p>Формат 2: = { список - инициаторов }; </p>

<p>Формат 1 используется при
инициализации переменных основных
типов и указателей, а формат 2 - при
инициализации составных объектов. </p>

<p>Примеры: </p>

<p>char tol = 'N'; </p>

<p>Переменная tol инициализируется
символом 'N'. </p>

<p>const long megabute = (1024 * 1024); </p>

<p>Немодифицируемая переменная megabute
инициализируется константным
выражением после чего она не может
быть изменена. </p>

<p>static int b[2][2] = {1,2,3,4}; </p>

<p>Инициализируется двухмерный
массив b целых величин элементам
массива присваиваются значения из
списка. Эта же инициализация может
быть выполнена следующим образом : </p>

<p>static int b[2][2] = { { 1,2 }, { 3,4 } }; </p>

<p>При инициализации массива можно
опустить одну или несколько
размерностей </p>

<p>static int b[3[] = { { 1,2 }, { 3,4 } }; </p>

<p>Если при инициализации указано
меньше значений для строк, то
оставшиеся элементы
инициализируются 0, т.е. при
описании </p>

<p>static int b[2][2] = { { 1,2 }, { 3 } }; </p>

<p>элементы первой строки получат
значения 1 и 2, а второй 3 и 0. </p>

<p>При инициализации составных
объектов, нужно внимательно
следить за использованием скобок и
списков инициализаторов. </p>

<p>Примеры: </p>

<pre>
        struct complex { double real;
                         double imag; }  comp [2][3] =
             { { {1,1}, {2,3}, {4,5} },
               { {6,7}, {8,9}, {10,11} } };
</pre>

<p>В данном примере
инициализируется массив структур
comp из двух строк и трех столбцов,
где каждая структура состоит из
двух элементов real и imag. </p>

<pre>
        struct complex comp2 [2][3] =
           { {1,1},{2,3},{4,5}, {6,7},{8,9},{10,11} };
</pre>

<p>В этом примере компилятор
интерпретирует рассматриваемые
фигурные скобки следующим образом: </p>

<p>- первая левая фигурная скобка -
начало составного инициатора для
массива comp2; </p>

<p>- вторая левая фигурная скобка -
начало инициализации первой строки
массива comp2[0]. Значения 1,1
присваиваются двум элементам
первой структуры; </p>

<p>- первая правая скобка (после 1)
указывает компилятору, что список
инициаторов для строки массива
окончен, и элементы оставшихся
структур в строке comp[0]
автоматически инициализируются
нулем; </p>

<p>- аналогично список {2,3}
инициализирует первую структуру в
строке comp[1], а оставшиеся структуры
массива обращаются в нули; </p>

<p>- на следующий список
инициализаторов {4,5} компилятор
будет сообщать о возможной ошибке
так как строка 3 в массиве comp2
отсутствует. </p>

<p>При инициализации объединения
задается значение первого элемента
объединения в соответствии с его
типом. </p>

<p>Пример: </p>

<pre>
      union tab { unsigned char name[10];
                  int tab1;
                 }           pers  =  {'A','H','T','O','H'};
</pre>

<p>Инициализируется переменная
pers.name, и так как это массив, для его
инициализации требуется список
значений в фигурных скобках. Первые
пять элементов массива
инициализируются значениями из
списка, остальные нулями. </p>

<p>Инициализацию массива символов
можно выполнить путем
использования строкового литерала.
</p>

<p>char stroka[ ] = &quot;привет&quot;; </p>

<p>Инициализируется массив символов
из 7 элементов, последним элементом
(седьмым) будет символ '\0', которым
завершаются все строковые
литералы. </p>

<p>В том случае, если задается размер
массива, а строковый литерал
длиннее, чем размер массива, то
лишние символы отбрасываются. </p>

<p>Следующее объявление
инициализирует переменную stroka как
массив, состоящий из семи
элементов. </p>

<p>char stroka[5] = &quot;привет&quot;; </p>

<p>В переменную stroka попадают первые
пять элементов литерала, а символы
'Т' и '\0' отбрасываются. </p>

<p>Если строка короче, чем размер
массива, то оставшиеся элементы
массива заполняются нулями. </p>

<p>Отметим, что инициализация
переменной типа tab может иметь
следующий вид: </p>

<p>union tab pers1 = &quot;Антон&quot;; </p>

<p>и, таким образом, в символьный
массив попадут символы: </p>

<p>'А','Н','Т','О','Н','\0', </p>

<p align="center">а остальные элементы
будут инициализированы нулем. </p>

<hr width="90%">

<p align="center">[ <a href="h11.htm">Назад</a> | <a
href="dir.htm">Оглавление </a>| <a href="h13.htm">Вперед</a>
] </p>

<p align="center">&nbsp;</p>
</body>
</html>
