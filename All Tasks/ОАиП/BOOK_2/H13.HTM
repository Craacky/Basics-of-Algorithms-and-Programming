<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Программирование на языке СИ</title>
</head>

<body bgcolor="#FFF5EE" text="#000000" link="#FF0000"
vlink="#A52A2A" alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h3><a name="13">1.3. Выражения И
Присваивания</a></h3>

<h4><a name="131">1.3.1. Операнды и операции</a></h4>

<p>Комбинация знаков операций и
операндов, результатом которой
является определенное значение,
называется выражением. Знаки
операций определяют действия,
которые должны быть выполнены над
операндами. Каждый операнд в
выражении может быть выражением.
Значение выражения зависит от
расположения знаков операций и
круглых скобок в выражении, а также
от приоритета выполнения операций. </p>

<p>В языке СИ присваивание также
является выражением, и значением
такого выражения является
величина, которая присваивается. </p>

<p>При вычислении выражений тип
каждого операнда может быть
преобразован к другому типу.
Преобразования типов могут быть
неявными, при выполнении операций и
вызовов функций, или явными, при
выполнении операций приведения
типов. </p>

<p>Операнд - это константа, литерал,
идентификатор, вызов функции,
индексное выражение, выражение
выбора элемента или более сложное
выражение, сформированное
комбинацией операндов, знаков
операций и круглых скобок. Любой
операнд, который имеет константное
значение, называется константным
выражением. Каждый операнд имеет
тип. </p>

<p>Если в качестве операнда
используется константа, то ему
соответствует значение и тип
представляющей его константы.
Целая константа может быть типа int,
long, unsigned int, unsigned long, в зависимости от
ее значения и от формы записи.
Символьная константа имеет тип int.
Константа с плавающей точкой
всегда имеет тип double. </p>

<p>Строковый литерал состоит из
последовательности символов,
заключенных в кавычки, и
представляется в памяти как массив
элементов типа char,
инициализируемый указанной
последовательностью символов.
Значением строкового литерала
является адрес первого элемента
строки и синтаксически строковый
литерал является немодифицируемым
указателем на тип char. Строковые
литералы могут быть использованы в
качестве операндов в выражениях,
допускающих величины типа
указателей. Однако так как строки
не являются переменными, их нельзя
использовать в левой части
операции присваивания. </p>

<p>Следует помнить, что последним
символом строки всегда является
нулевой символ, который
автоматически добавляется при
хранении строки в памяти. </p>

<p>Идентификаторы переменных и
функций. Каждый идентификатор
имеет тип, который устанавливается
при его объявлении. Значение
идентификатора зависит от типа
следующим образом: </p>

<p>- идентификаторы объектов целых и
плавающих типов представляют
значения соответствующего типа; </p>

<p>- идентификатор объекта типа enum
представлен значением одной
константы из множества значений
констант в перечислении. Значением
идентификатора является
константное значение. Тип значения
есть int, что следует из определения
перечисления; </p>

<p>- идентификатор объекта типа struct
или union представляет значение,
определенное структурой или
объединением; </p>

<p>- идентификатор, объявляемый как
указатель, представляет указатель
на значение, заданное в объявлении
типа; </p>

<p>- идентификатор, объявляемый как
массив, представляет указатель,
значение которого является адресом
первого элемента массива. Тип
адресуемых указателем величин - это
тип элементов массива. Отметим, что
адрес массива не может быть изменен
во время выполнения программы, хотя
значение отдельных элементов может
изменяться. Значение указателя,
представляемое идентификатором
массива, не является переменной и
поэтому идентификатор массива не
может появляться в левой части
оператора присваивания. </p>

<p>- идентификатор, объявляемый как
функция, представляет указатель,
значение которого является адресом
функции, возвращающей значения
определенного типа. Адрес функции
не изменяется во время выполнения
программы, меняется только
возвращаемое значение. Таким
образом, идентификаторы функций не
могут появляться в левой части
операции присваивания. </p>

<p>Вызов функций состоит из
выражения, за которым следует
необязательный список выражений в
круглых скобках: </p>

<p>выражение-1 ([ список выражений ]) </p>

<p>Значением выражения-1 должен быть
адрес функции (например,
идентификатор функции). Значения
каждого выражения из списка
выражений передается в функцию в
качестве фактического аргумента.
Операнд, являющийся вызовом
функции, имеет тип и значение
возвращаемого функцией значения. </p>

<p>Индексное выражение задает
элемент массива и имеет вид: </p>

<p>выражение-1 [ выражение-2 ] </p>

<p>Тип индексного выражения
является типом элементов массива, а
значение представляет величину,
адрес которой вычисляется с
помощью значений выражение-1 и
выражение-2. </p>

<p>Обычно выражение-1 - это указатель,
например, идентификатор массива, а
выражение-2 - это целая величина.
Однако требуется только, чтобы одно
из выражений было указателем, а
второе целочисленной величиной.
Поэтому выражение-1 может быть
целочисленной величиной, а
выражение-2 указателем. В любом
случае выражение-2 должно быть
заключено в квадратные скобки. Хотя
индексное выражение обычно
используется для ссылок на
элементы массива, тем не менее
индекс может появляться с любым
указателем. </p>

<p>Индексные выражения для ссылки на
элементы одномерного массива
вычисляются путем сложения целой
величины со значениями указателя с
последующим применением к
результату операции разадресации
(*). </p>

<p>Так как одно из выражений,
указанных в индексном выражении,
является указателем, то при
сложении используются правила
адресной арифметики, согласно
которым целая величина
преобразуется к адресному
представлению, путем умножения ее
на размер типа, адресуемого
указателем. Пусть, например,
идентификатор arr объявлен как
массив элементов типа double. </p>

<p>double arr[10]; </p>

<p>Таким образом, чтобы получить
доступ к i-тому элементу массива arr
можно написать аrr[i], что, в силу
сказанного выше, эквивалентно i[a].
При этом величина i умножается на
размер типа double и представляет
собой адрес i-го элемента массива arr
от его начала. Затем это значение
складывается со значением
указателя arr, что в свою очередь
дает адрес i-го элемента массива. К
полученному адресу применяется
операция разадресации, т.е.
осуществляется выборка элемента
массива arr по сформированному
адресу. </p>

<p>Таким образом, результатом
индексного выражения arr[i] (или i[arr])
является значение i-го элемента
массива. </p>

<p>Выражение с несколькими
индексами ссылается на элементы
многомерных массивов. Многомерный
массив - это массив, элементами
которого являются массивы.
Например, первым элементом
трехмерного массива является
массив с двумя измерениями. </p>

<p>Для ссылки на элемент
многомерного массива индексное
выражение должно иметь несколько
индексов заключенных к квадратные
скобки: </p>

<p>выражение-1 [ выражение-2 ][
выражение-3 ] ... </p>

<p>Такое индексное выражение
интерпретируется слева направо,
т.е. вначале рассматривается первое
индексное выражение: </p>

<p>выражение-1 [ выражение-2 ] </p>

<p>Результат этого выражения есть
адресное выражение, с которым
складывается выражение-3 и т.д.
Операция разадресации
осуществляется после вычисления
последнего индексного выражения.
Отметим, что операция разадресации
не применяется, если значение
последнего указателя адресует
величину типа массива. </p>

<p>Пример: </p>

<p>int mass [2][5][3]; </p>

<p>Рассмотрим процесс вычисления
индексного выражения mass[1][2][2]. </p>

<p>1. Вычисляется выражения mass[1].
Ссылка индекс 1 умножается на
размер элемента этого массива,
элементом же этого массива
является двухмерный массив
содержащий 5х3 элементов, имеющих
тип int. Получаемое значение
складывается со значением
указателя mass. Результат является
указатель на второй двухмерный
массив размером (5х3) в трехмерном
массиве mass. </p>

<p>2. Второй индекс 2 указывает на
размер массива из трех элементов
типа int, и складывается с адресом,
соответствующим mass [1]. </p>

<p>3. Так как каждый элемент
трехмерного массива - это величина
типа int, то индекс 2 увеличивается на
размер типа int перед сложением с
адресом mass [1][2]. </p>

<p>4. Наконец, выполняется
разадресация полученного
указателя. Результирующим
выражением будет элемент типа int. </p>

<p>Если было бы указано mass [1][2], то
результатом был бы указатель на
массив из трех элементов типа int.
Соответственно значением
индексного выражения mass [1] является
указатель на двухмерный массив. </p>

<p>Выражение выбора элемента
применяется, если в качестве
операнда надо использовать элемент
структуры или объединения. Такое
выражение имеет значение и тип
выбранного элемента. Рассмотрим
две формы выражения выбора
элемента: </p>

<p>выражение.идентификатор , </p>

<p>выражение-&gt;идентификатор . </p>

<p>В первой форме выражение
представляет величину типа struct или
union, а идентификатор - это имя
элемента структуры или
объединения. Во второй форме
выражение должно иметь значение
адреса структуры или объединения, а
идентификатор - именем выбираемого
элемента структуры или
объединения. </p>

<p>Обе формы выражения выбора
элемента дают одинаковый
результат. Действительно, запись,
включающая знак операции выбора
(-&gt;), является сокращенной версией
записи с точкой для случая, когда
выражению стоящему перед точкой
предшествует операция
разадресации (*), примененная к
указателю, т.е. запись </p>

<p>выражение -&gt; идентификатор </p>

<p>эквивалентна записи </p>

<p>(* выражение) . идентификатор </p>

<p>в случае, если выражение является
указателем. </p>

<p>Пример: </p>

<pre>
      struct tree { float          num;
                    int            spisoc[5];
                    struct tree   *left;      }  tr[5] , elem ;
             elem.left = &amp; elem;
</pre>

<p>В приведенном примере
используется операция выбора (.) для
доступа к элементу left структурной
переменной elem. Таким образом
элементу left структурной переменной
elem присваивается адрес самой
переменной elem, т.е. переменная elem
хранит ссылку на себя саму. </p>

<p>Приведение типов это изменение
(преобразование) типа объекта. Для
выполнения преобразования
необходимо перед объектом записать
в скобках нужный тип: </p>

<p>( имя-типа ) операнд. </p>

<p>Приведение типов используются
для преобразования объектов одного
скалярного типа в другой скалярный
тип. Однако выражению с приведением
типа не может быть присвоено другое
значение. </p>

<p>Пример: </p>

<pre>
      int i;
      bouble x;
      b = (double)i+2.0;
</pre>

<p>В этом примере целая переменная i
с помощью операции приведения
типов приводится к плавающему типу,
а затем уже участвует в вычислении
выражения. </p>

<p>Константное выражение - это
выражение, результатом которого
является константа. Операндом
константного выражения могут быть
целые константы, символьные
константы, константы с плавающей
точкой, константы перечисления,
выражения приведения типов,
выражения с операцией sizeof и другие
константные выражения. Однако на
использование знаков операций в
константных выражениях налагаются
следующие ограничения: </p>

<p>1. В константных выражениях нельзя
использовать операции
присваивания и последовательного
вычисления (,) . </p>

<p>2. Операция &quot;адрес&quot; (&amp;) может
быть использована только при
некоторых инициализациях. </p>

<p>Выражения со знаками операций
могут участвовать в выражениях как
операнды. Выражения со знаками
операций могут быть унарными (с
одним операндом), бинарными (с двумя
операндами) и тернарными (с тремя
операндами). </p>

<p>Унарное выражение состоит из
операнда и предшествующего ему
знаку унарной операции и имеет
следующий формат: </p>

<p>знак-унарной-операции операнд . </p>

<p>Бинарное выражения состоит из
двух операндов, разделенных знаком
бинарной операции: </p>

<p>операнд1 знак-бинарной-операции
операнд2 . </p>

<p>Тернарное выражение состоит из
трех операндов, разделенных
знаками тернарной операции (?) и (:), и
имеет формат: </p>

<p>операнд1 ? операнд2 : операнд3 . </p>

<p>Операции. По количеству
операндов, участвующих в операции,
операции подразделяются на
унарные, бинарные и тернарные. </p>

<p>В языке Си имеются следующие
унарные операции: </p>

<p>- арифметическое отрицание
(отрицание и дополнение); </p>

<p>~ побитовое логическое отрицание
(дополнение); </p>

<p>! логическое отрицание; </p>

<p>* разадресация (косвенная
адресация); </p>

<p>&amp; вычисление адреса; </p>

<p>+ унарный плюс; </p>

<p>++ увеличение (инкремент); </p>

<p>-- уменьшение (декремент); </p>

<p>sizeof размер . </p>

<p>Унарные операции выполняются
справа налево. </p>

<p>Операции увеличения и уменьшения
увеличивают или уменьшают значение
операнда на единицу и могут быть
записаны как справа так и слева от
операнда. Если знак операции
записан перед операндом
(префиксная форма), то изменение
операнда происходит до его
использования в выражении. Если
знак операции записан после
операнда (постфиксная форма), то
операнд вначале используется в
выражении, а затем происходит его
изменение. </p>

<p>В отличие от унарных, бинарные
операции, список которых приведен в
табл.7, выполняются слева направо. </p>

<p><b>Таблица 7</b></p>

<table border="1" width="60%">
    <tr>
        <th>Знак операции</th>
        <th>Операция</th>
        <th>Группа операций</th>
    </tr>
    <tr>
        <td align="center">*</td>
        <td align="center">Умножение</td>
        <td align="center" rowspan="3">Мультипликативные</td>
    </tr>
    <tr>
        <td align="center">/</td>
        <td align="center">Деление</td>
    </tr>
    <tr>
        <td align="center">%</td>
        <td align="center">Остаток от деления</td>
    </tr>
    <tr>
        <td align="center">+</td>
        <td align="center">Сложение</td>
        <td align="center" rowspan="2">Аддитивные</td>
    </tr>
    <tr>
        <td align="center">-</td>
        <td align="center">Вычитание</td>
    </tr>
    <tr>
        <td align="center">&lt;&lt;</td>
        <td align="center">Сдвиг влево</td>
        <td align="center" rowspan="2">Операции
        сдвига</td>
    </tr>
    <tr>
        <td align="center">&gt;&gt;</td>
        <td align="center">Сдвиг вправо</td>
    </tr>
    <tr>
        <td align="center">&lt;</td>
        <td align="center">Меньше</td>
        <td align="center" rowspan="5">Операции
        отношения</td>
    </tr>
    <tr>
        <td align="center">&lt;=</td>
        <td align="center">Меньше или равно</td>
    </tr>
    <tr>
        <td align="center">&gt;=</td>
        <td align="center">Больше или равно</td>
    </tr>
    <tr>
        <td align="center">==</td>
        <td align="center">Равно</td>
    </tr>
    <tr>
        <td align="center">!=</td>
        <td align="center">Не равно</td>
    </tr>
    <tr>
        <td align="center">&amp;</td>
        <td align="center">Поразрядное И</td>
        <td align="center" rowspan="3">Поразрядные
        операции</td>
    </tr>
    <tr>
        <td align="center">|</td>
        <td align="center">Поразрядное ИЛИ</td>
    </tr>
    <tr>
        <td align="center">^</td>
        <td align="center">Поразрядное
        исключающее ИЛИ</td>
    </tr>
    <tr>
        <td align="center">&amp;&amp;</td>
        <td align="center">Логическое И</td>
        <td align="center" rowspan="2">Логические
        операции</td>
    </tr>
    <tr>
        <td align="center">||</td>
        <td align="center">Логическое ИЛИ</td>
    </tr>
    <tr>
        <td align="center">,</td>
        <td align="center">Последовательное
        вычисление</td>
        <td align="center">Последовательного
        вычисления</td>
    </tr>
    <tr>
        <td align="center">=</td>
        <td align="center">Присваивание</td>
        <td align="center" rowspan="11">Операции
        присваивания</td>
    </tr>
    <tr>
        <td align="center">*=</td>
        <td align="center">Умножение с
        присваиванием</td>
    </tr>
    <tr>
        <td align="center">/=</td>
        <td align="center">Деление с
        присваиванием</td>
    </tr>
    <tr>
        <td align="center">%=</td>
        <td align="center">Остаток от деления с
        присваиванием</td>
    </tr>
    <tr>
        <td align="center">-=</td>
        <td align="center">Вычитание с
        присваиванием</td>
    </tr>
    <tr>
        <td align="center">+=</td>
        <td align="center">Сложение с
        присваиванием</td>
    </tr>
    <tr>
        <td align="center">&lt;&lt;=</td>
        <td align="center">Сдвиг влево с
        присваиванием</td>
    </tr>
    <tr>
        <td align="center">&gt;&gt;=</td>
        <td align="center">Сдвиг вправо
        присваиванием</td>
    </tr>
    <tr>
        <td align="center">&amp;=</td>
        <td align="center">Поразрядное И с
        присваиванием</td>
    </tr>
    <tr>
        <td align="center">|=</td>
        <td align="center">Поразрядное ИЛИ с
        присваиванием</td>
    </tr>
    <tr>
        <td align="center">^=</td>
        <td align="center">Поразрядное
        исключающее ИЛИ с
        присваиванием</td>
    </tr>
</table>

<p>Левый операнд операции
присваивания должен быть
выражением, ссылающимся на область
памяти (но не объектом объявленным
с ключевым словом const), такие
выражения называются
леводопустимыми к ним относятся: </p>

<p>- идентификаторы данных целого и
плавающего типов, типов указателя,
структуры, объединения; </p>

<p>- индексные выражения, исключая
выражения имеющие тип массива или
функции; </p>

<p>- выражения выбора элемента (-&gt;) и
(.), если выбранный элемент является
леводопустимым; </p>

<p>- выражения унарной операции
разадресации (*), за исключением
выражений, ссылающихся на массив
или функцию; </p>

<p>- выражение приведения типа если
результирующий тип не превышает
размера первоначального типа. </p>

<p>При записи выражений следует
помнить, что символы (*), (&amp;), (!), (+)
могут\ обозначать унарную или
бинарную операцию. </p>

<h4><a name="132">1.3.2. Преобразования при
вычислении выражений</a></h4>

<p>При выполнении операций
производится автоматическое
преобразование типов, чтобы
привести операнды выражений к
общему типу или чтобы расширить
короткие величины до размера целых
величин, используемых в машинных
командах. Выполнение
преобразования зависит от
специфики операций и от типа
операнда или операндов. </p>

<p>Рассмотрим общие арифметические
преобразования. </p>

<p>1. Операнды типа float преобразуются
к типу double. </p>

<p>2. Если один операнд long double, то
второй преобразуется к этому же
типу. </p>

<p>3. Если один операнд double, то второй
также преобразуется к типу double. </p>

<p>4. Любые операнды типа char и short
преобразуются к типу int. </p>

<p>5. Любые операнды unsigned char или unsigned
short преобразуются к типу unsigned int. </p>

<p>6. Если один операнд типа unsigned long,
то второй преобразуется к типу unsigned
long. </p>

<p>7. Если один операнд типа long, то
второй преобразуется к типу long. </p>

<p>8. Если один операнд типа unsigned int,
то второй операнд преобразуется к
этому же типу. </p>

<p>Таким образом, можно отметить, что
при вычислении выражений операнды
преобразуются к типу того операнда,
который имеет наибольший размер. </p>

<p>Пример: </p>

<pre>
        double         ft,sd;
        unsigned char  ch;
        unsigned long  in;
        int            i;
        ....
           sd=ft*(i+ch/in);
</pre>

<p>При выполнении оператора
присваивания правила
преобразования будут
использоваться следующим образом.
Операнд ch преобразуется к unsigned int
(правило 5). Затем он преобразуется к
типу unsigned long (правило 6). По этому же
правилу i преобразуется к unsigned long и
результат операции, заключенной в
круглые скобки будет иметь тип unsigned
long. Затем он преобразуется к типу
double (правило 3) и результат всего
выражения будет иметь тип double. </p>

<h4><a name="133">1.3.3. Операции отрицания и
дополнения</a></h4>

<p>Операция арифметического
отрицания (-) вырабатывает
отрицание своего операнда. Операнд
должен быть целой или плавающей
величиной. При выполнении
осуществляются обычные
арифметические преобразования. </p>

<p>Пример: </p>

<pre>
       double  u = 5;
       u = -u;          /* переменной u присваивается ее отрицание,
                            т.е. u  принимает значение -5     */
</pre>

<p>Операция логического отрицания
&quot;НЕ&quot; (!) вырабатывает значение 0,
если операнд есть истина (не нуль), и
значение 1, если операнд равен нулю
(0). Результат имеет тип int. Операнд
должен быть целого или плавающего
типа или типа указатель. </p>

<p>Пример: </p>

<pre>
       int t, z=0;
       t=!z;
</pre>

<p>Переменная t получит значение
равное 1, так как переменная z имела
значение равное 0 (ложно). </p>

<p>Операция двоичного дополнения (~)
вырабатывает двоичное дополнение
своего операнда. Операнд должен
быть целого типа. Осуществляется
обычное арифметическое
преобразование, результат имеет
тип операнда после преобразования. </p>

<p>Пример: </p>

<pre>
       char            b = '9';
       unsigned char   f;
        b = ~f;
</pre>

<p>Шестнадцатеричное значение
символа '9' равно 39. В результате
операции ~f будет получено
шестнадцатеричное значение С6, что
соответствует символу 'ц'. </p>

<h4><a name="134">1.3.4. Операции
разадресации и адреса</a></h4>

<p>Эти операции используются для
работы с переменными типа
указатель. </p>

<p>Операция разадресации (*)
осуществляет косвенный доступ к
адресуемой величине через
указатель. Операнд должен быть
указателем. Результатом операции
является величина, на которую
указывает операнд. Типом
результата является тип величины,
адресуемой указателем. Результат
не определен, если указатель
содержит недопустимый адрес. </p>

<p>Рассмотрим типичные ситуации,
когда указатель содержит
недопустимый адрес: </p>

<p>- указатель является нулевым; </p>

<p>- указатель определяет адрес
такого объекта, который не является
активным в момент ссылки; </p>

<p>- указатель определяет адрес,
который не выровнен до типа
объекта, на который он указывает; </p>

<p>- указатель определяет адрес, не
используемый выполняющейся
программой. </p>

<p>Операция адрес (&amp;) дает адрес
своего операнда. Операндом может
быть любое именуемое выражение. Имя
функции или массива также может
быть операндом операции
&quot;адрес&quot;, хотя в этом случае
знак операции является лишним, так
как имена массивов и функций
являются адресами. Результатом
операции адрес является указатель
на операнд. Тип, адресуемый
указателем, является типом
операнда. </p>

<p>Операция адрес не может
применятся к элементам структуры,
являющимися полями битов, и к
объектам с классом памяти register. </p>

<p>Примеры: </p>

<pre>
      int t, f=0,  * adress;
      adress = &amp;t /* переменной adress, объявляемой как
                     указатель, присваивается адрес переменной t */
     * adress =f; /* переменной находящейся по адресу, содержащемуся
                     в переменной adress, присваивается значение
                     переменной f,  т.е.  0 , что эквивалентно
                     t=f;      т.е.   t=0;                       */
</pre>

<h4><a name="135">1.3.5. Операция sizeof</a></h4>

<p>С помощью операции sizeof можно
определить размер памяти которая
соответствует идентификатору или
типу. Операция sizeof имеет следующий
формат: </p>

<p>sizeof(выражение) . </p>

<p>В качестве выражения может быть
использован любой идентификатор,
либо имя типа, заключенное в скобки.
Отметим, что не может быть
использовано имя типа void, а
идентификатор не может относится к
полю битов или быть именем функции. </p>

<p>Если в качестве выражения
указанно имя массива, то
результатом является размер всего
массива (т.е. произведение числа
элементов на длину типа), а не
размер указателя, соответствующего
идентификатору массива. </p>

<p>Когда sizeof применяются к имени
типа структуры или объединения или
к идентификатору имеющему тип
структуры или объединения, то
результатом является фактический
размер структуры или объединения,
который может включать участки
памяти, используемые для
выравнивания элементов структуры
или объединения. Таким образом,
этот результат может не
соответствовать размеру,
получаемому путем сложения
размеров элементов структуры. </p>

<p>Пример: </p>

<pre>
      struct     { char   h;
                   int    b;
                   double f;
                 } str;
      int a1;
      a1  = sizeof(str);
</pre>

<p>Переменная а1 получит значение,
равное 12, в то же время если сложить
длины всех используемых в
структуре типов, то получим, что
длина структуры str равна 7. </p>

<p>Несоответствие имеет место в виду
того, что после размещения в памяти
первой переменной h длинной 1 байт,
добавляется 1 байт для выравнивания
адреса переменной b на границу
слова (слово имеет длину 2 байта для
машин серии IBM PC AT /286/287), далее
осуществляется выравнивание
адреса переменной f на границу
двойного слова (4 байта), таким
образом в результате операций
выравнивания для размещения
структуры в оперативной памяти
требуется на 5 байт больше. </p>

<p>В связи с этим целесообразно
рекомендовать при объявлении
структур и объединения располагать
их элементы в порядке убывания
длины типов, т.е. приведенную выше
структуру следует записать в
следующем виде: </p>

<pre>
     struct  { double f;
               int    b;
               char   h;
              } str;
</pre>

<h4><a name="136">1.3.6. Мультипликативные
операции</a></h4>

<p>К этому классу операций относятся
операции умножения (*), деления (/) и
получение остатка от деления (%).
Операндами операции (%) должны быть
целые числа. Отметим, что типы
операндов операций умножения и
деления могут отличаться, и для них
справедливы правила
преобразования типов. Типом
результата является тип операндов
после преобразования. </p>

<p>Операция умножения (*) выполняет
умножение операндов. </p>

<pre>
     int  i=5;
     float f=0.2;
     double g,z;
         g=f*i;
</pre>

<p>Тип произведения i и f
преобразуется к типу double, затем
результат присваивается
переменной g. </p>

<p>Операция деления (/) выполняет
деление первого операнда на второй.
Если две целые величины не делятся
нацело, то результат округляется в
сторону нуля. </p>

<p>При попытке деления на ноль
выдается сообщение во время
выполнения. </p>

<pre>
     int i=49, j=10,  n, m;
     n = i/j;                 /* результат   4   */
     m = i/(-j);              /* результат  -4   */
</pre>

<p>Операция остаток от деления (%)
дает остаток от деления первого
операнда на второй. </p>

<p>Знак результата зависит от
конкретной реализации. В данной
реализации знак результата
совпадает со знаком делимого. Если
второй операнд равен нулю, то
выдается сообщение. </p>

<pre>
     int n = 49, m = 10, i, j, k, l;
     i = n % m;             /*    9    */
     j = n % (-m);          /*    9    */
     k = (-n) % m;          /*    -9   */
     l = (-n) % (-m);       /*    -9   */
</pre>

<h4><a name="137">1.3.7. Аддитивные операции</a></h4>

<p>К аддитивным операциям относятся
сложение (+) и вычитание (-). Операнды
могут быть целого или плавающего
типов. В некоторых случаях над
операндами аддитивных операций
выполняются общие арифметические
преобразования. Однако
преобразования, выполняемые при
аддитивных операциях, не
обеспечивают обработку ситуаций
переполнения и потери значимости.
Информация теряется, если
результат аддитивной операции не
может быть представлен типом
операндов после преобразования.
При этом сообщение об ошибке не
выдается. </p>

<p>Пример: </p>

<pre>
     int   i=30000, j=30000, k;
            k=i+j;
</pre>

<p>В результате сложения k получит
значение равное -5536. </p>

<p>Результатом выполнения операции
сложения является сумма двух
операндов. Операнды могут быть
целого или плавающего типа или один
операнд может быть указателем, а
второй - целой величиной. </p>

<p>Когда целая величина
складывается с указателем, то целая
величина преобразуется путем
умножения ее на размер памяти,
занимаемой величиной, адресуемой
указателем. </p>

<p>Когда преобразованная целая
величина складывается с величиной
указателя, то результатом является
указатель, адресующий ячейку
памяти, расположенную на целую
величину дальше от исходного
адреса. Новое значение указателя
адресует тот же самый тип данных,
что и исходный указатель. </p>

<p>Операция вычитания (-) вычитает
второй операнд из первого. Возможна
следующая комбинация операндов: </p>

<p>1. Оба операнда целого или
плавающего типа. </p>

<p>2. Оба операнда являются
указателями на один и тот же тип. </p>

<p>3. Первый операнд является
указателем, а второй - целым. </p>

<p>Отметим, что операции сложения и
вычитания над адресами в единицах,
отличных от длины типа, могут
привести к непредсказуемым
результатам. </p>

<p>Пример: </p>

<pre>
     double d[10],* u;
     int i;
     u = d+2;  /*  u  указывает на третий элемент массива */
     i = u-d;  /*  i  принимает значение равное 2         */
</pre>

<h4><a name="138">1.3.8. Операции сдвига</a></h4>

<p>Операции сдвига осуществляют
смещение операнда влево (<<) или вправо (>&gt;) на
число битов, задаваемое вторым
операндом. Оба операнда должны быть
целыми величинами. Выполняются
обычные арифметические
преобразования. При сдвиге влево
правые освобождающиеся биты
устанавливаются в нуль. При сдвиге
вправо метод заполнения
освобождающихся левых битов
зависит от типа первого операнда.
Если тип unsigned, то свободные левые
биты устанавливаются в нуль. В
противном случае они заполняются
копией знакового бита. Результат
операции сдвига не определен, если
второй операнд отрицательный. </p>

<p>Преобразования, выполненные
операциями сдвига, не обеспечивают
обработку ситуаций переполнения и
потери значимости. Информация
теряется, если результат операции
сдвига не может быть представлен
типом первого операнда, после
преобразования. </p>

<p>Отметим, что сдвиг влево
соответствует умножению первого
операнда на степень числа 2, равную
второму операнду, а сдвиг вправо
соответствует делению первого
операнда на 2 в степени, равной
второму операнду. </p>

<p>Примеры: </p>

<pre>
      int  i=0x1234, j,  k ;
      k = i<<4 ; /* k="0x0234" */ j="i&lt;&lt;8" ; /* j="0x3400" */ i="j">&gt;8 ;         /*    i = 0x0034   */
</pre>

<h4><a name="139">1.3.9. Поразрядные операции</a></h4>

<p>К поразрядным операциям
относятся: операция поразрядного
логического &quot;И&quot; (&amp;), операция
поразрядного логического
&quot;ИЛИ&quot; (|), операция поразрядного
&quot;исключающего ИЛИ&quot; (^). </p>

<p>Операнды поразрядных операций
могут быть любого целого типа. При
необходимости над операндами
выполняются преобразования по
умолчанию, тип результата - это тип
операндов после преобразования. </p>

<p>Операция поразрядного
логического И (&amp;) сравнивает
каждый бит первого операнда с
соответствующим битом второго
операнда. Если оба сравниваемых
бита единицы, то соответствующий
бит результата устанавливается в 1,
в противном случае в 0. </p>

<p>Операция поразрядного
логического ИЛИ (|) сравнивает
каждый бит первого операнда с
соответствующим битом второго
операнда. Если любой (или оба) из
сравниваемых битов равен 1, то
соответствующий бит результата
устанавливается в 1, в противном
случае результирующий бит равен 0. </p>

<p>Операция поразрядного
исключающего ИЛИ (^) сравнивает
каждый бит первого операнда с
соответствующими битами второго
операнда. Если один из сравниваемых
битов равен 0, а второй бит равен 1,
то соответствующий бит результата
устанавливается в 1, в противном
случае, т.е. когда оба бита равны 1
или 0, бит результата
устанавливается в 0. </p>

<p>Пример. </p>

<pre>
     int  i=0x45FF,     /*      i= 0100 0101 1111 1111   */
          j=0x00FF;             j= 0000 0000 1111 1111   */
     char r;
       r = i^j;      /* r=0x4500 = 0100 0101 0000 0000   */
       r = i|j;      /* r=0x45FF = 0100 0101 0000 0000   */
       r = i&amp;j      /* r=0x00FF = 0000 0000 1111 1111    */
</pre>

<h4><a name="1310">1.3.10. Логические операции</a></h4>

<p>К логическим операциям относятся
операция логического И (&amp;&amp;) и
операция логического ИЛИ (||).
Операнды логических операций могут
быть целого типа, плавающего типа
или типа указателя, при этом в
каждой операции могут участвовать
операнды различных типов. </p>

<p>Операнды логических выражений
вычисляются слева направо. Если
значения первого операнда
достаточно, чтобы определить
результат операции, то второй
операнд не вычисляется. </p>

<p>Логические операции не вызывают
стандартных арифметических
преобразований. Они оценивают
каждый операнд с точки зрения его
эквивалентности нулю. Результатом
логической операции является 0 или
1, тип результата int. </p>

<p>Операция логического И (&amp;&amp;)
вырабатывает значение 1, если оба
операнда имеют нулевые значения.
Если один из операндов равен 0, то
результат также равен 0. Если
значение первого операнда равно 0,
то второй операнд не вычисляется. </p>

<p>Операция логического ИЛИ (||)
выполняет над операндами операцию
включающего ИЛИ. Она вырабатывает
значение 0, если оба операнда имеют
значение 0, если какой-либо из
операндов имеет ненулевое
значение, то результат операции
равен 1. Если первый операнд имеет
ненулевое значение, то второй
операнд не вычисляется. </p>

<h4><a name="1311">1.3.11. Операция
последовательного вычисления</a></h4>

<p>Операция последовательного
вычисления обозначается запятой (,)
и используется для вычисления двух
и более выражений там, где по
синтаксису допустимо только одно
выражение. Эта операция вычисляет
два операнда слева направо. При
выполнении операции
последовательного вычисления,
преобразование типов не
производится. Операнды могут быть
любых типов. Результат операции
имеет значения и тип второго
операнда. Отметим, что запятая
может использоваться также как
символ разделитель, поэтому
необходимо по контексту различать,
запятую, используемую в качестве
разделителя или знака операции. </p>

<h4><a name="1312">1.3.12. Условная операция</a></h4>

<p>В языке СИ имеется одна тернарная
операция - условная операция,
которая имеет следующий формат: </p>

<p>операнд-1 ? операнд-2 : операнд-3 </p>

<p>Операнд-1 должен быть целого или
плавающего типа или быть
указателем. Он оценивается с точки
зрения его эквивалентности 0. Если
операнд-1 не равен 0, то вычисляется
операнд-2 и его значение является
результатом операции. Если
операнд-1 равен 0, то вычисляется
операнд-3 и его значение является
результатом операции. Следует
отметить, что вычисляется либо
операнд-2, либо операнд-3, но не оба.
Тип результата зависит от типов
операнда-2 и операнда-3, следующим
образом. </p>

<p>1. Если операнд-2 или операнд-3
имеет целый или плавающий тип
(отметим, что их типы могут
отличаться), то выполняются обычные
арифметические преобразования.
Типом результата является тип
операнда после преобразования. </p>

<p>2. Если операнд-2 и операнд-3 имеют
один и тот же тип структуры,
объединения или указателя, то тип
результата будет тем же самым типом
структуры, объединения или
указателя. </p>

<p>3. Если оба операнда имеют тип void,
то результат имеет тип void. </p>

<p>4. Если один операнд является
указателем на объект любого типа, а
другой операнд является указателем
на vold, то указатель на объект
преобразуется к указателю на vold,
который и будет типом результата. </p>

<p>5. Если один из операндов является
указателем, а другой константным
выражением со значением 0, то типом
результата будет тип указателя. </p>

<p>Пример: </p>

<p>max = (d<=b) ? b : d; <p>Переменной max присваивается
максимальное значение переменных d
и b. </p>

<h4><a name="1313">1.3.13. Операции увеличения
и уменьшения</a></h4>

<p>Операции увеличения (++) и
уменьшения (--) являются унарными
операциями присваивания. Они
соответственно увеличивают или
уменьшают значения операнда на
единицу. Операнд может быть целого
или плавающего типа или типа
указатель и должен быть
модифицируемым. Операнд целого или
плавающего типа увеличиваются
(уменьшаются) на единицу. Тип
результата соответствует типу
операнда. Операнд адресного типа
увеличивается или уменьшается на
размер объекта, который он
адресует. В языке допускается
префиксная или постфиксная формы
операций увеличения (уменьшения),
поэтому значения выражения,
использующего операции увеличения
(уменьшения) зависит от того, какая
из форм указанных операций
используется. </p>

<p>Если знак операции стоит перед
операндом (префиксная форма
записи), то изменение операнда
происходит до его использования в
выражении и результатом операции
является увеличенное или
уменьшенное значение операнда. </p>

<p>В том случае если знак операции
стоит после операнда (постфиксная
форма записи), то операнд вначале
используется для вычисления
выражения, а затем происходит
изменение операнда. </p>

<p>Примеры: </p>

<pre>
      int t=1, s=2, z, f;
           z=(t++)*5;
</pre>

<p>Вначале происходит умножение t*5, а
затем увеличение t. В результате
получится z=5, t=2. </p>

<pre>
           f=(++s)/3;
</pre>

<p>Вначале значение s увеличивается,
а затем используется в операции
деления. В результате получим s=3, f=1. </p>

<p>В случае, если операции
увеличения и уменьшения
используются как самостоятельные
операторы, префиксная и
постфиксная формы записи
становятся эквивалентными. </p>

<p>z++; /* эквивалентно */ ++z; </p>

<h4>1.3.14. Простое присваивание</h4>

<p>Операция простого присваивания
используется для замены значения
левого операнда, значением правого
операнда. При присваивании
производится преобразование типа
правого операнда к типу левого
операнда по правилам, упомянутым
раньше. Левый операнд должен быть
модифицируемым. </p>

<p>Пример: </p>

<pre>
       int t;
       char f;
       long z;
       t=f+z;
</pre>

<p>Значение переменной f
преобразуется к типу long,
вычисляется f+z ,результат
преобразуется к типу int и затем
присваивается переменной t. </p>

<h4><a name="1315">1.3.15. Составное
присваивание</a></h4>

<p>Кроме простого присваивания,
имеется целая группа операций
присваивания, которые объединяют
простое присваивание с одной из
бинарных операций. Такие операции
называются составными операциями
присваивания и имеют вид: </p>

<p>(операнд-1) (бинарная операция) =
(операнд-2) . </p>

<p>Составное присваивание по
результату эквивалентно
следующему простому присваиванию: </p>

<p>(операнд-1) = (операнд-1) (бинарное
операция) (операнд-2) . </p>

<p>Отметим, что выражение составного
присваивания с точки зрения
реализации не эквивалентно
простому присваиванию, так как в
последнем операнд-1 вычисляется
дважды. </p>

<p>Каждая операция составного
присваивания выполняет
преобразования, которые
осуществляются соответствующей
бинарной операцией. Левым
операндом операций (+=) (-=) может быть
указатель, в то время как правый
операнд должен быть целым числом. </p>

<p>Примеры: </p>

<pre>
     double  arr[4]={ 2.0, 3.3, 5.2, 7.5 } ;
     double  b=3.0;
     b+=arr[2];      /*  эквивалентно   b=b+arr[2]            */
     arr[3]/=b+1;    /*  эквивалентно   arr[3]=arr[3]/(b+1)   */
</pre>

<p>Заметим, что при втором
присваивании использование
составного присваивания дает более
заметный выигрыш во времени
выполнения, так как левый операнд
является индексным выражением. </p>

<h4><a name="1316">1.3.16. Приоритеты операций
и порядок вычислений</a></h4>

<p>В языке СИ операции с высшими
приоритетами вычисляются первыми.
Наивысшим приоритетом является
приоритет равный 1. Приоритеты и
порядок операций приведены в табл.
8. </p>

<p><b>Таблица 8</b> </p>

<table border="1" width="70%">
    <tr>
        <th>Приоритет</th>
        <th>Знак операции</th>
        <th>Типы операции </th>
        <th>Порядок выполнения</th>
    </tr>
    <tr>
        <td align="center">2</td>
        <td align="center">() [] . -&gt;</td>
        <td align="center">Выражение</td>
        <td align="center">Слева направо</td>
    </tr>
    <tr>
        <td align="center">1</td>
        <td align="center">- ~ ! * &amp; ++ -- sizeof
        приведение типов </td>
        <td align="center">Унарные</td>
        <td align="center">Справа налево</td>
    </tr>
    <tr>
        <td align="center">3</td>
        <td align="center">* / %</td>
        <td align="center">Мультипликативные</td>
        <td align="center" rowspan="11">Слева направо</td>
    </tr>
    <tr>
        <td align="center">4</td>
        <td align="center">+ -</td>
        <td align="center">Аддитивные</td>
    </tr>
    <tr>
        <td align="center">5</td>
        <td align="center">&lt;&lt; &gt;&gt;</td>
        <td align="center">Сдвиг</td>
    </tr>
    <tr>
        <td align="center">6</td>
        <td align="center">&lt; &gt; &lt;= &gt;=</td>
        <td align="center">Отношение</td>
    </tr>
    <tr>
        <td align="center">7</td>
        <td align="center">== !=</td>
        <td align="center">Отношение
        (равенство)</td>
    </tr>
    <tr>
        <td align="center">8</td>
        <td align="center">&amp;</td>
        <td align="center">Поразрядное И</td>
    </tr>
    <tr>
        <td align="center">9</td>
        <td align="center">^</td>
        <td align="center">Поразрядное
        исключающее ИЛИ</td>
    </tr>
    <tr>
        <td align="center">10</td>
        <td align="center">|</td>
        <td align="center">Поразрядное ИЛИ</td>
    </tr>
    <tr>
        <td align="center">11</td>
        <td align="center">&amp;&amp;</td>
        <td align="center">Логическое И</td>
    </tr>
    <tr>
        <td align="center">12</td>
        <td align="center">||</td>
        <td align="center">Логическое ИЛИ</td>
    </tr>
    <tr>
        <td align="center">13</td>
        <td align="center">? :</td>
        <td align="center">Условная</td>
    </tr>
    <tr>
        <td align="center">14</td>
        <td align="center">= *= /= %= += -= &amp;= |= &gt;&gt;=
        &lt;&lt;= ^=</td>
        <td align="center">Простое и составное
        присваивание</td>
        <td align="center">Справа налево</td>
    </tr>
    <tr>
        <td align="center">15</td>
        <td align="center">,</td>
        <td align="center">Последовательное
        вычисление</td>
        <td align="center">Слева направо</td>
    </tr>
</table>

<h4><a name="1317">1.3.17. Побочные эффекты</a></h4>

<p>Операции присваивания в сложных
выражениях могут вызывать побочные
эффекты, так как они изменяют
значение переменной. Побочный
эффект может возникать и при вызове
функции, если он содержит прямое
или косвенное присваивание (через
указатель). Это связано с тем, что
аргументы функции могут
вычисляться в любом порядке.
Например, побочный эффект имеет
место в следующем вызове функции: </p>

<p>prog (a,a=k*2); </p>

<p>В зависимости от того, какой
аргумент вычисляется первым, в
функцию могут быть переданы
различные значения. </p>

<p>Порядок вычисления операндов
некоторых операций зависит от
реализации и поэтому могут
возникать разные побочные эффекты,
если в одном из операндов
используется операции увеличения
или уменьшения, а также другие
операции присваивания. </p>

<p>Например, выражение i*j+(j++)+(--i)
может принимать различные значения
при обработке разными
компиляторами. Чтобы избежать
недоразумений при выполнении
побочных эффектов необходимо
придерживаться следующих правил. </p>

<p>1. Не использовать операции
присваивания переменной в вызове
функции, если эта переменная
участвует в формировании других
аргументов функции. </p>

<p>2. Не использовать операции
присваивания переменной в
выражении, если эта переменная
используется в выражении более
одного раза. </p>

<h4><a name="1318">1.3.18. Преобразование
типов</a></h4>

<p>При выполнении операций
происходят неявные преобразования
типов в следующих случаях: </p>

<p>- при выполнении операций
осуществляются обычные
арифметические преобразования
(которые были рассмотрены выше); </p>

<p>- при выполнении операций
присваивания, если значение одного
типа присваивается переменной
другого типа; </p>

<p>- при передаче аргументов функции.
</p>

<p>Кроме того, в Си есть возможность
явного приведения значения одного
типа к другому. </p>

<p>В операциях присваивания тип
значения, которое присваивается,
преобразуется к типу переменной,
получающей это значение.
Допускается преобразования целых и
плавающих типов, даже если такое
преобразование ведет к потере
информации. </p>

<p>Преобразование целых типов со
знаком. Целое со знаком
преобразуется к более короткому
целому со знаком, посредством
усечения старших битов. Целая со
знаком преобразуется к более
длинному целому со знаком, путем
размножения знака. При
преобразовании целого со знаком к
целому без знака, целое со знаком
преобразуется к размеру целого без
знака и результат рассматривается
как значение без знака. </p>

<p>Преобразование целого со знаком к
плавающему типу происходит без
потери] информации, за исключением
случая преобразования значения
типа long int или unsigned long int к типу float,
когда точность часто может быть
потеряна. </p>

<p>Преобразование целых типов без
знака. Целое без знака
преобразуется к более короткому
целому без знака или со знаком
путем усечения старших битов. Целое
без знака преобразуется к более
длинному целому без знака или со
знаком путем дополнения нулей
слева. </p>

<p>Когда целое без знака
преобразуется к целому со знаком
того же размера, битовое
представление не изменяется.
Поэтому значение, которое оно
представляет, изменяется, если
знаковый бит установлен (равен 1),
т.е. когда исходное целое без знака
больше чем максимальное
положительное целое со знаком,
такой же длины. </p>

<p>Целые значения без знака
преобразуются к плавающему типу,
путем преобразования целого без
знака к значению типа signed long, а
затем значение signed long
преобразуется в плавающий тип.
Преобразования из unsigned long к типу
float, double или long double производятся с
потерей информации, если
преобразуемое значение больше, чем
максимальное положительное
значение, которое может быть
представлено для типа long. </p>

<p>Преобразования плавающих типов.
Величины типа float преобразуются к
типу double без изменения значения.
Величины double и long double преобразуются
к float c некоторой потерей точности.
Если значение слишком велико для
float, то происходит потеря
значимости, о чем сообщается во
время выполнения. </p>

<p>При преобразовании величины с
плавающей точкой к целым типам она
сначала преобразуется к типу long
(дробная часть плавающей величины
при этом отбрасывается), а затем
величина типа long преобразуется к
требуемому целому типу. Если
значение слишком велико для long, то
результат преобразования не
определен. </p>

<p>Преобразования из float, double или long
double к типу unsigned long производится с
потерей точности, если
преобразуемое значение больше, чем
максимально возможное
положительное значение,
представленное типом long. </p>

<p>Преобразование типов указателя.
Указатель на величину одного типа
может быть преобразован к
указателю на величину другого типа.
Однако результат может быть не
определен из-за отличий в
требованиях к выравниванию и
размерах для различных типов. </p>

<p>Указатель на тип void может быть
преобразован к указателю на любой
тип, и указатель на любой тип может
быть преобразован к указателю на
тип void без ограничений. Значение
указателя может быть преобразовано
к целой величине. Метод
преобразования зависит от размера
указателя и размера целого типа
следующим образом: </p>

<p>- если размер указателя меньше
размера целого типа или равен ему,
то указатель преобразуется точно
так же, как целое без знака; </p>

<p>- если указатель больше, чем
размер целого типа, то указатель
сначала преобразуется к указателю
с тем же размером, что и целый тип, и
затем преобразуется к целому типу. </p>

<p>Целый тип может быть преобразован
к адресному типу по следующим
правилам: </p>

<p>- если целый тип того же размера,
что и указатель, то целая величина
просто рассматривается как
указатель (целое без знака); </p>

<p>- если размер целого типа отличен
от размера указателя, то целый тип
сначала преобразуется к размеру
указателя (используются способы
преобразования, описанные выше), а
затем полученное значение
трактуется как указатель. </p>

<p>Преобразования при вызове
функции. Преобразования,
выполняемые над аргументами при
вызове функции, зависят от того, был
ли задан прототип функции
(объявление &quot;вперед&quot;) со
списком объявлений типов
аргументов. </p>

<p>Если задан прототип функции и он
включает объявление типов
аргументов, то над аргументами в
вызове функции выполняются только
обычные арифметические
преобразования. </p>

<p>Эти преобразования выполняются
независимо для каждого аргумента.
Величины типа float преобразуются к
double, величины типа char и short
преобразуются к int, величины типов
unsigned char и unsigned short преобразуются к
unsigned int. Могут быть также выполнены
неявные преобразования переменных
типа указатель. Задавая прототипы
функций, можно переопределить эти
неявные преобразования и позволить
компилятору выполнить контроль
типов. </p>

<p>Преобразования при приведении
типов. Явное преобразование типов
может быть осуществлено
посредством операции приведения
типов, которая имеет формат: </p>

<p>( имя-типа ) операнд . </p>

<p>В приведенной записи имя-типа
задает тип, к которому должен быть
преобразован операнд. </p>

<p>Пример: </p>

<pre>
         int     i=2;
         long    l=2;
         double    d;
         float     f;
         d=(double)i * (double)l;
         f=(float)d;
</pre>

<p align="center">В данном примере величины
i,l,d будут явно преобразовываться к
указанным в круглых скобках типам. </p>

<hr width="90%">

<p align="center">[ <a href="h12.htm">Назад</a> | <a
href="dir.htm">Оглавление </a>| <a href="h14.htm">Вперед</a>
] </p>

<p align="center">&nbsp;</p>
</body>
</html>
