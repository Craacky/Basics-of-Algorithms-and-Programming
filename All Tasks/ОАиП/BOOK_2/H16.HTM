<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Программирование на языке СИ</title>
</head>

<body bgcolor="#FFF5EE" text="#000000" link="#FF0000"
vlink="#A52A2A" alink="#FF0000">
<div align="center"><center>

<table border="0" width="100%">
    <tr>
        <td>&nbsp;</td>
    </tr>
</table>
</center></div>

<hr noshade width="90%">

<h4><a name="161">1.6.1. Исходные файлы и
объявление переменных</a></h4>

<p>Обычная СИ-программа
представляет собой определение
функции main, которая для выполнения
необходимых действий вызывает
другие функции. Приведенные выше
примеры программ представляли
собой один исходный файл,
содержащий все необходимые для
выполнения программы функции.
Связь между функциями
осуществлялась по данным
посредством передачи параметров и
возврата значений функций. Но
компилятор языка СИ позволяет
также разбить программу на
несколько отдельных частей
(исходных файлов), оттранслировать
каждую часть отдельно, и затем
объединить все части в один
выполняемый файл при помощи
редактора связей. </p>

<p align="center">При такой структуре
исходной программы функции,
находящиеся в разных исходных
файлах могут использовать
глобальные внешние переменные. Все
функции в языке Си по определению
внешние и всегда доступны из любых
файлов. Например, если программа
состоит из двух исходных файлов,
как показано на рис.2., то функция main
может вызывать любую из трех
функций fun1, fun2, fun3, а каждая из этих
функций может вызывать любую
другую. </p>
<div align="center"><center>

<table border="0">
    <tr>
        <td bgcolor="#C0C0C0"><pre>
 main ()
 {  ...
 }     
 fun1()
 {  ...
 }     
</pre>
        </td>
        <td rowspan="2"><font color="#FFFFFF">.</font></td>
        <td bgcolor="#C0C0C0"><pre>
 fun2()
 {  ...
 }
 fun3()
 {  ...
 }
</pre>
        </td>
    </tr>
    <tr>
        <th>file1.c</th>
        <th>file2.c</th>
    </tr>
    <tr>
        <th colspan="3">Рис.2. Пример программы
        из двух файлов</th>
    </tr>
</table>
</center></div>

<p>Для того, чтобы определяемая
функция могла выполнять какие либо
действия, она должна использовать
переменные. В языке СИ все
переменные должны быть объявлены
до их использования. Объявления
устанавливают соответствие имени и
атрибутов переменной, функции или
типа. Определение переменной
вызывает выделение памяти для
хранения ее значения. Класс
выделяемой памяти определяется
спецификатором класса памяти, и
определяет время жизни и область
видимости переменной, связанные с
понятием блока программы. </p>

<p>В языке СИ блоком считается
последовательность объявлений,
определений и операторов,
заключенная в фигурные скобки.
Существуют два вида блоков -
составной оператор и определение
функции, состоящее из составного
оператора, являющегося телом
функции, и предшествующего телу
заголовка функции (в который входят
имя функции, типы возвращаемого
значения и формальных параметров).
Блоки могут включать в себя
составные операторы, но не
определения функций. Внутренний
блок называется вложенным, а
внешний блок - объемлющим. </p>

<p>Время жизни - это интервал времени
выполнения программы, в течение
которого программный объект
(переменная или функция)
существует. Время жизни переменной
может быть локальным или
глобальным. Переменная с
глобальным временем жизни имеет
распределенную для нее память и
определенное значение на
протяжении всего времени
выполнения программы, начиная с
момента выполнения объявления этой
переменной. Переменная с локальным
временем жизни имеет
распределенную для него память и
определенное значение только во
время выполнения блока, в котором
эта переменная определена или
объявлена. При каждом входе в блок
для локальной переменной
распределяется новая память,
которая освобождается при выходе
из блока. </p>

<p>Все функции в СИ имеют глобальное
время жизни и существуют в течение
всего времени выполнения
программы. </p>

<p>Область видимости - это часть
текста программы, в которой может
быть использован данный объект.
Объект считается видимым в блоке
или в исходном файле, если в этом
блоке или файле известны имя и тип
объекта. Объект может быть видимым
в пределах блока, исходного файла
или во всех исходных файлах,
образующих программу. Это зависит
от того, на каком уровне объявлен
объект: на внутреннем, т.е. внутри
некоторого блока, или на внешнем,
т.е. вне всех блоков. </p>

<p>Если объект объявлен внутри
блока, то он видим в этом блоке, и во
всех внутренних блоках. Если объект
объявлен на внешнем уровне, то он
видим от точки его объявления до
конца данного исходного файла. </p>

<p>Объект может быть сделан
глобально видимым с помощью
соответствующих объявлений во всех
исходных файлах, образующих
программу. </p>

<p>Спецификатор класса памяти в
объявлении переменной может быть
auto, register, static или extern. Если класс
памяти не указан, то он
определяется по умолчанию из
контекста объявления. </p>

<p>Объекты классов auto и register имеют
локальное время жизни.
Спецификаторы static и extern определяют
объекты с глобальным временем
жизни. </p>

<p>При объявлении переменной на
внутреннем уровне может быть
использован любой из четырех
спецификаторов класса памяти, а
если он не указан, то
подразумевается класс памяти auto. </p>

<p>Переменная с классом памяти auto
имеет локальное время жизни и видна
только в блоке, в котором объявлена.
Память для такой переменной
выделяется при входе в блок и
освобождается при выходе из блока.
При повторном входе в блок этой
переменной может быть выделен
другой участок памяти. </p>

<p>Переменная с классом памяти auto
автоматически не инициализируется.
Она должна быть
проинициализирована явно при
объявлении путем присвоения ей
начального значения. Значение
неинициализированной переменной с
классом памяти auto считается
неопределенным. </p>

<p>Спецификатор класса памяти register
предписывает компилятору
распределить память для переменной
в регистре, если это представляется
возможным. Использование
регистровой памяти обычно приводит
к сокращению времени доступа к
переменной. Переменная,
объявленная с классом памяти register,
имеет ту же область видимости, что и
переменная auto. Число регистров,
которые можно использовать для
значений переменных, ограничено
возможностями компьютера, и в том
случае, если компилятор не имеет в
распоряжении свободных регистров,
то переменной выделяется память
как для класса auto. Класс памяти register
может быть указан только для
переменных с типом int или
указателей с размером, равным
размеру int. </p>

<p>Переменные, объявленные на
внутреннем уровне со
спецификатором класса памяти static,
обеспечиваю возможность сохранить
значение переменной при выходе из
блока и использовать его при
повторном входе в блок. Такая
переменная имеет глобальное время
жизни и область видимости внутри
блока, в котором она объявлена. В
отличие от переменных с классом auto,
память для которых выделяется в
стеке, для переменных с классом static
память выделяется в сегменте
данных, и поэтому их значение
сохраняется при выходе из блока. </p>

<pre>
     Пример:
  /*  объявления переменной i на внутреннем уровне
            с  классом памяти static.                    */
  /*   исходный файл file1.c       */
     main()
        { ...
        }
     fun1()
        {  static int i=0; ...
        }
   /* исходный файл   file2.c       */
     fun2()
        {  static int i=0; ...
        }
     fun3()
        {  static int i=0; ...
        }
</pre>

<p>В приведенном примере объявлены
три разные переменные с классом
памяти static, имеющие одинаковые
имена i. Каждая из этих переменных
имеет глобальное время жизни, но
видима только в том блоке (функции),
в которой она объявлена. Эти
переменные можно использовать для
подсчета числа обращений к каждой
из трех функций. </p>

<p>Переменные класса памяти static
могут быть инициализированы
константным выражением. Если явной
инициализации нет, то такой
переменной присваивается нулевое
значение. При инициализации
константным адресным выражением
можно использовать адреса любых
внешних объектов, кроме адресов
объектов с классом памяти auto, так
как адрес последних не является
константой и изменяется при каждом
входе в блок. Инициализация
выполняется один раз при первом
входе в блок. </p>

<p>Переменная, объявленная локально
с классом памяти extern, является
ссылкой на переменную с тем же
самым именем, определенную
глобально в одном из исходных
файлов программы. Цель такого
объявления состоит в том, чтобы
сделать определение переменной
глобального уровня видимым внутри
блока. </p>

<pre>
     Пример:
  /*   объявления  переменной  i,  являющейся  именем внешнего
       массива длинных целых чисел, на локальном уровне      */
  /*      исходный файл    file1.c          */
     main()
        { ...
        }
     fun1()
        { extern long i[]; ...
        }
  /*     исходный файл      file2.c         */
     long i[MAX]={0};
     fun2()
        {  ...
        }
     fun3()
        {  ...
        }
</pre>

<p>Объявление переменной i[] как extern в
приведенном примере делает ее
видимой внутри функции fun1.
Определение этой переменной
находится в файле file2.c на
глобальном уровне и должно быть
только одно, в то время как
объявлений с классом памяти extern
может быть несколько. </p>

<p>Объявление с классом памяти extern
требуется при необходимости
использовать переменную, описанную
в текущем исходном файле, но ниже по
тексту программы, т.е. до выполнения
ее глобального определения.
Следующий пример иллюстрирует
такое использование переменной с
именем st. </p>

<pre>
     Пример:
     main()
     { extern int st[]; ...
     }
     static int st[MAX]={0};
     fun1()
     {   ...
     }
</pre>

<p>Объявление переменной со
спецификатором extern информирует
компилятор о том, что память для
переменной выделять не требуется,
так как это выполнено где-то в
другом месте программы. </p>

<p>При объявлении переменных на
глобальном уровне может быть
использован спецификатор класса
памяти static или extern, а так же можно
объявлять переменные без указания
класса памяти. Классы памяти auto и
register для глобального объявления
недопустимы. </p>

<p>Объявление переменных на
глобальном уровне - это или
определение переменных, или ссылки
на определения, сделанные в другом
месте программы. Объявление
глобальной переменной, которое
инициализирует эту переменную
(явно или неявно), является
определением переменной.
Определение на глобальном уровне
может задаваться в следующих
формах: </p>

<p>1. Переменная объявлена с классом
памяти static. Такая переменная может
быть инициализирована явно
константным выражением, или по
умолчанию нулевым значением. То
есть обявления static int i=0 и static int i
эквивалентны, и в обоих случаях
переменной i будет присвоено
значение 0. </p>

<p>2. Переменная объявлена без
указания класса памяти, но с явной
инициализацией. Такой переменной
по умолчанию присваивается класс
памяти static. То есть объявления int i=1
и static int i=1 будут эквивалентны. </p>

<p>Переменная объявленная глобально
видима в пределах остатка
исходного файла, в котором она
определена. Выше своего описания и
в других исходных файлах эта
переменная невидима (если только
она не объявлена с классом extern). </p>

<p>Глобальная переменная может быть
определена только один раз в
пределах своей области видимости. В
другом исходном файле может быть
объявлена другая глобальная
переменная с таким же именем и с
классом памяти static, конфликта при
этом не возникает, так как каждая из
этих переменных будет видимой
только в своем исходном файле. </p>

<p>Спецификатор класса памяти extern
для глобальных переменных
используется, как и для локального
объявления, в качестве ссылки на
переменную, объявленную в другом
месте программы, т.е. для расширения
области видимости переменной. При
таком объявлении область видимости
переменной расширяется до конца
исходного файла, в котором сделано
объявление. </p>

<p>В объявлениях с классом памяти
extern не допускается инициализация,
так как эти объявления ссылаются на
уже существующие и определенные
ранее переменные. </p>

<p>Переменная, на которую делается
ссылка с помощью спецификатора extern,
может быть определена только один
раз в одном из исходных файлов
программы. </p>

<h4><a name="162">1.6.2. Объявления функций</a></h4>

<p>Функции всегда определяются
глобально. Они могут быть объявлены
с классом памяти static или extern.
Объявления функций на локальном и
глобальном уровнях имеют
одинаковый смысл. </p>

<p>Правила определения области
видимости для функций отличаются
от правил видимости для переменных
и состоят в следующем. </p>

<p>1. Функция, объявленная как static,
видима в пределах того файла, в
котором она определена. Каждая
функция может вызвать другую
функцию с классом памяти static из
своего исходного файла, но не может
вызвать функцию определенную с
классом static в другом исходном
файле. Разные функции с классом
памяти static имеющие одинаковые
имена могут быть определены в
разных исходных файлах, и это не
ведет к конфликту. </p>

<p>2. Функция, объявленная с классом
памяти extern, видима в пределах всех
исходных файлов программы. Любая
функция может вызывать функции с
классом памяти extern. </p>

<p>3. Если в объявлении функции
отсутствует спецификатор класса
памяти, то по умолчанию принимается
класс extern. </p>

<p>Все объекты с классом памяти extern
компилятор помещает в объектном
файле в специальную таблицу
внешних ссылок, которая
используется редактором связей для
разрешения внешних ссылок. Часть
внешних ссылок порождается
компилятором при обращениях к
библиотечным функциям СИ, поэтому
для разрешения этих ссылок
редактору связей должны быть
доступны соответствующие
библиотеки функций. </p>

<h4><a name="163">1.6.3. Время жизни и область
видимости программных объектов</a></h4>

<p>Время жизни переменной
(глобальной или локальной)
определяется по следующим
правилам. </p>

<p>1. Переменная, объявленная
глобально (т.е. вне всех блоков),
существует на протяжении всего
времени выполнения программы. </p>

<p>2. Локальные переменные (т.е.
объявленные внутри блока) с классом
памяти register или auto, имеют время
жизни только на период выполнения
того блока, в котором они объявлены.
Если локальная переменная
объявлена с классом памяти static или
extern, то она имеет время жизни на
период выполнения всей программы. </p>

<p>Видимость переменных и функций в
программе определяется следующими
правилами. </p>

<p>1. Переменная, объявленная или
определенная глобально, видима от
точки объявления или определения
до конца исходного файла. Можно
сделать переменную видимой и в
других исходных файлах, для чего в
этих файлах следует ее объявить с
классом памяти extern. </p>

<p>2. Переменная, объявленная или
определенная локально, видима от
точки объявления или определения
до конца текущего блока. Такая
переменная называется локальной. </p>

<p>3. Переменные из объемлющих
блоков, включая переменные
объявленные на глобальном уровне,
видимы во внутренних блоках. Эту
видимость называют вложенной. Если
переменная, объявленная внутри
блока, имеет то же имя, что и
переменная, объявленная в
объемлющем блоке, то это разные
переменные, и переменная из
объемлющего блока во внутреннем
блоке будет невидимой. </p>

<p>4. Функции с классом памяти static
видимы только в исходном файле, в
котором они определены. Всякие
другие функции видимы во всей
программе. </p>

<p>Метки в функциях видимы на
протяжении всей функции. </p>

<p>Имена формальных параметров,
объявленные в списке параметров
прототипа функции, видимы только от
точки объявления параметра до
конца объявления функции. </p>

<h4><a name="162">1.6.4. Инициализация
глобальных и локальных переменных</a></h4>

<p>При инициализации необходимо
придерживаться следующих правил: </p>

<p>1. Объявления содержащие
спецификатор класса памяти extern не
могут содержать инициаторов. </p>

<p>2. Глобальные переменные всегда
инициализируются, и если это не
сделано явно, то они
инициализируются нулевым
значением. </p>

<p>3. Переменная с классом памяти static
может быть инициализирована
константным выражением.
Инициализация для них выполняется
один раз перед началом программы.
Если явная инициализация
отсутствует, то переменная
инициализируется нулевым
значением. </p>

<p>4. Инициализация переменных с
классом памяти auto или register
выполняется всякий раз при входе в
блок, в котором они объявлены. Если
инициализация переменных в
объявлении отсутствует, то их
начальное значение не определено. </p>

<p>5. Начальными значениями для
глобальных переменных и для
переменных с классом памяти static
должны быть константные выражения.
Адреса таких переменных являются
константами и эти константы можно
использовать для инициализации
объявленных глобально указателей.
Адреса переменных с классом памяти
auto или register не являются константами
и их нельзя использовать в
инициаторах. </p>

<pre>
     Пример:
    int global_var;
    int func(void)
    { int local_var;                      /* по умолчанию auto  */
      static int *local_ptr=&amp;local_var;   /*  так неправильно   */
      static int *global_ptr=&amp;global_var; /*  а так правильно   */
      register int *reg_ptr=&amp;local_var;   /*  и так правильно   */
    }
</pre>

<p align="center">В приведенном примере
глобальная переменная global_var имеет
глобальное время жизни и
постоянный адрес в памяти, и этот
адрес можно использовать для
инициализации статического
указателя global_ptr. Локальная
переменная local_var, имеющая класс
памяти auto размещается в памяти
только на время работы функции func,
адрес этой переменной не является
константой и не может быть
использован для инициализации
статической переменной local_ptr. Для
инициализации локальной
регистровой переменной reg_ptr можно
использовать неконстантные
выражения, и, в частности, адрес
переменной local_ptr. </p>

<hr width="90%">

<p align="center">[ <a href="h15.htm">Назад</a> | <a
href="dir.htm">Оглавление </a>| <a href="h17.htm">Вперед</a>
] </p>

<p align="center">&nbsp;</p>
</body>
</html>
