                             188

                            SBRK 

    ФОРМАТ
  
  #include <malloc.h>   /* используется только для описания функции */

   char *sbrk(incr);
   int incr;
   

    ОПИСАНИЕ

  Функция вновь устанавливает переменное значение для вызываемого
   процесса. Переменное значение является адресом первого байта
   неполученной памяти.Sbrk функция добавляет incr байтов к 
   переменному значению; размер памяти, получаемый процессом,
   соответственно изменяется.Заметим, что incr может быть
   отрицательным, в этом случае область получаемой памяти уменьшается
   на incr байтов.
   
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Старое переменное значение.
  -1, индицирует что нет достаточной доступной памяти;
      errno устанавливается в ENOMEM
     
   Замечание:В программах компактной,большой и высшей модели SBRK
             не приводит к результату.
      
    СМОТРИ ТАКЖЕ

    calloc,free,malloc,realloc
    
    ПРИМЕР

    #include <malloc.h>
    #include <stdio.h>
    /* Получить 100 байтов памяти
     */
    char *alloc;
    alloc = sbrk(100);
    .
    .
    .
    /* Уменьшить полученную память до 60 байтов
    */
    if (alloc ! = (char) -1)
         sbrk(-40);
               
 
 
                            189

                            SCANF

    ФОРМАТ
  
  #include <stdio.h>

  int scanf(format-string[,argument...]);
  char *format-string;
    

    ОПИСАНИЕ

  Функция читает данные из стандартного вводного потока stdin в
   расположения, заданные аргументами ( arguments).
   Каждый аргумент должен быть указателем на переменную с типом,
   соответствующим типу, определенному в format-string. Format-string
   управляет интерпретацией вводных полей. Format-string может        
   содержать одно или более из следующего:
   - Символы ограничители (пробел(' '), табуляция ('\t'), или
     новая строка ('\n')).Все символы ограничители до символа не
     ограничителя считываются, но не помещаются. Один символ
     ограничитель соответствует некоторому числу (включая ноль ).
   - Cимволы не ограничители, за исключением символа процента(%).
     Символы не ограничители считываются но не помещаются,
     соответствуя символу не ограничителю. Если следующий символ
     не соответствует, scanf завершается.
   - Спецификации формата, которые определяются знаком процента (%).
     Спецификация формата заставляет scanf прочитать и преобразовать
     символы на входе в значения определяемого типа. Значение
     присваивается аргументу из списка аргументов.
   Format-string считывается слева направо.Символы,не входящие
   в спецификацию формата, не устанавливаются в соответствие           
   последовательности символов на входе;символы, установленные в
   соответствие, сканируются (просматриваются), но не помещаются.
   Если символ  на stdin конфликтует с format-string, scanf
   завершается.
   Когда первая спецификация формата встречается, значение первого
   входного поля преобразуется согласно спецификации формата и 
   помещается в расположение, определяемое первым аргументом.
   Вторая спецификация формата заставляет второе входное поле
   преобразоваться и поместиться во второй аргумент, и таким образом
   до конца format-string.
   Входное поле включает все символы до первого символа ограничителя,
   или до первого символа,который не может быть преобразован,согласно
   спецификации формата, или до длины поля width, если определено.
   Если определено аргументов больше для заданной спецификации формата,
   то лишние аргументы игнорируются. Результат неопределенный,если
   нет достаточно аргументов для заданной спецификации формата.
   Спецификация формата имеет следующую форму:
     %[*][width][{F|N}][h|I}] type
   Каждое поле в спецификации формата есть одиночный символ или число.
   Символ type, который появляется в последнем поле формата,
   определяет:входное поле интерпретируется как символ,строка или число
   Самая простая спецификация формата содержит только символ процента
   и символ типа (например,%s ).
                            190
   
   Если до символа процента (%) следует символ,который не является
   символом,управляющим форматом,то этот символ и все последующие 
   символы (до следующего символа процента ) рассматриваются как
   простая последовательность символов на входе. Например,чтобы
   определить символ процента на входе,используйте %% .
   Звездочка (*), следующая за символом процента,запрещает 
   присвоение тех входных полей,которые интерпретируются как поле,
   определяемого типа type. Поле сканируется, но не помещается.
   Width является положительным десятичным целым, контролирующее
   максимальное число символов, которые будут прочитаны из stdin.
   Не более чем width символов преобразуются и помещаются в
   соответствующий аргумент.Меньше чем width символов может быть   
   прочитано, если символ ограничитель или символ,который не может быть
   преобразован согласно заданному формату, встретились раньше.
   F и N префиксы позволяют не принимать во внимание способ адресации
   используемой модели памяти. F должен быть префиксом к аргументу,
   указывающий на далекий (far) обьект, N должен быть префиксом к 
   аргументу, указывающий на близкий (near) аргумент.
   Префикс  l индицирует, что long версия type будет использована,
   тогда как префикс h индицирует ,что short версия type будет
   использована. Соответствующий аргумент должен указывать на long
    или double обьект ( с l символом ) или short обьект (с h символом).
    Модоффикации l и h могут быть использованы с d,l,o,x и u символами
    type. Модификация l может быть использована с e и f символами.
    Модификации l и h игнорируются ,если определены другой type.
    Символы  type и их суть описаны в таблице R.4.
                            191
    
    Таблица R.4.
    Cимволы type.
    -------------------------------------------------------------------
    Cимвол  Тип на входе                          Тип аргумента
    -------------------------------------------------------------------
      d     Десятичное целое                      Указатель на int
      D     Десятичное целое                      Указатель на long
      o     Восьмеричное целое                    Указатель на int
      O     Восьмеричное целое                    Указатель на long
      x     Шестнадцатиричное целое               Указатель на int 
      X     Шестнадцатиричное целое               Указатель на long
      i     Десятичное,шестнадцатиричное          Указатель на int
            или восьмеричное целое
      I     Десятичное, шестнадцатиричное         Указатель на long
            или восьмеричное целое
      u     Десятичное целое без знака            Указатель на unsigned
                                                  int
      U     Десятичное целое без знака            Указатель на unsigned
                                                  long
      e     Значение с плавающей точкой,          Указатель на float
      f     состоящее из необязательного
            знака (+ или -), набор одного    
            или более десятичных цифр,
            возможно, содержащих десятичную
            точку и необязательной экспоненты
            ("e" или "E"), за которой следует
            целое значение необязательно со         
            знаком.
      с     Cимвол.Символы ограничители           Указатель на char
            пропускаются при чтении, когда c
            определен;чтобы прочитать следующий
            cимвол не ограничитель, используйте
            %1s
      s     Строка                                Указатель на массив
                                                  символов,достаточный
                                                  для размещения вход- 
                                                  ного поля плюс завер-
                                                  шающий символ конца
                                                  строки('\0'),который
                                                  автоматически добав-
                                                  ляется
      n     Читать из потока stream или буфера    Указатель на int, в
                                                  которую помещается
                                                  число успешно прочи-
                                                  танных символов из
                                                  потока stream или
                                                  буфера, на которую
                                                  было указано при
                                                  вызове scanf.
   --------------------------------------------------------------------
                            192
   
   Чтобы прочитать строки ,не разделенные символами пробела, набор в
   квадратных скобках ([]) может быть подставлен для типа s.Соответст-
   вующее входное поле читается до первого символа, которое не        
   находится внутри квадратных скобок.Если первый символ в наборе
   является знаком вставки (^), эффект противоположный; входное поле
   читается до первого символа, который появился в остатке набора
   символов.
   Чтобы поместить строку без символа конца строки('\0'),используйте
   спецификацию %nc, где n десятичное целое. В этом случае с тип индици-
   рует, что аргумент является указатель на массив символов. Следующие
   n символов будут прочитаны из входного потока в определяемое
   расположение и символ конца строки ('\0') не будет добавлен.
   Scanf функция сканирует (просматривает) каждое входное поле,
   символ за символом. Чтение может быть остановлено раньше, чем
   будет достигнут пробельный символ по различным причинам:
   определенное width было достигнуто;следующий символ не может быть
   преобразован,как определено; следующий символ конфликтует с символом
   в управляющей строке, в которой устанавливается соответствие; или
   следующий символ не должен появиться (или не появится) в заданном
   наборе символов. Когда это произошло, следующий невведенный символ
   рассматривается, как первый символ следующего входного поля.
   
   ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Число полей, которые были успешно преобразованы и присвоены.
   Возвращаемое значение не включает поля, которые были прочитаны, но
   не присвоены.                                              
   EOF, если была попытка прочитать конец файла.
   0, если не было присвоенных полей.
   
    СМОТРИ ТАКЖЕ

    fscanf,printf,sscanf,vfprintf,vprintf,vsprintf
                            193
    
    ПРИМЕР
    /******************* exampl1 *********************************/
    #include <stdio.h>
          
    int i;      
    float fp;
    char c,s[81];

    scanf("%d %f %c %s,&i,&fp,&c,s);

    /********************* exampl2 ****************************/

    #include <stdio.h>
    main ()       /* Преобразовать шестьнадцатеричное или восьмеричное
                    число к десятичному виду */
    {
     int numassigned,val;
     printf("Введи шестьнадцатеричное и восьмеричное #, или 00 выход:\n");
     do  {
          printf(" #=");
          numassigned = scanf("%i, &val);
          printf("Десятичное = %i\n", val);
          }
      while ( val && numassigned);
      /* Цикл закончится, когда введут 00 или scanf не сможет
         преобразовать входное поле */
    }  
      
    ВЫВОД:

    Введи шестьнадцатеричное или восьмеричное  #, или 00 выход:
    # = Oxf
    Десятичное # =15
    #= 0100
    Десятичное # =64
    #= 00
    Десятичное # =0
                             194

                            SEGREAD

    ФОРМАТ
    
  #include <dos.h>

  void segread(segregs);
  struct SREGS *segregs;


    ОПИСАНИЕ

    Функция заполняет структуру ,на которую указывает segregs,
    текущим содержанием сегментных регистров.
    Функция предназначена для использования с intdosx и int86x
    функциями, чтобы восстановить значения сегментных регистров
    для дальнейшего использования.
    
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
    
    Нет кодов возврата

    СМОТРИ ТАКЖЕ

    intdosx,int86x,FP-SEG
    
    ПРИМЕР

  #include <dos.h>
               
    struct SREGS segregs;
    unsigned int cs,ds,es,ss;
    /*  Следующие утверждения получают значения сегментных регистров
    */
    
    segread(&segregs);
    cs=segregs.cs;
    ds=segregs.ds;
    es=segregs.es;
    ss=segregs.ss;
    
                            195

                            SETBUF

    ФОРМАТ
  
  #include <stdio.h> 

    void setbuf(streem,buffer);
    FILE *stream;
    char *buffer;
    
    
    ОПИСАНИЕ

    Функция позволяет пользователю контролировать буферизацию для опре-
    деленного потока stream. Аргумент stream должен относиться к 
    открытому файлу. Если аргумент buffer есть NULL, то stream не
    буферизован. Иначе, buffer должен указывать на массив символов
    длины BUFSIZ,где BUFSIZ есть размер буфера, как определено в
    stdio.h. Определенный пользователем buffer используется для 
    буферизованного ввода/вывода заданного потока stream, вместо
    получаемого, по умолчанию, системного буфера.
    Stderr и stdoux потоки не буферизованы по умолчанию, но им могут
    быть присвоены буфера посредством setbuf.
    
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Нет кодов возврата
    
    СМОТРИ ТАКЖЕ

    ffush,fopen,fclose

    ПРИМЕР

    #include <stdio.h>
    
    char buf[BUFSIZ];
    FILE *stream1, *stream2;
    
    stream1 = fopen("data1","r");
    stream2 = fopen("data2","w");
    setbuf(stream1,buf);
    setbuf(stream2,NULL);
    
  
               
                            196

                            SETJMP

    ФОРМАТ
    
  #include <setjmp.h>

    int setjmp(env);
    jmp_buf env;
    

    ОПИСАНИЕ

    Функция сохраняет множество окружения, которое в последующем
    может быть востановлено, используя longjmp функцию.
    Setjmp и longjmp функции
    предоставляют возможность, чтобы выполнить нелокальное goto, и
    обычно используются, чтобы миновать выполнение контроля за возвра-
    щаемым кодом по предыдуще вызванной команде без использования
    обычных соглашений  по вызову и возврату.
    Вызов setjmp сохраняет текущее множество окружения в env. Последую-
    щий вызов longjmp востанавливает сохраненное окружение и
    возвращает управление на точку, следующую непосредственно за
    соответствущим setjmp вызовом. Значения всех переменных (за
    исключением регистровых переменных), доступных команде,
    принимающей управление, содержат значения, которые они имели,
    когда longjmp был вызван. Значения регистровых переменных
    непредсказуемы.
    
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, после сохранения множества окружения.
    Значение value аргумента функции longjmp, если setjmp возвращает
    значение, как результат longjmp вызова.
    
    Замечание:Значение регистровых переменных при вызове setjmp не
              могут быть востановлены в правильные значения после 
              выполнения longjmp вызова.
    
    
    СМОТРИ ТАКЖЕ

    longjmp
                            197
    
    ПРИМЕР

    #include <stdio.h>
    #include <setjmp.h>
    jmp-buf mark;
    main( )
         {
         if (setjmp(mark)  !=0) {
              printf("longjmp был вызван\n");
              recover();
              exit(1);
              }
          printf("setjmp был вызван\n");
          .
          .
          .
          p();
          .
          .
          .
          }
     p()
          {
          int error =0;
          .
          .
          .
          if (error !=0)
                   longjmp(mark,-1);
                   .
                   .
                   .
                   }
          recover()
                  {
                  /* Позаботтесь, чтобы данные файла не запортились
                  */
                  .
                  .
                  .
                  }
                  
                             198

                            SETMODE

    ФОРМАТ
    
  #include <io.h>    /* используется только для описания функции */ 
  #include <fcntl.h>

    int setmode(handle,mode);
    int handle;
    int mode;
    

    ОПИСАНИЕ

    Функция устанавливает переведенный вид файла, заданного в handle,
    к mode.Mode должно быть одним из следующих констант:
     
     O_TEXT   Устанавливает текстовый (переведенный) вид.Возврат-ка-
     ретки/перевод строки комбинация (CR-LF) переводится в одиночную
     перевод строки (LF) на входе. (LF) переводится в (CR-LF) при
     выходе.
     O_BINARY  Устанавливает бинарный (непереведенный) вид.
     
    Setmode функция обычно используется, чтобы модифицировать переве-
    денный вид, заданный по умолчанию, stdin.stdout,sdterr,stdoux и
    stdprn, но не может быть использовано для любого файла.
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Предыдуще переведенный вид, если успешно.
    _1, индицирует об ошибке; errno устанавливается в одно из следующих
    значений:
     EBADF   Неправильное файд handle
     EINVAL  Неправильный mode аргумент ( ни O_TEXT, ни O_BINARY).
     
     
    СМОТРИ ТАКЖЕ
    
    creat,fopen,open
    
    ПРИМЕР
    
    #include <stdio.h>
    #include <fcntl.h>
    #include <io.h>
    
    int result;
    
    /* Следующее утверждение устанавливает stdin в двоичный вид
    */
    result = setmode(fileno(stdin),O_BINARY);
    
                             199

                            SETVBUF

    ФОРМАТ
    
  #include <stdio.h>

    int setvbuf(stream,buf,type,size);
    FILE *stream;
    char *buf;
    int type;
    int size;
    

    ОПИСАНИЕ

    Функция  позволяет пользователю контролировать буферизацию и
    размер буфера, определяемого потока stream. Поток stream должен
    относиться к открытому файлу. Массив, на который указывает buf,
    используется в качестве буфера, если это не NULL, в случае которого
    поток не буферизован. Если поток буферизован, type определяет тип,
    который должен быть либо _IONBF, либо _IOFBF, или _IOLBF.
    Если тип _IOFBF или _IOLBF, то size используется как размер
    буфера. Если тип _IONBF, то поток не буферизован, и size и buf 
    игнорируются.
    Допустимое значение size: больше 0 и меньше чем максимальный
    размер целого (int).
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, если успешно.
    НЕнулевое значение, если тип или размер буфера определены   
    некорректно.
    
    СМОТРИ ТАКЖЕ

    setbuf,fflush,fopen,fclose
    
    ПРИМЕР

  #include <stdio.h>
   
    char buf[1024];
    FILE *stream1,*stream2;
    main()
          {
          stream1 = fopen("data1","r");
          stream2 = fopen("data2","w");
          /* stream1 будет использовать назначенный пользователем
             буфер в 1024 байта, stream2 не буферизован */
          if (setvbuf(stream1,buf,_IOFBF,sizeof(buf)) !=0)
               printf("Некорректный type или size \n");
          if (setvbuf(stream2,NULL,_IONBF,0) !=0)
               printf("Некорректный type или size \n");
          }
          
               
                  
               


                          ABORT

    ФОРМАТ

  #include <>    /* используется только для описания функции */

    ОПИСАНИЕ

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    СМОТРИ ТАКЖЕ

    ПРИМЕР

  # include <>
                            200

                            SIGNAL

    ФОРМАТ
    
  #include <signal.h> 

    int (*signal(sig,func)();
    int sig;
    int (*func)();
    

    ОПИСАНИЕ

    Функция позволяет процесс,чтобы выбрать одну из трех возможностей 
    для управления сигналами прерывания из операционной системы.
    Аргумент sig должен быть одним из явных констант SIGINT или
    SIGFPE, определенных в signal.h. SIGINT соответствует сигналу
    прерывания MS-DOS INT23H, SIGFPE соответствует исключительным
    ситуациям с плавающей точкой,которые не скрыты, такие как перепол-
    нение, деление на ноль, недействительная операция.
    Aргумент func  должен быть одним из явных констант SIG_DEL или
    SIG_IGN( также, определенных в signal.h), или адресом функции.
    Действие, которое выбирается, когда сигнал прерывания получен,
    зависит от значения func следующим образом:
    SIG_IGN   Сигнал прерывания игнорируется. Это значение никогда
              не должно задаваться для  SIGFPE, т.к. cостояние
              процесса с плавающей точкой становиться неопределенным.
    SIG_DEL   Вызванный процесс завершается и управление передается
              на уровень MS_DOS команд. Все файлы, открытые процессом,
              закрываются,но буфера не скидываются.
    Адрес     Для SIGINT сигнала, функция, на которую указывает func,
    функции   получает аргумент SIGINT и выполняется. Если функция
              возвращает управление, вызванный процесс возобновляет
              выполнение непосредственно за точкой, в которой был
              принят сигнал прерывания.
              Перед тем, как определяемая фукция выполнится,значение
              func устанавливается в SIG_DEL; следующий сигнал
              прерывания трактуется как описано выше для SIG_DEL; 
              если этот вмешавшийся вызов signal не определен по
              другому. Это позволяет пользователю вновь устанавливать
              сигналы в вызванной функции по необходимости.
              Для SIGFPE, функция, на которую указывает func, получает
              два аргумента, SIGFPE и код ошибки FPE_xxx, и выполняется
              (Смотри включаемый файл float.h для описания FPE_xxx
              кодов). Значения func вновь не устанавливается для 
              принятия сигнала;чтобы вернуться из исключения с плаваю-
              щей точкой, используйте SETJMP вместе с LONGJMP.
              (Смотри пример для _fpreset).
              Если функция возвращает управление, вызванный процесс
              возобновляет выполнение с состоянием процесса для
              плавающей точки.
                            201
              
              
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Предыдущее значение func.
    _1, если недействительноу значение sig;
        errno устанавливается в EINVAL.
        
    Замечание:Сигнал окружения не сохраняется в порождаемых процессах,
              созданных по вызову exec или spawn команд. Сигнал
              окружения вновь устанавливается по умолчанию в
              порождаемом процессе.
    
    
    СМОТРИ ТАКЖЕ

    abort,exit,_exit,_fpreset,spawnl,spawnle,spawnlp,spawnv,spawnve,
    spawnvp
    
    ПРИМЕР

  #include <stdio.h>
  #include <signal.h>
  #include <stdlib.h>
  #include <process.h>
  
  int handler( );
  main()
        {
        if (signal(SIGINT,handler) = (int(*) ( ))-1) {
            fprintf(stderr,"невозможно установить SIGINT\n");
            abort( );
            }
            .
            .
            .
         }
    int handler( )
         {
         char ch;
         
         printf("завершить обработку?");
         scanf("%1c",&сh);
         if (ch == 'y' || ch == 'Y')
             exit(0);
         signal (SIGINT,handler); /* signal, который вызывается здесь
                                  ** такой, что следующий сигнал преры-
                                     рывания передает управление к
                                     handler(), а не OS
                                  */ 
         }
         
               
                           202

                          SIN-SINH  

    ФОРМАТ

  #include <math.h>                                                  
  double sin(x);
  double sinh(x);
  double x;

    ОПИСАНИЕ
   
  Функции sin и sinh возвращают синус и гиперболический синус
  аргумента x ,соответственно.
   
     
   ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
  
 Функция sin возвращает значения синуса x.
 Если x большое и произошла частичная утрата значения в результате,
 генерируется PLOSS ошибка, но ошибочное сообщение не печатается.
 Если x такое большое, что произошла полная утрата значения в резуль-
 тате, то печатается ошибочное состояние TLOSS на stderr и возвра-
 щается 0. В обоих случаях errno устанавливается в ERANGE.        
 Функция sinh возвращает значение гиперболического синуса x. Если
 результат большой, то errno устанавливается в ERANGE и возвращается
 значение HUGE(положительное или отрицательное, в зависимости от
 значения x)
 Обработку ошибок можно изменить, используя mather команду.
  
  
    СМОТРИ ТАКЖЕ

 acos,asin,atan,atan2,cos,cosh,tan,tanh
 

    ПРИМЕР

  #include <math.h>
  
  double pi=3.1415926535, x,y;         
 
  x=pi/2;
  y=sin(x);   /* y = 1.0 */
  y=sinh(x);  /* y = 2.3 */
  
  
 


                          203

                          SOPEN     

    ФОРМАТ

  #include <fcntl.h>                                                     
  #include <sys\types.h>
  #include <sys\stat.h>
  #include <share.h>
  #include <io.h>
  
  int sopen(pathname,oflag,shflag[,pmode]);
  char *pathname;
  int oflag;
  int shflag;
  int pmode;
  
    
    ОПИСАНИЕ

  Функция открывает файл, определенный в pathname, и предоставляет
  файл для последующего чтения или записи, как определено в
  oflag и shflag. Целое выражение oflag формируется комбинацией
  одной или более явных констант, определенных в fcntl.h .
  Когда более одной явной константы заданы, они разделяются оператором
  ИЛИ (|).
      O_APPEND      Переместить указатель файла на конец файла перед
                    операцией записи;
      O_CREAT       Создать и открыть новый файл;
                    не дает эффект, если файл, определенный в pathname,
                    существует.
      O_EXECL       Возвращает ошибочное значение, если определенный
                    в pathname файл существует; применяется только
                    тогда, когда используется O_CREAT.
      O_RDONLY      Открыть файл только для чтения; если этот флаг
                    задан, ни O_RDWR , ни O_WRONLY не могут быть за-
                    даны.
      O_RDWR        Открыть файл только для чтения и записи; если этот
                    флаг задан, ни O_RDWR, ни O_WRONLY не могут быть
                    заданы.
      O_TRUNC       Открыть и сжать файл до нулевой длины; файл должен
                    иметь доступ для записи; содержимое файла теряется.
      O_WRONLY      Открыть файл только для чтения; если этот флаг за-
                    дан, ни O_RDONLY, ни O_RDWR не могут быть заданы.
      O_BINARY      Открыть файл в бинарном(непереводимом) виде.
                    (Смотри fopen для описания текстового вида).
                    
      Замечание:O_TRUNC затиряет содержимое существующего файла.
                Используется с осторожностью.
                            204
  
  Аргумент shflag является константным выражением, состоящим из одной
  или более явных констант, определенных в share.h . Смотри MS-DOS 
  документацию для получения подробной информации о распределенных
  видах.
  
      SH_COMPAT      Установить совместимый вид.
      SH_DENYRW      Отказать доступ к файлу для чтения и запмси.
      SH_DENYWR      Отказать доступ для записи.
      SH_DENYRD      Отказать доступ для чтения.
      SH_DENYNO      Разрешить доступ для чтения и записи.
      
  Аргумент pmode требуется только тогда, когда определен O_CREAT.
  Если файл не существует, pmode определяет способ доступа к файлу,
  которые устанавливаются, когда новый файл закрывается в первый раз.
  В другом случае аргумент pmode игнорируется. Аргумент pmode является
  целым выражением, содержащим одну или две явные константы, такие как
  S_IWRITE и S_IREAD, определенные в sys\stat.h. Когда обе константы
  заданы, они разделяются оператором ИЛИ (|). Суть pmode аргумента в 
  следующем:
       S_IWRITE             Доступ для записи
       S_IREAD              Доступ для чтения
       S_IREAD|S_IWRITE     Доступ для записи и чтения.
  Если доступ для записи не задан, то файл только для чтения.
  Под MS-DOS все файлы доступны для чтения; поэтому нет необходимости
  задавать доступ только для записи. Таким образом S_IWRITE и   
  S_IREAD|S_IWRITE элвивалентны.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Файл handle для открытого файла.
  -1  индицирует об ошибке; при этом errno устанавливается в одно из
      следующих значений: 
       EACCES    Заданное имя пути является каталогом; или была
                 попытка открыть файл для записи, который только
                 для чтения; или произошло нарушение распределения.
       EEXIT     Флаги O_CREAT и O_EXCL определены, но файл уже
                 существует.
       EINVAL    SHARE.COM не установлено.
       EMFILE    Нет более доступных handle(слишком много открытых
                 файлов).
       ENOENT    Файл или путь не найдены.
       
  
    СМОТРИ ТАКЖЕ

   close,creat,fopen,open.umask
   
    Замечание:Функция sopen должна быть использована только под
              MS-DOS версии 3.0 и позже. Под ранними версиями
              аргумент shflag игнорируется.
                            205
   
    ПРИМЕР

  #include <fcntl.h>
  #include <sys\types.h>
  #include <sys\stat.h>
  #include <share.h>
  #include <io.h>
  
  extern unsigned char _osmajor;
  int fh;
  
         /*   Переменная _osmajor используется, чтобы проверить
         **   номер версии MS-DOS перед вызовом sopen
         */
         
  if (_osmajor >=3)
          fh=sopen("data",O_RDWR|O_BINARY, SH_DENYRW);
  else
          fh=open("data", O_RDWR|O_BINARY);
          
 
                            206

                         SPAWNL-SPAWNVPE     

    ФОРМАТ

  #include <stdio.h>  
  #include <process.h>
 
  int spawnl(modeflag,pathname,arg0,arg1...,argn,NULL);
  int spawnle(modeflag,pathname,arg0,arg1...,argn,NULL,envp);
  int spawnlp(modeflag,pathname,arg0,arg1...,argn,NULL);
  int spawnlpe(modeflag,pathname,arg0,arg1...,argn,NULL,envp);
  int spawnv(modeflag,pathname,argv);
  int spawnve(modeflag,pathname,argv,envp);
  int spawnvp(modeflag,pathname,argv);
  int spawnvpe(modeflag,pathname,argv,envp);
  
  int modeflag;
  char *pathname;
  char *arg0,*arg1,...,*argn;
  char *argv[];
  char *envp[];
  
  
    ОПИСАНИЕ

  Функции spawn создают и выполняют новый порождаемый процесс.
  Достаточно памяти должно быть доступно для загрузки и выполнения
  порождаемого процесса. Аргумент modeflag определяет: действие будет
  браться от процесса родителя перед или в течение spawn. Следующие
  значения для modeflag определены в process.h:
       P_WAIT     Приостановить процесс родителя, пока выполнение  
                  порождаемого процесса не завершится.
       P_NOWAIT   Продолжать выполнять процесс родитель вместе с
                  порождаемым процессом.
       P_OVERLAY  Наложить порождаемый процесс на процесс родитель,
                  затерев родитель(такой же эффект, как вызов exec)
                  
  Только P_WAIT и P_OVERLAY могут быть в настоящее время использо-
  ваться. P_NOWAIT заложен для будущих возможностей. Использование
  P_NOWAIT возвратит код ошибки.
  Аргумент pathname определяет файл, который будет выполняться,
  как порождаемый процесс. Pathname может определить полный путь
  (с корня), частичный путь(с текущего каталога) или просто имя
  файла. Если неуспешно, то расширение  .EXE  добавляется и делается
  новая попытка. Если pathname содержит расширение, только это расши-
  рение используется. Если pathname заканчивается точкой,то поиск
  ведется для pathname без расширения. Spawnlp,spawnlpe,spawnvp и 
  spawnvpe команды ведут поиск для pathname (используя определенные
  процедуры) в каталогах,определяемых в переменной окружения PATH.
  
  Аргументы передаются порождаемому процессу , заданием одного или
  более указателей на символьные строки,как аргументы при spawn вы-
  зове. Эти символьные строки формируют список аргументов для
  порождаемого процесса. Комбинация длин строк , формирующих список
  аргументов, не должен превышать 128 байтов. Нулевой символ 
  ('\0') для каждой строки не учитается, но символы пробелы, разделя-
  ющие аргументы , учитываются.
                            207
  
  Аргументы указателя могут быть переданы как отдельные аргументы
  (spawnl, spawnle, spawnlp, spawnlpe) или как массив указателей 
  (spawnv, spawnve, spawnvp, spawnvpe). Минимум один аргумент, 
  arg0 или argv[0] должен быть передан порождаемому процессу. По со-
  глашению, этот аргумент является копией pathname.(Различные значения
  не вырабатывают ошибку). Под MS-DOS раньше 3.0 , передаваемое зна-
  чение arg0 или argv[0] не доступен для порождаемого процесса.
  Под MS-DOS 3.0 и позже доступен.
  Вызов spawnl, spawnle, spawnlp, spawnlpe обычно используется,
  когда число аргументов известно заранее. Аргумент arg0 обычно 
  является указателем на символьные строки, формирующие новый список
  аргументов. Следующим за argn должен быть NULL указатель, означающий
  конец списка аргументов.    
  Вызов spawnv, spawnvp, spawnve, spawnvpe обычно используются,
  когда число аргументов переменно. Указатели на аргументы передаются
  как массив argv. Аргумент argv[0] обычно является указателем на
  pathname, а от argv[1] до argv[n] -указатели на символьные строки,
  формирующие новый список аргументов. Аргумент argv[n+1] должен
  быть NULL указатель, означающий конец списка аргументов.
  Файлы, которые были открыты, когда spawn вызвался, остаются откры-
  тыми в порождаемом процессе. При вызове spawnl, spawnlp, spawnv,
  spawnvp, порождаемый процесс унаследует и окружение родителя.
  Вызов spawnle, spawnlpe, spawnve или  spawnvpe позволяют пользова-
  телю вносить изменения в окружение для порождаемого процесса,
  передав список окружающих характеристик через envp аргумент.
  Аргумент envp является массивом символьных указателей , каждый эле-
  мент которого (за исключением последнего элемента ) указывает на 
  строку , завершающимся нулевым символом ('\0'), определяющую 
  переменную окружения. Такая строка обычно имеет форму:
     NAME = value
  где NAME - имя переменной окружения , а value является строковым
  значением , в которую переменная устанавливается. (Заметим, что
  value не заключается в двойные кавычки). Последним элементом
  массива envp должен быть  NULL. Когда envp содержит только NULL,
  порождаемый процесс унаследует окружение от родителя.
  
  
  ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Статус завершения порождаемого процесса.
  Статус завершения есть 0, если процесс завершится нормально.
  Статус завершения может быть установлен в ненулевое значение,
  если порождаемыйпроцесс специально вызвал exit команду с ненулевым
  аргументом. Если не установлено, положительный статус завершения
  индицирует о ненормальном завершении: abort или прерывание.
  -1  индицирует об ошибке (порождаемый процесс не стартовал);
  и errno устанавливается в одно из следующих значений:
    E2BIG     Список аргументов превышает 128 к, или область ,
              требуемая для информации окружения, превышает 32 к.
    EINVAL    Недействительный аргумент modeflag
    ENOENT    Файл или имя пути не найдены.
    ENOEXEC   Определяемый файл не выполняемый, или имеет недействи-
              тельный формат, чтобы выполняться
    ENOMEM    Нет достаточной доступной памяти, чтобы выполнить
              порождаемый процесс.
                            208
              
  Замечание:
  
  Spawn вызовы не перенимают переводимый вид открытого файла.
  Если порождаемый процесс использует файлы , унаследованные от
  родителя, setmode команда должна быть использована , чтобы
  установить переводимый вид этих файлов к желаемому виду.
  Сигнал окружения не перенимается порождаемым процессом , созданным
  по вызову spawn команды. Сигнал окружения устанавливается по
  умолчанию в порождаемом процессе.
  
  
  СМОТРИ ТАКЖЕ

  abort, execl, execle, execlp, execlpe, execv, execve, execvp,
  execvpe, exit, _exit, onexit, system
  
  
    ПРИМЕР

  #include <stdio.h>
  #include <process.h>
  
  extern char **envirion;
  
  char *args[4];
  int result;
  
  args[0]="child";
  args[1]="one";
  args[2]="two";
  args[3]=NULL;
  .
  .
  .
  /* Следующие утверждения деляют попытку запустить порождаемый
     процесс "child.exe" и передать ей 3 аргумента.
     Первые 3 оставляют процесс родитель, последние 3 накладывают 
     порождаемый процесс на родителя
  */
  result=spawnl(P_WAIT,"child.exe","child","one","two",NULL);
  result=spawnle(P_WAIT,"child.exe","child","one","two",
         NULL,envirion);
  result=spawnlp(P_WAIT,"child.exe","child","one",
         "two",NULL);
  result=spawnv(P_OVERLAY,"child.exe",args);
  result=spawnve(P_OVERLAY,"child.exe",args,envirion);
  result=spawnvp(P_OVERLAY,"child.exe",args);
                           209

                          SPRINTF
                          
    ФОРМАТ

  #include <stdio.h>    
  int sprintf(buffer,format-string[,argument...]);
  char *buffer;
  char *format-string;
  

    ОПИСАНИЕ

  Функция форматирует и помещает наборы символов и значений в buffer.
  Каждый аргумент (если несколько) преобразуется и выводится согласно
  соответствующей спецификации формата в format-string. Format-string
  состоит из обычных символов и имеет определенную форму и функцию,
  как format-string аргумент для printf функции; смотри описание
  printf для получения описания format-string и arguments.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Число символов , помещенных в buffer.
  
  
    СМОТРИ ТАКЖЕ

  fprintf,printf,sscanf
  
  
    ПРИМЕР

  #include <stdio.h>
               
  char buffer[200];
  int i,j;
  double fp;
  char *s="computer";
  char c;
  .
  .
  .
  /* Преобразовать и напечатать различные данные  */
  
  j=sprintf(buffer, "%s\n",s);
  j += sprintf(buffer+j,"%c\n",c);
  j += sprintf(buffer+j,"%d\n",i);
  j += sprintf(buffer+j,"%f\n",fp);
  
  
  
                            210

                            SQRT 
                          

    ФОРМАТ

  #include <math.h>    
  
  double sqrt(x);
  double x;
  

    ОПИСАНИЕ

  Функция вычисляет квадратный корень от x.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Результат квадратного корня.
  0 ,если х отрицательное; при этом errno устанавливается в EDOM и
  печатается ошибочное сообщение DOMAIN. Обработку ошибки можно
  изменить , используя mather команду.
  
  
    СМОТРИ ТАКЖЕ

  exp,log,matherr,pow
  
  
    ПРИМЕР

  #include <math.h>
  #include <stdlib.h>
  
  double x, y, z;
  .
  .
  .
  if ((z=sqrt(x+y)) == 0.0)
         if ((x+y) < 0.0)
                 perror("sqrt от отрицательного числа").
                 
                 
  
               
                          211

                          SRAND  
                          

    ФОРМАТ

  #include <stdlib.h>    
  
  void srand(seed);
  unsigned seed;
  

    ОПИСАНИЕ

 Функция устанавливает стартовую точку для сгенерированных наборов
 псевдослучайных целых. Чтобы переинициализировать генератор,
 используйте 1 ,как seed аргумент. При других значениях для seed 
 устанавливается случайная стартовая точка.
 Rand функция используется , чтобы найти сгенерированные случайные
 числа.
 
 
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Нет кодов возврата.
  
  
    СМОТРИ ТАКЖЕ

  rand
  
  
    ПРИМЕР

  #include <stdlib.h>
  #include <stdio.h>
  
  int x, ranvals[20];
  
  /* Проинициализировать генератор случайных чисел и сохранить
  ** первые 20 случайных чисел сгенерированных в массиве
  */
  
  srand(17);
  for (x=0; x<20; ranvals[x++]=rand( ))
  
  
                           212

                          SSCANF

    ФОРМАТ

  #include <stdio.h>    
  
  int sscanf(buffer,format-string[,argument...]);
  char *buffer;
  char *format-string;
  

    ОПИСАНИЕ

  Функция читает данные из buffer в расположения, заданные в arguments.
  Каждый аргумент должен быть указателем на переменную с типом,
  которая соответствует типу, определенному в format-string.
  Format-string управляет интерпретацией входных полей и имеет неко-
  торую форму и функцию, как format-string аргумент для scanf функции:
  смотри описание scanf функции для получения описания format-string.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Число полей , которые были успешно преобразованы и присвоены.
  Возвращаемое значение не включает поля, которые были прочитаны,
  но не присвоены.
  EOF , если была попытка прочитать конец файла .
  0 ,если не было присвоенных полей.
  
  
    СМОТРИ ТАКЖЕ

  fscanf, scanf, sprintf
  
  
    ПРИМЕР

  #include <stdio.h>
  
  char *tokenstring = "15 12 14...";
  int i;
  float fp;
  char s[81];
  char c;
  .
  .
  .
  /* Ввод различных данных
  */
  
  sscanf(tokenstring, "%s",s);
  sscanf(tokenstring, "%c",&c);
  sscanf(tokenstring,"%d",&i);
  sscanf(tokenstring,"%f",&fp);
  
  
  
               
                            213

                          STACKAVAIL

    ФОРМАТ
    
    unsigned int stackavail();
    
  #include <malloc.h>   /* используется только для описания функции */

    ОПИСАНИЕ
    Функция возвращает приблизительный размер в байтах памяти,
     доступной для динамического получения памяти по alloca.
     

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Размер в байтах, как беззнаковое целое значение.
    
    СМОТРИ ТАКЖЕ

    alloca,freect,memavl
    
    ПРИМЕР

  # include <malloc.h>
  main( )
        {
        char *ptr;
        printf("Stack memory available before alloca = %u\n,
                stackavail( ));
        ptr = alloca(1000*sizeof(char));
        printf("Stack memory available after alloca = %u\n,
                stackavail( ));
        }
        
    ВЫВОД
    
    Stack memory available before alloca = 1682
    Stack memory available after alloca = 678
    

                          214

                          STAT
                          

    ФОРМАТ

  #include <sys\types.h>    
  #include <sys\stat.h>
  
  int stat(pathname, buffer);
  char *pathname;
  struct stat *buffer;
  

    ОПИСАНИЕ

  Функция получает информацию о файлах и каталогах, определенных
  в pathname, и помещает ее в структуру, на которую указывает буфер.
  Stat структура, определенная в sys\stat.h , содержит следующие
  поля:
      st_mode      Бит маска для вида информации в файле.
                   S_IFDIR , бит устанавливается , если pathname
                   определяет каталог; S_IFREG бит устанавливается,
                   если pathname определяет обычный файл.
                   Пользователь устанавливает бит чтения/записи.
                   Согласно способу доступа к файлу; для установки
                   битов используется расширение имени файла.
      st_dev       Номер драйвера диска, содержащий файл.
     st_rdev       --"--"--"--"--"--"--"--"--"--"--"--"--"--"--"
     st_nlink      Всегда 1.
     st_size       Размер файла в байтах.
     st_atime      Время последней модификации файла.
     st_mtime      --"--"--"--"--"--"--"--"--"--"--"--"--"--"--"--"
     st_ctime      --"--"--"--"--"--"--"--"--"--"--"--"--"--"--"--" 
     
  Есть еще поля в stat структуре , но они не содержат значимой
  информации для MS-DOS.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ


  0, если информация о статусе файла получена.
  -1, если имя файла или имя пути не могут быть найдены ; errno
      устанавливается в ENOENT.
      
      
    СМОТРИ ТАКЖЕ

  access, fstat
  
                            215
  
    ПРИМЕР

  #include <sys\types.h>
  #include <sys\stat.h>
  #include <stdio.h>
  
  struct stat buf;
  int result;
  char *args[4];
  .
  .
  .
  result = stat("child.exe",&buf);
  
  if (result == 0)
          if (buf.st_mode & S_IEXEC)
                  execv("child.exe",args);
                  
                  
               

                            216

                          STATUS87

    ФОРМАТ
  
  #include <float.h> 

  unsigned int _status87();
    

    ОПИСАНИЕ
    
    Функция получает слово статуса плавающей точки.Слово статуса
     плавающей точки является комбинацией 8087/80287 слов статуса
     и других условий, обнаруженных 8087/80287 обработчиком исключений,
     такие как переполнение и недополнение с плавающей точкой.
     
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Бит, индицирующий статус плавающей точки.
    Смотри включаемый файл float.h для получения полного описания
    битов, возвращаемых _status87.
    
    СМОТРИ ТАКЖЕ

    _clear87, _control87
    
    ПРИМЕР

  # include <stdio.h>
  # include <float.h>
  
  double a = 1e-40,b;
  float x,y;
  main ( )
        {
        printf("status = %.4x-clear\n",_status87( ));
        /*
        */
        y=a;
        printf("status = %.4x-inexact,underflow,denormal\n",
                _status87( ));
        /*
        */
        b=y;
        printf("status = %.4x-inexact,underflow,denormal\n",
               _status87( ));
        /*
        */
        _clear87( );
        }
        
               

                            217

                        STRCAT-STRDUP

    ФОРМАТ
  
  #include <string.h>  /* используется только для описания функции */

    char *strcat(string1,string2);
    char *string1;
    char *string2;
    
    char *strchr(string,c);
    char *string;
    int c;
    
    int strcmp(string1,string2);
    char *string1;
    char string2;
    
    int strcmpi(string1,string2);
    char *string1;
    char *string2;
    
    char strcpy(string1,string2);
    char *string1;
    char *string2;
    
    int strcspn(string1,string2);
    char *string1;
    char *string2;
    
    char *strdup(string);
    char *string;
    
    int stricmp(string1,string2);
    char *string1;
    char *string2;
    

    ОПИСАНИЕ

    Функции strcat,strchr,strcmp,strcmpi,strcpy,strcspn,strdup и
    stricmp оперируют со строками, которые завершаются нулевым
    символом ('\'). Проверка на переполнение не выполняется,
    когда строка копируется или добавляется.
    Функция strcat добавляет string2 в string1, завершает строку ре-
    зультат нулевым символом и возвращает указатель на сцепленную
    строку (string1).
    Функция strchr возвращает указатель на первое местонахождение
    символа с в строке string. Символ c может быть нулевым символом
    ('\0'); тогда поиск ведется для нулевого символа. Функция
    возвращает NULL, если символ не найден.
    Функция strcmp сравнивает string1 и string2 лексографически и
    возвращает значение, индицирующее их взаимоотношение, как
    следующее:
     меньше 0   string1 меньше чем string2
       0        string1 идентично string2
     больше 0   string1 больше чем string2
                            218
     
    Функции strcmpi и stricmp являются менее чувствительной версией
    strcmp. Аргументы string1 и string2 сравниваются в таком варианте,
    что заглавные и прописные буквы считаются эквивалентными.
    Функция strcpy копирует string2, включая завершающий нулевой символ
    в расположение, определяемое через string1, и возвращает указатель
    в string1.
    Функция strcspn возвращает индекс первого символа в string1,
    который принадлежит набору символов, определяемых в string2.
    Это значение эквивалентно длине начальной подстроки string1,
    которая не содержит символы из string2. Завершающий нулевой
    символ не рассматривается для поиска. Если string1 начинается с 
    символа из string2, то возвращается 0.
    Функция strdup получает область памяти ( по вызову malloc) для
    копироввания строки и возвращает указатель на область памяти
    которая содержит скопированную строку. Возвращает NULL, если
    не могла быть получена память.
    
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Описаны выше.
    
    СМОТРИ ТАКЖЕ

    strncat,strncmp,strncpy,strnicmp,strrchr,strspn
    
    ПРИМЕР

  # include <string.h>
  
    char string[100], template[100], *result;
    int numresult;
    .
    .
    .
    /* Собирается строка "computer program", используя strcpy,strcat
    */
    
    strcpy(string,"computer");
    result = strcat(string,"program");
    /* Ведет поиск первого местонахождения 'a' в строке
    */
    result = strchr(string,'а');
    /* Определяет: строка больше, меньше или равна другой
    */
    numresult = strcmp(string,template);
    /* Сравнение двух строк, когда заглавные и прописные буквы
       считаются одинаковыми */
    numresult = strcmpi("hello","HELLO");
    /* Сделать копию строки
    */
    result = strcpy(template,string);
    /* Поиск для символов a,b,c в строке
    */
    strcpy(string,"xyzabbc");
    result = strcspn(string,"abc");
    /* Сделать новый указатель на строку, продублировав ее
    */
    result = strdup(string);
    
    
               

                            219

                          STRERROR

    ФОРМАТ
  
  #include <string.h>  /* используется только для описания функции */
    
    char *strerror(string);
    char *string;
    int errno;
    int sys_nerr;
    char sys_errlist[sys_nerr];
    

    ОПИСАНИЕ

     Если string является NULL, функция возвращает указатель
     на строку, которая содержит системное ошибочное сообщение для
     последнего вызова библиотеки, которая дала ошибку;эта строка
     завершается символом новой строки('/n').
     Eсли string не равна NULL, то функция возвращает указатель на
     строку, содержащую, по порядку: вашу строку сообщения,
     двоеточие, пробел, системное ошибочное сообщение для 
     посделнего вызова библиотеки, которая дала ошибку, и символ 
     новой строки.Ваша строка сообщения может быть длиной максимум
     94 байта.
     В отличие от perror, strerror сама не печатает никаких сообщений.
     Чтобы напечатать сообщение, возвращаемое strerror, на stderr,
     вашей программе необходимо printf утверждение, как показано в
     следующей строке:
           if ((access("datafile",2))==-1)
              printf(strerror(NULL));
     Действительный код ошибки помещается в переменную errno, которая
     должна быть описана на внешнем уровне. К системному ошибочному
     сообщению получают доступ через переменную sys_erlist, которая
     является массивом сообщений, упорядоченным по кодам ошибок.
     Функция strerror получает доступ к нужному ошибочному сообщению,
     используя значение errno как индекс для sys_errlist. Значение
     переменной sys_nerr определяется, как максимальное число
     элементов в массиве sys_errlist.
     Чтобы результат был правильным, strerror должна быть вызвана 
     непосредственно за библиотечной командой, которая вернула
     ошибку. Иначе, значение errno может быть затерто последующими    
     вызовами.
     
     Замечание:
      Под MS-DOS некоторые errno значения из списка errno.h не
      используются. Смотри  Приложение А " Ошибочные сообщения" для
      получения списка errno значений, используемым в MS-DOS, и их
      соответствия ошибочным сообщениям. Функция strerror печатает
      пустую строку для errno значений, которые не используются под
      MS-DOS.
      
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Нет кодов возврата.
    
    СМОТРИ ТАКЖЕ

    clearerr,ferror,perror
                            220
    
    ПРИМЕР

  #include <fcntl.h>
  #include <sys\types.h>
  #include <sys\stat.h>
  #include <io.h>
  #include <stdlib.h>
  
  int fh1,fh2;
  fh1 = open("data1",O_RDONLY);
  if (fh1==-1)
       strerror("попытка открыть входной файл неудачна");
  fh2 = open("data2",O_WRONLY|O_TRUNC|O_CREAT,
                     S_IREAD|S_WRITE);
   if (fh2==-1)
        strerror("попытка открыть выходной файл неудачна");
        
               

                           221

                          STRLEN

    ФОРМАТ
  
  #include <string.h> /* используется только для описания функции */
    
    int strlen(string);
    char *string;
    

    ОПИСАНИЕ
    
    Функция возвращает длину строки string в байтах, не
     учитывая завершающий нулевой символ ('\0').
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Длина строки.
    Нет ошибочных кодов возврата.
    
    
    ПРИМЕР

  #include <string.h>
  
    char *string = "some space";
    int result;
    .
    .
    .
    /* Определить длину строки
    */
    result = strlen(string);
    
               

                           222

                          STRLWR

    ФОРМАТ
  
  #include <string.h>  /* используется только для описания функции */
    
    char strlwr(string);
    char *string;
    

    ОПИСАНИЕ
    
    Функция преобразует заглавные буквы в заданной строке string,
     завершающейся нулевым символом ('\0'), в прописные.
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на преобразованную строку string.
    Нет ошибочных кодов возврата.
    
    СМОТРИ ТАКЖЕ

    strupr
    
    ПРИМЕР

  #include <string.h>
  char string[100], *copy;
  .
  .
  .
  /* Сделать прописную копию строки
  */
  copy = strlwr(strdup(string));
  
               

                            223

                       STRNCAT-STRNSET

    ФОРМАТ
  
  #include <string.h>  /* используется только для описания функции */

    char *strncat(string1,string2,n);
    char *string1;
    char *string2;
    unsigned int n;
    
    int strncmp(string1,string2.n);
    char *string1;
    char *string2;
    unsigned int n;
    
    int strnicmp(string1,string2,n);
    char *string1;
    char *string2;
    unsigned int n;
    
    char *strncpy(string1,string2,n);
    char *string1;
    char *string2;
    unsigned int n;
    
    char *strnset(string,c,n);
    char *string;
    int c;
    unsigned int n;
    
    ОПИСАНИЕ

    Функции strncat,strncmp,strnicmp,strncpy,strnset оперируют,
     самое большее, первых n символов с завершающимися нулевым
     символом строками.
     Функция strncat добавляет, самое большее, первые n
     символов string2 в string1, завершает результирующую строку с
     нулевым символом ('\0') и возвращает указатель на сцепленную 
     строку(string1). Если n больше чем длина string2, то длина
     string2 используется вместо n.
     Функция strncmp сравнивает, самое большее, первые n символов
     string1 и string2 лексографически и возвращает значение, 
     индицирующее взаимоотношение между подстроками, как показано
     ниже.
      Меньше 0    substring1 меньше чем substring2
         0        substring1 идентично substring2
      Больше 0    substring1  больше чем substring2.
    Функция strnicmp является менее чувтсвительной версией strncmp;
    функция сравнивает две строки string1 и string2 в таком варианте,
    что заглавные и прописные считаются эквивалентными.
    Функция  strncpy копирует точно n символов string2 в string1 и
    возвращает string1. Если n меньше чем длина string2, нулевой символ
    ('\0') не добавляется автоматически в скопированную строку.
    Если n больше чем длина string2, то в строку результат добавляется
    нулевой символ ('\0') после n символов.
    Функция strnset устанавливает, самое большое первых n символов 
    string в символ с и возвращает указатель на измененную строку 
    string. Если n больше чем длина string, то длина string используется
    вместо n.
                            224
    
    
    СМОТРИ ТАКЖЕ

    strcat,strcmp,strcpy,strset
    
    ПРИМЕР

  #include <string.h>
  
    char string[30] = {"12345678901234567890"};
    main( )
    {
    char copy[100],suffix[100],*result;
    int numresult;
    unsigned int nresult;
    .
    .
    .
    /* Обьеденить string с не более 10 символами suffix
    */
    result = strncat(string,suffix,10);
    /* Определить старшинство string по отношению к "program", но
       расматривается не более 7 символов */
    strcpy(string,"programmer");
    numresult = strncmp(string,"program",7); /* numresult = 0 */
    /* Сравнить 4 символа двух строк, считая заглавную и прописную 
    букву равными
    */
    strcpy(string,"PROGRESS");
    nresult = strnicmp(string,"program",4); /*  nresult = 0 */
    /* Скопировать максимум 99 символов string
    */
    result = strncpy(copy,string,99);
    /* Установить первые 4 символа string в 'x'
    */
    result = strnset("computer",'x',4); /* result = "xxxxuter" */
    }
    
               

                           225

                          STRPBRK

    ФОРМАТ
    
  #include <string.h> /* используется только для описания функции */
    
    char *strpbrk(string1,string2);
    char *string1;
    char *string2;
    

    ОПИСАНИЕ

    Функция находит первое местоположение в string1 любого символа
    из string2. Завершающий нулевой символ ('\0') не включается в
    поиск.
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на первое местоположение любого символа из string2 в
    string1.
    NULL указатель, если нет общих символов.
    
    СМОТРИ ТАКЖЕ

    strchr,strrchr
    
    ПРИМЕР

  # include <string.h>
  
  char string[100], *result;
  .
  .
  .
  /* Возвращает первое местонахождение либо 'a' либо 'b' в string
  */
  result = strpbrk(string,"ab");
  
               

                          226

                         STRRCHR

    ФОРМАТ
    
  #include <string.h>   /* используется только для описания функции */
    
    char *strrchr(string,c);
    char *string;
    int c;
    

    ОПИСАНИЕ
    
    Функция находит последнее местоположение символа с в string.
     Завершающий нулевой символ включается в поиск.
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на последнее местоположение с в string.
    NULL, если заданный символ не найден.
    
    СМОТРИ ТАКЖЕ

    strchr,strpbrk
    
    ПРИМЕР

  #include <string.h>
  char string[100], *result;
  .
  .
  .
  /* Ведет поиск последнего местонахождения 'a' в string
  */
  result = strrchr(string,'a');
  
               

                           227

                          STRREV

    ФОРМАТ
    
  #include <string.h>  /* используется только для описания функции */
    
    char *strrev(string);
    char *string;
    

    ОПИСАНИЕ
    
    Функция изменяет порядок символов в string на противоположный.
    Завершающий нулевой символ ('\0') остается на месте.
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на измененную строку.
    
    СМОТРИ ТАКЖЕ

    strcpy,strset
    
    ПРИМЕР

  #include <string.h>
  char string[100];
  int result;
  .
  .
  .
  /* Определить: является ли string полиндромом (читается одинаково
     вперед и назад */
  result = strcmp(string,strrev(strdup(string)));
  /* Если result == 0 , то string полиндром 
  */
  
               

                          228

                         STRSET

    ФОРМАТ
    
  #include <string.h>  /* используется только для описания функции */
    
    char *strset(string,c);
    char *string;
    int c;
    

    ОПИСАНИЕ
    
    Функция устанавливает все символы заданного string, за
     исключением завершающего нулевого символа ('\0'), в с.
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на измененную строку.
    
    СМОТРИ ТАКЖЕ

    strnset
    
    ПРИМЕР

  #include <string.h>
  char string[100], *result;
  .
  .
  .
  /* Устанавливает строку пробелов
  */
  result = strset(string,' ');
  
               

                           229

                          STRSPN

    ФОРМАТ
    
  #include <string.h>  /* используется только для описания функции */
    
    int strspn(string1,string2);
    char *string1;
    char *string2;
    

    ОПИСАНИЕ
    
    Функция возвращает индекс первого символа в string1,который
     не принадлежит набору символов string2;
     Это значение эквивалентно длине начальной подстроки string1,
     которая содержит только символы из string2;
     Нулевой символ, завершающий string2, не рассматривается.
     Если string1 начинается с символа не из string2, strspn
     возвращает 0.
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Значение целого, определяющее позицию первого символа в string1,
    которое не из string2.
    
    СМОТРИ ТАКЖЕ

    strcspn
    
    ПРИМЕР

  #include <string.h>
    char *string="cabbage";
    int result;
    .
    .
    .
    /* result = 5
    */
    result = strspn(string,"abc");
    
               

                          230

                         STRSTR

    ФОРМАТ
    
  #include <string.h>  /* используется только для описания функции */
    
    char *strstr(string1,string2);
    char *string1;
    char *string2;
    

    ОПИСАНИЕ
    
    Функция возвращает указатель на первое  местоположение string1 в
    string2.
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на string1, если найдено string1.
    NULL, если не найдено.
    
    СМОТРИ ТАКЖЕ

    strcspn
    
    ПРИМЕР

  #include <string.h>
  main( )
        {
        char *string1 = "needle in a haystack";
        char *string2 = "hay";
        printf("%s\n",strstr(string1,string2));
        }
        
    ВЫВОД
    
    haystack
    
               

                          231

                      STRTOD-STRTOL

    ФОРМАТ
    
  #include <stdlib.h>
    
    double strtod(nptr,endptr);
    char *nptr;
    char **endptr;
    
    long strtol(nptr,endptr,base);
    char *nptr;
    char **endptr;
    int base;
    

    ОПИСАНИЕ

    Функции strtod и strtol преобразуют строку символов в значение
     длинное с плавающей точкой или длинное целое соответственно.
     Строка символов является последовательностью символов, которая
     может быть интерпретирована как числовые значения определенного
     типа. Эти функции прекращают чтение строки с первого символа,
     которое они не могут распознать как часть числа (которое
     может быть нулевым символом,завершающим строку);для strtol
     этим последним символом может быть также первый числовой символ,
     больший или равный base. Если endptr не NULL, то *endptr указывает
     на символ, который прекращает рассмотрение(сканирование).
     Функция strtod предполагает nptr, чтобы указать на строку
     следующего вида:
     [ограничитель][знак][цифры][.цифры][{d|D|e|E}[знак]цифры]
     Первый символ, который не соответствует этой форме прекращает
     сканирование.
     Функция strtol предполагает nptr, чтобы указывать на строку
     следующего вида:
     [ограничитель][знак][0][x][цифры]
     Если base лежит между 2 и 36, то он используется как основание
     для числа. Если base есть 0 ,то начальные символы строки, на 
     которые указывает nptr, используются, чтобы определить основание:
     если первый символ есть '0' и второй символ есть цифры '1'-'7',
     то строка интерпретируется как восьмеричное целое;если первый
     символ есть '0' и второй символ есть 'x' или 'X', то строка
     интерпретируется как шестнадцатиричное целое; если первый символ
     есть '1'-'9', то строка интерпретируется как десятичное целое.
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Функция strtod возвращает значение числа с плавающей точкой.
    HUGE, если произошло переполнение или недополнение.
    Функция strtod возвращает результат преобразованной строки.
    LONG_MIN соответственно, если произошло переполнение или  
    недополнение.В обоих случаях errno устанавливается в ERANGE.
    
    СМОТРИ ТАКЖЕ

    atof,atol
                            232
    
    ПРИМЕР

  #include <stdlib.h>
     main( )
         {
         char *string,*stopstring;
         double x;
         long l;
         int bs;
         
         string ="3.1415926This stopped it";
         x =strtod(string,&stopstring);
         printf("string = %s\n",string);
         printf("   strtod=%f\n",x);
         printf("   stopped scan at %s\n\n", stopstring);
         
         string="10110134932";
         printf("string=%s\n",string);
         for (bs=2;bs<=8;bs *= 2) {
             1= strtol(string,&stopstring,bs);
             printf("   strtol=%1d (base %d)\n",1,bs);
             printf("   stopped scan at %s\n\n",stopstring);
             }
        }
        
    ВЫВОД
    
    string=3]1415926Nhis stopped it;
    strtod=3.141593
    stopped scan at This stopped it;
    
    string=10110134932
    strtol=45(base2)
    stopped scan at 34932
    
    strtol=4423(base 4)
    stopped scan at 4932
    
    strtol=2134108(base 8)
    stopped scan at 932
    
               
                           233

                          STRTOK

    ФОРМАТ
  
  #include <string.h> /* используется только для описания функции */
    
    char *strtok(string1,string2);
    char *string1;
    char *string2;
    

    ОПИСАНИЕ
    
    Функция читает string1,как набор нуль и более знаков, и string2,
     как набор символов, которые являются разделителями знаков в
     string1. Знаки в string1 могут быть разделены одним или более
     разделителями из string2. Знаки из string1 разделяются на наборы
     при вызове strtok.
     При первом вызове strtok для заданного string1, функция ведет
     поиск первого знака в string1.
     Чтобы прочитать следующий знак из string1, необходимо вызвать
     strtok c NULL значением string1 аргумента.
     NULL string1 аргумент заставляет strtok вести поиск для
     следующего знака в предыдущей знаковой строке.
     Набор разделителей может различаться от вызова к вызову, так что
     string2 может иметь любые значения.
     
     Замечание:
     Вызов strtok будет модифицировать string1 при каждом вызове strtok
     при этом вставляется нулевой символ ('\0') после знака в string1.
     
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    При первом вызове strtok она возвращает указатель на первый знак
    в string1. При последующем вызове с тем же знаком, strtok возвраща-
    ет указатель на следующий знак в строке. NULL указатель
    возвращается, когда нет более знаков. Все знаки завершаются      
    нулевым символом.
    
    СМОТРИ ТАКЖЕ

    strcspn,strspn
                            234
    
    ПРИМЕР

  #include <string.h>
  #include <stdio.h>
  char *string="a string,of.. tokens ";
  .
  .
  .
  /* Цикл выбирает слова (разделенные пробелами или запятыми) из строки
  */
  token = strtok(string," , ");
  while (token !=NULL ) {
                     /*
                     */
                     .
                     .
                     .
          token = strtok(NULL," , ");
                        }
                        /* Возвращаемыми словами являются "a",
                           "string","of","tokens"
                        */
                        
               
                          235

                         STRUPR

    ФОРМАТ
    
  #include <string.h>  /* используется только для описания функции */
    
    char *strupr(string);
    char *string;
    

    ОПИСАНИЕ
    
    Функция преобразует прописные буквы, заданные в string, в
    заглавные.
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на преобразованную строку.
    
    СМОТРИ ТАКЖЕ

    strlwr
    
    ПРИМЕР

  #include <string.h>
  char string[100], *copy;
  .
  .
  .
  /*
  */
  copy = strupr(strdup(string));
  
               
                          236

                          SWAB

    ФОРМАТ
  
  #include <stdlib.h>  /* используется только для описания функции */
    
    void swab(source,destination,n);
    char *source;
    char *destination;
    int n;
    

    ОПИСАНИЕ
    
    Функция копирует n байтов из source, меняя местами каждую пару
     смежных байтов, и помещает результат в destination. Целое n
     должно быть числом, который позволяет обмен. Функция обычно
     используется, чтобы бинарные данные перевести в машинные, которые
     используют различный порядок байтов.
     
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Нет кодов возврата
    
    СМОТРИ ТАКЖЕ

    fgetc,fputc
    
    ПРИМЕР

  # include <stdlib.h>
  #define NBYTES 1024
  
  char from[NBYTES], to [NBYTES];
  /* Корирует n байтов из одного расположения в другое,
     меняя местами каждую пару смежных байтов */
  swab(from,to,NBYTES);
  
               
                           237

                          SYSTEM

    ФОРМАТ
    
  #include <process.h>  /* используется только для описания функции */
  #include <stdlib.h>   /* исп-ся либо process.h либо stdlib.h */
    
    int system(string);
    char *string;
    

    ОПИСАНИЕ
    
    Функция рассматривает заданное string как командный интерпретатор
    и выполняет строку как команду MS-DOS. Функция посылает переменные
    окружения COMSPEC и PATH в файл MS-DOS COMMAND.COM, которая 
    используется чтобы выполнить string команду.
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, если строка успешно выполнилась.
    -1, индицирует об ошибке; errno устанавливается в одно из
    следующих значений:
    E2BIG     Список аргументов для команды превышает 128 байтов,
              или область, требуемая для информации окружения,
              превышает 32к.
    ENOENT    COMMAND.COM не может быть найдена.
    ENOEXEC   COMMAND.COM имеет неправильный формат и не выполняем.
    ENOMEM    Нет достаточной доступной памяти для выполнения команды;
              или доступная память испорчена;или существуют неправильные
              блоки, индицирующий,что процесс, который сделал вызов,
              был неправильно расположен.
              
    СМОТРИ ТАКЖЕ

    execl,execle,execlp,execv,execve,execvp,exit,_exit,spawnl,spawnle,
    spawnlp,spawnv,spawnve,spawnvp
    
    ПРИМЕР

  #include <process.h>
  int result;
  /* Следующее утверждение попытается скопировать
     номер версии DOS в log файл */
  result=system("ver >> result.log");
  
               
                           238

                          TAN-TANH

    ФОРМАТ
    
  #include <math.h> 
    
    double tan(x);
    double tanh(x);
    double x;
    

    ОПИСАНИЕ
    
    Функция tan и tanh возвращает тангенс и гиперболический тангенс,
    соответственно, от x.
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Функция tan возвращает тангенс от х. Если х большое и происходит 
    частичная утрата результата, то errno устанавливается в ERANGE и
    генерируется, но не печатается, ошибка PLOSS.
    Если х такое большое, что происходит утрата результата, то ERRNO
    устанавливается в ERANGE, возвращается 0, и печататется ошибочное
    сообщение TLOSS.
    Функция tanh возвращает гиперболический тангенс от х.
    
    СМОТРИ ТАКЖЕ

    acos,asin,atan,atan2,cos,cosh,sin,sinh
    
    ПРИМЕР

  #include <math.h>
    double pi,x,y;
    pi=3.1415926535;
    x=tan(pi/4.0);   /* x = 1.0 */
    y=tanh(x);       /* y = 1.6 */
    
               
                          239

                          TELL 

    ФОРМАТ
  
  #include <io.h>    /* используется только для описания функции */
    
    long tell(handle);
    int handle;
    

    ОПИСАНИЕ
    
    Функция получает текущую позицию указателя файла, связанное с 
    handle. Позиция выражается как число байтов от начала файла.
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Текущая позиция.
    -1L, если недействительный handle аргумент;при этом errno 
    устанавливается в EBADF.Для устройств терминала и принтера
    возвращаемое значение неопределено.
    
    СМОТРИ ТАКЖЕ

    ftell,lseek
    
    ПРИМЕР

  #include <io.h>
  #include <stdio.h>
  #include <fcntl.h>
  
  int fn;
  long position;
  fn=open("data",O_RDONLY);
  .
  .
  .
  position=tell(fn);
  .
  .
  .
  lseek(fn,position,0);
  
  
  
               
                              240

                         TEMPNAM-TMPNAM

    ФОРМАТ
    
  #include <stdio.h>
    
    char *tmpnam(string);
    char *string;
    
    char *tempnam(dir,prefix);
    char *dir;
    char *prefix;
    

    ОПИСАНИЕ
    
    Функция tmpnam генерирует имя временного файла, который будет
    доступен как временный файл. Это имя помещается в string. Если
    string есть NULL, то память получается для строки с использованием
    malloc. В случае использования malloc ответственность за 
    освобождение  памяти возлагается на пользователя.
    Строка символов, которую создает tmpnam, состоит из цифровых 
    символов от'0' до '9'; числовое значение строки может быть от 1 до
    65535.
    Функция tempnam позволяет создать пользователю временный файл в
    другом каталоге. Prefix является префиксом к имени файла.
    Функция просматривает файл с заданным именем в каталогах,пролистывая
    в порядке предшествования:
             Условие                           Используемый каталог для
                                                   tempnam
    Переменная окружения ТМР установлена и      Каталог,определенный
    каталог,определенный в ТМР существует        в ТМР
    Переменная окружения ТМР не установлена     Аргумент dir для
    или каталог, определенный в ТМР не           tempnam
    существует
    Аргумент dir есть NULL, или dir есть         P_tmpdir в stdio.h
    имя несуществующего каталога.
    P_tmpnam не существует                        \tmp
    Если все попытки неудачны, то tempnam возвращает значение NULL.
    
    
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Обе функции возвращают указатель на сгенерированное имя, за
    исключением, когда нет возможности создать это имя, или имя
    является не унмкальным. NULL, если имя не может быть создано или 
    уже существует.
    
    
    СМОТРИ ТАКЖЕ

    tmpfile
                            241
    
    ПРИМЕР

  #include <stdio.h>
  
  main()
     {
     char *name1,*name2;
     if ((name1=tmpnam(NULL)) !=NULL)
      printf("%s есть имя для временного файла.\n",name1);
      else
         printf("невозможно создать уникальное имя файла\n");
     if ((name2=tempnam("a:\\tmp","std")) ! =NULL)
         printf("%s есть имя для временного файла.\n", name2);
         else
          printf("невозможно создать уникальное имя файла\n");
     }
     
     
               

  
                          242

                          TIME

    ФОРМАТ

  #include <time.h>    /* используется только для описания функции */
  long time(timeptr);
  long *timeptr;
  

    ОПИСАНИЕ

  Функция возвращает число секунд, прошедших с 00:00:00 Greenwich 
  mean time, Январь 1 1970, согласно часам системы. Возвращаемое
  значение помещается в расположение, заданное в timeptr; timeptr
  может быть NULL, в этом случае возвращаемое значение не помещается.
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Число прошедших секунд.
  Нет ошибочных кодов возврата.
  
    СМОТРИ ТАКЖЕ

  asctime, ftime, gmtime, localtime, utime
  
    ПРИМЕР

  #include <time.h>
  #include <stdio.h>
  
  long ltime;
  
  time(&ltime);
  printf("Время есть %s\n",ctime(&ltime));
  
  
                          243

                         TMPFILE

    ФОРМАТ

  #include <stdio.h>  
  
  FILE *tmpfile();
  

    ОПИСАНИЕ

  Функция создает временный файл и возвращает указатель на этот файл.
  Если файл не может быть открыт, tmpfile возвращает NULL указатель. Этот
  временный файл автоматически удаляется, когда программа завершается 
  нормально, или когда rmtmp вызывается, предполагая, что текущий рабочий
  каталог не изменяется. Временный файл открывается в "w+" виде.
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Указатель на поток.
  NULL указатель, если файл не может быть открыт.
  
    СМОТРИ ТАКЖЕ

  tmpnam, tempnam, rmtmp
  
    ПРИМЕР

  #include <stdio.h>
  
  FILE *stream;
  char tmpstring[] = "Строка для временной записи";
  
  main()
  
         {
         if ((stream = tmpfile ()) == NULL)
                 perror ("Невозможно сделать временный файл");
         else
                 fprintf(stream, "%s", tmpstring);
         }       
                             244

                        TOASCII-_TOUPPER

    ФОРМАТ

  #include <ctype.h>  
  int toascii(c);
  int tolower(c)
  int_tolower(c);
  int toupper(c);
  int_toupper(c);
  int  C;
  
  
    ОПИСАНИЕ

  Макросы toascii, tolower,_tolower, toupper  и _toupper преобразуют
  одиночный символ, как определено. 
  Макро toascii устанавливает все старшие 7 битов C в 0, так что преобразо-
  ванное значение представляет символ в наборе символов ASCII. Если C уже
  представляет ASCII символ то C не изменяется.
  Макро tolower преобразует в заглавную букву, если C есть прописная буква.
  Иначе C не изменяется.
  Макро_tolower является версией tolower, которая используется, когда извест-
  но, что C прописная буква. Результат _tolower неопределен, если C не явля-
  ется прописной буквой.
  Макро toupper преобразует C в прописную букву, если C есть заглавная буква.
  Иначе, C  не изменяется.
  Макро _toupper является версией toupper, которая используется в тех слу-
  чаях, когда известно, что C заглавная буква. Результат не определен, если
  C не является заглавной буквой.
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Преобразованный символ.
  Нет ошибочных кодов возврата.
  
    СМОТРИ ТАКЖЕ

  isalnum, isalpha, isascii, iscntrl, isdigit, isgraph, islower, isprint,
  ispunct, isspace, isupper, isxdigit
  
    ПРИМЕР

  #include <stdio.h>
  #include <ctype.h>
  
  int ch;
  /* Следующие утверждения анализируют все символы между
     кодами 0x0 и 0x7f */
  
  for (ch = 0; ch <=0x7f; ch++) {
          printf(" toupper=%#04x",toupper(ch));
          printf(" tolower=%#04x",tolower(ch));
          if (islower(ch))
                  printf(" _toupper=%#04x",_toupper(ch));
          if (isupper(ch))
                  printf(" _tolower=%#04x",_tolower(ch));
          putchar('\n');
          }
          
               
 
 


                          245

                          TZSET

    ФОРМАТ

  #include <time.h>    /* используется только для описания функции */

  void tzset();
  int daylight;
  long timezone;
  char *tzname[2];
  
    ОПИСАНИЕ

  Функция использует текущую среду переменной окружения TZ, чтобы присвоить
  значения трем переменным: daylight, timezone и tzname.
  Эти переменные используются функциями ftime и localtime, чтобы сделать
  корректировку Greenwich mean time (GMT) в локальное время. Значение пере-
  менной окружение TZ,должно быть трехбуквенным именем зоны, такой как PST,
  следующим за знаковым числом, задающим различие в часах между GMT и локаль-
  ным временем. За числом может следовать трехбуквенное имя daylight saving
  time зоны, такое как PDT. Например, "PST8PDT" представляет правильное TZ
  значение для Pacific time зоны.
  Следующие значения присваиваются переменным daylight, timezone и tzname,
  когда tzset вызывается:
  Timezone       различие в секундах между GMT и локальным временем.
  Daylight       ненулевое значение, если daylight saving tame определено в
                 TZ среде; иначе 0.
  Tzname[0]      строковое значение трехбуквенного имени зоны из TZ среды.
  Tzname[1]      строковое значение трехбуквенного имени зоны daylight
                 saving tame и пустая строка, если daylight saving time зона
                 не включена в TZ среду.
  Если TZ текуще не установлена, то по умолчанию "PST8PDT" устанавливается,
  которая соответствует времени зоны Pacific. По умолчанию daylight есть 1;
  Timezone есть 28800; tzname[0] есть "PST"; и tzname[1] есть "PDT".
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Нет кодов возврата.
  
    СМОТРИ ТАКЖЕ

  Asctime, ftime, localtime.
  
    ПРИМЕР

  #include <time.h>
  
  int daylight;
  long timezone;
  char *tzname[];
  .
  .
  .
  putenv(TZ=EST5); 
  tzset();           /* daylight = 0
                        timezone = 18000
                        tzname[0] = "EST"
                        tzname[1] пусто */
  
  
  


                          246

                          ULTOA

    ФОРМАТ

  #include <stdlib.h>    /* используется только для описания функции */

  char ultoa(value, string, radix);
  unsigned long value;
  char *string;
  int radix;
  
    ОПИСАНИЕ

  Функция преобразует цифры, заданного целого value, в завершающуюся нуле-
  вым символом строку и помещает результат в string. Проверка на переполне-
  ние не выполняется. Аргумент radix есть основание value; он должен быть
  в пределах от 2 до 36.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Указатель на string.
  Нет ошибочных кодов возврата.
  
  
    ЗАМЕЧАНИЕ
    
  Память, получаемая для string, должна быть достаточной, чтобы поместить
  возвращаемую строку. Функция может возвращать до 33 байтов.
  
  
    СМОТРИ ТАКЖЕ

  itoa, ltoa
  
    ПРИМЕР

  #include <stdlib.h>
  
  int radix = 16;
  char buffer[40];
  char *p;
              /* p будет = "501d9138" */
  p = ultoa(1344115000L, buffer, radix);
                          247

                          UMASK

    ФОРМАТ

  #include <sys\types.h>  
  #include <sys\stat.h>
  #include <io.h>
  
  int umask (pmode);
  int pmode;
  
    ОПИСАНИЕ

  Функция устанавливает маску доступа к файлу для текущего процесса 
  в виде, определенному в pmode. Маска способа доступа используется,
  чтобы модифицировать возможность для новых файлов, создаваемых 
  посредством creat,open или sopen. Если бит в маске 1, то соответ-
  ствующий бит в файлах,запрашивающих значение доступа, устанавливает-
  ся в 0 (не позволено). Если бит в маске 0, то соответствующий бит 
  остается неизменным. Способ доступа для нового файла не устанавли- 
  вается до тех пор, пока файл не будет закрыт в первый раз.
  Аргумент pmode является константным выражением, содержащим одну или 
  обе явные константы S_IWRITE и S_IREAD, установленных в sys\stat.h.
  Когда обе константы заданы, они разделяются оператором  ИЛИ (|). 
  Суть pmode аргумента в следующем:
      S_IWRITE          Запись не разрешена (файл только для чтения)
      S_IREAD           Чтение не разрешено (файл только для записи)
      
  Например, если бит записи установлен в маске, то новый файл будет 
  только для чтения.
      
    ЗАМЕЧАНИЕ
    
  Под MS-DOS все файлы доступны для чтения: нет необходимости задавать
  доступ только для записи.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Предыдущее значение pmode.
  Нет ошибочных кодов возврата.
  
    СМОТРИ ТАКЖЕ

  chmod, creat, mkdir, open
  
    ПРИМЕР

  #include <sys\types.h>
  #include <sys\stat.h>
  #include <io.h>
  
  int oldmask;
  
  oldmask = umask(S_IWRITE);  /* создание файлов только для чтения */
                           248

                          UNGETC

    ФОРМАТ

  #include <stdio.h>  
  
  int ungetc(c, stream);
  int C;
  FILE *stream;
  

    ОПИСАНИЕ

  Функция проталкивает символ C обратно на заданный вводной поток
  stream. Поток stream должен быть буферизован и открыт для чтения.
  Последующая операция чтения с потока stream стартует с символа C.
  Попытка протолкнуть EOF на поток игнорируется. Функция возвращает  
  ошибочное значение, если еще ничего не было прочитано из потока 
  stream, или если символ невозможно протолкнуть обратно. Символы,
  расположенные в потоке посредством ungetc, могут быть очищены,
  если fseek или rewind функции вызваны раньше, чем символ введен
  из потока.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Символ C.
  EOF, если попытка протолкнуть символ неудачна.
  
  
    СМОТРИ ТАКЖЕ

  getc, getchar, putc, putchar
  
  
    ПРИМЕР

  #include <stdio.h>
  #include <ctype.h>
  
  FILE *stream;
  int ch;
  int result = 0;
  .
  .
  .
  /* Следующее утверждение выбирает десятичные целые  из stream */
  
  while ((ch = getc(stream)) !=EOF && isdigit(ch))
          result = result * 10 + ch - '0';
          
  if (ch != EOF)
          ungetc(ch,stream); /* Вернуть недесятичное обратно */
                          249

                         UNGETCH

    ФОРМАТ

  #include <conio.h>    /* используется только для описания функции */

  int ungetch(c);
  int c;
  
    ОПИСАНИЕ

  Функция проталкивает символ C обратно на консоль так, что символ C 
  является следующим символом для чтения. Функция неудачна, если она
  вызвана более одного раза перед чтением следующего символа.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Символ C, если успешно.
  EOF, если попытка неудачна.
  
  
    СМОТРИ ТАКЖЕ

  cscanf, getch, getche
  
  
    ПРИМЕР

  #include <conio.h>
  #include <ctype.h>
  
  char buffer[100];
  int count = 0;
  int ch;
  
  /* Следующие утверждения получают слова, разделенные пробелами 
     или символами новых строк с клавиатуры */
  
  ch = getche ();
  
  while (isspace(ch))            /* пропустить предшествующий пробел */
           ch = getche();
           
  while (count < 99) {           /* выбор слов */
           if (isspace(ch)       /* конец слов */
                  break;
                  
           buffer[count++] = ch;
           ch = getche();
           }
           
  ungetch(ch);                   /* вернуть разделитель обратно */
  buffer[count] = '\0';          /* завершающий нулевой символ */
                           250

                          UNLINK

    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */
  #include <stdio.h> /* исп-ся либо io.h либо stdio.h */
  
  int unlink(pathname);
  char *pathname;
  

    ОПИСАНИЕ

  Функция удаляет файл, определенный в pathname.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  0, если файл удален.
  -1, индицирует об ошибке; errno устанавливается в одно из следующих
     значений:
     
     EACCES      Имя пути определяет каталог или файл только для
                 чтения
     ENOENT      Файл или путь не найдены.
     
     
    СМОТРИ ТАКЖЕ

  close, remove
  
    ПРИМЕР

  #include <io.h>
  #include <stdlib.h>
  
  int result;
  
  result = unlink ("tmpfile");
  if (result == -1)
          perror("невозможно удалить tmpfile");
                          251

                          UTIME

    ФОРМАТ

  #include <sys\types.h>  
  #include <sys\utime.h>
  
  int utime(pathname, times);
  char *pathname;
  struct utimbuf *times;
  

    ОПИСАНИЕ

  Функция устанавливает время модификации для файла, определенного
  в pathname. Процесс должен иметь доступ для записи к файлу; иначе,
  время не может быть изменено.
  Хотя utimbuf структура содержит  поле для доступа к времени, под 
  MS-DOS только время модификации является устанавливаемым. Если 
  times является NULL указателем, время модификации устанавливается в
  текущее время. Иначе, times должен указывать на структуру типа 
  utimbuf, определенный в sys\utime.h. Время модификации устанавлива-
  ется из поля modtime в этой структуре.
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
    
  0, если время модификации для файла изменено.
  -1, индицирует об ошибке; errno устанавливается в одно из
      следующих значений:
      
      EACCES      Имя пути определяет каталог или файл только для
                  чтения.
      EMFILE      Слишком много открытых файлов (файл должен откры-
                  ваться, чтобы изменить время ее модификации).
      ENOENT      Файл или имя пути не найдены.
      

    СМОТРИ ТАКЖЕ
    
  asctime, ctime, fstat, ftime, gmtime, localtime, stat, time
  
  
    ПРИМЕР
    
  #include <sys\types.h>
  #include <sys\utime.h>
  #include <stdio.h>
  #include <stdlib.h>
  
  /* Установить время модификации файла в текущее время */
  
  if (utime("/tmp/data",NULL) == -1)
          perror("utime неудачна");
          
          
          
          
               
 
 




    
                         252

                     VA_ARG-VA_START

    ФОРМАТ

  #include <varargs.h>   /* Требуется для совместимости с UNIX V */
  #include <stdarg.h>    /* Требуется для совместимости с ANSI C */
  
  void va_start(arg-ptr);
  void va_start(arg-ptr, prev-param);
  tupe va_arg(arg-ptr, type);
  void va_end(arg-ptr);
  va_list arg-ptr;
  type
  prev-param
  va_alist
  va-dcl
  
  
    ОПИСАНИЕ

 Макросы VA_START, VA_ARG и VA_END проставляют возможность доступа
 к аргументам функции, когда функции передается переменное число аргу-
 ментов. Две версии макросов применимы: макросы, определенные в
 varargs.h совместимы с UNIX SYSTEM V, а макросы, определенные в
 stdarg.h соответствуют предпологаемому ANSI C стандарту.
 Обе версии предпологают, что функции передаются фиксированное число
 требуемых аргументов, за которыми следует переменное число необяза-
 тельных аргументов. Требуемые аргументы описываются как простые пара-
 метры для функции и к ним доступ осуществляется через имя параметров.
 Доступ к необязательным аргументам осуществляется через макросы
 varargs.h и stdarg.h, которые устанавливают указатель на первый нео-
 бязательный аргумент в списке аргументов, перебирают аргументы из
 списка, и переустанавливают указатель,когда выбор аргумента сделан.
 UNIX SYSTEM V макросы, определенные в varargs.h, используются следую-
 щим образом:
 
    1. Любые требуемые аргументы для функции могут быть описаны как
       параметры обычным образом.
       
    2. Последний параметр для функции представляет список необязатель-
       ных аргументов. Этот параметр должен иметь имя va_alist (не пе-
       репутайте с va_list, который определяется как тип va_alist).
       
    3. Макро va_dcl появляется после определения функции и перед от-
       крывающей левой скобкой функции. Эта маска определяет как за-
       вершить описание va_alist параметра, включением завершающей
       точки с запятой; следовательно, точка с запятой не должна сле-
       довать за va_dcl.
       
    4. В пределах функции, va_start макро устанавливает arg-ptr на 
       начало списка необязательных аргументов, передающихся функции.
       Макро va_start должен быть использован раньше, чем va_arg
       используется в первый раз. Аргумент arg_ptr должен иметь тип 
       va_list.
                            253
       
    5. Макро va_arg делает следующее:
          - находит значение заданного type из расположения, задан-
            ного в arg_ptr.
          - увеличивает arg_ptr, чтобы указать на следующий аргумент
            в списке, используя размер type, чтобы определить, где 
            следующий аргумент начинается.
       Макро va_arg может быть использовано любое число раз в преде-
       лах функции, чтобы найти аргументы из списка.
       
    6. После того, как все аргументы найдены, va_end устанавливает
       указатель на NULL.
       
  Предпологаемый ANSI C стандарт макро, определенный в stdarg.h, опе-
  рирует немного другим способом, как описано ниже:
  
    1. Все требуемые акгументы для функции описываются как параметры
       обычным образом. Макро va_dcl не используется с stdarg.h макро.
       
    2. Макро va_start устанавливает arg_ptr на первый необязательный
       аргумент в списке аргументов, передаваемых функции. Аргумент
       arg_ptr должен иметь тип va_list. Аргумент prev-param является
       именем требуемого параметра, предшествующего первому необяза-
       тельному аргументу из списка аргументов. Макро va_start должен
       быть использован раньше использования va_arg в первый раз.
    3. Макро va_arg делает следующее:
      
        -находит значение заданного type из расположения, заданного
         в  arg_ptr.
        -увеличивает arg_ptr, чтобы указать на следующий аргумент в
         списке, используя размер type, чтобы определить, где начи-
         нается следующий аргумент.
         
   Макро va_arg может быть использован любое число раз в пределах
   функции, чтобы найти аргументы из списка.
            
     4. После того, как все аргументы найдены, va_end устанавливает
        указатель на NULL.
        
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
    
  Макро va_arg возвращает текущий аргумент; va_start и va_end не
  возвращают значения.
  

    СМОТРИ ТАКЖЕ

  vfprintf, vprintf, vsprintf
                            254
  
    ПРИМЕР

  Листинги программ, использующих varargs.h
  
  #include <stdio.h>
  #include <varargs.h>
  
  main()
  {
      int n;
      .
      .
      .
      /* Вызов функции с 4 аргументами; последний аргумент -1
         означает конец списка аргументов */
      n = average(2, 3, 4, -1);
      printf("Average is: %d\n", n);
      .
      .
      .
      /* Вызов функции с 5 аргументами; последний аргумент -1 
         означает конец списка аргументов */
      n = average(5, 7, 9, 11, -1);
      printf("Average is:  %d\n", n);
   }
   
   average(va_alist)
   va_dcl
   {
       int i = 0, count = 0, sum = 0;
       va_list arg_marker;
       
       va_start(arg_marker);
       
       /* Пересчитать аргументы и присвоить их число в sum,
          пока последний аргумент -1 не будет достигнут */
       for (; (i = va_arg(arg_marker,int)) >=0; sum+=i, count++)
               ;
       return (count ? (sum/count) : count);
       
   }    
                            255
   
   Листинги програм, использующих stdarg.h
   
   #include <stdio.h>
   #include <stdarg.h>
   
   main()
   {
        int n;
        .
        .
        .
      /* Вызов функции с 4 аргументами; последний аргумент -1
         означает конец списка аргументов */
        
        n = average(2, 3, 4, -1);
        printf("Average is: %d\n", n);
        .
        .
        .
      /* Вызов функции с 5 аргументами; последний аргумент -1 
         означает конец списка аргументов */
        
        n = average(5, 7, 9, 11, -1);
        printf("Average is: %d\n", n);
   }
   
   average(first)
   int first;
   {
        int i = 0, count = 0, sum;
        va_list arg_marker;
        
        va_start(arg_marker, first);
        
        /* Добавить первый аргумент к sum и увеличить count;
           возврат, если первый аргумент есть -1 */
        if (first != -1)
                sum = first;
        tlst
                return (0);
        count++;
       /* Пересчитать аргументы и присвоить их число в sum,
          пока последний аргумент -1 не будет достигнут */
        
        for (; (i = va_arg(arg_marker, int)) >=0; sum+=i, count++)
               ;
        return (sum/count);
        
     }
                             256

                        VFPRINTF-VSPRINTF

    ФОРМАТ

  #include <stdio.h> 
  #include <varargs.h> /* для совместимости с UNIX V */
  #include <stdarg.h>  /* для совместимости с ANSI C */
  
  int vfprintf(stream, format-string, arg-ptr);
  int vprintf(format-string, arg-ptr);
  int vsprintf(buffer, format-string, arg-ptr);
  
  FILE *stream;
  char *buffer;
  char *format-string;
  va-list arg-ptr;
  
  
     ОПИСАНИЕ

  Функции vfprintf, vprintf и vsprintf форматизуют и выводят данные
  в поток stream, в стандартный вывод, или буфер, соответственно.
  Эти функции подобны функциям fprintf, printf и sprintf, но допуска-
  ют указатель на список аргументов.
  Format-string имеет определенную форму и функцию, как format-string
  аргумент для printf функции; смотри описание printf для получения
  описания format-string.
  Параметр arg-ptr имеет тип va_list, который определен в  varargs.h
  и stdarg.h. Параметр arg-ptr указывает на список аргументов, которые
  преобразуют и выводят согласно соответствующей спецификации формата
  в format-string.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Число записанных символов.
  
  
    СМОТРИ ТАКЖЕ

  fprintf, printf, sprintf, va_arg, va_end, va_start
                            257
  
    ПРИМЕР

  #include <stdio.h>
  #include <varargs.h>
  
  main()
  {
      int line = 1;
      char *filename = "EXAMPL";
      .
      .
      .
      error("Ошибка: line %d, file %s\n", line, filename);
      .
      .
      .
      error("Синтаксическая ошибка\n");
      
   }
   
   error(va_alist)
   va_dcl
   {
          char *fmt;
          va_list arg_ptr;
          
          va_start(arg_ptr);
          /* arg_ptr сейчас указывает на format-string */
          fmt = va_arg(arg_ptr, char *);
          /* arg-ptr сейчас указывает на аргумерт после format-string */
          vprintf(fmt, arg_ptr);
          va_end(arg_ptr);
    }
    
    Output:
    
   Ошибка: line 1, fike EXAMPLE
   Синтаксическая ошибка
                          258

                          WRITE

    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */
  
  int write(handle, buffer, count);
  int handle;
  char *buffer;
  unsigned int count;
  

    ОПИСАНИЕ

  Функция записывает count байтов из buffer в файл, связанный с
  handle. Операция записи начинается с текущей позиции указателя
  файла (если несколько), связанного с заданным файлом. Если файл
  открыт для расширения, операция начинается с текущего конца файла.
  После операции записи указатель файла возрастает на число байтов,
  действительно записанных.
  
  
    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Число байтов, действительно записанных. Возвращаемое значение
  может быть положительным, но меньше count.
  -1, индицирует об ошибке; error устанавливается в одно из следующих
      значений:
  
        EACCES       Файл только для чтения или защищен от записи.
        
        EBADF        Недействительный файл handle.
        
        ENOSPC       Нет памяти для устройства.
        
  Если записывается более 32 К (максимальный размер типа int) в файл,
  возвращаемое значение должно быть типа unsigned int. Однако, макси-
  мальное число байтов для записи в файл есть 65534, так как 65535
  (или 0xFFFF) есть граница от -1 и возвращает ошибку.
  
  
    СМОТРИ ТАКЖЕ

  fwrite, open, read
                            259
  
    ПРИМЕР

  #include <io.h>
  #include <stdio.h>
  #include <fcntl.h>
  
  char buffer[60000];
  
  main()
        {
        int fh;
        unsigned int nbytes = 60000, byteswritten;
        
        if ((fh = open("c:/data/cont.dat",O_WRONLY)) == -1) {
                perror("неудачная попытка открыть выводной файл");
                exit(1);
                }
        if ((byteswritten = write(fh, buffer, nbytes)) == -1 ) {
                perror("");
        else
                printf("Записано %u байтов в файл\n", byteswritten);
        .
        .
        .
        }
                          260
                       
                       ПРИЛОЖЕНИЕ А
                       
                    ОШИБОЧНЫЕ СООБЩЕНИЯ
      
      Это приложение описывает значения, в которые переменная errno
 может  быть  установлена,  когда  происходит  ошибка при вызове  
 функции  библиотеки. Заметим, что только некоторые функции устанавливают
 переменную errno.
      Ошибочное сообщение связано с каждым значением errno. Это 
 сообщение может быть напечатано, используя perror функцию.
      Значение errno отражает суть ошибки для последнего
 вызова, которое установило errno. Значение errno  автоматически  не
 очищается при последующем успешном вызове. Таким  образом, для
 получения точных результатов, необходимо выполнить проверку на ошибки
 и  печатать  сообщения  об  ошибках, если требуется, сразу после вызова.
      Файл  включения  errno.h содержит определение значений errno.
 Однако, не все определения,заданные в errno.h используется под MS-DOS.
      Это приложение содержит только errno, используемые в  MS-DOS.
 Для получения полного списка значений errno, см. файл включения errno.h.
      
           Таблица А.1  Значения errno и их суть

__________________________________________________________________________

   Величина   Сообщение           Описание
__________________________________________________________________________
                                                                   
 E2BIG      Arg list too      Список аргументов превышает 128 байтов, 
            long.(список      или память, требуемая для информации
            аргументов        окружения превышает 32 Кбайта.
            слишком длинный)       
 EACCES     Permission        Доступ невозможен:
            denied.           разрешение файлов  не  позволяет
            (Доступ невоз-    указанный доступ. Эта  ошибка   может
             можен   )        происходить  в ряде обстоятельств;при 
                              попытке получить доступ к файлу (или,
                              в таком  же случае, оглавлению) таким
                              образом, который несовместим с атрибу-
                              тами файла.
                              Например:  попытка  чтения  из  файла
                              который  не  открыт,  попытка  записи
                              в файл, открытого только для чтения,
                              или открыть оглавлении вместо  файла.
                              В  версиях MS-DOS 3.0 и выше, EACCES
                              также может указывать на нарушение 
                              запирания или разделения.
                              Ошибка  может также встретится при
                              попытке переименовать  файл  или
                              удалить существующее оглавление.
                               
 EBADF      Bad file          Handle указанного файл не является
            number.           действительным значением handle для
            (Плохое           файла или относится к не открытому
            число             файлу:  или была попытка записать в
            файла.)           файл или устройство,открытые только
                              для чтения (или наоборот).
                            261  
                              
 EDEADLOCK  Resource            Запирающее нарушение: файл не может
            deadlock          быть заперт после 10 попыток  (MS-DOS
            would occur.      версия 3.0 и позже).
            (Произошел        
            тупик для       
            ресурсов.)        
                                                                
                    
 EDOM       Math argument.     Аргумент к математической функции
            (аргумент          не входит в область функции. 
            математический).
            
 EEXIST     File exists        Флаги O_CREAT и  O_EXCL  указаны,
            (файл существует) когда  открывается  файл,  а  файл  с
                              таким именем уже существует.
                              
 EINVAL     Invalid             Недействительная величина, которая
            argument.         дана  для одного из аргументов к функции.
                              Например,  величина  дана для начала,
                              но указатель файла  позиционирован
                              раньше начинающегося в файле.
                              
 EMFILE     Too many open      Нет более доступных handle, так как
            files.(слишком    слишком много открытых файлов.   
            файлов).         
                              
 ENOENT     No such file or    Указанные   файл  или  оглавление  не
            directory.        существуют или не могут быть найдены.
            (нет такого файла  Это    сообщение    возможно    когда
            или оглавления)   указанный   файл  не  существует  или
                              компонета существующего оглавления не
                              указано в пути.
                              
 ENOEXEC    Exec format       Попытка  сделать  выполнение  файла,
            error. (ошибка    который не является выполняемым или
            формата exec).    имеет недействительный формат для
                              выполнения файла.
                              
 ENOMEM     Not enough core.   Нет достаточной   памяти, годной  к
            (нет достаточ-    использованию.  Это  сообщение  может
            ного ядра).       происходить     когда    недостаточно
                              имеющейся памяти для выполнения  дитя
                              процесса или, когда запрос на получение
                              памяти в sbrk или getcwd  не  может
                              быть удовлетворено.
                                        
 ENOSPC     No space left     Больше не пространства, доступного для
            on device(нет     записи на устройстве (например, диск
            пространства      полон).
            отпущенного в     
            устройстве).
            
 ERANGE     Result too        Аргумент  в  математической  функции-
            large. (          слишком  большой, результат частично,
            Результат слиш-   или вообще потерян.
            ком большой).      Эта  ошибка  может   происходить   в
                              другой  функции когда аргумент больше
                              чем   ожидается.   (Например,   когда
                              аргумент  имя-пути в функции getcwd
                              длиннее чем ожидается.)
                            162  
                                   
 EXDEV      Cross-device       При попытке сделать передачу файла в 
            link.             разные    устройства    (используя
                              функцию rename). 
                                   
                              

