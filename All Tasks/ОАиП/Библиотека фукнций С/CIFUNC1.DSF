



















                      Си - КОМПИЛЯТОР

               для операционной системы MS-DOS

                   БИБЛИОТЕЧНЫЕ  ФУНКЦИИ
































                          Брежнев

                            1987


                          ВВЕДЕНИЕ

  Данная книга является переводом Microsoft C Compiler for MS-DOS
  Operating System, Run-Time Library Reference и содержит описание
  всех библиотечных функции для использования в прогроммах, которые
  пишутся на языке программирования Cи.
  Данный перевод ,в отличие от оригинала, не содержит описание вклю-
  чаемых файлов и не расматривает вопросы совместимости функции
  для операционных систем MS-DOS и XENIX.
  Автор перевода почти уверен в корректности синтаксиса функции,
  но надеется, что его простят за допущенные неточности при переводе
  описания функции.
                           Зуфар Якупов.   КАМАЗ,УОП


                            1

                      СОДЕРЖАНИЕ

глава 1. ОБЩЕЕ ОПИСАНИЕ ФУНКЦИИ ПО КАТЕГОРИЯМ

         1.1  Манипуляции с буфером................................5
         1.2  Классификация символов и преобразование..............5
         1.3  Преобразование данных................................6
         1.4  Управление каталогами................................6
         1.5  Управление файлами...................................6
         1.6  Ввод/вывод...........................................7
         1.6.1  Ввод/вывод потоком.................................8
         1.6.1.1  Открытие потоков.................................9
         1.6.1.2  Переопределение указателей потока................9
         1.6.1.3  Управление буферизованными потоками..............10
         1.6.1.4  Закрытие потоков.................................10
         1.6.1.5  Чтение и запись данных...........................10
         1.6.1.6  Обнаружение ошибок...............................11
         1.6.2  Функции в/в нижнего уровня.........................11
         1.6.2.1  Открытие файлов..................................11
         1.6.2.2  Переопределение handle...........................12
         1.6.2.3  Чтение и запись данных...........................12
         1.6.2.4  Закрытие файлов..................................12
         1.6.3  Функции в/в с консоли и порта......................13
         1.7  Математика...........................................14
         1.8  Манипулирование памятью..............................15
         1.9  Интерфейс к MS-DOS...................................16
         1.10 Управление процессами................................17
         1.11 Поиск и сортировка...................................20
         1.12 Манипуляции со строками..............................20
         1.13 Манипуляции со временем..............................21
         1.14 Функции манипуляции со списком аргументов............21
         1.15 Другие функции.......................................22

глава 2. ОПИСАНИЕ ФУНКЦИИ

         abort.....................................................23
         abs.......................................................24
         access....................................................25
         acos......................................................26
         alloca....................................................27
         asctime...................................................28
         asin......................................................29
         assert....................................................30
         atan-atan2................................................31
         atof-atol.................................................32
         bdos......................................................34
         bessel....................................................35
         bsearch...................................................36
         cabs......................................................38
         calloc....................................................39
         ceil......................................................40
         cgets.....................................................41
         chdir.....................................................42
         chmod.....................................................43
         chsize....................................................44
         _clear87..................................................45
         clearerr..................................................46
         close.....................................................47
         _control87................................................48
                            2

         cos-cosh..................................................49
         cprintf...................................................50
         cputs.....................................................51
         creat.....................................................52
         cscanf....................................................53
         ctime.....................................................54
         dieeetomsbin-dmsbintoieee.................................55
         difftime..................................................56
         dosexterr.................................................57
         dup-dup2..................................................58
         ecvt......................................................60
         eof.......................................................61
         execl-execvpe.............................................62
         exit-_exit................................................65
         exp.......................................................66
         _expand...................................................67
         fabs......................................................68
         fclose-fcloseall..........................................69
         fcvt......................................................70
         fdopen....................................................71
         feof......................................................73
         ferror....................................................74
         fflush....................................................75
         _ffree....................................................76
         fgetc-fgetchar............................................77
         fgets.....................................................78
         fieeetomsbin-fmsbintoieee.................................79
         filelength................................................80
         fileno....................................................81
         floor.....................................................82
         flushall..................................................83
         _fmalloc..................................................84
         fmod......................................................85
         _fmsize...................................................86
         fopen.....................................................87
         FP_OFF-FP_SEG.............................................88
         _fpreset..................................................89
         fprintf...................................................90
         fputc-fputchar............................................91
         fputs.....................................................92
         fread.....................................................93
         free......................................................94
         _freect...................................................95
         freopen...................................................96
         frexp.....................................................97
         fscanf....................................................98
         fseek.....................................................99
         fstat....................................................100
         ftell....................................................102
         ftime....................................................103
         fwrite...................................................104
         gcvt.....................................................105
         getc-getchar.............................................106
         getch....................................................107
         getche...................................................108
         getcwd...................................................109
                            3

         getenv...................................................110
         getpid...................................................111
         gets.....................................................112
         getw.....................................................113
         gmtime...................................................114
         halloc...................................................115
         hfree....................................................116
         hypot....................................................117
         inp......................................................118
         int86....................................................119
         int86x...................................................120
         intdos...................................................122
         intdosx..................................................123
         isalnum-isascii..........................................124
         isatty...................................................125
         iscntrl-isxdigit.........................................126
         itoa.....................................................127
         kbhit....................................................128
         labs.....................................................129
         ldexp....................................................130
         lfind-lsearch............................................131
         localtime................................................133
         locking..................................................136
         log-log10................................................137
         longjmp..................................................138
         lseek....................................................140
         ltoa.....................................................142
         malloc...................................................143
         matherr..................................................144
         _memavl..................................................146
         memccpy..................................................147
         memchr...................................................148
         memcmp...................................................149
         memcpy...................................................150
         memicmp..................................................151
         memset...................................................152
         mkdir....................................................153
         mktemp...................................................154
         modf.....................................................155
         movedata.................................................156
         _msize...................................................157
         _nfree...................................................158
         _nmalloc.................................................159
         _nmsize..................................................160
         onexit...................................................161
         open.....................................................162
         outp.....................................................164
         perror...................................................165
         pow......................................................166
         printf...................................................167
         putc-putchar.............................................173
         putch....................................................174
         putenv...................................................175
         puts.....................................................176
         qsort....................................................177
         rand.....................................................179
         read.....................................................180
         realloc..................................................182
         remove...................................................183
                            4

         rename...................................................184
         rewind...................................................185
         rmdir....................................................186
         rmtmp....................................................187
         sbrk.....................................................188
         scanf....................................................189
         segread..................................................194
         setbuf...................................................195
         setjmp...................................................196
         setmode..................................................198
         setvbuf..................................................199
         signal...................................................200
         sin-sinh.................................................202
         sopen....................................................203
         spawnl-spawnvpe..........................................206
         sprintf..................................................209
         sqrt.....................................................210
         srand....................................................211
         sscanf...................................................212
         stackavail...............................................213
         stat.....................................................214
         _status87................................................216
         strcat-strdup............................................217
         strerror.................................................219
         strlen...................................................221
         strlwr...................................................222
         strncat-strnset..........................................223
         strpbrk..................................................225
         strrchr..................................................226
         strrev...................................................227
         strset...................................................228
         strspn...................................................229
         strstr...................................................230
         strtod-strtol............................................231
         strtok...................................................233
         strupr...................................................235
         swab.....................................................236
         system...................................................237
         tan-tanh.................................................238
         tell.....................................................239
         tempnam-tmpnam...........................................240
         time.....................................................242
         tmpfile..................................................243
         toascii-_toupper.........................................244
         tzset....................................................245
         ultoa....................................................246
         umask....................................................247
         ungetc...................................................248
         ungetch..................................................249
         unlink...................................................250
         utime....................................................251
         va_arg-va_start..........................................252
         vfprintf-vsprintf........................................256
         write....................................................258

Приложение А. ОШИБОЧНЫЕ СООБЩЕНИЯ.................................260
                            5

       глава 1.  ОБЩЕЕ ОПИСАНИЕ ФУНУЦИЙ ПО КАТЕГОРИЯМ

               1.1  Манипуляции с буфером.

   Функция                  Использование

   memccpy        -копирует символы из одного буфера в другой
                   до тех пор пока установленный (определенный)
                   символ  не  будет  скопирован или определенное
                   число символов не будет скопировано.

   memchr         -возвращает указатель на первое местонахождение
                   , в пределах указанного количества символов ,
                   определенного символа в буфере.

   memcmp         -сравнивает  указанное  число  символов из двух
                   буферов.

   memicmp        -сравнивает указанное число символов двух буферов,
                   считая заглавные и прописные буквы эквивалентными

   memcpy         -копирует  указанное  количество   символов   из
                   одного буфера в другой.

   memset         -использует заданный символ, чтобы проинициализировать
                   им указанное количество байтов в буфере.

   movedata       -копирует определенное количество  символов  из
                   одного  буфера  в  другой,  даже  когда буфера
                   находятся в разных сегментах.

  Функции для обращения к буферу  объявлены  во включаемом файле
                   memory.h.


            1.2  Классификация символов и преобразование.

   Функция                    Использование

   isalnum        -тест для алфавитно-цифровых символов.
   isalpha        -тест для алфавитных символов.
   isascii        -тест для ASCII символов.
   iscntrl        -тест для управляющих символов.
   isdigit        -тест для десятичных цифр.
   isgraph        -тест для печатных символов, исключая пробел.
   islower        -тест для прописных символов.
   isprint        -тест для печатных символов.
   ispunct        -тест для символов пунктуации.
   isspace        -тест для символа пробела.
   isupper        -тест для больших (заглавных) символов.
   isxdigit       -тест для 16-тиричных символов.
   toascii        -преобразование символов в код ASCII.
   tolower        -тест  символов  и  преобразование в прописные символы,
                   если заглавные символы.
   toupper        -тест символов и преобразование заглавных символов в
                   прописные.
  _tolower        -преобразование символов в прописные (безусловно).
  _toupper        -преобразование символов в заглавные (безусловно).
         Все эти макроопределения находятся в ctype.h.
                            6

                 1.3  Преобразование данных.

   Функция                    Использование

   atof           -преобразование строки во float (плавающая точка)
   atoi           -преобразование строки в int (целое)
   atol           -преобразование строки в long (длинное целое)
   ecvt           -преобразование double (длинное с плавающей) в строку
   fcvt           -преобразование double в строку
   gcvt           -преобразование double в строку
   itoa           -преобразование int в строку
   ltoa           -преобразование long в строку
   ultoa          -преобразовани unslgned (безнаковое) long в строку

             Эти программы объявлены в файле stdlib.h.
             Только функция atof объявлена в math.h.


                  1.4   Управление каталогами

   chdir          -изменение текущего рабочего каталога.
   getcwd         -получить текущий рабочий каталог.
   mkdir          -создать новый каталог.
   rmdir          -удаление каталога.

             Эти функции объявлены в файле включения direct.h.


                1.5  Управления файлами.

   access         -проверка  доступа к файлу
   chmod          -изменение  доступа к файлу
   chsize         -изменение размера файла.
   filelength     -проверка длины файла.
   fstat          -получение информации о статусе файла .
   isatty         -проверка для символьного  устройства .
   locking        -запирает  область  в  файле  (действителен  с
                   версией MS-DOS 3.0 и выше).
   mktemp         -создание уникального имени файла.
   remove         -удаление файла.
   rename         -переименование файла.
   setmode        -установить  файл в переводимый вид.
   stat           -получение  статус информации именованногго файла.
   umask          -установка маски разрешения по умолчанию.
   unlink         -удаление файла.

             Эти программы за исключением fstat и stat объявлены
 в файле включения io.h , функции fstat и stat объявлены в файле
 sys\stat.h.
             Функции access, chmod, rename, stat и unlink
 оперируют с файлами, определенными посредством имени пути или
 имени файла.
             Функции chsize,filelength,isatty,locking,setmode,fstat
 работают с файлами посредством присвоения файлу handle (определенное
 число соответствующее файлу). Функция locking работает только под
 MS-DOS 3.0 и позже; она запирает область файла от доступа других
 пользователей.
                            7

                  1.6  Ввод и вывод.

     Программы  ввода  и  вывода  в  стандартной  С  библиотеке
позволяют вам читать и  записывать  данные  в  и  из  файлов  и
устройств. Следующие 3 типа функций ввода/вывода возможны:
     1. Ввод/вывод потоком.
     2. Ввод/вывод на нижнем уровне.
     3. Ввод/вывод с консолью и портом.

Функция ввода/вывода потоком берет данные файла как поток
индивидуальных символов.
Когда поток открыт для ввода/вывода, откпытый файл связывается со
структурой типа FILE (определенным в stdio.h), содержащим базовую
информацию о файле. Указатель на структуру FILE возвращается, когда
файл открывается. Этот указатель (указатель потока) используется
для последующих  операций с файлом.
Функции в/в потоком дают возможность для буферизованного, форматиро-
ванного и неформатированного в/в. Когда поток буферизован, данные
читаются из или записываются в поток из выбранной области памяти,
называемой буфером. При записи, содержимое выводного буфера записывает-
ся в указанное расположение, когда буфер полон, поток закрыт или
программа нормально завершилась. При чтении, блок данных располагается
во вводной буфер и данные читаются из буфера; когда вводной буфер пуст,
следующий блок данных передается в буфер.

Функции в/в с консоли и порта могут рассматриваться как расширение
функции в/в потоком. Они позволяют читать или записывать на консоль
(терминал) или в порт в/в (такой,как порт принтера). Функции в/в с
портом просто читают или записывают данные побайтно. Некоторые допол-
нительные опции возможны для функции в/в с консолью (например:ввод с
эхом и без эхо).

Функции в/в на низком уровне не выполняют буферизацию и форматирование;
они могут расматриваться как обращение к возможностям в/в орерационной
системы непосредственно.
Когда файл открывается для в/в на низком уровне, файл handle связывается
с открытым файлом. Handle есть целое значение, которое исрользуется
для последующих операций с файлом.
                            8

                 1.6.1  Функции в/в потоком

   clearerr            -очистка индикатора ошибки для потока.
   fclose              -закрытие потока.
   fcloseall           -закрытие всех открытых потоков.
   fdopen              -открытие   потока   используя handle.
   feof                -тест для конца файла в потоке.
   ferror              -тест для ошибки в потоке.
   fflush              -скидывание потока.
   fqetc               -чтение  символов  из   потока  (версия функции).
   fileno              -получить файл handle, связанный с потоком.
   fgetchar            -чтение символа из stdin (версия функции).
   fgets               -чтение строки из потока.
   flushall            -скидывание всех потоков.
   fopen               -открытие потока.
   fprint              -запись форматированных данных в поток
   fputc               -запись символа в stream (версия функции).
   fputchar            -запись символа в stdout (версия функции).
   fputs               -запись строки в stream.
   fread               -чтение неформатированных данных из stream.
   freopen             -переназначить FILE указатель.
   fscanf              -чтение форматированных данных из stream.
   fscek               -перемещение указателя файла
                        в установленное расположение.
   ftell               -получение текущую позицию указателя файла .
   fwrite              -запись   неформатированных данных в stream.
   getc                -чтение символа из stream (версия макро).
   getchar             -чтение символа из stdin (версия макро).
   gets                -чтение линий из stdin.
   getw                -чтение двоичных int из stream.
   printf              -запись форматированных данных в stdout.
   putc                -запись символа в stream (версия макро).
   putchar             -запись символа в stdout (версия макро).
   puts                -зипись линий в stream.
   putw                -запись двоичных int в stream.
   rewind              -перепозиционирование
                        указателя файла в начало потока.
   rmtmp               -удалить временные файлы, созданные посредством
                        tmpfile.
   scanf               -чтение форматизированных данных из stdin.
   setbuf              -управление буферизацией потока.
   setvbuf             -управление буферизацией потока и размером буфера
   sprintf             -запись форматированных данных в строку.
   sscanf              -чтение форматированных данных из строки
   tempnam             -сгенерировать имя временного файла в
                        заданном каталоге.
   tmpfile             -создать временный файл.
   tmpnam              -сгенерировать имя временного файла.
   ungetc              -помещение символа в буфер.
   vfprintf            -записать форматированные данные в stream.
   vprintf             -записать форматированные данные в stdout.
   vsprintf            -записать форматированные данные в строку.
                            9


     Эти функции объявлены в файле включения stdio.h. Некоторые
константы определенные в stdio.h могут  быть  полезны  в  вашей
программе:
     константа   EOF - это  определенная  значение возврата при
     конце файла;
     константа NULL - указатель на нуль;
     константа FILE - структура, которая содержит информацию  о
     потоке;
     константа  BUFSIZ  -  определяет  размер  буфера  потока в
     байтах.

               1.6.1.1   Открытие потоков.

   Поток должен быть открыт использованием  fdopen,  fopen,  или
     freopen  функций  до  выполнения операции ввода  и  вывода с этим
     потоком. Когда поток открыт, именованный  поток  может  быть
     открыт  для  чтения,  записи или обе и могут быть открыт в
     текстовом или двоичном виде.
     Эти функции возвращают указатель на структуру FILE, которая
     используется для обращения к потоку.

               1.6.1.2   Переопределение указателей потока:
                         stdin, stdout, stderr, stdaux, stdprn.

     Когда    программа   начинает   выполняться,   5   потоков
автоматически  открываются.  Эти  потоки  - стандартный   ввод,
стандартный  вывод,  стандартные  ошибки,  стандартный порт
и стандартная  печать.  По  умолчанию,  стандартный
ввод/вывод и станд. ошибки -это консоль.
     Назначения стандартный порт и печать
зависят от конфигурации машины; эти потоки обычно указывают  на
вспомогательный  порт  и  принтер, соответственно, но они могут
быть не установлены в особых  системах.  Обязательно  проверьте
вашу конфигурацию машины до использования этих потоков.
     Когда  вы  используете функции потока, вы можете указывать
стандарт.ввод, вывод, ошибки, порт, печать, используя  следущие
указанные FILE:
     stdin - стандартный ввод
     stdout- стандартный вывод
     stderr- станд. ошибки
     stdaux- станд. порт
     stdprn- станд. печать.
     Вы   можете  использовать  эти  указатели  в  каких-нибудь
функциях, которые требуют указатель потока как аргумент.
     Вы можете использовать символы переуказания MS-DOS ( <,> или >> )
чтобы  переопределенить стандартный ввод и вывод для особых программ.
     Вы можете переопределить stdin, stdout, stderr, stdax  или
stdprn так что, они будут относиться к файлу на диске или устройству.
Freopen функция используется для этих возможностей.
                            10

            1.6.1.3  Управление буферизованными потоками.

     Открытые файлы, для которых используются в/в потоком, буферузуются
по умолчанию, за исключением потоков stdin,stdout,stderr,stdaux,atdprn.
     Потоки  stderr и stdaux - не буферизованы. Если к ним используется
printf или scanf функция, им назначается временный буфер. Оба потока
могут также буферизоваваться использованием setbuf или setvbuf функции.
Потоки stdin,stdout,stdprn буферизованы; буфер скидывается, когда
он полон или функция завершила в/в.
Использованием функции setbuf или setvbuf вы можете сделать поток
небуферизованным или связать буфер с небуферизованным потоком.
     Буфера размещенные  в  системе  не  доступны  пользователю,
кроме буферов полученных с помощью setbuf или setvbuf и проименованных
пользователем (с ними можно обращаться как с переменными).  Буфера
должны  иметь  постоянный  размер,  равный константе BUFSIZ в stdio.h.
Если используется setvbuf, размер буфера ты устанавливаешь сам.
     Буфера автоматически скидываются, когда они полны , когда
связанный файл закрывается или когда программа завершена нормально.
  Вы  можете  скинуть  буфера  в  другое  время,   используя
fflush  и  flushall  функции. Fflush скидывает один указанный
поток,  а  flushall  скидывает  все  потоки,  которые   открыты  и
буферизованы.


            1.6.1.4  Закрытие потоков.

     Функции fclose и fcloseall закрывают поток или потоки.
Fclose  -  один  указанный  поток, fcloseall - все потоки, кроме
stdin,stdout, stderr, stdaux, stdprn.
     Если ваша программа  не  делает  закрытия  потоков,  потоки
автоматически  закрываются, когда программа завершается. Однако,
это хорошая практика закрывать потоки, когда  завершены  с  ними
операции, так как число потоков, которые могут быть открыты в одно
время ограничено.

             1.6.1.5  Чтение и запись данных.

     Функции в/в потоком позволяют вам передавать данные различным
способом.
     Операции  чтения  и  записи  в потоках начинаются с текущей
позиции в  потоке,  узнаваемой  как  "file  pointer"  (указатель
файла)  для  потока.  Указатель  файла изменяется после выполнения
операции  чтения  или записи.
Например,  если  вы  читаете  один  символ  из  потока,
указатель файла  увеличивается  в  1  байт,  так  что  следующая
операция  начнется  с  первого  несчитанного символа. Если поток
этот открытый  для  добавления,  указатель  файла  автоматически
позиционируется в конец файла перед каждоц операцией записи.
     Поток,  связанный  с  устройством (таким как консоль), не
имеет указателя файла. Данные  прибывающие  из  или  ушедшие  на
консоль  не  могут  быть  доступны  случайно. Программы, которые
используют   указатель   файла,   будут   иметь   неопределенный
результат,если используют поток, связанный с устройством.
                            11

            1.6.1.6  Обнаружение ошибок.

  Когда происходит ошибка в операции с потоком, индикатор ошибки
для потока устанавливается. Вы можете использовать  макро  ferror,
чтобы определить ошибка ли произошла. После каждой ошибки индикатор
ошибки остается установленным до тех пор,пока не очистите индикатор
ошибки,  вызвав clearerr или rewind.

             1.6.2  Функции в/в нижнего уровня

        Функция          Использование

          close        -закрыть файл.
          creat        -создать файл.
          dup          -создать   второй  handle для файла.
          dup2         -переназначить handle для файла.
          eof          -тест   (проверка)   для   конца    файла
          lseek        -перепозицирование  указателя   файла   в
                        заданное расположение.
          open         -открыть файл.
          read         -читать данные из файла.
          sopen        -открыть    файл   для разделения файла
          tell         -получить текущую позицию указателя файла.
          write        -записать данные в файл.

      Нижний  уровень  ввода  и  вывода  не  работает с буферизо-
ванными или форматированными данными.  Файлы, открытые  посредством
функции  нижнего  уровня  вызываются ссылкой на файл handle,
целочисленной величины, используюмой операционной системой, чтобы
обращаться к файлу.
       Функция open используется для открытия файлов;
    В MS-DOC версия 3.0 или выше, sopen может быть использована
для открытия файлов с атрибутами файла-деления.
       Функции  нижнего  уровня, в отличии от функции потока, не
требуют включения файла stdio.h. Кроме нескольких общих констант
определенных  в  stdio.h;  например,  индиикатор конца файла EOF ,
может быть полезным. Если ваша программа требует эти  константы,
вы должны включить stdio.h.
       Объявление  для  функций  нижнего  уровня  есть  в  файле
включения io.h.


             1.6.2.1  Открытие файлов.

       Файл должен быть открыт функциями open, sopen  или  creat
до  того  как  ввод  и  вывод  функций нижнего уровня может быть
выполнен с этим файлом.
       Файл может быть открыт для чтения, записи, или  обоих,  и
открыт в текстовом или двоичном виде.
       Файл   включения   fcntl.h   должен  быть  включен, когда
открывается  файл,  так  как  содержит  определения  для  флагов
используемых  в open. В некоторых случаях файл sys\types.h и sys\stat.h
также должны быть включены.
       Эти функции возвращают заголовок (handle) файла, который
используется при последующих операциях с файлом. Когда вы
вызываете одну из  этих  функций,  присвойте возвращаемое значение
целочисленной переменной и используйте  эту  переменную, чтобы
обращаться к открытому файлу.
                            12

             1.6.2.2  Переопределение handle

       Когда  программа  начинает  выполняться, 5 handle
,соответсвующих  стандартному  вводу,выводу,ошибкам,порту и
принтеру,уже  назначены . С использованием следующих переопределенний
handle , программа может вызвать функцию нижнего уровня, сделав
доступным стандартный ввод,вывод,ошибки,порт и принтер потокам

       поток     handle

       stdin       0
       stdout      1
       stderr      2
       stdaux      3
       stdprn      4

       Вы можете  использовать  эти  handle  файлов  в  ваших
программах   без  предварительного открытия  назначенных
файлов.  Они  автоматически   открываються,  когда  стартует
программа.
   Так же как с функциями  потоков,  вы  можете  использовать
переопределения, чтобы переопределить стандартный ввод и вывод.
Функции dup и dup2 позволяют вам назначать много handle для одного
файла; эти  функции  обычно используются, чтобы связать доопределенные
handle с различными файлами.
заголовки файлов с разными файлами.


            1.6.2.3  Чтение и запись данных.

       Операции read и write как и функции  потока,  начинают  с
текущей позиции в файле. Текущая позиция изменяется при каждой операции
чтения или записи.
       Функция eof может  быть  использована для проверки
состояния  конец  файла.   Программы  в/в  нижнего  уровня
устанавливают переменную  errno, когда  происходит  ошибка.  Это
значит,что  вы  можете  использовать  функцию  perror для печати
информации об ошибках в/в.
       Вы можете спозиционировать указатель файла где-нибудь в файле,
используя lseek  функцию.  Следующая  операция берет место с
позиции вами указанной ( определенной ). Используя функция  tell, вы
можете определить текущую позицию указателя файла.
       Устройство   (такое   как  консоль)  не  имеет  указателя
файла. Результат  программ  lseek  и   tell   неопределен,   если
используются с handle, связанный с устройством.


             1.6.2.4  Закрытие файлов.

Функция   close   закрывает   открытые   файлы.  Открытые  файлы
автоматически закрываются, когда программа завершается.
                            13

             1.6.3  Функции в/в с консоли и порта

     cgets             -чтение строк с консоли.
     cprintf           -запись форматированных данных на консоль.
     cputs             -запись строк на консоль.
     cscanf            -чтение форматированных данных с консоли.
     getch             -чтение символов с консоли.
     getche            -чтение символов с консоли с эхом.
     inp               -чтение с указанного порта в/в.
     kbhit             -проверка  для  нажатия клавиши на консоли.
     outp              -запись в указанный порт в/в.
     putch             -запись символа на консоль.
     ungetch           -"неполучение"  последнего прочитанного символа
                        с  консоли  так  что, он становится следующим
                        символом для чтения.

       Эти функции  объявлены  в файле включения conio.h

       Консоль или порт не могут быть открыты или закрыты  перед
выполнением в/в, так что нет функции открытия и закрытия.
       Функции в/в порта (inp и outp) читают или записывают  1
байт  за один вызов  из  указанного порта. Функции в/в с  консоли
позволяют читать и записывать  строки  (cgets и cputs),
форматированные данные (cscanf и cprintf) и символы.
       Функция  kbhit  определяет:  действительно ли нажали на
клавишу консоли. Эта функция позволяет вам проверять ввод  с
клавиатуры до вашей потытки чтения с консоли.
                            14

               1.7  Математика

      acos              -вычисление  арккосинус.
      asin              -вычисление  арксинус.
      atan              -вычисление  арктангенс x.
      atan2             -вычисление  арктангенс y/x.
      bessel            -вычисление  Бессель функции.
      cabs              -находит абсолютное значение комплексного
                         числа.
      ceil              -находит наименьшее целое, большее или равное х.
      _clear87          -получить и очистить слово статуса плавающей
                         точки.
      _control87        -получить старое слово управления с плавющей
                         точкой и переустановить на новое значение.
      cos               -вычисление косинуса.
      cosh              -вычисление гиперболического косинуса.
      dieeetomsbin      -преобразовать число двойной точности из IEEE
                         формата в Microsoft двоичный формат.
      dmsbintoieee      -преобразовать число двойной точности из
                         в Microsoft двоичного формата в IEEE формат.
      exp               -вычисление функции экспоненты.
      fabs              -нахождение абсолютного значения double.
      fieeetomsbin      -преобразовать число с плавающей точкой из
                         IEEE формата в Microsoft двоичный формат.
      floor (пол)       -найти наибольшее целое, меньше или равно х.
      fmod              -нахождение остатка от x/y.
      fmsbintoieee      -преобразовать числос плавающей точкой из
                         Microsoft двоичного формата в IEEE формат.
      _fpreset          -переинициализировать пакет плавающей арифметики.
                                                                     n
      frexp             -представить х как произведение мантиссы на 2 .
                         экспоненте.
      hypot             -вычисление гипотенузы.
                                           exp
      ldexp             -вычисление x на  2.
      log               -вычисление натурального логарифма.
      log10             -вычисление логарифма по основанию 10.
      matherr           -управление ошибками маиематики.
      modf              -разбить х на дробную и целую часть.
      pow               -вычисление x в степени y.
      sin               -вычисление синуса.
      sinh              -вычисление гиперболического синуса.
      sqrt              -нахождение квадратного корня.
      _status87         -получить слово статуса плавающей точки.
      tan               -вычисление тангенса.
      tanh              -вычисление гиперболического тангенса.



      Все  математические  функции  (исключая matherr) работают с
 величинами с плавающей точкой и требует  поддержки  с  плавающей
 точкой.
      Функции объявлены в файле включения math.h, за исключением
_clear87,_control87,_fpreset,_status87, которые определены во вкключае-
мом файле float.h .
      Программа matherr вызывается математической функцией, когда
 происходит  ошибка.  Эта  программа  определена в библиотеке, но
может быть переопределена пользователем, если она необходима для
различных процедур обработки ошибок.
                            15


                  1.8  Манипулирование памятью.

     alloca             -получение блока памяти из программного стэка.
     calloc             -получение памяти для массива.
     _expand            -переполучить блок памяти, не перемещая ее с
                         месторасположения.
     _ffree             -освободить блок, полученный посредством
                         _fmalloc.
     _fmalloc           -получить блок памяти вне данного сегмента.
     free               -освободить блок, полученный посредством
                         calloc,malloc или realloc.
     _freect            -возвращает апроксемированное число областей,
                         заданного размера, которые можно получить.
     _fmsize            -возвращает размер блока памяти, на которую
                         указывает далекий (far) указатель.
     halloc             -получить память для большого массива.
     hfree              -освободить блок памяти, полученный посредством
                         halloc.
     malloc             -получить блок.
     _memavl            -возвращает апроксимированное число байтов,
                         доступных для получения.
     _msize             -возвращает размер блока, полученный посредством
                         calloc,malloc,realloc.
     _nfree             -освобождает блок,полученный посредством _nmalloc.
     _nmalloc           -получить блок памяти в заданном сегменте.
     _nmsize            -возвращает размер блока, на которую указывает
                         близкий (near) указатель.
     realloc            -переполучить блок.
     sbrk               -переустановить адрес первого байта
                         неполученной памяти.
     stackavail         -возвращает размер памяти, доступной для
                         получения посредством alloca.

      Функции  получения  памяти,  позволяют  вам  получить,
освободить и переопределить блоки памяти. Они  объявлены  в  файле
включения malloc.h.
      Функции calloc и malloc получают блоки памяти. Функция malloc
получает заданное число байтов, тогда как calloc получает и инициа-
лизирует нулями массив элементов заданного размера. Функции _fmalloc
и _nmalloc подобны malloc, за исключением того, что _fmalloc и _nmalloc
позволяют получить блок байтов в том случае, когда происходит ограни-
чение по адресу для текущей модели памяти. Функция halloc выполняется
аналогично calloc , но halloc получает память для большого массива
(больше 64К).
Функции realloc и _expand изменяют размер полученного блока.
Функция free (для calloc,malloc и realloc), функция _ffree
(для _fmalloc), функция _nfree (для _nmalloc) и функция hfree
(для halloc) освобождают память, которая была предыдуще получена, и
делают ее доступной для последующего получения.
Функции _freect и _memavl выдают: сколько памяти доступно для
динамического получения в заданном сегменте; _freect возвращает
апроксимированное число полей заданного размера, которые могут
быть получены; _memavl возвращает общее число байтов, доступных
для получения.
Функции _msize (для calloc,malloc,realloc и _expand), _fmsize
(для _fmalloc) и _nmsize (для _nmalloc) возвращают размер блока
полученной памяти.
                            16

      Функция  sbrk  -  это  нижний уровень получения памяти.
Она изменяет переменное число, позволяя программе выгодно брать
годную неразмещенную память.
В  общем,  программа которая использует функцию sbrk
не должна  использовать  другие  функции  размещения памяти,
хотя их использование не запрещено.
    Все предыдущие функции получали память из общей памяти.
Microsoft C также предоставляет 2 функции, alloca и stackavail,
для получения памяти из стэка и определения количества доступной
памяти в стэке.


                 1.9  Интерфейс к MS-DOS.

     bdos              -вызов системы MS-DOS;  использует  только
                        DX и AL регистры.
     dosexterr         -получение значений  регистров из системы
                        MS-DOS вызовом  59H.
     FP_OFF            -возвращает смещение far (далекого) указателя.
     FP_SEG            -возвращает сегмент far (далекого) указателя.
     int86             -вызов прерывания MS-DOS.
     int86x            -вызов прерывания MS-DOS.
     intdos            -системный  вызов  MS-DOS;
                        использует регистры, отличные от DX и AL.
     intdosx           -системный  вызов  MS-DOS;
                        использует регистры, отличные от DX и AL.
     segread           -возвращает текущее значение сегментных
                        регистров.

     Для получения детального описания этих функции смотр раздел
     "Описание функции".
     Эти функции и макро объявлены в dos.h.
                            17

                1.10  Управление процессами.

      abort            -завершить процесс
      execl            -выполнить порождаемый процесс  со
                        списком аргументов.
      execle           -выполнить порождаемый процесс со списком
                        аргументов и заданным окружением.
      execlp           -выполнить порождаемый процесс, используя
                        переменную PATH и список аргументов.
      execlpe          -выполнить порождаемый процесс, используя
                        переменную PATH, заданное окружение и список
                        аргументов.
      execv            -выполнить порождаемый процесс с массивом
                        аргументов.
      execve           -выполнить порождаемый процесс с массивом
                        аргументов и заданным окружением.
      execvp           -выполнить порождаемый процесс, используя
                        переменную PATH и массив аргументов.
      execvpe          -выполнить порождаемый процесс, используя
                        переменную PATH, заданное окружение и массив
                        аргументов.
      exit             -завершить процесс.
     _exit             -завершить процесс без скидывания буферов.
      getpid           -получить номер процесса.
      onexit           -выполнить функцию при завершении программы.
      signal           -управление сигналом прерывания.
      spawnl           -выполнить порождаемый процесс со списком
                        аргументов.
      spawnle          -выполнить порождаемый процесс со  списком
                        аргументов и заданным окружением.
      spawnlp          -выполнить порождаемый процесс, используя
                        переменную PATH и список аргументов.
      spawnlpe         -выполнить порождаемый процесс, используя PATH
                        переменную, заданное окружение и список
                        аргументов.
      spawnv           -выполнить порождаемый процесс с  массивом
                        аргументов.
      spawnve          -выполнить порождаемый процесс с массивом
                        аргументов и заданным окружением.
      spawnvp          -выполнить порождаемый процесс, используя
                        переменную PATH и массив аргументов.
      spawnvpe         -выполнить порождаемый процесс, используя PATH
                        переменную, заданное окружение и массив
                        аргументов.
      system           -выполнение команды MS-DOS.


      Термин " процесс"  относится к программе, которая выполняется
под управлением операционной системы.
      Процесс  состоит из кодов программы и данных, плюс информации,
принадлежащей статусу процесса, такой как число открытых файлов.
Где бы вы не выполняли программу на MS-DOS  уровне,  вы  запускаете
процесс. Добавим,  вы  можете  запустить,  остановить  и  управлять
процессом  из  программы, используя функции управления процессом.
      Все функции управления процессом объявлены в файле включения
process.h.  (исключая  signal).  Функция  signal объявлена в файле
signal.h.
                            18

      Функции управления процессом позволяют сделать следующее:
         1. Идентифицировать процесс уникальным числом (getpid).
         2. Завершить процесс (abort,exit,_exit).
         3. Управлять сигналом прерывания (signal).
         4. Начать новый процес (разновидности exec и spawn функции,
            system функция).

      Функции  abort  и  _exit  осуществляют  немедленное завершение
без скидывания буферов потоков. Функция exit осуществляет выход после
скидывания буферов потоков.
      System вызывает на выполнение заданную команду MS-DOS. Функции
exec и spawn начинают новый процесс, называемый порождаемым прцессом.
Разница  между  exec  и  spawn  программами в том, что spawn
способна возвращать  управление  из  порождаемого процесса к его
родителю.  Оба и родитель и порождаемый процесс размещаются в  памяти
(если  не указан P_OVERLAY)
      В  функции exec порождаемый процесс перекрывает родитель процесс,
так что возврат управления в родитель  процесс  невозможен  (если  не
произошла  ошибка  во  время  попытки  запуска  на выполнение порожда-
емого процесса).
      В Таблице 4.1 приводится способ формирования exec и spawn.
Имя функции задается в первом поле. Второе поле определяет: исполь-
зуется ли PATH переменная для поиска файла на выполнение, которое
определяет порождаемый процесс.
Третье поле описывает метод передачи аргументов порождаемому процессу.
Передача аргументов списком означает,  что аргументы  в порождаемый
процесс передаются списком, как отдельные аргументы, при вызове exec или
spawn. Передача аргументов массивом означает, что аргументы  помещаются
в массив и указатель на массив передается порождаемому процессу.
      Метод  спискок-аргументов  обычно используется, когда число
аргументов постоянно или известно заранее, а метод передачи аргументов
массивом полезен, когда число аргументов должно быть определено во
время работы.
      Последнее поле определяет: унаследует ли окружение порождаемый
процесс от родителя или оно будет изменено для.
                            19

      Таблица 4.1
___________________________________________________________________
|          |   Использование   |     Способ    |                  |
| Функция  |       PATH        |    передачи   |  Окружение       |
|          |    переменной     |   аргументов  |                  |
|__________|___________________|_______________|__________________|

  execl          не использует     список          наследует от
  spawnl            PATH           аргументов      родителя

  execle         не использует     список          указатель на
  spawnle           PATH           аргументов      таблицу окружения
                                                   (последний аргумент)

  execlp         использует        список           наследуют от
  spawnlp           PATH           аргументов       родителя

  execlpe        использует        список          указатель на
  spawnlpe          PATH           аргументов      таблицу окружения
                                                   (последний аргумент)

  execv          не использует     массив           наследуют от
  spawnv            PATH           аргументов       родителей

  execve         не использует     массив           Указатель на
  spawnve           PATH           аргументов       таблицу окружения
                                                    (последний аргумент)

  execvp         используют        массив           Унаследует от
  spawnvp          PATH            аргументов       родителя

  execvpe        использует        массив           Указатель на
  spawnvpe          PATH           аргументов       таблицу окружения
                                                    (последний аргумент)
___________________________________________________________________
                            20

                 1.11  Поиск и сортировка.

      bsearch          -выполняет двоичный поиск.
      lfind            -выполняет линейный поиск для заданного значения.
      lsearch          -выполняет линейный поиск для заданного значения,
                        которое добавляется в массив, если не найдено.
      qsort            -выполняет быструю сортировку.

          Эти функции объявлены в файле search.h.


                1.12  Манипуляции со строками.

      strcat           -добавить строку.
      strchr           -найти первое месторасполжение заданного символа
                        в строке.
      strcmp           -сравнить две строки.
      strcmpi          -сравнить две строки, считая символы нижних и
                        верхних регистров равными ("грубое" сравнение).
      strcpy           -копировать одну строку в другую.
      strcspn          -найти первое месторасположение символа из
                        заданного набора символов в строке.
      strdup           -дублирование строки.
      strerror         -сохранить системное ошибочное сообщение и
                        необязательное пользовательское ошибочное
                        сообщение в строке.
      stricmp          -"грубое" сравнение двух строк (идентично
                        strcmpi).
      strlen           -найти длину строки.
      strlwr           -преобразовать строку в символы нижнего регистра.
                        (прописные буквы).
      strncat          -добавить n символов в строку.
      strncmp          -сравнение n символов в двух строках.
      strncpy          -скопировать  n  символов из одной строки в
                        другую.
      strnicmp         -"грубое" сравнение n символов двух строк.
      strnset          -установить n символов в  строке  в  заданный
                        символ.
      strpbrk          -найти первое месторасположение символа из одной
                        строки в другой.
      strrchr          -найти последнее месторасположение заданного
                        символа в строке.
      strrev           -переставить (перевернуть) строку.
      strset           -установить все  символы  строки  в  заданный
                        символ.
      strspn           -найти  первую  подстроку из заданного набора
                        символов в строке.
      strstr           -найти первое месторасположение заданной строки
                        в другой.
      strtok           -найти следующую точку в строке.
      strupr           -преобразовать строку в символы верхнего регистра
                        (заглавные буквы).

      Эти функции строк объявлены в файле string.h.
      Все  функции  строк  работают со строками, завершающимися нулевым
символом. Когда работают с массивом символов, не имеющих в конце нулевого
символа,  вы  можете  использовать  функции преобразования буферов,
описанные выше в этой главе.
                            21

                 1.13  Манипуляции со временем

      asctime          -обращение   времени   из    структуры    в
                        символьную строку.
      ctime            -обращение времени из длинного целого (long
                        integer) в строку символов.
      ftime            -получить   текущее   время   системы   как
                        структуру.
      gmtime           -обращение  времени  из  целого (integer) в
                        структуру.
      localtime        -обращение   времени   из    целочисленного
                        (integer)    в   структуру   с   локальным
                        исправлением.
      time             -получить  текущее  системное   время   как
                        длинное целое (long integer).
      tzset            -установить  переменную внешнего времени из
                        переменной времени среды.
      utime            -установить время изменения файла.

      Функции time и ftime  возвращают  текущее  время  как  число
секунд   прошедших   с   1  января  1970  Гринвичского  Всемирного
времени. Эта величина может быть преобразована, приспособлена и сохра-
нена различным образом,  используя asctime, ctime, gmtime и localtime
функции.  Функция  utime   устанавливает   время  модификации  для
указанного  файла , используя текущее время или значение времени,
хранимое в структуре.
      Функция ftime требует  2  файла  включения:  sys\types.h   и
sys\timeb.h. Функция ftime объявлена в sys\timeb.h.
      Функция utime также требует два файла включения: sys\types.h
и sys\utime.h. Объявлена функция utime в файле sys\utime.h.
      Остальные функции времени объявлены в файле time.h.
      Когда  вы  хотите  использовать ftime или localtime, чтобы сделать
регулировку  для  локального   времени,   вы   должны   определить
переменную среды  TZ.


             1.14  Функции манипуляции со списком аргументов

      va_arg          -восстановить аргумент из списка.
      va_end          -переустановить указатель.
      va_start        -установить указатель на начало списка аргументов.

      Эти функции дают возможность получить доступ к аргументам функции,
когда число аргументов переменно.
      Для совместимости с UNIX System V используйте файл включения
vararg.h; для совместимости с ANSI C используйте stdarg.h.
                            22

                1.15  Другие функции

      abs             -найти абсолютное значение int.
      assert          -тест для логических ошибок.
      getenv          -получить величину переменной среды (окружения).
      labs            -найти абсолютное значение long.
      longjmp         -восстановить  сохраненную среду.
      perror          -напечатать сообщение ошибки.
      putenv          -добавить или изменить значение переменной
                       среды.
      rand            -получить псевдо-случайное число.
      setjmp          -сохранить среду.
      srand           -инициализировать псевдо-случайные наборы.
      swab            -перемешать байты в данных.

      Все функции, исключая assert,longjmp и setjmp, описаны в stdlib.h.
      Аssert-это макро и определена в assert.h.
      Функции setjmp и longjmp объявлены в setjmp.h.
      Программы getenv и putenv предоставляют доступ в таблицу среды.
 Глобальная  переменная environ также указывает на таблицу среды, но
 рекомендуем, чтобы  вы  использовали  getenv и putenv функции для
 доступа  и  изменения  установленной среды, нежели обращаться к
 таблице среды прямо.
      Функция perror печатает системное ошибочное сообщение для послед-
 него вызова системы, которая сгенерировала ошибку.
      Программа  swab типично используется,чтобы преобразовать данные
 для машины, которая использует другое старшинство байтов.

                            23

         глава 2. ОПИСАНИЕ ФУНКЦИИ


                            ABORT

    ФОРМАТ

  #include <process.h>    /* используется только для описания функции */
  #include <stdlib.h>     /* используйте либо process.h либо stdlib.h */
    void abort();

    ОПИСАНИЕ

  Функция abort выводит сообщение
   Abnormal program termination (ненормальное завершение программы)
  to stderr, потом завершает вызванный процесс, возвращает управление
  процессу, который инициализировал вызванный процесс (обычно операци
  онная система)
  Abort не скидывает буфера, связанные с потоками

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Статус 3 возвращается процессу источнику или операционной  системе

    СМОТРИ ТАКЖЕ

  execl,execle,execlp,execlpe,execv,execve, execvp, execvpe,exit,
  _exit,signal,spawnl,spawnle,spawnlp,spawnlpe,spawnv,spawnve,spawnvp,
  spawnvpe

    ПРИМЕР

  #include<stdio.h>

  main(argc,argv)
  int argc;
  char *argv[];
  {
  FILE  *stream;
  if ((stream=fopen(argv[argc-1],"r"))==NULL) {
          fprintf(stderr,
                  "%s невозможно открыть файл %s\n",argv[O],argv[argc-1]);
          abort();
          }
          /* Note; the program name is stored in argv[O] only in
          ** MS-DOS version 3.0 and later; in version prior to
          ** 3.0, argv[O] conains the string "C"
          */
  }

  ВЫВОД:
  c:\bin\update.exe невозможно открыть файл employ.dat
  Abnormal program termination

                            24

                            ABS

    ФОРМАТ

  #include <>    /* используется только для описания функции */
  int abs(n);
  int n;


    ОПИСАНИЕ

  abs функция возвращает абсолютное значение аргумента, которое яв-
  ляется целым числом

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  abs функция возврашает абсолютное значение ее  аргумента. Нет кодов
  ошибок.

    СМОТРИ ТАКЖЕ

  cabs,fabs,labs

    ПРИМЕР

  #include <stdlib.h>
  int x=-4,y;
  y=abs(x);
  print("%d\t%d\n",x,y);

  ВЫВОД:
  -4      4

                            25

                            ACCESS

    ФОРМАТ

  #include <io.h> */используется только для описания функции */
  int access(pathname, mode);
  char *pathname;
  int mode;


    ОПИСАНИЕ

  ACCESS функция устанавливает: существует ли указанный файл и есть ли к нему
  к нему доступ в данном mode (способе доступа). Возможное значение
  mode и его суть следующие:
         06 Проверить на возможность чтения и записи
         04 Проверить на возможность чтения
         02 Проверить на возможность записи
         00 Проверить на сушествование файла

  В MS DOS все существующие файлы доступны для чтения. Таким образом
  mode 00 и 04, а также 02 и 06 идентичны

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
  0 - есть доступ в указанном способе доступа
  1 - нет доступа в указанном способе доступа
      или файла не существует и при этом errno устанавливается в одно
      из следующих значений:
         EACCES - нет доступа в указанном способе доступа
         ENOENT - файл или путь к нему не найден


    СМОТРИ ТАКЖЕ

  chmod,fstat,open,stat

    ПРИМЕР

  #include<io.h>
  #include<fcntl.h>
  int fn;
  .
  .
  .
  /* проверка на возможность записи */
  if ((access("data",2))== -1) {
          perror("нет доступа для записи в файл");
          exit(1);
          }
  else
          fn = open("data", O_WRONLY);



                            26

                           ACOS


    ФОРМАТ

  #include <math.h>
  double acos(x);
  double x;


    ОПИСАНИЕ
  Acos функция вычисляет значение арккосинуса от x. Возвращаемое зна-
  чение находится в пределах от -1 до 1.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
  Значение арккосинуса от аргумента .
  0, если значение аргумента х не находится в пределах от -1 до 1;
  при этом errno устанавливается в EDOM и печатается сообщение об
  ошибке DOMAIN в stderr.
  Обработку ошибочной ситуации можно изменить, используя matherr
  команду

   СМОТРИ ТАКЖЕ

  asin,atan,atan2,cos,matherr,sin,tan

   ПРИМЕР

  #include <math.h>
  int errno;
  main( )
         {
         float x,y;

         for (errno=EDOM; errno==EDOM; y=acos(x)) {
         printf("Косинус = ");
         scanf("%f",&x);
         errno=0;
         }
         printf("Аркосинус от %f=%f\n",x у);
         }

  ВЫВОД:
  Косинус = 3
  acos: DOMAIN error
  Косинус = -1.0
  Аркосинус от -1.000000 = 3.141593


                            27

                            ALLOCA

    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */
  char *alloca(size);
  unsigned size;

    ОПИСАНИЕ

  Команда получает size байтов из программного стека.
  Полученная память автоматически освобождается, когда функция,
  которая вызвала alloca, завершается.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Cимвольный указатель на полученную память.
  Память, на которую указывает возвращаемое значение, является выров-
  ненной для любого типа объектов. Чтобы получить указатель, отличный
  от символьного, используйте преобразование типа для возвращаемого зна-
  чения.
  Возвращаемое значение есть NULL, если память не может быть получена.

    СМОТРИ ТАКЖЕ

  calloc, malloc, realloc

  Замечание: значение указателя, которое возвращает alloca, никогда
             не должно использоваться, чтобы передать как аргумент
             для free функции. Так как alloca манипулирует со стэком,
             он должен использоваться только в простых операторах
             присваивания, и не должен использоваться в выражениях,
             которые являются аргументом к функции.

    ПРИМЕР

  #include <malloc.h>
  int *intarray;
  /* Получение памяти для 10 целых */
  intarray = (int *)alloca(10*sizeof(int));
                            28

                            ASCTIME

    ФОРМАТ

  #include <time.h>
  char *asctime(time);
  struct tm *time;


    ОПИСАНИЕ

  Функция asctime преобразует время из структурного формата в строку
  символов. Значение времени обычно получают, используя gmtime или
  localtime функции, которые возвращают указатель на tm структуру,
  установленной в time.h
  Результатом выполнения asctime является строка, содержащая 26 симво-
  лов и форму, показанную на следующем примере:
  Mon Jan 02  02:03:55  1980\n\0
  Символы новой строки (\n) и конца строки (\n) занимают две последние позиции в
  позиции в строке.


   ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Указатель на строку результат. Нет ошибочных кодов возврата.


  СМОТРИ ТАКЖЕ

 ctime, ftime, gmtime, localtime, time, tzset

  ПРИМЕР

 #include <time.h>
 #include <stdio.h>
 struct tm *newtime;
 long ltime;
 .
 .
 .
 time(&ltime);
 newtime=localtime(&ltime);


 printf ("Текущая дата и время: %s\n",
         asctime(newtime));




                            29

                           ASIN

   ФОРМАТ

  #include<math.h)
  double asin(x);
  double x;

   ОПИСАНИЕ

  Функция вычисляет арксинус аргумента х. Значение находится в пре-
  делах от -пи/2 до пи/2.
  Значение аргуменнта х должно быть в пределах от -1 до 1.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Значение арксинуса от аргумента.
  0, если значение аргумента х не находится в пределах от -1 до 1;
  при этом errno устанавливается в EDOM, печатается сообщение об
  ошибке DOMAIN в stderr.
  Обработку ошибочной ситуации можно изменить, используя matherr ко-
  манду.

    СМОТРИ ТАКЖЕ

  acos,atan,atan2,cos,matherr, sin, tan.

    ПРИМЕР

  #include <math.h>
  int errno;
  main( )
        {
        float x, y;
        for  (errno=EDOM; errno==EDOM; y=asin(x)) {
                printf("Синус = ");
                scanf("%f,&x);
                errno=0;
                }

        printf ("Aрксинус от %f=%f\n",x,y);
        }

 ВЫВОД:
 Синус = -1.001
 asin: DOMAIN error
 Cинус = -1
 Арксинус от -1.000000 = -1.570796



                            30

                         ASSERT


     ФОРМАТ

  #include <assert.h>
  void assert (expression);

     ОПИСАНИЕ

  ASSERT команда печатает диагностическое сообщение и завершает вызван-
  ный процесс,если значение выражения ложь (0). Диагностическое сооб-
  щение имеет следующую форму:
  Asseption failed: file <имя файла>, line <номер строки>
  Если значение выражения истина, то никаких действий не выполняется
  Assert команда обычно используется, чтобы определить в программе
  логические ошибки.
  Заданное выражение должно измениться таким образом,чтобы оно имело
  значение истина, только в том случае, когда программа выполняется
  правильно (как задумано). После того, как программа отлажена, мож-
  можно использовать идентификатор NDBUG, чтобы не выполнить assert
  команды.
  Если NDBUG установлен с  /D опцией или с директивой  #define, то
  процессор не будет обрабатывать assert команду в исходной программе

     ПРИМЕР

  #include <stdio.h>
  #include <assert.h>
  analyze_string (string)
  char *string;
          {
          /* Проверка строки перед обработкой */
          assert (string =NULL);


          assert (*string != '\ 0');
          .
          .
          .
          }




                            31

                         ATAN-ATAN2


     ФОРМАТ

  #include<math. h>

  double atan(x);
  double(x);

  double atan2(y,x);
  double x;
  double y;

     ОПИСАНИЕ

  atan и atan2 функции вычисляют арктангенс x и y/x соответственно:
  atan возвращает значение в пределах от -пи/2 до пи/2; atan2 возвра-
  щает значение в пределах от -пи до пи.

     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  atan и atan2 возвращают значение арктангенса.
  0, если оба аргумента функции atan2 нулевые; при этом errno
  устанавливается в EDOM и печатается сообщение об ошибке DOMAIN
  в stderr.
  Обработку ошибки можно изменить, используя команду matherr.

     СМОТРИ ТАКЖЕ

  acos, asin, cos, matherr, sin, tan

     ПРИМЕР

  #include<math.h>

  printf("%.7f\n",atan(1.0));
  printf("%.7f\n"atan2(-1.0,1.0);

  ВЫВОД:
  0.7853982
  -0.7853982
                            32

                          ATOF-ATOL

     ФОРМАТ

  #include<math.h>
  #include<stdlib.h>    /* используйте math.h или stdlib.h */

  double atof(string);
  char* string;

  #include<stdlib.h>

  int atoi(string);
  long atol(string);
  char *string;

     ОПИСАНИЕ

  Эта функция преобразует строку символов в число с плавающей точкой
  двойной точности (atof), в целое (atoi), в длинное целое (atol).
  Строка символов является последовательностью символов,которая может
  быть интерпретирована, как числовое значение определяемого типа.
  Функция заканчивает чтение символов из входной строки, как только
  встретит символ, который не может быть распознан как часть числа
  (который может быть символом конца строки).
  Для atof строка должна иметь форму:
         [ограничитель][знак][цифры][.цифры][e[знак]цифры]
  Ограничитель-может состоять из символов пробела и/или вертикальной
  табуляции, которые игнорируются.
  Знак-это "+"или "-".
  Цифры -это один или более десятичных цифр.
  Если нет цифр до десятичной точки, то они должны присутствовать после
  десятичной точки.
  Знак  "e"или "E" есть экспонента.
  Для atoi и atol строка должна иметь форму:
  [ограничитель][знак][цифры].


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Функции возвращают значения с плавающей точкой двойной точности,
  целое или длинное число, произведя интерпретацию строки символов
  как число.
  0(0L для atof), если не может преобразовать входную строку.

     СМОТРИ ТАКЖЕ

  ecvt,fcvt,gcvt
                            33

     ПРИМЕР

  #include <math.h>
  extern long atol(\ );
  main  (\ )
        {
        char *s;
        double x;
        int i;
        long l;

        s = " -2309.12E-15;
        x = atof(s);
        printf("%e\t",x);

        s = "7.8912654773d210";
        x = atof(s);
        printf("%e\t",x);

        s = "  -9885";
        i = atoi(s);
        printf("%d\t",i);

        s = "98854 dollars";
        l = atol(s);
        printf("%ld\n",l);
        }

    ВЫВОД:
    -2.309120e-012  7.891265e +210   -9885   98854



                            34

                            BDOS

     ФОРМАТ

  #include<doc.h>

  int bdos(dosfn, dosdx, dosal);
  int dosfn;
  unsigned int dosdx;
  unsigned int dosal;


    ОПИСАНИЕ

  Функция выполняет обращение к MS-DOS, которое определяется в dosfn,
  передав значения dosdx и docol в DX и AL регистры ,соответственно
  Bdos выполняет INT21H команду, чтобы обратиться к системе.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Bdos возвращает результат обращения к системе в AX регистре.

    СМОТРИ ТАКЖЕ

  intdos, intdosx.

    ПРИМЕР

  Пример показывает обращение к 9 функции (высветить строку).
  AL регистр не используется.

  #include <dos.h>

  char *buffer = "Введи имя файла:$" ;
          /* В AL нет необходимости, 0 используется */
  bdos (9,(unsigned) buffer,0);






                            35

                           BESSEL

     ФОРМАТ

  #include<math.h>
  double j0(x);
  double j1(x);
  double jn(n,x);
  double y0(x);
  double y1(x);
  double yn(n,x);
  double x;
  int n;

     ОПИСАНИЕ

  j0,j1 и jn команды возвращают bessel функцию первого порядка по-
  следовательностей 0,1 и n соответственно.
  y0,y1 и yn команды вазвращают bessel функцию втогого порядка по-
  следовательностей 0,1, и n соответственно. Аргумент х должен быть
  положительным.

     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Эти функции возвращают результат beesel функции от х.
  Для j0,j1,y0,y1, если х слишком велико, возвращается значение 0,
  в errno засылается ERANGE и выводится сообщение об ошибке TLOSS
  в stderr.
  Для y0, y1 или yn, если значение x отрицательно, возвращается значение
  HUGE, errno устанавливается в EDOM и выводится ошибочное сообщение
  DOMAIN на stderr.
  Обработку ошибок можно изменить используя matherr команду.


     СМОТРИ ТАКЖЕ

  matherr

     ПРИМЕР

  #include<math.h>
  double x,y,z;
  .
  .
  .
  y=j0(x);
  z=yn(3,x);





                             36

                            BSEARCH

    ФОРМАТ

  #include <search.h> /* используется только для описания функции */
  char * bsearch(key, base, num, width, compare);
  char *key;
  char *base;
  unsigned num, width;
  int (*compare)();

    ОПИСАНИЕ

  Bsearch функция выполняет поиск в отсортированном массиве из num
  элементов,каждый из которых имеет длину в width байтов.
  Base является указатель на массив, в котором, ,будет вестись поиск.
  Значение key является значением, по которому будет вестись поиск.
  Compare является указателем на шаблон, по которому будут сравнивать-
  ся два элемента массива и возвращать значение определяющее их соот-
  ношение. Bsearch будет вызывать compare шаблон один или более раз
  в течении сортировки, переводя указатель к двум элементам массива
  при каждом вызове.
  Шаблон должен сравнивать элементы, потом возвращать одно из следую-
  щих значений.
  < 0, если элемент 1 меньше элемента 2
    0, если элемент 1 равен элементу 2
  > 0, если элемент 1 больше элемента 2


    BОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Указатель на первое месторасположение key в массиве
 NULL, если key не найден

    СМОТРИ ТАКЖЕ

 lfind,lsearch,qsort
                            37

    ПРИМЕР

  #include <search.h>
  #include <string.h>
  #include <stdio.h>

  int compare();
  main (argc,argv)
    int argc;
    char **argv;
    {
    char **result;
    char *key = "PATH";
  /* Следующие утверждения находят аргумент, который начинается
     с "PATH", предполагая, что аргументы лексографически отсортированы
  */
    result = (char **)bsearch((char *)&key, (char *)argv,
                              argc, sizeof(char *),compare);
    if (result)
       printf ("%s найден\n",*result);
    else
       printf ("%s Путь не найден\n",*result);
    }
 int compare (arg1,arg2)
     char **arg1, **arg2;
     {
     return (strncmp(*arg1,*arg2,strlen(*arg1)));
     }
                            38

                            CABS


     ФОРМАТ

   #include<math.h>
   double cabs(z);
   struct compex z;

     ОПИСАНИЕ

   Cabs функция вычисляет абсолютное значение комплексного числа.
   Комплексное число должно иметь структуру типа complex, опреде-
   ленный в math.h в следующем виде:
   struct complex {
          double x,y;
          };
   Вызов cabs эквивалетно sgrt(z.x*z.x+x.y*z.y)

     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Cabs возврапщает абсолютное значение. Нет кодов ошибок.


     СМОТРИ ТАКЖЕ

   abs, fabs, labs


     ПРИМЕР

   #include<math.h>

   struct complex value;
   double d;

   value.x=3.0;
   value.y=4.0;

   d=cabs(value);



                            39

                           CALLOС


     ФОРМАТ

   #include<malloc.h>

   char *calloс(n,size);
   unsigned n;
   unsigned size;


     ОПИСАНИЕ

   Calloс функция получает область памяти для массива из n элементов,
   каждый из которых имеет длину в size байтов. Каждый элемент ини-
   циализируется нулем.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Указатель на полученную область памяти.
   NULL, если нет доступной памяти .


     СМОТРИ ТАКЖЕ

   free, halloс, hfree, malloс, realloс


     ПРИМЕР

   #include<malloс.h>

   long *lalloс;
   .
   .
   /* Получение памяти для 40 long целых и проинициализировать 0 */
   lalloс= (long *)calloс (40,sizeof (long));


                             40

                             CEIL


     ФОРМАТ

   #include<math.h>

   double ceil(x);
   double x;


     ОПИСАНИЕ

   Ceil функция возвращает самое маленькое целое, которое больше или
   равно значению числа с плавающей точкой.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Число с плавающей точкой. Нет кодов ошибок.


     ПРИМЕР

   #include <math.h>

   double y;
   .
   .
   .
   y=ceil(1.05);            /*y=2.0 */
   y=ceil(-1.05);           /*y=-1.0 */




                            41

                            CGETS


     ФОРМАТ

   #include<conio.h> /* используется только для описания функции */

   char *cgets(str);
   char *str;


     ОПИСАНИЕ

   Cgets функция читает строку символов прямо с консоли и помещает
   строку и ее длину по указателю str. Str должен быть указателем
   на массив символов.
   Первый элемент массива str[0] должен содержать максимальную длину
   строки, которая будет прочитана. Массив должен иметь достаточную
   длину, чтобы поместить строку, символ конца строки ('\0') и два
   байта дополнительно.
   Cgets читает символы до тех пор, пока не прочитает возврат каретки\
   перевод строки комбинацию (CR-LF) или установленное число символов
   не будет прочитано.
   Прочитанная строка начинается со str[2]. Если прочитан CR-LF комби-
   нация она располагается за символом конца строки ('\0').
   Действительная длина строки помещается в str [1].


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Указатель на начало строки, т.е. на str [2]. Нет кодов ошибок.


     CМОТРИ ТАКЖЕ

   getch, getche


     ПРИМЕР

   #include <conio.h>

   char buffer [82];
   char *result;
   int numread;
   .
   .
   .
   *buffer = 80;   /* максимальное число символов */
   result = cgets (buffer); /* чтение символов с консоли */
   numread = buffer[1];     /* количество прочитанных символов */
                            42

                           CHDIR


     ФОРМАТ

   #include<direct.h> /* используется только для описания функции */
   int chdir (pathname);
   char *pathname;


     ОПИСАНИЕ

   Chdir функция обращается в текущий каталог,чтобы изменить его на
   каталог, установленный в pathname. Pathname должен указывать на
   существующий каталог.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   0, если текущий каталог успешно изменен, или текущим  был каталог,
   который определен в pathname.
   1, если установленный в pathname каталог не может быть найден.
   При этом errno устанавливается в ENOENT.


     СМОТРИ ТАКЖЕ

   mkdir, rmdir, system


     ПРИМЕР

   #include <direct.h>
   /* Следующие утверждения устанавливают текущим корневой каталог  */

   chdir ("/");







                            43

                           CHMOD


     ФОРМАТ

   #include <sys\types.h>
   #include <sys\stat.h>
   #include <io.h>

   int chmod (pathname,pmode>;
   char *pathname;
   int pmode;


     ОПИСАНИЕ

   Chmod функция изменяет доступ, установленнный для файла,
   который определен в pathname. Доступом для файла является чтение
   и запись. pmode константное выражение, содержащее одну или обе
   костанты S_IWRITE  и S_IREAD , определенные в sys\stat.h.
   Другие значения для pmode  игнорируются.
   Когда задаются обе константы, оно разделяется оператором OR (|).
   Суть pmode аргумента в следующем:
      S_IWRITE            доступ для записи
      S_IREAD             доступ для чтения
      S_IREAD | S-IWRITE  доступ для чтения и записи.
   В MS-DOS все файлы доступны для чтения, таким образом S_IWRITE  и
   S_IREAD|S_IWRITE являются эквивалентными.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   0 - доступ успешно изменен.
   1 - не может быть найден указанный файл;
   errno устанавливается в ENOENT.


     СМОТРИ ТАКЖЕ

   access, creat, fstat, open, stat


     ПРИМЕР

   #include <sys\types.h>
   #include <sys\stat.h>
   #include <io.h>

   int result;
   .
   .
   .
   result = chmod("data",S_IREAD); /* определить файл только для чтения */
   if (result == -1)
          perror ("невозможно изменить доступ к файлу");





                            44

                           CHSIZE


     ФОРМАТ

   #include<io.h>  /* используется только для описания функции */
   int chsize(handle,size);
   int handle;
   long size;


     ОПИСАНИЕ

   Chsize функция расширяет или сужает файл, связанный с handle до
   длины, определенной в  size. Файл должен быть открыт с доступом для
   записи. Нулевой символ ('\0') добавляется, если файл расширя-
   ется. Если файл сужается, все записи с конца файла до длины size
   обрезаются.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   0  - если длина успешно изменена.
   -1 - индицирует ошибку, при этом errno устанавливается в одно из
   следующих значений:

    EACCES  - указанный файл только для чтения.
              В MS-DOS 3.0 и поздних версиях EACCES может индицировать,
              что файл закрыт для доступа.
    EBADF  -  недействительное handle.
    ENOSPC -  недостаточно места на устройстве.


     СМОТРИ ТАКЖЕ

   close, creat, open


     ПРИМЕР

   #include <io.h>
   #include <fcntl.h>
   #include <sys\types.h>
   #include <sys\stat.h>

   #define MAXSIZE 32768L
   int fn, result;
   .
   .
   .
   fn = open("data", O_RDWR|O_CREAT,  S_IREAD|S_IWRITE);
   .
   .
   .
   /*                   */
   if (lseek(fn,OL,2) > MAXSIZE)
           result = chsize (fn, MAXSIZE);










                            45

                          _CLEAR87


    ФОРМАТ

  #include <float.h>
  unsigned int _clear87();

    ОПИСАНИЕ

  Функция получает и очищает слово статуса с плавающей точкой.
  Слово статуса с плавающей точкой есть
  комбинация 8087/80287 слово статуса и других условий, обнаруженных
  обработчиком исключительных состояний 8087/80287, такие как пере-
  полнение и недополнение стэка с плавающей точкой.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Биты в возвращаемом значении индицируют статус с плавающей точкой.
  Смотри включаемый файл floct.h для получения описания битов,
  возвращаемых _clear87.


    СМОТРИ ТАКЖЕ

  _control87,_status87

    ПРИМЕР

  #include <stdio.h>
  #include <float.h>

  double a = 1e-40,b;
  float x,y;

  main ()
    {
    printf("status =%.4x - clear\n",_clear87());
    y=a;           /*store into y is inexact and underflows */
    printf("status =%4x - inexact, underflow\n",_clear87());
    b = y;         /* y is denormal */
    printf("status =%.4x - denormal\n",_clear87());






                            46

                           CLEARERR


     ФОРМАТ

   #include <stdio.h>

   void clearerr (stream);
   FILE *stream;


     ОПИСАНИЕ

   Clearerr функция устанавливает индикатор ошибки и индикатор конца
   файла для указанного потока на 0. Индикатор ошибки автоматически
   не очищается, т.е.если установлен индикатор ошибки для указаннного
   потока, то при последующих операциях с потоком будет возвращаться
   индикатор ошибки до тех пор, пока не будут выполнены clearerr или
   rewind функции (не будет очищен индикатор ошибки).


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Нет кодов возврата

     СМОТРИ ТАКЖЕ

   eof,feof,ferror,perror

     ПРИМЕР

   include <stdio.h>
   include <stdlib.h>

   FILE *stream;
   int c;
   /* Следующие утверждения выводят данные в поток и потом
   выполняют проверку: была ли ошибка. Поток должен быть предварительно откры
   открыт для записи
   */
   if ((c=getc(stream)) == EOF) {
      if (ferror(stream) {
          fprintf(stderr,"ошибка записи\n");
          clearerr(stream);
          }
   }
                            47

                            CLOSE


    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */

  int close(handle);
  int handle;

    ОПИСАНИЕ

  Функция закрывает файл, связанный с handle.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  0,  если файл успешно закрыт.
  -1, если недействительный handle аргумент; errno устанавливается
      в EBADF.

    СМОТРИ ТАКЖЕ

  chsize,creat,dup,dup2,open,unlink


    ПРИМЕР

  #include <io.h>
  #include <fcntl.h>

  int fh;

  fh = open("data",O_RDONLY);
  .
  .
  .
  close(fh);
                            48

                         _CONTROL87

    ФОРМАТ

  #include <float.h>

  unsigned int _control87(new, mask);
  unsigned int new;
  unsigned int mask;


    ОПИСАНИЕ

  Функция получает и устанавливает слово управления плавающей точки.
  Слово управления плавающей точки позволяет программе изменить
  точность,способ округления,граничность в пакете арифметики пла-
  вающей точки.Обработка исключений плавающей точки может также
  быть замаскирована или размаскирована, используя функцию _control87.
  Если значение для mask равно 0, то _control87 получает слово управ-
  ления плавающей точки.Если mask ненулевое, то новое значение слова
  устанавливается следующим образом; для любого бита, который включен
  (равен 1) в mask, соответствующий бит в new используется, чтобы
  изменить слово управления. Другими словами
    fpcntrl=((fpcntrl & ~mask) | (new & mask)),
  где frcntrl является словом состояния плавающей точки.



    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Биты в возвращаемом значении индицирует состояние плавающей точ-
  ки. Смотри включаемый файл для получения описания битов,возвраща-
  емых _control87.


    СМОТРИ ТАКЖЕ

  _clear87, _status87

    ПРИМЕР

  #include <stdio.h>
  #include <float.h>

  double a = .1;

  main()
         {
         /* получить слово состояния */
         printf("control = %.4x\n", _control87(0,0));
         printf("a*a= .01 =%.15e\n",a*a);
         /* установить точность, равный 24 бита */
         _control87(PC_24,MCW_PC);
         printf("a*a= .01 (rounded to 24 bits)= %.15e\n",a*a);
         /* установить инициирование по умолчанию */
         _control87(CW_DEFAULT,Oxffff);
         printf("a*a= .01 =%.15e\n",a*a);
         }




                            49

                          COS-COSH

    ФОРМАТ

  #include <math.h>
  double cos(x);
  double cosh(x);
  double x;

    ОПИСАНИЕ

  Функция cos и cosh возвращает косинус и гиперболический косинус от x,
  соответственно.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Функция COS возвращает косинус от x.
  Если x большое и происходит
  частичная утрата результата, то COS генерирует ошибку PLOSS, но
  сообщение не печатает. Если x такое большое, что происходит полная
  утрата результата, то COS печатает ошибочное сообщение TLOSS на
  sdterr, возвращает 0. В обоих случаях errno устанавливается в
  ERANGE.
  Функция COSH возвращает гиперболический косинус от x.
  Если результат является очень большим, то COSH возвращает значение HUGE
  и устанавливает errno в ERANGE. Обработку ошибок можно изменить,
  используя matherr команду.

    СМОТРИ ТАКЖЕ

  acos, asin, atan, atan2, matherr, sin, sinh, tan, tanh

    ПРИМЕР

  #include <math.h>

  double x, y;
  .
  .
  .
  y = cos(x);
  y = cosh(x);




                            50

                          CPRINTF


     ФОРМАТ

   #include <conio.h> /* используется только для описания функции */

   int cprintf (format-string[,argument...]);
   char *format-string;

     ОПИСАНИЕ

   Cprintf функция форматирует и выводит наборы сомволов и значений на
   консоль, используя функцию putch для вывода символов.
   Каждый аргумент преобразуется и выводится в том формате, который
   определен в format-string.
   Format-string имеет определенную форму и функцию и является аргу-
   ментом для cprintf функции.
   Format-string и аргументы описаны в описании функции printf.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Cprintf возвращает количество напечатанных символов .


     СМОТРИ ТАКЖЕ

   fprintf,printf,sprintf,vprintf

     ПРИМЕР

   #include <conio.h>

   int i = -16, j = 29;
   unsigned int k = 511;
   /* Следующее утверждение напечатает i=16, j=0x1d, k=511 */
   cprintf("i=%d, j=%#x, k=%\n",i,j,k);



                            51

                            CPUTS


     ФОРМАТ

   #include <conio.h> /* используется только для описания функции */

   void cputs(str);
   char *str;

     ОПИСАНИЕ

   Cputs функция записывает строку,( указанную в str ) вместе с симво-
   лом конца строки на консоль.
   Заметим, что комбинация возврат каретки/перевод строки не записывается


     ВОЗРАЩАЕМОЕ ЗНАЧЕНИЕ

   Нет кодов возврата

     СМОТРИ ТАКЖЕ

   putch

     ПРИМЕР

   #include <conio.h>

   char *buffer = "Вставьте диск с данными в драйвер a: \r\n";
   /* Следующее утверждение выводит запрос на консоль */
   cputs(buffer);

                            52

                           CREAT


     ФОРМАТ

   #include <sys\types.h>
   #include <sys\stat.h>
   #include <io.h> /* используется только для описания функции */

   int creat(pathname,pmode);
   char *pathname;
   int pmode;

     ОПИСАНИЕ

   Creat функция либо создает новый файл, либо открывает и сужает су-
   ществующий файл. Если файл, указанный в pathname не существует,
   новый файл создается с заданным доступом и открывается для записи.
   Если файл уже существует с доступом для записи, creat сужает файл
   до длины 0, уничтожая предыдущие данные и открывая его для записи.
   Доступ, установленный в pmode, применим только к вновь создаваемым
   файлам. Новый файл получает установленный доступ после того, как
   он будет закрыт. Описание pmode смотри в описании функции CHMOD.


     ВОЗРРАЩАЕМОЕ ЗНАЧЕНИЕ

   Creat возвращает значение handle для созданного файла.
   -1 индицирует об ошибке и errno устанавливается  в одно из следую-
   щих значений:
    EACCES    pathname указывает на существуущий файл с доступом толь-
              ко для чтения или указывает на каталог вместо файла.
    EMFILE    нет больше доступных файлов (т.е.много открытых файлов).
    ENOENT    pathname не найден.


    СМОТРИ ТАКЖЕ

  chmod,chsize,close,dup,dup2,open,sopen,umask

    ПРИМЕР

   #include <sys\types.h>
   #include <sys\stat.h>
   #include <io.h>
   #include <stdlib.h>

   int fh;

   fh = creat("data",S_IREAD|S_IWRITE);
   if (fh == -1)
      perror ("невозможно создать файл");


                            53

                           CSCANF


    ФОРМАТ

  #include <conio.h>

  int cscanf (format-string[,argument...]);
  char format-string;


    ОПИСАНИЕ

  cscanf функция читает данные с консоли на места, указанные в аргумен-
  тах (argument), используя getche функцию, чтобы  прочитать символы.
  Каждый аргумент должен указывать на переменную того типа, который
  соответствует ее описанию в format-string.
  Смотри scanf функцию для получения описания format-string.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Количество областей, которые были успешно преобразованы и присвоены.
  EOF, если прочитан конец файла.
  0, если нет присвоенных областей.


    СМОТРИ ТАКЖЕ

  fscanf,scanf,sscanf

    ПРИМЕР

  #include <conio.h>

  int result;
  char buffer[20];
  .
  .
  .
  cprintf ("Введите имя файла: ");
  /* Cледующее утверждение вводит строку с клавиатуры */
  result = cscanf("%19s",buffer);

                            54

                            CTIME


     ФОРМАТ

   #include <time.h> /* используется только для описания функции */

   char *ctime(time);
   long *time;

     ОПИСАНИЕ

   Ctime функция преобразует время из длинного целого в строку символов
   Значение time обычно получают, вызывая функцию time, которая возвра-
   щает число секунд, прошедших с 1-го января 1970 года.
   Строка результат после выполнения ctime содержит 26 символов и
   имеет вид, показанный на следующем примере:
   Mon Jan 02 02:03:05  1980\n\0.
   Каждое поле имеет символьный формат. Символ новой строки ('\n') и
   нулевой  символ ('\0') занимают две последние позиции в строке.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Указатель на строку результат.
   Нет кодов ошибок.


     СМОТРИ ТАКЖЕ

   acstime,ftime,gmtime,localtime,time

     ПРИМЕР

   #include <time.h>
   #include <stdio.h>

   long ltime;

   time (&ltime);
   printf ("время: %s\n",ctime($ltime));
                            55

                 DIEEETOMSBIN-DMSBINTOIEEE

    ФОРМАТ

  #include <math.h>

  int  dieeetomsbin(src8,dst8);
  int  dmsbintoieee(src8,dst8);
  double  *src8,*dst8;


    ОПИСАНИЕ

  Dieeetomsbin команда преобразует число двойной точности в IEEE
  формате в Micrisift двоичный формат. Dmsbintoieee команда прео-
  бразует число двойной точности в Microsoft двоичном формате в
  IEEE формат.
  Аргумент src8 является указателем на double значение, которое будет
  преобразоваться. Результат помещается в расположение, которое зада-
  ется через dst8.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  0, если преобразование успешно.
  1, если произошло переполнение.

    СМОТРИ ТАКЖЕ

  fieeetomsbin,fmsbintoieee

                            56

                          DIFFTIME


    ФОРМАТ

  #include <time.h>    /* используется только для описания функции */

  double difftime(time2, time1);
  timt_t time2;
  time_t time1;


    ОПИСАНИЕ

  Функция вычисляет разницу time2-time1.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Число двойной точности, которое является разницей в секундах от
  time1 до time2.

    СМОТРИ ТАКЖЕ

  time

    ПРИМЕР

  # include <time.h>

  int mark[10000];

  main()
      {
      /* */

      time_t start, finish;
      register int i, loop, n, num, step;

      time(&start);
      for (loop = 0; loop < 10000; ++loop)
          for (num = 0, n = 3; n < 10000; n +=2)
              if (!mark[n]) {
                     /*  */
                     step = 28n;
                     for (i = 38n; i < 10000; i += step)
                             mark[i] = -1;
                      ++num;
                      }
       time(&finish);

       /* */

       printf("\nProgram takes %f seconds to find %d primes.\n",
            difftime(finish, start)/1000, num);
       }




                            57

                          DOSEXTERR


     ФОРМАТ

   #include <dos.h>

   int dosexterr(buffer);
   struct DOSERROR *buffer;

     ОПИСАНИЕ

   Dosexterr функция получает значение регистра, возвращаемое MS-DOS
   системой по вызову CSH, и помещает значение в структуру, на которую указ
   указывает buffer.
   Cтруктура типа DOSERROR определена в dosh и имеет следующий вид:
                  struct DOSERROR {
                         int exterror;
                         char class;
                         char action;
                         char locus;
                         }
   Если в качестве аргумента задан NULL указатель, то dosexterr
   возвращает значение в AX без заполнения полей структуры.

     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Значение в AX регистре (идентичное значению поля exterror).

     СМОТРИ ТАКЖЕ

   perror

     ПРИМЕР

   #include <dos.h>

   int dosexterr(buffer);
   struct DOSERROR *buffer;


                            58

                           DUP-DUP2

    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */

  int dup(handle);
  int handle;

  int dup2(handle1, handle2);

  int handle1;
  int handle2;


    ОПИСАНИЕ

  Функции dup и dup2 заставляют handle второго файла связать с текущим
  открытым файлом. Можно  позаботиться об операциях с файлом, исполь-
  зуя файл handle, так как все handle, связанные с заданным файлом,
  используют тот же указатель файла. Способ доступа, разрешенный для
  файла, не изменится при создании нового handle.
  Функция dup возвращает следующий доступный файл handle для заданного
  файла.
  Функция dup2 заставляет заданный handle, handle2, быть определенными
  к тому же файлу, как handle1. Если handle2 связан с открытым файлом
  во время вызова, то файл закрывается.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Функция dup возвращает новый файл handle.
  Функция dup2 возвращает 0, если успешно.
  Обе функции возвращают -1, если произошла ошибка;
  и errno устанавливается в одно из следующих значений:
     EBADE      недействительный файл handle
     EMFILE     нет больше доступных handle (слишком много открытых
                файлов).

    СМОТРИ ТАКЖЕ

  close, creat, open
                            59

    ПРИМЕР

  #include <io.h>
  #include <stdlib.h>

  int fh;
  .
  .
  .
  /* Получить другой файл handle, который связывается с тем же
  файлом как handle1 (stdout) */

  fh = dup(1);

  if (fh == -1)
          perror("dup(1) неудачен");

  /* Получить handle 3 к тому же файлу как handle 1 (stdout).
  Если handle 3 уже открыт, то он закрывается */

  fh = dup2(1,3);

  if (fh != 0)
          perror("dup2(1,3) неудачен");




                            60

                            ECVT


     ФОРМАТ

   #include <stdlib.h> /* используется только для описания файла */

   char *ecvt(value,ndigits,decptr,signptr);
   double value;
   int ndigits;
   int *decptr;
   int *signptr;

     ОПИСАНИЕ

   Ecvt функция преобразует число с плавающей точкой в строку символов
   Ecvt хранит ndigits цифр числа value как строка и помещает нулевой
   символ ('\0').
   Если число цифр в value больше, чем ndigits,то отсекаются цифры вы -
   сокого порядка. Если число цифр меньше, чем ndigits,то строка допол-
   няется нулями. В возвращаемой строке помещаются только цифры.
   Позицию десятичной точки и знак числа можно получить из decptr
   и signptr.
   Decptr указывает на целое, значение которого является позицией де-
   сятичной точки от начала строки. Ноль или отрицательное число гово-
   рит о том, что позиция десятичной точки находится слева от первой
   цифры.
   Signptr является указателем на целое, индицирующее знак числа.
   Ее значение 0, если число положительно. В других случаях число отри-
   цательно.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Указатель на строку цифр.

     ЗАМЕЧАНИЕ

   ecvt и fcvt функции используут один и тот же буфер для преобразова-
   ний. При каждом вызове одной из этих команд, значение от предыдущего
   вызова теряется.

     СМОТРИ ТАКЖЕ

   atof,atoi,atol,fcvt,gcvt

     ПРИМЕР

   #include <stdlib.h>

   int decimal, sign;
   char *buffer;
   int precision = 10;

   buffer = ecvt(3.1415926535,precision,$decimal,&sign);
   /* buffer содержит "3.141592654",decimal = 1,sign = 0 */
                          61

                          EOF


     ФОРМАТ

   #include <io.h> /* требуется только для описания функции */

   int eof (handle);
   int handle;


     ОПИСАНИЕ

   Eof функция определяет был ли передан конец файла, для файла,
   связанного с handle.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   1,   если  текущаа позиция есть конец файла
   0,   если не конец файла.
   -1,  недействительный файл handle, при этом errno устанавливается
        в EBADF.

     СМОТРИ ТАКЖЕ

   clearerr,feof,ferror,perror

     ПРИМЕР

   #include <io.h>
   #include <fcntl.h>

   int fh,count;
   char buf[10];

   fh = open("data",O_RDONLY);
   /* Следующее утверждение выполняет проверку на конец файла
      перед чтением */
   while (!eof(fh)) {
         count = read (fh,buf.10);
         .
         .
         .
         }
                            62

                        EXECL-EXECVPE


     ФОРМАТ

   #include <process.h> /* требуется только для описания функции */

   int execl (pathname,arg0,arg1,...,argn,NULL);
   int execle (pathname,arg0,arg1,...,argn,NULL,envp);
   int execlp (pathname,arg0,arg1,...,argn,NULL);
   int execlpe (pathname,arg0,arg1,...,argn,NULL,envp);
   int execv (pathname,argv);
   int execve(pathname,argv,envp);
   int execvp(pathname,argv);
   int execvpe (pathname,argv,envp);

   char *pathname;
   char *arg0,*arg1,...,argn;
   char argv [];
   char envp [];


     ОПИСАНИЕ

   Эти  функции загружают и выполняют новые порождаемые процессы.
   Когда вызов прошел успешно, порожденный процесс располагается в
   памяти, где раньше располагался вызвавший процесс. Должно быыть
   достаточно памяти для загрузки и выполнения порожденных процессов.
   Аргумент pathname определяет файл, который должен быть выполнен как поро
   порожденный процесс.
   Pathname может определить весь путь(начиная с корня), частичный путь
   (с текущего каталога) или просто имя файла. Если pathname не имеет
   расширения и не заканчивается точкой, то exec справа добавляет рас-
   ширение "COM" и ищет файл; если неуспешно, то добавляется расширение
   "EXE". Если pathname имеет расширение, то только это расширение ис-
   пользуется.
   Если pathname заканчивается с точкой, exec ищет файл без расширения.
   Execlp и execvp ведут поиск для имени файла (используя определнные
   процедуры) в каталогах, определенных в PATH переменых.
   Аргументы передаются к новому процессу заданием одного или более
   указателей на строки символов, как аргументы при вызове exec.
   Эти символьные строки есть список аргументов для порождаемого процесса.
   Суммарная длина строк, формирующая список аргументов для порождаемо-
   го процесса, не должна превышать 128 байтов. Нулевые символы
   ('0') для каждой строки не учитываются, но пробелы (разделяющие аргу-
   менты) учитываются. Указатели аргументов могут быть переданы как от-
   дельные аргументы (execl, execle, execlp) или как массив указателей
   (execv, execve, execvp).
   Минимум один аргумент, arg0 или arg[0], должен быть передан в порож-
   даемый процесс. Обычно этот аргумент является копией pathname аргу-
   мента. Вызов execl, execle, execlp  титично используется в тех слу-
   чаях, когда число аргументов известно заранее.
   Arg0 является обычно указателем на pathname.
   Arg1 до arg n  являются указателями на символьные строки, формирую-
   щие новый список аргументов. Следующий за arg n  должен быть указа-
   телем на NULL, что означает конец списка аргументов.
   Execv, execve, execvp обычно используются,  когда число аргументов
   для нового процесса переменно.
                            63

   Указатели на аргументы передаются как массив argv. Argv[0] являет-
   ся обычно указателем на pathname. Argv[1] до argv[n] являются ука-
   зателями на символьные строки, формирующие новый список аргументов.
   Argv[n+1] должен быть указателем на NULL, означающий конец списка
   аргументов. Файлы, которые открыты, когда exec вызываются остаются
   открытыми для нового процесса. При вызове execl, execlp, execv и
   execvp порождаемый процесс унаследует и окружение родителя. Execle
   и execve позволяет изменить окружение для порождаемого процесса,
   передав список окружающей среды через аргумент envp. Envp является
   массивом символьных указателей, каждый элемент которого является
   указателем на строку, определяющим переменную для окружения. Такая
   строка обычно имеет следующую форму:
    NAME=value, где N- имя переменной для окружения, а value является
   строковым значением, в которое переменная устанавливается. Когда
   envp есть NULL, это означает, что окружающая среда унаследуется у
   родителя


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   -1, индицирует об ошибке и errno устанавливается в одно из следую-
   щих значений:
       E2BIA    список аргументов превышает 128 байтов или память, тре-
                буемая для информации об окружающей среде превышает
                32 К.
       EACCES   ошибка в указанном файле.
       EMFILE   слишком много открытых файлов (указанный файл открыва-
                ется, чтобы передать ей управление для выполнения)
       ENOENT   файл или путь не найдены
       ENOEXEC  указанный файл не выполняемый или имеет неправильный
                формат, чтобы выполниться.
       ENOMEM   нет достаточной памяти, чтобы выполнить порождаемый
                процесс; или доступная память испорчена; или существу-
                ют блоки неверной длины, означающий, что процесс роди-
                тель не был расположен в памяти должным образом.


     ЗАМЕЧАНИЕ

   При вызове exec не сохраняются в приведенном виде открытые файлы.
   Если порожденный процесс должен использовать файлы, унаследованные
   от родителя, то setmode команда должна быть использована, чтобы при-
   вести эти файлы к желаемому виду.
   Сигнал окружения, созданный при вызове exec команды, не сохраняется
   в порожденном процессе, а устанавливается по умолчанию.

     СМОТРИ ТАКЖЕ

   abort,exit,_exit,onexit,spawnl,spawnle,spawnlp,spawnlpe,
   spawnv,spawnve,spawnvp,spawnvpe,system
                            64

     ПРИМЕР

   #include <process.h>
   #include <stdio.h>

   extern char **environ;
   char *args[4];
   int result;

   args[0] = "child";
   args[1] = "one";
   args[2] = "two";
   args[3] = NULL;
   /* Следующие утверждения делают попытку выполнить процесс
      "child.exe" и передать ей 3 аргумента */
   result = execl  ("child.exe","child","one","two",NULL);
   result = execle ("child.exe","child","one","two",NULL,environ);
   result = execlp ("child.exe","child","one","two",NULL);
   result = execv  ("child.exe",args);
   result = execve ("child.exe",args,environ);
   result = execvp ("child.exe",args);






                              65

                            EXIT-_EXIT

    ФОРМАТ

  #include <process.h>    /* используется только для описания функции */
  #include <stdlib.h>     /* используйте либо process.h либо stdlib.h */
  void exit(status);      /* завершает, закрыв файлы */
  void _exit(status);     /* завершает без скидывания буферов */
  int   status;           /* статус завершения */

    ОПИСАНИЕ

  Exit и _еxit функции  завершают вызванный процесс.
  Exit   скидывает все буфура и закрывает все открытые файлы перед
          завершением процесса.
  _Exit   завершает процессы без скидывания буферов, связанные с пото-
          ками.
  Status  заданный  нулевым, индицирует  о нормальном завершении,
          отличный от нулевого, индицирует от ошибке.

   ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Нет кодов возврата.

   СМОТРИ ТАКЖЕ

  abort, execl, execle, execlp, execv, execve, execvp, oпexit, spawnl,
  spawnle, spawnlp, spawnv, spawnve, spawnvp, system.

   ПРИМЕР

  #include <process.h>
  #include <stdio.h>

  FILE *stream;
  .
  .
  .
  /* следующие утверждения завершают процесс после
  ** скидывания буферов и закрытия открытых файлов,
  ** если файл невозможно открыть
  */

  if ( (stream = fopen ("data","r") ) == NULL  {
          fprintf (stderr, "невозможно открыть файл\n");
          exit(1);
          }

  /* Следующие утверждения завершают процесс немедленно,
  ** если невозможно открыть файл
  */

  if ( (stream = fopen("data", "r") ) == NULL) {
          fprintf (stderr, "невозможно открыть файл\n");
          _exit(1) ;
          }

                            66

                            EXP

     ФОРМАТ

   include <math.h>
   double exp(x);
   double x:           /* значение с плавающей точкой */

     ОПИСАНИЕ

   Функция возвращает экспоненту от аргумента, числа с плавающей
   точкой.

     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
                              х
   Экспоненту от аргумента ( е ).
   НИGE,  если переполнение.
   0, если недополнение.
   В обоих ошибочных случаях errno устанавливаются в ERANGE

     СМОТРИ ТАКЖЕ

   loq

     ПРИМЕР

   #inсlude <math.h>

   doudle x,y;
   .
   .
   .
   y = exp(x) ;



                            67

                          _EXPAND

    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */

  char *_expand(ptr,size);
  char *ptr;
  unsigned size;


    ОПИСАНИЕ

  Функция изменяет размер предыдуще полученного блока памяти, чтобы
  расширить или сжать блок без изменения ее месторасположения.
  Аргумент ptr указывает на начало блока. Аргумент size задает новый
  размер блока в байтах. Содержимое блока не изменяется.
  Аргумент ptr может  также указывать на блок, который был освобожден,
  до тех пор, пока не будет сделан вызов calloc,_expand, halloc,
  malloc, или realloc после того, как блок был освобожден. Если ptr
  указывает на освобожденный блок, то блок будет оставаться освобож-
  денным и после вызова _expand.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Символьный указатель на переопределенный блок памяти. В отличие от
  realloc, _expand не может переместить блок, когда изменяет его раз-
  мер.
  NULL, если нет достаточной доступной памяти, чтобы расширить блок
  до заданных размеров без перемещения. Область памяти, на которую
  указывает  возвращаемое значение, является выравненной и доступной
  для любого типа объектов. Новый размер памяти может быть проверен
   _msize функцией. Чтобы получить указатель типа, отличного от char,
  используйте перекидывание возвращаемого значения.

    СМОТРИ ТАКЖЕ

  calloc, free, halloc, malloc, _msize, realloc

    ПРИМЕР

  #include <stdio.h>
  #include <malloc.h>

  main( )

    {
    long *oldptr;
    unsigned int newsize = 64000;

    oldptr =(long *)malloc(10000*sizeof(long));
    printf("Размер блока памяти, на которую указывает oldptr = %u\n",
               _msize(oldptr));
    if (_expand(oldptr, newsize) != NULL)
      printf("блок расширен до %u\n",_msize (oldptr));
    else
      printf("блок расширен только до %u\n",_msize(oldptr));
    }



                            68

                            FABS

     ФОРМАТ

   #include <math.h>
   double fabs(x);
   double x;

     ОПИСАНИЕ

   Функция возвращает абсолютное значение
   аргумента,числa с плавающей точкой.

     ВОЗВРАЩAEMOE 3HAЧЕНИE

   Абсолютное значение. Нет ошибочных кодов возврата.

     CMOTPU TAKЖЕ

   abs, cabs, labs

     ПРИМЕР

   #include <mаth.h>
   double x, y;
   .
   .
   .
   y = fabs(x);



                            69

                      FCLOSE - FCLOSEALL

     ФОРМАТ

   #include <stdio.h>
   int fclose(stream);
   FILE *stream ;
   int fcloseall();

     ОПИСАНИЕ

   Функции fclose и fcloseall закрывают поток или потоки.
   Все буфера, связанные с потоками, скидываются до их закрытия.
   Системные буфера очищаются, когда поток закрывается. Буфера,
   присвоенные по команде setbuf, автоматически не очищаются.
   Fclose функция закрывает заданный буфер. Fcloseall закрывает все
   буфера, за исключением stdin, stdout, stdoux, stdprn.

     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Fclose возвращает значение 0, если поток успешно закрыт.
   Feloseall  возвращает количество закрытых потоков.
   Обе функции возвращают EOF, если произошла ошибка.

     CMOTPИ TAKЖЕ

   сlose, fdopen, fflush, fopen, freopen

     ПРИМЕР

   #include <stdio.h>

   FILE *stream;
   int numclosed;

   stream = fopen("data","r");
   .
   .
   .
   /* Cледующее утверждение закрывает поток stream */
   fclose(stream);
   /* Следующее утверждение закрывает все потоки, за исключением
   ** stdin, stdout, stderr, stdaux, and stdprn;
   */

   numclosed = fcloseall ();


                            70

                            FCVT

     ФОРМАТ

   #include <stdlib.h>  /* требуется толбко для описания функции */
   char fcvt(value,ndec,decptr,signptr);
   double value;
   int ndec;
   int *decptr;
   int *signptr;

     ОПИСАНИЕ

  Функция преобразует число с плавающей точкой в строку символов.
  Value есть чисо с плавающей точкой, которое должно быть преобразовано.
  Fcvt помещает цифры числа в строку с завершающим нулевым симво-
  лом ('\0'). Ndec определяет число цифр после десятичной точки.
  Если число цифр после десятичной точки в value больше ndec,
  то  корректная цифра округляется, согласно преоброзаваниям в FORTRAN F.
  Ecли меньше, то строка дополняется нулями.
  В строке хранятся только цифры. Позиции десятичной точки и знака
  числа    могут быть  получены из decptr и signtr, после вызова
  функции. Decptr указывает на целое значение, которое является пози-
  цией десятичной точки от начала строки. Ноль или отрицательное зна-
  чение означают, что десятичная точка располагается левее первой цифры.
  Signtr указывает на целое, индицирующий знак числа.
  Нуль означает, что число положительно; отличное от нуля
  означает, что число отрицательно.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Указатель на строку цифр.
  Нет ошибочных кодов возврата.

  Замечание: Ecvt и fevt  функции используют  oдин и тот же буфер
             для преобразований. При каждом вызове одной из этих команд
             результаты предыдущего вызова теряются.

   СМОТРИ ТАКЖЕ

   atof, atoi, atol, ecvt, gcvt

    ПРИМЕР

   #include <stdlib.h>
   int decimal, sign;
   char *buffer;
   int precision = 1O;
   buffer = fcvt(3.1415926535,precision,&decimal,&sign);
   /* buffer = "31415926535", decimal = 1, sign = 0 */


                            71

                           FDOPEN


    ФОРМАТ

  #include <stdlib.h>
  FILE *fdopen(handle,tуpe);
  int handle;
  char *type;

    ОПИСАНИЕ

  Функция связывает поток ввода/вывода с файлом, установленным в handle
  Type является строкой символов, определяющих способ доступа к файлу,
  и может принимать следующие значения:

  "r"   Открыть для чтения (файл должен существовать).
  "w"   Открыть пустой файл для записи; если файл существует, то его
        содержимое теряется
  "a"   Открыть для записи в конец файла (добавления); файл создается,
        если он не существует.
  "r+"  Открыть для чтениия и записи (файл должен существовать).
  "w+"  Открыть пустой файл для чтения и записи; если файл существует
        ее содержание теряется.
  "a+"  Открыть для чтения и добавления; файл создается, если он не
        существует.

  Замечание:
  Будьте осторожны при исподьзовании "w" и "w+", т.к. они могут запор-
  тить существующие файлы.

  Определяемый тип должен быть совместим со способом доступа,  с которым
  файл был открыт.
  Когда файл открыт с "a" или "a+" типом, данные записываются в конец
  файла. Хотя указатель файла может быть перемещен, используя fseek
  или rewind функции, но он всегда будет перемещаться обратно на конец
  файла при записи данных. Таким образом, существующие данные не могут
  быть затерты.
  Когда "r+","w+" или "a+" типы определены, чтение и запись разрешены
  (если файл открыт для "update").
  Однако, переключение с чтения на запись должно осуществляться fseek
  или rewind командами.
  Текущая позиция может быть определена для fseek команды, если необ-
  ходимо.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Указатель на открытый поток.
  NULL,  если ошибка.

    СМОТРИ ТАКЖЕ

  dup, dup2, fclose, fcloseall, fopen, freopen, open.
                            72

    ПРИМЕР

   #include <stdio.h>
   #include <fcntl.h>
   FILE *stream;
   int fh;

   fh = open("data",O_RDONLY);

   /* Следующее утверждение связывает поток с
   ** открытым файл  handle:
   */
   stream = fdopen(fh,"r");

                            73

                            FEOF

    ФОРМАТ

  #include <stdio.h>
  int feof(stream);
  FILE *stream;         /* Указатель на структуру файл */

    ОПИСАНИЕ

  Функция определяет: достигнут ли конец данного потока. Если конец
  файла достигнут, операция чтения возвращает индикатор конца файла
  до тех пор, пока поток не будет закрыт или rewind команда не будет
  вызвана.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  0, если конец файла.
  Отличное от нуля, если не конец файла.

  Замечание: Feof выполняется как макрокоманда.

     CМОТРИ ТАКЖЕ

  clearerr, eof, ferror, perror.

      ПРИМЕР

  #include <stdio.h>
  char string[100];
  FILE *stream;

  /* Следующие утверждения осуществляют process входных строк
  ** пока не наступит конец файла
  */
     while (! feof (stream))
          if (fscanf(stream,"%s",string) )
             process (string);


                            74

                           FERROR


    ФОРМАТ

  #include <stdio.h>
  int ferror(stream);
  FILE * stream;

    ОПИСАНИЕ

  Функция осуществляет проверку на ошибку при чтении записи с задан-
  ного потока.
  Если имела место ошибка, то индикатор ошибки для потока остается
  установленным до тех пор, пока поток не будет закрыт или не будут
  выполнены rewind или clearerr команды.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  0, если нет ошибок.
  Ненулевое значение, если встретилась ошибка для заданного потока.

  Замечание: ferror выполняется, как макрокоманда.

    СМОТРИ ТАКЖЕ

  clearerr, eof, feof, fopen, perror.

    ПРИМЕР

  # include <stdio.h>
  FILE *stream;
  char *string;
  .
  .
  .
  /* Следующие утверждения выводят данные на поток и
  ** потом проверяют, не было ли ошибки записи.
  ** Поток должен быть вначале открыт для записи
  */
  fprintf (stream,"%s\n",string);
  if (ferror(stream)) {
     fprintf (stderr,"ошибка записи\n");
     clearerr (stream);
     }

                            75

                           FFLUSH

     ФОРМАT

    include <stdio.h>

    int fflush(stream);
    FILE *stream;

     ОПИСАНИЕ

    Функция записывает содержимое буфера, связанного с выводимым пото-
    ком stream, в файл, связанный с этим потоком. Поток остается откры-
    тым после вызова функции. Если поток не буферизован, то вызов
    функции не производит никаких действий.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, если буфер успешно скинут.
    FOF, индицирует об ошибке.
    Значение 0 возвращается и в тех случаях, когда поток не буферизован
    или открыт только для чтения.

    Замечание: буфера автоматически скидывается, когда они заполнены,
               когда поток  закрывается, или когда программа
               завершилась нормально без закрытия потока.


    СМОТРИ ТАКЖЕ

    fclose, flushall,  setbuf

    ПРИМЕР

  # include <stdio.h>

  FILE * stream;
  char buffer [BUFSIZ];
  .
  .
  .
  /* Следующие утверждения скидывают буфер потока stream и
  ** устанавливают новый буфер для этого потока */

  fflush(stream);
  setbuf(stream, buffer);



                            76

                           _FFREE

    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */

  void _ffree(ptr);
  char far *ptr;


    ОПИСАНИЕ

  Функция освобождает блок памяти, который распологается вне данного
  сегмента. Аргумент ptr указывает на блок памяти, предыдуще получен-
  ный обращением к _fmalloc. Число освобождаемых байтов есть
  число байтов, которое было определено, когда блок был получен.
  После вызова, освобожденные блоки снова доступны для получения.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Нет кодов возврата.

    СМОТРИ ТАКЖЕ

  fmalloc, free, malloc


    ЗАМЕЧАНИЕ

  Попытка освободить неправильное ptr (указатель не был получен
  посредством _fmalloc) может нарушить последующее получение и
  привести к ошибке.


    ПРИМЕР

  #include <malloc.h>
  #include <stdio.h>

  char far *alloc;

  /* Получение 100 байтов и последующее освобождение */

  if ((alloc = _fmalloc(100)) == NULL)

          printf("невозможно получить память\n");
  else    {
          .
          .
          .
          _ffree (alloc);

          }





                            77

                           FGETC


    ФОРМАТ

  #include <stdio.h>
  int fgetc(stream);
  FILE * stream;

  int fgetchar();

    ОПИСАНИЕ

  Fgetc функция  читает один символ из вводного потока stream с теку-
  щей позиции и перемещает указатель файла на следующий символ.
  Fgetchar эквивалентно fgetc (stdin).

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Введенный символ.
  FOF, если конец файла или ошибка; feof или ferror функции должны
  быть использованы, чтобы различить конец файла от ошибки.

    Замечание: fgete и fgetehar являются едентичными getc и  getchar,
               но являются функциями, а не макросами.

    СМОТРИ ТАКЖЕ

  fputc, fputchar, getc, getchar

    ПРИМЕР

  # include <stdio.h>

  FILE *stream;
  char buffer[81];
  int i;
  int ch;
  .
  .
  .
  /* Следующие утверждения накапливают строку ввода из
  ** stream;
  */
  for (i = 0); (i < 80) && ( (ch = fgetc(stream) != EOF) &&
           (ch != '\n'); i++)
           buffer[i] = ch;

  buffer[i] = '\0';

  /* "fgetchar()" может быть использована вместо "fgetc(stream)",
  ** чтобы накапливать строку ввода из stdin.
  */
                            78

                           FGETS


      ФОРМАТ

    #include <stdio.h>
    char *fgets(string,n,stream);
    char *string;
    int n;
    FILE *stream;

      ОПИСАНИЕ

   Функция читает строку из входного потока stream и помещает ее в
   string. Символы читаются из текущей позиции потока до тех пор,
   пока не будет прочитан символ новой строки ('\n'), который вклю-
   чается в строку, или пока не наступит конец потока, или не будет
   прочитано (n-1) символов. Результат помещается в string и заканчива-
   ется нулевым символов ('\0'). Если n равно 1, то формируется
   пустая строка.

      ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Fgets возвращает строку.
    NULL, если ошибка или конец файла, которых можно отличить,исполь-
    зуя feof или ferror функцию.

      СМОТРИ ТАКЖЕ

    fputs, gets, puts

      ПРИМЕР

  #include <stdio.h>
  char line[100], *result;

  \* Следующщее утверждение получает строку ввода из stream,
  ** пока не будет прочитано 99 символов или символ \n */

  result = fgets(line,100, stream);


                          79

                FIEEETOMSBIN-FMSBINTOIEEE

    ФОРМАТ

  #include <math.h>

    int fieeetomsbin(src4,dst4);
    int fmsbintoieee(src4,dst4);
    float *src4,dst4;

    ОПИСАНИЕ

  Команда fieeetomsbin преобразует число с плавающей точкой из
  IEEE формата в Microsoft двоичный формат. Команда fmsbintoieee пре-
  образует число с плавающей точкой из Microsoft двоичного формата
  в IEEE формат. Эти команды позволяют C программам (которые хранят
  число с плавающей точкой в IEEE формате) использовать числовые дан-
  ные из файлов, созданных с Microsoft BASIC (которые хранят числа с
  плавающей в Microsoft двоичном формате) и наоборот.
  Аргумент src4 указывает на float значение, которое будет преобра-
  зоваться. Результат помещается в расположение, заданное в dst4.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  0, если преобразование успешно.
  1, если переполнение.

    СМОТРИ ТАКЖЕ

  dieeetomsbin, dmsbintoieee




                            80

                          FILELENGTH


   ФОРМAТ

  #include <io.h>
  long filelength(handle);
  int handle;

    ОПИСАНИЕ

  Функция возвращает длину в байтах файла, связанного с заданным
  handle.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Длину файла в байтах.
  -1L, если ошибка, при этом errno устанавливается в EBADF, означающий,
  что недействительное handle.

    CMОТРИ ТАКЖЕ

  сhsize, fileno, fstat, stat

    ПРИМЕР

  #include <io.h>
  #include <stdio.h>
  #inglude <stdlib.h>

  FILE *stream;
  long length;

  stream = fopen ("data","r");
  .
  .
  .
  /* Следующие утверждения попытаются определить длину
  ** файла, связанного со stream:
  */

  length = filelength(fileno(stream) );
  if (length == -1L)
          perror("filelength неудачна");









                            81

                           FILENO


    ФОРМАТ

  #include <stdio.h>

  int fileno(stream);
  FILE *stream;

    ОПИСАНИЕ
  Функция возвращает файл handle (понимают как указатель), связанный с
  заданным потоком stream. Если более чем одно handle cвязаны с пото-
  коm, то функция возвращает то handle, которое было открыто первым.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Файл handle.
  Нет ошибочных кодов возврата.
  Результат неопределенный, если stream не определен как открытый файл.

  Замечание: Fileno выполняется как макрос.

    СМОТРИ ТАКЖЕ

  fdopen, filelength, fopen, freopen


    ПРИМЕР

  #include <stdio.h>

  int result;

  /* Следующее утверждение определяет handle файла потока stderr
  */
  result = fileno(stderr);   /* result = 2 */





  length = filelendth(fileno{stream) );
  if (length == -1L
          perror("filelength failed");
                            82

                            FLOOR


    ФОРМАТ

  #include <math.h>

  double floor(x);
  double x;


    ОПИСАНИЕ

  Функция возвращает значение с плавающей точкой, что представляет
  собой наибольшее целое, которое меньше или равно х.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Число с плавающей точкой.
  Нет ошибочных кодов возврата.

    СМОТРИ ТАКЖЕ

  ceil,fmod

    ПРИМЕР

  #include <math.h>

  double y;
  y = floor(2.8);     /* y = 2.0 */
  y = floor(-2.8);    /* y = -3.0 */

                            83

                          FLUSHALL


    ФОРМАТ

  #include <stdio.h>    /* используется только для описания функции */

  int flushall();

    ОПИСАНИЕ

  Функция записывает содержимое всех буферов, связанных с открытыми
  выводными потоками, в файлы, связанные с этими потоками.
  Все потоки остаются открытыми после flushall.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Количество открытых потоков (вводных и выводных).
  Нет ошибочных кодов возврата.

  Замечание: буфера автоматически скидываются, когда они заполнены,
             когда потоки закрыты, или когда программа нормально
             завершилась без закрытия потоков.

    СМОТРИ ТАКЖЕ

  fflush

    ПРИМЕР

  #include <stdio.h>

  int numopen;
  /* Следующее утверждение скидывает буфера всех потоков */
  numopen = fflushall();
                            84

                          _FMALLOC

    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */

  char far *_fmalloc(size);
  unsigned size;


    ОПИСАНИЕ

  Функция получает блок памяти как минимум size байтов вне заданного
  сегмента. (Блок может быть больше size байтов в результате выравни-
  вания)

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Далекий (far) указатель на char. Область памяти, на которую указы-
  вает возвращаемое значение, является выровненной для любого типа
  объектов. Для получения указателя типа, отличного от char, исполь-
  зуйте перекидывание возвращаемого значения.
  Если нет достаточной памяти вне заданного блока, будет попытка полу-
  чить память, используя заданный блок. Если и в этом случае недоста-
  точно памяти возвращаемое значение есть NULL.

    СМОТРИ ТАКЖЕ

  _ffree, _fmsize, malloc, realloc

    ПРИМЕР

  #include <malloc.h>

  int *intarray;

  /* Получить память для 20 целых */

  intarray = (int *)_fmalloc(20*sizeof(int));






                            85

                            FMOD

    ФОРМАТ

  #include <>    /* используется только для описания функции */

  double fmod(x,y);
  double x;
  double y;

    ОПИСАНИЕ

  Функция вычисляет остаток от деления х на у, такой, что х = iу + f,
  где i - целое, f имеет такой же знак как х, и абсолютное значение х
  меньше абсолютного  значения у.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Остаток в виде числа с плавающей точкой.
  0, если у имеет нулевое значение или деление х на у приводит
  к переполнению.

    СМОТРИ ТАКЖЕ

  ceil,fabs,floor

    ПРИМЕР

  #include <math.h>

  double x,y,z;
  x = -10.0;
  y = 3.0;
  z = fmod (x,y);       /* z = -1.0 */
                            86

                          _FMSIZE

    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */

  unsigned _fmsize(ptr);
  char far *ptr;

    ОПИСАНИЕ

  Функция возвращает размер в байтах памяти, полученной по вызову
  _fmalloc.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Размер в байтах, как безнаковое целое.

    СМОТРИ ТАКЖЕ

  _ffree, _fmalloc, malloc, _msize, _nfree, _nmalloc, _nmsize

    ПРИМЕР

  #include <malloc.h>
  #include <stdio.h>

  main ( )
           {
           char far *stringarray;

           stringarray = _fmalloc(200*sizeof(char));
           if (stringarray !=NULL)
             print("%u получено байтов\n",_fmsize(stringarray));
           else
               printf("Получение памяти неудачна.\n");
           }





                            87

                            FOPEN


    ФОРМАТ

  #include <stdio.h>

  FILE *fopen(pathname,type);
  char *pathname;
  char *type;

    ОПИСАНИЕ

  Функция открывает файл, определенный в pathname.
  Тype является символьной строкой, который определяет тип доступа,
  требуемый для файла.
  Описание типов смотри в описании fdopen.
  Здесь определяется еще 2 типа для перевода новой строки.

  t    Открыть в текстовом (переведенном) шаге;
       Комбинация возврат-каретки / перевод строки (CR-LF)переводится в
       перевод строки (LF) при вводе; символ перевода строки (LF)
       переводится в комбинацию возврат-каретки/перевод строки при выводе.

  в    Открыть в двоичном (непереведенном) шаге.
       Сказанные выше переводы пресекаются.

      ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Указатель на открытый файл.
  NULL индицирует об ошибке.


    СМОТРИ ТАКЖЕ

  fclose,fcloseall,fdopen,ferror,fileno,freopen,open,setmode

    ПРИМЕР

  #include <stdio.h>

  main (argc,argv);
  int argc;
  char *argv[];
  {
  FILE *stream;
  /* Делается попытка открыть файл, имя которого хранится по
     указателю argv[argc-1]; если попытка неуспешна печатается
     ошибочное сообщение на stderr
  */
  if ((stream = fopen(argv[argc-1],"r")) == NULL) {
     fprintf (stderr,"%s невозможно открыть файл %s\n",argv[0],
             argv[argc-1]);
     exit(1);
     }
  }

                           88

                       FP_OFF-FP_SEG

    ФОРМАТ

  #include <dos.h>

    unsigned FP_OFF(longptr);
    unsigned FP_SEG(longptr);
    char far *longptr;

    ОПИСАНИЕ

 FP_OFF и FP_SEG макросы возвращают смещение и сeгмент соотвественно,
 указателя longptr.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 FP_OFF возвращает беззнаковое целое, представляющее собой смещение.
 FP_SEG возвращает беззнаковое целое, представляющее собой сегмент.

    СМОТРИ ТАКЖЕ

  segread

    ПРИМЕР

  #include <dos.h>

  char far *p;
  unsigned int seg_val;
  unsigned int off_val;
  .
  .
  .
  seg_val = FP_OFF(p);
  off_val = FP_SEG(p);


                            89

                          _FPRESET

    ФОРМАТ

  #include <float.h>

  void _fpreset();

    ОПИСАНИЕ

  Функция переинициализирует пакет арифметики с плавающей точкой.
  Эта функция обычно используется вместе с signal, system, или
  exec и spawn командами.
  Если программа улавливает ошибочные сигналы с плавающей точкой
  (SIGFPE) с помощью signal, то эти сигналы можно обнаружить из
  ошибок с плавающей точкой включением _fpreset и сделав longjmp.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Нет кодов возврата.


    СМОТРИ ТАКЖЕ

  execl, execle, execlp, execlpe, execv, execve, execvp,execvpe,
  signal, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve,
  spawnvp, spawnvpe


    ПРИМЕР

  #include <stdio.h>
  #include <signal.h>
  #include <setjmp.h>
  #include <float.h>

  int fphandler ();
  jmp_buf mark;
  double a = 1.0, b = 0.0, c;

  main ()
    {
    if (signal(SIGFPE, fphandler) == (int(*) ()) -1)
             abort();
    if (setjmp(mark) == 0) {
            c = a/b;             /* сгенерировать f.p. ошибку */
            printf("Should never get heve\n");
            }
    printf("Обнаружена ошибка плавающей арифметики\n");
    }

  int fphandler(sig, num)
           int sig,num;

   {
   printf("signal = %d subcode = %d\n",sig,num);
   _fpreset();     /* переинициализировать пакет плав.арифметики */
   longjmp(mark, -1);
   }
                            90

                           FPRINTF

    ФОРМАТ

  #include <stdio.h>

  int fprintf(stream,format-string[,argument...]);
  FILE *stream;
  char format-string;


    ОПИСАНИЕ

 Функция  форматирует и печатает наборы символов и значений в вывод-
 ной поток stream. Каждый аргумент (если несколько) преобразуется и
 выводится, согласно формату преобразования, определяемым в format-
 string.
 Format - string имеет, определенный вид и функцию, как аргумент  для
 printf функции; смотри printf функцию для описания format-string и
 ее аргументов (argument).


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Количество напечатанных символов.

    СМОТРИ ТАКЖЕ

 cprintf,fscanf,printf,sprintf

    ПРИМЕР

 #include <stdio.h>

 FILE *stream;
 int i = 10;
 double fp = 1.5;
 char *s = "this is string";
 char c = '\n';

 stream = fopen("results"."w");
 /* Преобразовать и напечатать различные данные */
 fprintf (stream,"%s%c",s,c);  /* напечатает "this is string" */
 fprintf (stream,"%d\n",i);  /* напечатает 10 */
 fprintf (stream,"%f",fp);  /* напечатает 1.500000 */
                            91

                       FPUTC-FPUTCHAR

    ФОРМАТ

  #include <stdio.h>

  int fputc(c,stream);
  int c:
  FILE *stream;

  int fputchar(c);
  int c;


    ОПИСАНИЕ

 Fputc функция записывает одиночный символ с на выводной поток stream
 в текущую позицию. Frutchar эквивалентно  fputc (c,stdout).

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Записанный символ.
 EOF, если конец файла или ошибка, которые можно различить, используя
 feof или ferror функцию.

    СМОТРИ ТАКЖЕ

 fgetc,fgetchar,putc,putchar

    ПРИМЕР

 #include <stdio.h>

 FILE *stream;
 char buffer[81];
 int i;
 int ch;
 /* Следующее утверждение выводит содержимое buffer на поток */
 for (i = 0; (i < 81) && ((ch = fputc(buffer[i],stream)) != EOF); i++);
 /* "fputchar()" нужно использовать вместо "fputc(stream)",
    чтобы записать buffer в stdout */
                            92

                            FPUTS


    ФОРМАТ

  #include <stdio.h>

  int fputs(string,stream);
  char *string;
  FILE *stream;


    ОПИСАНИЕ

 Функция копирует строку string на выводной поток stream, в текущую
 позицию. Нулевой символ ('\0') не копируется.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Последний записанный символ.
 0, если строка string пустая.
 EOF, если ошибка.

    СМОТРИ ТАКЖЕ

 fgets,gets,puts

    ПРИМЕР

 #include <stdio.h>

 FILE *stream;
 int result;

 result = fputs("файл скорректирован\n",stream);
                            93

                            FREAD


    ФОРМАТ

  #include <stdio.h>

  int fread(buffer,size,count,stream);
  char *buffer;
  int size;
  int count;
  FILE *stream;


    ОПИСАНИЕ

 Функция читает count знаков длины size из  вводного потока stream и
 помещает их в заданный буфер buffer. Указатель файла, связанный с
 потоком stream, увеличивается на число байтов, действительно прочи-
 танных.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Количество действительно прочитанных знаков, которое может быть меньше
 чем count, если встретилась ошибка или конец файла раньше, чем было
 прочитано count знаков.

    СМОТРИ ТАКЖЕ

 fwrite,read

    ПРИМЕР

 #include <stdio.h>

 FILE *stream;
 long list[100];
 int numread;

 stream = fopen("data","r+b");
 /* Следующее утверждение прочитает 100 коротких целых из stream */
 numread = fread ((char *)list,sizeof(long),100,stream);
                            94

                            FREE


    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */

  void free(ptr);
  char *ptr;

    ОПИСАНИЕ

 Функция освобождает блок памяти. Ptr указывает на блок памяти, который
 раньше был получен по вызову calloc, malloc или realloc функции.
 Число освобождающихся байтов есть число байтов, которые были определе-
 ны при получении блока памяти. После вызова освободившиеся байты дос-
 тупны для  получения.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Нет кодов возврата.

  Замечание: если для free задано неправильное ptr (указатель, который
             получен не посредством calloc, malloc, realloc) это может
             привести к ошибкам.

    СМОТРИ ТАКЖЕ

  calloc,malloc,realloc

    ПРИМЕР

  #include <malloc.h>
  #include <stdio.h>

  char *alloc;
  /* Получить 100 байтов и затем освободить их */
  if ((alloc = malloc(100)) == NULL)
     printf ("невозможно получить память\n");
  else
     {
     .
     .
     .
     free(alloc);
     }
                            95

                          _FREECT

    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */

  unsigned int _freect(size);
  unsigned int size;

    ОПИСАНИЕ

  Функция скажет вам, как много памяти является доступной для динами-
  ческого получения памяти, возвращая апроксемированное число; сколько
  раз можно вызвать malloc, чтобы получить память, заданного размера
  в данном сегменте.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Число обращений как беззнаковое целое.


    СМОТРИ ТАКЖЕ

  calloc, _expand, malloc, _memavl, _msize. realloc


    ПРИМЕР

  main ()

      {
      int i;

      printf("Апроксемированное число возможных вызовов malloc\n");
      printf("Чтобы получить память для одного integer = %u\n",
                 _freect(sizeof(int)));
      }


                            96

                           FREOPEN

    ФОРМАТ

  #include <stdio.h>

  FILE *freopen(pathname,type,stream);
  char *pathname;
  char *type;
  FILE *stream;


    ОПИСАНИЕ

 Функция закрывает файл, текуще связанный с потоком stream и переназна-
 чает поток stream на файл, определенный в pathname. Freopen обычно ис-
 пользуется, чтобы определить файлы stdin, stdout, stderr и stdprn на
 файлы, определенные пользователем.
 Новый файл, связанный с потоком stream, открывается с заданным типом
 доступа type, описание которого приведено в описании функции fdopen.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Указатель на новый открытый файл.
 NULL, если встретилась ошибка; при этом файл оригинал закрывается.


    СМОТРИ ТАКЖЕ

  fclose,fcoseall,fdopen,fileno,fopen,open,setmode

    ПРИМЕР

  #include <stdio.h>

  FILE *stream;
  .
  .
  .
  /* Следующее утверждение закрывает поток stdout и
     переназначает ее указателю stream */
  stream = freopen ("data2","w+",stdout);
                            97

                            FREXP


    ФОРМАТ

  #include <math.h>

  double frexp(x,expptr);
  double x;
  int *expptr;


    ОПИСАНИЕ

 Функция разбивает число с плавающей точкой х на мантиссу m и экспонен-
 ту n таким образом, что абсолютное значение m больше или равно 0.5 и
                     n
 меньше 1.0 и х = m*2 . Целое эксполента n помещается в область, ука-
 занную в expptr.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Мантисса m.
 0, для мантиссы и экспоненты, если значение х равно 0.
 Нет ошибочных кодов возврата.

    СМОТРИ ТАКЖЕ

 ldexp,modf

    ПРИМЕР

 #include <math.h>

 double x,y;
 int n;
 .
 .
 .
 x = 16.4;
 y = frexp(x,&n);  /* y = .5125, n = 5 */
                            98

                           FSCANF


    ФОРМАТ

  #include <stdio.h>

  int fscanf (stream,format-string[,argument...]);
  FILE *stream;
  char *format-string;


    ОПИСАНИЕ

 Функция читает данные из текущего расположения потока stream и распо-
 лагает их в поля, заданные в аргументах argument (если несколько).
 Каждый из которых должен быть указателем на переменную с типом,
 который  соответствует типу, определенному в format-string.
 Format-string управляет интерпретацией областей ввода и имеет опре-
 деленный вид и функцию, как аргумент для scanf функции; смотри описа-
 ние format-string в описании scanf функции.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Количество областей, которые были успешно преобразованы и присвоены.
 Возвращаемое значение не включает области, которые были прочитаны,
 но не присвоены.
 FOF, если прочитан конец файла.
 0, если нет областей, которые были присвоены.


    СМОТРИ ТАКЖЕ

 cscanf,fprintf,scanf,sscanf

    ПРИМЕР

 #include <stdio.h>

 FILE *stream ;
 long l;
 float fp;
 char s[81];
 char c;

 stream = fopen("data","r");
 /* Ввод различных данных */
 fscanf (stream,"%s",s);
 fscanf (stream,"%c",&c);
 fscanf (stream,"%ld",&l);
 fscanf (stream,"%f",&fp);
                            99

                           FSEEK

    ФОРМАТ

  #include <stdio.h>

  int  fseek (stream,offset,origin);
  FILE *stream;
  long offset;
  int origin;


    ОПИСАНИЕ

  Функция перемещает указатель файла, связанного с потоком stream,
  на новое месторасположение, которое есть смещение offset байтов от
  origin. Следующая операция с потоком выполняется с нового место-
  расположения. В потоке, открытым для обновления, следующей операцией
  может быть чтение или запись.
  Аргумент origin должен быть одной из следующих констант, определенных
  в stdio.h:

   SEEK_SET     Начало файла
   SEEK_CUR     Текущая позиция указателя файла
   SEEK_END     Конец файла

  Функция может быть использована, чтобы перерасположить указатель
  в любое место файла. Указатель может быть перемещен за конец файла.
  Однако, попытка переместить указатель в расположение до начала файла
  приведет к ошибке.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  0, если указатель успешно перемещен.
  Ненулевое значение, если ошибка.
  Неопределенное значение для таких устройств, как терминал и принтер.

    СМОТРИ ТАКЖЕ

  ftell,lseek,rewind

    ПРИМЕР

  #include <stdio.h>

  FILE *stream;
  int  result;

  stream = fopen("data","r");
  .
  .
  .
  /* Следующее утверждение возвращает указатель на начало файла */
  result = fseek(stream,0L,SEEK_SET);



                            100

                            FSTAT


    ФОРМАТ

  #include <sys.types.h>
  #include <sys.stat.h>

  int fstat(handle,buffer);
  int handle;
  struct stat *buffer;


    ОПИСАНИЕ

 Функция получает информацию об открытых файлах, связанных с заданным
 handle, и помещает ее в структуру, на которую указывает buffer.
 Структура с типом stat определена в sys\stat.h и содержит следующие
 области:

    st-mode        Бит маска для вида информации. S_IFCNR бит устанав-
                   ливается, если handle для устройства. S_UFREA уста-
                   навливается если handle для файла.
                   Пользовательский бит чтения/записи устанавливается,
                   согласно типу доступа к файлу.

    st-dev         Либо драйверное число дисков, содержащих файл, или
                   handle в случае устройства.

    st-rdev        Либо драйверное число дисков, содержащих файл, или
                   handle в случае устройства.

    st-nlink       Всегда 1

    st-atime       Время последней модификации файла.

    st-mtime       Время последней модификации файла.

    st-ctime       Время последней модификации файла.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  0, если статус информация получена.
  -1,неправильное файл handle; при этом errno устанавливается в EBADF.

  Замечание: если заданный handle относится к устройству, то поле раз-
             меров и времени в stat структуре не имеют смысла.


    СМОТРИ ТАКЖЕ

 access,chmod,filelength,stat
                            101

    ПРИМЕР

 #include <fcntl.h>
 #include <sys\types.h>
 #include <sys\stat.h>
 #include <stdio.h>

 struct stat buf;
 int fh,result;

 fh = open ("tmp/data",O_RDONLY);
 .
 .
 .
 result = fstat(fh,&buf);
 if (result == 0)
    printf ("размер файла есть %ld\n",buf,st_size);

                            102

                            FTELL

    ФОРМАТ

  #include <stdio.h>

  long ftell(stream);
  FILE *stream;


    ОПИСАНИЕ

 Функция получает текущую позицию указателя файла, связанного с потоком
 stream. Позиция выражается  как смещение относительно начала файла.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Текущая позиция.
 -1L, индицирует об ошибке.
 Для устройств терминала и принтера, или когда поток обращается к не-
 открытому файлу, возвращаемое значение не определено.

    СМОТРИ ТАКЖЕ

 fseek,lseek,tell

    ПРИМЕР

  #include <stdio.h>

  FILE *stream;
  long position;

  stream = fopen("data","rb");
  .
  .
  .
  position = ftell(stream);




                            103

                            FTIME

    ФОРМАТ

  #include <sys\types.h>
  #include <sys\timeb.h>

  void  ftime(timeptr);
  struct  timeb *timeptr;


    ОПИСАНИЕ

 Функция получает текущее время и помещает ее в структуру, на которую
 указывает timeptr. Timeb структура установлена в sys\timeb.h. Она со-
 держит 4 области: time, millitm, timezone и dstflag.
 В time задается время в секундах, начиная с 00:00:00 Greenwich Mean
 Time, 1 января 1970 г.
 В millitm задается этот же интервал более точно в 1000 миллисекундах.
 В timezone задается различие в минутах, при движении в западном нап-
 равлении, между Greenwich Mean Time и временем региона.
 Значение timezone устанавливается из значения глобальной переменной
 timezone (смотри tzset).
 Dstflag ненулевое, если Daylight Saving Time является значимым для
 времени в регионе, определяемым из значения глобальной переменной
 daylight (смотри tzset).


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Функция задает значения в областях структуры, на которую указывает
 timeptr. Это не является возвращаемым значением.


    СМОТРИ ТАКЖЕ

  asctime,ctime,gmtime,localtime,time,tzset

    ПРИМЕР

  #include <sys\types.h>
  #include <sys\tibeb.h>
  #include <stdio.h>
  #include <time.h>

  main ()
  {
  struct timeb timebuffer;
  char *timeline;

  ftime (&timebuffer);
  timeline = ctime(&(timebuffer.time));
  printf ("Время = %.19s.%hi %s",timeline, timebuffer.millitm,
          &timeline[20]);

    ВЫВОД

  Время = Wed Dec 04 17:58:29.420 1985


                            104

                            FWRITE

    ФОРМАТ

  #include <stdio.h>

  int  fwrite(buffer,size,count,stream);
  char  *buffer;
  int  size;
  int  count;
  FILE *stream;


    ОПИСАНИЕ

 Функция записывает count число знаков длины size из buffer в выводной
 поток stream. Указатель файла, связанный с потоком stream, увеличива-
 ется на число записанных байтов.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Количество действительно записанных знаков, которое может быть меньше
 чем count, если встретилась ошибка.

    СМОТРИ ТАКЖЕ

 fread,write

    ПРИМЕР

  #include <stdio.h>

  FILE *stream;
  long list[100];
  int  numwritten;

  stream = fopen("data","r+b");
  .
  .
  .
  /* Следующее утверждение записывает 100 коротких целых в поток
     в двоичном формате */
  numwritten = fwrite ((char *)list,sizeof(long),100,stream);

                            105

                            GCVT

    ФОРМАТ

  #include <stdlib.h>

  char  gcvt(value,ndec,buffer);
  double  value;
  int  ndec;
  char  *buffer;


    ОПИСАНИЕ

 Функция преобразует число с плавающей точкой value в строку символов
 и помещает строку в buffer. Буфер должен быть достаточно большим,
 чтобы принять преобразованное число с символом конца строки ('\0'),
 который автоматически появляется.
 Функция попытается перевести ndec значимых цифр в Фортран F формат.
 При неудаче,переводится ndec значимых цифр в Фортран E формат.
 Незначащие нули подавляются при преобразовании.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Указатель на строку цифр.
 Нет ошибочных кодов возврата.


    СМОТРИ ТАКЖЕ

 atof,atoi,atol,ecvt,fcvt

    ПРИМЕР

  #include <stdlib.h>

  char  buffer[50];
  int  precision = 7;
  gcvt (-3.1415e5,precision,buffer); /* buffer содержит "-314150.0" */

                            106

                        GETC-GETCHAR

    ФОРМАТ

  #include <stdio.h>

  int  getc(stream);
  FILE *stream;
  int  getchar();


    ОПИСАНИЕ

  getc читает символ из текущей позиции потока stream и устанавливает
  связанный с потоком указатель файла на следующий символ.
  Getchar идентично getc (stdin).


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Оба макроса возвращают прочитанный символ.
  EOF, если ошибка или конец файла, которые можно расписать используя
  feof или ferror функции.

  Замечание: getc и getchar идентичны fgetc и fgetchar, но являются
             макросами, а не функциями.

    СМОТРИ ТАКЖЕ

  fgetc,fgetchar,getch,getche,putc,putchar,ungetc

    ПРИМЕР

  #include <stdio.h>

  FILE *stream;
  char  buffer[*];
  int  i,ch;

  /* Следующие утверждения получают строку из stdin */
  for (i = 0;(i < 80) && ((ch = getchar()) != EOF) && (ch != '\n');i++)
      buffer[i] = ch;

  buffer[i] = '\0';
                            107

                            GETCH

    ФОРМАТ

  #include <conio.h>    /* используется только для описания функции */

  int  getch();


    ОПИСАНИЕ

 Функция читает без эхо (без отражения на экране) одиночный символ с
 "консоли".


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Прочитанный символ.


    СМОТРИ ТАКЖЕ

 cgets,getche,getchar

    ПРИМЕР

  #include <conio.h>
  #include <ctype.h>

  int  ch;
  /* Этот цикл получает символы с клавиатуры, пока не будет нажат
     пробел */
  do {
     ch = getch();
     }
  while (isspace(ch));



                            108

                            GETCHE

    ФОРМАТ

  #include <conio.h>    /* используется только для описания функции */

  int  getche ();


    ОПИСАНИЕ

   Функция читает одиночный символ из консоли с эхом (с отображением на
 экране). Если набран CONTROL-C, система выполняет INT23H (CONTROL-C
 exit).

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Прочитанный символ.
 Нет ошибочных кодов возврата.


    СМОТРИ ТАКЖЕ

 cgetc,getch.getchar

    ПРИМЕР

  #include <conio.h>
  #include <ctype.h>

  int  ch;

  /* Получить символ с клавиатуры с отображением на консоли.
     Если это прописная пуква, то преобразовать ее в заглавную и
     записать под старым символом */
  ch = getche ();
  if (isupper(ch))
     cprintf ("\b%c",_tolower(ch));



                            109

                            GETCWD

    ФОРМАТ

  #include <direct.h>    /* используется только для описания функции */

  char  *getcwd(pathbuf,n);
  char  *pathbuf;
  int  n;


    ОПИСАНИЕ

 Функция получает полное имя пути текущего каталога и помещает ее в
 pathbuf. Аргумент n определяет максимальную длину имени пути.
 Приведет к ошибке, если длина имени пути превышает n.
 Аргументом pathbuf может быть NULL; буфер размером n  будет автома-
 тически получен ( с помощью malloc) и будет использован, чтобы помес-
 тить имя пути.
 Этот буфер может быть позже освобожден, используя возвращаемое значе-
 ние getcwd функции ( указатель на полученный буфер), с free функцией.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Pathbuf.
 NULL, если ошибка; при этом errno устанавливается в одно из следующих
 значений:
     ENOMEM          Недостаточно памяти, чтобы получить n байтов
                     (когда NULL аргумент задан в качестве pathbuf).
     ERANGE           Имя пути превышает n символов.


    СМОТРИ ТАКЖЕ

  chdir,mkdir,rmdir

    ПРИМЕР

  #include <direct.h>
  #include <stdlib.h>

  char  buffer[51];

  /* Следующее утверждение помещает имя текущего рабочего каталога
     в buffer */
  if (getcwd(buffer,50) == NULL)
     perror ("getcwd ошибка");



                            110

                            GETENV

    ФОРМАТ

  #include <stdlib.h>    /* используется только для описания функции */

  char  *getenv(varname);
  char  *varname;


    ОПИСАНИЕ

 Функция организует поиск varname в списке переменных окружения. Переме-
 ные окружения определяют среду, в которой процесс выполняется
 (например: по умолчанию, ведется поиск путей к библиотекам, которые
 связаны с программой).


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Указатель на таблицу окружения, содержащая значение строки varname.
  NULL, если заданная переменная не определена.

  Замечания: входы в таблицу окружений нельзя изменить непосредственно.
             Чтобы сделать это, используйте putenv функцию. Чтобы мо-
             дифицировать возвращаемое значение без изменений в табли-
             це окружений, используйте strdup или strcpy, чтобы скопи-
             ровать строку.
             Getenv и putenv функции используют глобальную переменную
             environ, чтобы получить доступ к таблице окружений.
             Putenv может изменить значение environ, включив envp аргу-
             мент в "main" функцию.

    СМОТРИ ТАКЖЕ

  putenv

    ПРИМЕР

  #include <stdlib.h>

  char  *pathvar;

  /* Следующее утверждение получает значение переменной
     окружения PATH */
  pathvar = getenv("PATH");


                            111

                            GETPID

    ФОРМАТ

  #include <process.h> * /используется только для описания функции */

  int getpid();

    ОПИСАНИЕ

 Функция возвращает целое, процесс ID, который однозначно определяет
 вызванный процесс.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Процесс ID.
 Нет ошибочных кодов возврата.

    СМОТРИ ТАКЖЕ

 mktemp

     ПРИМЕР

  #include <process.h>
  #include <string.h>
  #include <stdio.h>

  char filename[9], pid[5];
  .
  .
  .
  strcpy(filename, "FILE");
  strcat(filename, itoa(getrid(), pid, 10));
        /* напечатает "FILEххххх",где xxxxx есть process id */
  printf("Имя файла есть %s\n", filename);



                            112

                            GETS

    ФОРМАТ

  #include <stdio.h>

  char *gets(buffer);
  char *buffer;


    ОПИСАНИЕ

 Функция читает строку из stdin и помещает в buffer.
 Строка включает все символы, включая первый встретившиеся символ
 новой строки ('\n').
 Строка результат заканчивается нулевым символом ('\0').


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

 Ее аргумент.
 NULL, если ошибка или конец файла, которые можно отличить, используя
 feof или ferror функцию.

    CМОТРИ ТАКЖЕ

 fgets, fputs, puts

    ПРИМЕР

 #include <stdio.h>

 char line[100];
 char *result;

 /* Следующее утверждение получает строку ввода из stdin
 */

 result = gets(line);
                            113

                            GETW

    ФОРМАТ

  #include <stdio.h)

  int getw(stream);
  FILE *stream;


     ОПИСАНИЕ

  Функция читает следующее двоичное значение типа int из определенного
  входного потока stream и увеличивает указатель файла, связанный с
  потоком, на следующий не прочитанный символ.
  GETW не предполагает специальное выравнивание знаков в потоке.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Прочитанное значение целого.
   EOF, если ошибка или конец файла; однако EOF может быть возвращено
        и при правильном значении целого, так что необходимо использо-
        вать feof или ferror функции, чтобы отличить эти условия.

   Замечания: Функция дает возможность для совместимости с предыдущими
              библиотеками. Проблема переноса может возникнуть, т.к.
              размеры int и старшинство битов в int различные при пере-
              ходе к различным системам.


    СМОТРИ ТАКЖЕ

  putw

    ПРИМЕР

  #include <stdio.h>
  #include <stdlib.h>

  FILE *stream;
  int  i;

  /* Следующее утверждение читает слово из stream и выполняет
     проверку: не было ли ошибки */
  i = getw (stream);
  if (ferror(stream)) {
     fprintf (stderr."getw неудачна\n");
     clearerr(stream);
     }




                            114

                            GMTIME

    ФОРМАТ

  #include <time.h>

  struct tm *gmtime(time);
  long *time;


     ОПИСАНИЕ

  Функция преобразует время из длинного целого в структуру. Длинное
  значение времени представляет собой секунды, прошедшие с 00:00:00
  1 января 1970 г. Grecnwieh Mean Time; значение которого обычно
  получают при вызове time.
  Функция разбивает значение time и помещает ее компоненты в структуру
  tm, определенному в time.h.. Результат отражает Greenwich Mean Time,
  а не время региона.
  Области в структуре tm хранит следующие значения:

     tm_sec            Ceкунды
     tm_min            Минуты
     tm_hour           Часы (0-24)
     tm_mday           День месяца (1-31)
     tm_mon            Месяц (0-11; январь = 0)
     tm_year           Год (текущий год минус 1900)
     tm_wday           День недели (0-6; воскресенье = 0)
     tm_yday           День года (0-365; январь 1 = 0)
     tm_isdst          Ненулевое, если Daylight Saving Time значимо,
                       иначе нулевое.

  Под MS-DOS даты до 1980 года не воспринимаются. Если time задает
  дату до 1 января 1980 г., то gmtime возвращает структуру, представ-
  ляющую время 00:00:00 январь 1, 1980г.


     ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Указатель на структуру результат.
  Нет ошибочных кодов возврата.


     СМОТРИ ТАКЖЕ

  аsctime, ctime, ftime, localtime, time


     ПРИМЕР

  #include <time.h>

  struct tm *newtime;
  long ltime;

  time(&ltime);
  newtime = gmtime(&ltime);
  printf("Greenwich mean time is %s\n", asctime(newtime));
                           115

                          HALLOC

    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */

  char  huge *halloc(n,size);
  long n;
  unsigned  size;


    ОПИСАНИЕ

  Функция получает память для большого массива из n элементов,
  каждый элемент которого размером в size байтов. Каждый элемент
  инициализируется 0.
  Если размер массива превышает 128К, то размер элемента массива
  должен быть степени 2.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Char huge указатель на полученную память.
  Полученная память, на которую указывает возвращаемое значение,
  является выровненной для любого типа обьектов. Чтобы получить
  указатель типа, отличного от char huge, используйте перекидывание
  возвращаемого значения.
  NULL, если нет достаточной доступной памяти.

    СМОТРИ ТАКЖЕ

  calloc,free,hfree,malloc,realloc

    ПРИМЕР

  #include <malloc.h>

  long huge *lalloc;
  .
  .
  .
  /* Получить память для 80000 long и инициализировать 0 */
  lalloc = (long huge *)halloc(80000L,sizeof(long));



                            116

                            HFREE

    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */

  void  hfree(ptr);
  char  huge *ptr;


    ОПИСАНИЕ

  Функция освобождает блок памяти. Аргумент ptr указывает на блок
  памяти, ранее полученный через обращение к halloc. Число освобожда-
  емых байтов есть число байтов, которое было определено,  когда блок
  получали. После вызова освобожденный блок доступен для получения.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Нет кодов возврата.

    СМОТРИ ТАКЖЕ

  halloc

    ПРИМЕР

  #include <malloc.h>
  #include <stdio.h>

  char  huge *alloc;
  /* Получить 80000 байтов и затем освободить их */
  alloc = halloc(80000L,sizeof(char));
  .
  .
  .
  if (alloc != NULL)
     hfree(alloc);
                            117

                            HYPOT

    ФОРМАТ

  #include <math.h>  /* используется только для описания функции */

    double hypot(x,y);
    double x,y;


    ОПИСАНИЕ

    Функция вычисляет длину гипотенузы от заданных двух сторон х и у.
     Вызов hypot эквивалентно sqrt(x*x+y*y)

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Длина гипотенузы.
     HUGE, если переполнение результата; при этом errno устанавливается
     в ERANGE.

    СМОТРИ ТАКЖЕ

     cabs

    ПРИМЕР

  #include <math.h>

  double x,y,z;
  x=3.0;
  y=4.0;
  z=hypot(x,y);
  printf("Гипотинуза = %2.1f\n",z);

  ВЫВОД

   Гипотинуза = 5.0

                            118

                             INP

    ФОРМАТ

  #include <conio.h>  /* используется только для описания функции */
    int inp(port);
    unsigned port;


    ОПИСАНИЕ

    Функция читает один байт с вводного порта port.
     Аргумент port  может быть беззнаковое целое от 0 до 65535.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Прочитанный байт.
     Нет ошибочных кодов возврата.

    СМОТРИ ТАКЖЕ

     outp

    ПРИМЕР

  #include <conio.h>

    unsigned port;
    char result;
    .
    .
    .
    result = inp(port);


                            119

                            INT86

    ФОРМАТ

  #include <dos.h>
    int int86(intno,inregs,outregs);
    int intno;
    union REGS *ingers;
    union REGS *outregs;


    ОПИСАНИЕ

     Функция выполняет 8086 системное прерывание,определяемое номером
      прерывания в intno. До прерывания int86 копирует содержимое
      inregs в соответствующие регистры. После прерывания функция
      копирует содержимое регистров в outregs. Также копируется статус
      системы (системный флаг) в поле cflag в outregs. Аргументы inregs
      и outregs должны быть типа REGS и они установлены в dos.h.
      Int86 используется для непосредственного обращения к DOS
      прерываниям.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Содержимое АХ регистра после прерывания. Если поле cflag в outregs
     ненулевое , значит имела место ошибка и переменная doserrno
     устанавливается в соответствующий код ошибки.

    СМОТРИ ТАКЖЕ

    bdos,intdos,intdosx,int86x

    ПРИМЕР

  #include <signal.h>
  #include <dos.h>
  #include <stdio.h>
  #include <process.h>

  /* (Номер прерывания 0x23), которое будет улавлено обработчиком
     прерываний. Заметим, что значения в regs не имеют значения
     для этого прерывания
  */
  #define CNTRL_C 0x23
  int int_handler(int);
  union REGS regs;
  .
  .
  .
  signal (SIGINT,int_handler);
  .
  .
  .
  int86(CNTRL_C,&regs,&regs);
                            120

                            INT86x

    ФОРМАТ

  #include <dos.h>
    int int86x(intno,inregs,outregs,segregs);
    int intno;
    union REGS *inregs;
    union REGS *outregs;
    struct SREGS *segregs;


    ОПИСАНИЕ

    Функция выполняет 8086 системное прерывание, определяемое номером
     прерывания в intno.
     До прерывания int86x копирует содержимое inregs и segregs в
     соответствующие регистры. Только значения DS и ES регистров в
     segregs используются. После прерывания функция копирует текущие
     значение регистров в outregs и востанавливает DS. Также копируется
     статус системы (системный флаг) в поле cflag в outregs.
     Inregs и outregs аргументы связываются с типом REGS. Segregs
     аргумент является структурой типа SREGS. Эти типы устанавливаются
     во включенном файле dos.h.
     Int86x предназначена для непосредственного обращения к DOS
     прерываниям , которые берут аргумент в ES регистре или берут
     значение DS регистра, которые отличаются от заданных по умолчанию
     данных сегмента.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Значение АХ регистра после прерывания.
    Если поле cflag в outregs ненулевое, значит встретилась ошибка и в
     переменную doserrno  устанавливается соответствующий код ошибки.

    Замечание:
          Значения сегмента, аргументы segregs, могут быть получены с
          использованием либо segread функции, либо FP_SEG  макроса.

    СМОТРИ ТАКЖЕ

    bdos,intdos,intdosx,int86,segread,FP_SEG
                            121

    ПРИМЕР

  #include <signal.h>
  #include <dos.h>
  #include <stdio.h>
  #include <process.h>
  /* Использование int 86x команды, чтобы сгенерировать прерывание
     0x21, которое включает системный вызов 'Change Atributes'
     (изменить атрибуты). Команда int86x используется, потому что
     имя файла является ссылкой на далекии (far) указатель, так что
     DS регистр должен быть точно установлен в SREGS структуру
  */
  #define SYSCALL      0x21  /* INT 21H системный вызов */
  #define CHANGE_ATTR 0x43   /* системный вызов 43H - изменить
                                атрибуты */
  char far *filename;        /* имя файла в далеком сегменте */

  union REGS inregs, outregs;
  struct SREGS segregs;
  int result;
  .
  .
  .
  inregs.h.ah=CHANGE_ATTR;   /* AH есть номер системного вызова */

  inregs.h.al=0;             /* AL есть функция (получить атрибуты) */

  inregs.x.dx=FP_OFF(filename); /* DS:DX указывает на имя файла */

  segregs.ds=FP_SEG(filename);
  result=int86x(SYSCALL,&inregs,&outregs,&segregs);
  if (outregs.x.cflag) {
      printf("невозможно получить атр. файла;errno номер %d\n",result);
      exit(1);
      }
  else {
        printf("Атрибуты=%#x\n", outregs.x.cx);
        }
                            122

                            INTDOS

    ФОРМАТ

  #include <dos.h>
    int intdos(inregs,outregs);
    union REGS *inregs;
    union REGS *outregs;


    ОПИСАНИЕ

    Функция включает вызов к MS_DOS, специфицированный значениями
    регистров, определяемых в inregs, и возвращает результат вызова
    к системе в outregs.
    Inregs и outregs аргументы связываются с типом REGS и определяются
    во включенном файле dos.h. Intdos выполняет INT21H команду. До
    выполнения команды функция копирует содержимое inregs в
    соответствующие регистры. После выполнения команды intdos копирует
    текущее значение регистров в outregs. Также копируется статус
    системы (ситемный флаг) в поле cflag в outregs. Если это поле
    ненулевое, значит флаг был установлен при системном вызове и
    индицирует об ошибочном условии. Intdos предназначена, чтобы
    включить вызов к MS_DOS, который индицирует ошибки установкой
    флага.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Значение в АХ регистре после системного вызова. Если поле cflag в
    outregs ненулевое, значит встретилась ошибка и в doserrno
    устанавливается соответствующий код ошибки.

    СМОТРИ ТАКЖЕ

    bdos,intdosx

    ПРИМЕР

  #include <dos.h>
  #include <stdio.h>

  union REGS inregs,outregs;
  .
  .
  .
  /* Следующие утверждения получают текущую дату, используя
     системный вызов 2а
  */

  inregs.h.ah=0x2a;
  intdos(&inregs,&outregs);
  printf("дата: %d%d%d\n", outregs.h.dh,outregs.h.d1,outregs.x.cx);


                           123

                          INTDOSX

    ФОРМАТ

  #include <dos.h>
    int intdosx(inregs,outregs,segregs);
    union REGS *inregs;
    union REGS *outregs;
    struct SREGS *segregs;


    ОПИСАНИЕ

    Функция включает вызов к DOS системе, специфицированный значениями
     регистров , определенных в inregs, и возвращает результат вызова в
     outregs.   Подобно   intdos  функции,  intdos  принимает  значения
    сегментных регистров в segregs, предоставляя возможность программам,
    которые  используют  сегменты  данных 'длиной модели' или  далекие
    указатели, определяющие эти сегменты, или указатели, которые должны
    быть   использованы  во время вызова системы. Inregs  и  outregs
    аргументы  связываются  с  типом  REGS. Segregs аргумент является
    структурой  типа  SREGS. Эти типы определяются во включаемом файле
    dos.h.
    Чтобы  включить  вызов,   intdosx   выполняет   int21h   команду.До
    выполнения  команды  функция копирует содержимое inregs и segregs в
    соответствующие  регистры. Только значения DS и ES регистров  в
    segregs  используются. После выполнения команды intdosx копирует
    текущее значение регистров в outregs и  восстанавливает  DS.  также
    копируется статус системы (системный флаг) в поле cflag в outregs.
      Если  это  поле  ненулевое, значит флаг был установлен при вызове
    системы и индицирует об ошибке. Intdosx предназначен для  системного
    вызова,  который берет аргумент в ES регистре или берет значение DS
    регистра, которые отличны от заданных по умолчанию данных сегмента

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Значение в АХ регистре после системного  вызова. Если поле cflag  в
    outregs   ненулевое,   значит   встретилась  ошибка  и  в  doserrno
    устанавливается соответствующий код ошибки.
      Замечание:
           Значения сегмента для segregs аргумента  могут  быть
           получены  с помощью segread функции или FD_SEG макроса.

    СМОТРИ ТАКЖЕ

     bdos,intdos,segread,FD_SEG

    ПРИМЕР

  #include <dos.h>
      union REGS inregs,outregs;
      struct SREGS segregs;
      char far *dir="/test/bin";
      /* Следующие утверждения текущий рабочий каталог,
         используя вызов функции DOS 3b
      */
      inregs.h.ah=0x3b;
      inregs.x.dx=FD_OFF(dir);
    segregs.ds=FP_SEG(dir);
     intdosx(&inregs,&outregs,&segregs);


                            124

                         ISALNUM-ISASCII

    ФОРМАТ

  #include <ctype.h>
      int isalnum(c); /* тест для ('A'-'Z','a'-'z','0'-'9') */
      int isalpha(c); /* тест для букв ('A'-'Z','a'-'z') */
      int isascii(c); /* тест для ASCII символов */
      int c;


    ОПИСАНИЕ

    Ctype команды выполняют тест для  заданного  целого,возвращая
    ненулевое  значение,  если  целое  удовлетворяет  условию  теста,и
    нулевое значение, если нет. Набор символов ASCII предполагается.
    Isascii  команда  дает  значимый  результат  для  всех  значений
    целого. Однако, остальные команды доют определенный результат только
    для  всех  значений  целых,  соответствующих  набору ASCII символов
    (только те, для которых  isascii  был  истина),а для  не  ASCII
    символов возвращают значение EOF (определенный в stdio.h).

      Замечание.
      Ctype команды выполняются как макросы.

    СМОТРИ ТАКЖЕ

      iscntrl,isdigit,isgraph,islower,isprint,ispunct,isspace,isupper,
      isxdigit,toascii,tolower,toupper

    ПРИМЕР

  #include <stdio.h>
  #include <ctype.h>

     int ch;

     /* Следующие утверждения анализируют все символы между кодами
        Ox00 и Ox7f, печатая "A" для букв, "AN" для алфавитно-цифровых,
        и "AS" для ASCII
     */
     for (ch=0;ch<=Ox7f;ch++) {
         printf ("%#04x",ch);
         printf ("%3s",isalnum(ch)  ? "AN" :  "");
         printf ("%2s",isalpha(ch)  ? "A"  :  "");
         printf ("%3s",isalcii(ch)  ? "AS" :  "");
         putchar ('\n');
         }
                           125

                          ISATTY

    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */
     int isatty (handle);
     int handle;


    ОПИСАНИЕ

         Функция устанавливает, заданный handle связан ли с символьным
    устройством ( такие, как терминал, принтер, консоль или порт.)

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Ненулевое значение, если устройство символьное.
    0, в других случаях.


    ПРИМЕР

  #include <io.h>

    int fh;
    long loc;
    .
    .
    .
    if (isatty(fh) == 0)
       loc = tell (fh);   /* если не устройство, получить текущую
                             позицию */
                            126

                       ISCNTRL-ISXDIGIT

    ФОРМАТ

  #include <ctype.h>

    int iscntrl(c); /* тест для управ. символов (0x00-0x1f или 0x7f) */
    int isdigit(c); /* тест для цифр ('0'- '9') */
    int isgrapf(c); /* тест для печат. символов, не включая пробел
                       (0x21-0x7e */
    int islower(c); /* тест для прописных букв ('a'-'z') */
    int isprint(c); /* тест для печат. символов (0x20-0x7e) */
    int ispunct(c); /* тест для пункт. символов  */
    int isspace(c); /* тест для пробела (0x09-0x0d или 0x20) */
    int isxdigit(c); /* тест для 16-чных цифр ('A'-'F','a'-'f'или'0'-'9') */
    int isupper(c); /* тест для заглавных букв ('A'-'Z') */

    ОПИСАНИЕ

    Ctype команды выполняют тест для  заданного  целого,возвращая
    ненулевое  значение,  если  целое  удовлетворяет  условию  теста,и
    нулевое значение, если нет. Набор символов ASCII предполагается.
    Isascii  команда  дает  значимый  результат  для  всех  значений
    целого. Однако, остальные команды доют определенный результат только
    для  всех  значений  целых,  соответствующих  набору ASCII символов
    (только те, для которых  isascii  был  истина),а для  не  ASCII
    символов возвращают значение EOF (определенный в stdio.h).

      Замечание.
      Ctype команды выполняются как макросы.

    СМОТРИ ТАКЖЕ

      isalnum,isalpha,isascii,toascii,tolower,toupper

    ПРИМЕР

  #include <stdio.h>
  #include <ctype.h>

     int ch;
     /* Следующие утверждения анализируют все символы между кодами
        Ox00 и Ox7f, печатая "U" для заглавных букв, "L" для прописных
        букв, "D" для цифр, "X" для 16-чных цифр, "S" для пробелов,
        "PU" для знаков пунктуации, "PR" печатных, "G" для графических,
        и "C" для управляющих. Если символ печатный, он  печатается
     */
     for (ch=0;ch<=Ox7f;ch++) {
         printf ("%2s",iscntrl(ch)  ? "C"  :  "");
         printf ("%2s",isdigit(ch)  ? "D"  :  "");
         printf ("%2s",isgraph(ch)  ? "G"  :  "");
         printf ("%2s",islower(ch)  ? "L"  :  "");
         printf ("%2s",isspace(ch)  ? "S"  :  "");
         printf ("%2s",isupper(ch)  ? "U"  :  "");
         printf ("%2s",isxdigit(ch) ? "C"  :  "");
         printf ("%3s",ispunct(ch)  ? "PU" :  "");
         printf ("%3s",isprint(ch)  ? "PR" :  "");
         printf (" %c",isprint(ch)  ? ch   :  '\0');
         putchar ('\n');
         }

                            127

                            ITOA

    ФОРМАТ

  #include <stdlib.h>  /* используется только для описания функции */
   char *itoa (vaiue,string,radix);
   int vaiue;
   char * string;
   int radix;

    ОПИСАНИЕ

       Функция преобразует цифры, заданные в value в строку символов,
    завершающихся  нулевым символом  ('\0'), и помещает результат в
    string. Radix аргумент определяет базу value;  он  должен  быть  в
    пределах  от  2 до 36. Если  radix  равно 10 и value отрицательно,
    первым символом в строке будет знак (-).

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на строку.
    Нет ошибочных кодов возврата.

    Замечание:
         Область памяти для string должна быть достаточной, чтобы
         поместить результат. Функция может возвращать до 17 байтов.

    СМОТРИ ТАКЖЕ

    ltoa,ultoa

    ПРИМЕР

  #include <stdlib.h>
   int radix = 8;
   char buffer [20];
   char *p;

   p = itoa(-3445,buffer,radix);      /* p = "171213" */


                            128

                            KBHIT

    ФОРМАТ

  #include <conio.h>  /* используется только для описания функции */
  int kbhit();

    ОПИСАНИЕ

    Функция проверяет консоль на нажатие клавиши.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Ненулевое значение, если клавиша была нажата.
    0, в других случаях.

    СМОТРИ ТАКЖЕ

    ПРИМЕР

  #include <conio.h>
  int result;

  /* Следующее утверждение проверяет на нажатие клавиши
  */

  result = kbhit();

  /* Если результат ненулой, нажатый символ начодится в буфере.
  ** Он может быть извлечен getch или getche командой.
  ** Если getch или getche были вызваны без проверки посредством
  ** kbhit, программа перейдет в ожидание нажатия клавиши
  */






                            129

                            LABS

    ФОРМАТ

  #include <stdib.h>  /* используется только для описания функции */
   long labs(n);
   long n;

    ОПИСАНИЕ

    Функция возвращает абсолютное значение длинного целого х.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Абсолютное значение.
    Нет ошибочных кодов возврата.

    СМОТРИ ТАКЖЕ

    abs,cabs,fabs

    ПРИМЕР

  #include <stdlib.h>

  long x, y:

  x = -41567L;
  y = labs(x);       /* y = 41567L */



                            130

                            LDEXP

    ФОРМАТ

  #include <math.h>

  double ldexp(x,exp);
  double x;
  int exp;

  ОПИСАНИЕ
                                   ехр
    Функция вычисляет значение х* 2   .

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
       ехр
    х*2   .
    HUGE, если переполнениеж при этом знак huge зависит от знака х.
    0, если недополнение.
     В обоих случаях errno устанавливается в ERANGE.

    СМОТРИ ТАКЖЕ

    frexp, modf

    ПРИМЕР

  #include <math.h>

  double x, y;
  int p;

  x = 1.5;
  p = 5;
  y = ldexp(x,p);       /* y = 48.0 */
                            131

                          LFIND-LSEARCH

    ФОРМАТ

  #include <search.h>  /* используется только для описания функции */

    char *lsearch(key,num,width,compare);
    char *lfind(key,base,num,width,compare);
    char  *key;
    char  *base;
    unsigned  *num,width;
    int (*compare)();

    ОПИСАНИЕ

 Lfind и lsearch функции выполняют линейный поиск для значения key
 в массиве из num элементов, каждый из которого размером width байтов.
 (В отличии от bsearch, lfind и lsearch не требуют, чтобы массив был
 отсортирован). Аргумент base является указателем на начало массива,
 в котором будет вестись поиск.
 Если key не найден lsearch добавляет его в конец, lfind этого не
 делает.
 Аргумент compare является указателем на предполагаемую пользователем
 команду, по которой будут сравниваться два элемента массива и возвра-
 щать значение, определяющее их взаимоотношение. Обе функции вызывают
 compare один или более раз во время поиска, переходя указателем к двум
 элементам массива при каждом вызове. Эта команда должна сравнивать
 элементы и возвращать одно из следующих значений:
       Ненулевое        элемент1 и элемент2 различны
       0                элемент1 и элемент2 идентичны


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Указатель на первое месторасположение key в массиве.
  NULL, если key не найден.

    СМОТРИ ТАКЖЕ

  bsearch
                            132

    ПРИМЕР

  /* Lsearch функция выполняет линейный поиск в массиве для key
     элемента и возвращает указатель на структуру, которая
     соответствует key или NULL, если key не найден
  */

  #include <search.h>
  #include <string.h>
  #include <stdio.h>

     int compare();

     main (argc,argv)
          int argc;
          char **argv;
          {
          char **result;
          char *key = "PATH";
     /* Следующие утверждения находят аргумент, который начинается
        с "PATH"  */
          result = (char **)lsearch((char *)&key, (char *)argv,
                                    &argc,sizeof(char *),compare);
          if (result)
             printf ("%s найдено\n",*result);
          else
             printf ("PATH не найден!\n");
          }
      int compare (arg1,arg2)
          char  **arg1,**arg2;
          {
          return(strncmp(*arg1,arg2,strlen(*arg1)));
          }
                            133

                          LOCALTIME

    ФОРМАТ

  #include <time.h>
  struct tm *localtime(time);
  long * time;

    ОПИСАНИЕ

         Функция преобразует время из длинного целого в
    структуру. Значение time есть секунды, прошедшие с 00:00:00
    январь 1, 1970г,Greenwitch Mean Time; это значение обычно получают с
    помощью time функции.
    Localtime разбивает значение time,  корректирует  его  для  времени
    региона и Daylight Saving Time,  если  применимо,  и  помещает
    скорректированное время в структуру  типа  tm  (смотри  gmtime  для
    получения  описания  tm  струртуры). Под  MS-DOS даты до 1980 г. не
    воспринимаются.  Если  time  представляет  дату  до  1980  г.,   то
    localtime   возвращает   структуру,  представляющую  дату  00:00:00
    январь 1, 1980г.
    Localtime  осуществляет  корреккцию  для  времени   региона,   если
    пользователь вначале установил переменную окружения TZ. Значение TZ
    должно быть трехбуквенным именем зоны (такой как PST), следующим за,
    возможно,  знаковым  числом, задающим различие между Grenwitch Mean
    Time и временем региона. Число  может  следовать  за  трехбуквенным
    именем  Daylight Saving Time  региона  (такой  как PDT). Localtime
    использует рзличие между Greenwitch Mean Time и  временем  региона,
    чтобы  приспособить  значение времени. Eсли  Daylight Saving Time в
    настоящем установлено в TZ, localtime также корректирует время  для
    этого региона. Если  tz  текуще  не  имеет  значения,  по умолчанию
    используется значение PST8PDT .Когда  tz  установлена,  три  другие
    переменные  окружения, timezone, daylight и tzname, устанавливаются
    автоматически. Смотри izset функцию для описания этих переменных.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Указатель на строку результат.
     Нет ошибочных кодов возврата.

    Замечание:
      Gmtime и localtime функции используют одни и  тот  же  буфер  для
    преобразований.  Поэтому  при  каждом  вызове  одной из этих команд
    результаты предыдущего вызова теряются.

    СМОТРИ ТАКЖЕ

    asctime, ctime, ftime, gmtime, time, tzset
                            134

    ПРИМЕР


  #include <stdio.h>
  #include <time.h>

  main ( )
            {
            struct tm * newtime;
            char *am_pm = "PM";
            time_t long_time;

            time (& long_time);
            newtime = localtime (& lond_time);

            if (newtime->tm_hour < 12)
                    am_pm = "AM";
            if (newtime->tm_hour > 12)
                    newtime->tm_hour -= 12;

            printf("%.19s %s\n", asctime(newtime), am_pm;
            }

  ВЫВОД:

  Tue Dec 10 11:30:12 AM
                            135

                           LOCKING

    ФОРМАТ

#include <sys\locking.h> /* используется только для описания функции */
  #include <io.h>

  int locking(handle, mode, nbyte);
  int handle;
  int mode;
  long nbyte;

    ОПИСАНИЕ

         Функция запирает или отпирает nbytes байтов файла,
    определяемого с handle. Запертые  байты  в  файле   не   доступны
    последующему  чтению  или  записи  этих  байтов  другими
    процессами. Отпирание файла  разрешают  другим  процессам  читать  и
    писать в предыдуще запертые файлы. Запирание и отпирание начинается с
    текущей позиции указателя файла и продолжается до последующих
    nbytes байтов или до конца файла.
    Mode определяет  запирающее  действие  и  должен  быть
    одним из следующих констант.
     lk_lock   Запереть определяемые байты. Если   байты   не  могут
               заперты, попытаться снова через 1 сек. Если после 10
               попыток байты не удалось запереть, возвращается ошибка.
     lk_rlck   Также, как lk_lock.
     lk_nblck  Запереть определяемые байты. Если байты не удалось
                запереть возвратить ошибку.
     lk_nbklck Также, как lk_nblck.
     lk_unlck  Отпереть определяемые байты. Байты должны быть предыдуще
               запертыми.
     Больше одного может быть запертых участков в файле, но пересекание
     участков не допустимо. Более того, не более одного участка могут
     отпираться за одно обращение. Когда файл отпирается, участок файла,
     который должен отпираться , должен соответствовать участку файла,
     который был предыдуще заперт. Locking функция не работает со
     смежными участками, так что, если два запертых региона являются
     смежными, каждый регион должен отпираться отдельно. Не должно
     оставаться запираний перед закрытием или завершением программы.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, если запирание прошло успешно.
    -1, индицирует о неудачной попытке; при этом errno устанавливается
        в одно из следующих значений.
    EACCES        Нарушение запирания (файл уже заперт и отперт).
    EBADF         Недействительное файл handle.
    EDEADLOCK     Нарушение запирания: когда lk_lock или lk_rlock
                   флаги определены и файд не может быть заперт после
                   10 попыток.
    EINVAL        SHARE COM не установлена.

    Замечание:
      Запирание должно использоваться только под MS_DOS 3.0 и поздних
      версий; под ранними версиями результат не достигается.
                            136

    СМОТРИ ТАКЖЕ

    creat, open

    ПРИМЕР

  #include <io.h>
  #include <sys\locking.h>
  #include <stdlib.h>

  extern unsigned char _osmajor;
  int fh;
  long pos;
  .
  .
  .
  /* Сохранить текущую позицию указателя файла, потом запереть
  ** участок файла от начала файла до сохраненной позиции
  */

  if (_osmajor >= 3)   {
          pos = tell (fh);
          lseek (fh, 0L, 0);
          if ((locking (fh, LK_NBLCK, pos)) ! = -1)  {
          .
          .
          .
          lseek (fh, 0L, 0);
          locking (fh, LK_NBLCK, pos);
          }
  }
                            137

                          LOG-LOG10

    ФОРМАТ

  #include <math.h>
  double log(x);
  double log10(x);
  double x;

    ОПИСАНИЕ

    Log и Log10 функции вычисляют натуральный логарифм и логарифм по
    основанию 10 от х соответственно.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Результат логарифма.
     Если х отрицательно, обе функции печатают ошибочное сообщение
     DOMAIN на stderr и возвращает отрицательное значение HUGE.
     Если х нулевое, обе функции печатают ошибочное сообщение SING
     на stderr и возвращают отрицательное значение HUGE .В обеих
     случаях errno устанавливается в edom. Обработку ошибки можно
     изменить , используя matherr  команду.

    СМОТРИ ТАКЖЕ

    exp, matherr, pow

    ПРИМЕР

  #include <math.h>

  double x = 1000.0, y;

  y = log(x);      /* y = 6.907755 */

  /* Функция log10 вычисляет логарифм по основанию 10 от
  ** заданного значения)
  */
  y = log10(x);       /* y = 3.0 */








                            138

                           LONGJMP

    ФОРМАТ

  #include <setjmp.h>

  void longjmp(env, value);
  imp_buf env;
  int value;

    ОПИСАНИЕ

    Функция восстанавливает множество окружений, предыдуще сохраненных
    в env по команде setimp. Setjmp и longjmp дают возможность, чтобы
    выполнить нелокальный переход и обычно используется, чтобы миновать
    выполнение контроля возвращаемых кодов  при предыдущем вызове без
    использования нормальных соглашений по вызову и возврату.
    Вызов setjmp сохранит текущее окружение в env. Последующий вызов
    longjmp восстанавливает сохраненное окружение и возвращает управление
    в точку после соответствующего setjmp вызова.Выполнение продолжается
    таким же образом, как если бы заданное value было возвращено при
    setjmp вызове.Значения всех переменных ( за исключонием регистровых)
    доступны, чтобы принять те значения, которые они имели, когда
    longjmp был вызван.Значения регистровых переменных непредсказуемы.
    Longjmp должен быть вызван раньше функции, которая вызывает результаты
    setjmp вызова.Вызов longjmp после функции, вызывающей результаты
    setjmp вызова, приведет к непредсказуемому режиму работы программы.
    Value, возвращаемое longjmp, должен быть нулевым.Если задан нулевой
    аргумент value, значением 1 заменяется действительное возвращаемое
    значение.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Нет возвращаемых значений.

     Предупреждение:
      Значения регистровых переменных при вызове setjmp не могут быть
      восстановлены в должные значения после того, как longjmp будет
      выполнен.

    СМОТРИ ТАКЖЕ

    setjmp
                            139

    ПРИМЕР

  #include <stdio.h>
  #include <setjmp.h>

  jmp_buf mark;

  main( )
          {
          if ( setjmp(mark) ! = 0)    {
                  printf("longjmp был вызван\n");
                  recover( );
                  exit(1);
                  }
          printf ("setjmp был вызван\n");
          .
          .
          .
          p( );
          .
          .
          .
          }
   p( )
          {
          int error = 0;
          .
          .
          .
          if (error != 0)
                  longjmp(mark,-1);
          .
          .
          .
          }
   recover( )
          {
          /* позаботиться, чтобу файлы не были запорчены перед
          ** завершением программы */
          .
          .
          .
          }
                            140

                            LSEEK

    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */

  long lseek(handle, offset,origin);
  int handle;
  long offset;
  int origin;

    ОПИСАНИЕ

    Функция перемещает указатель файла , связанного с handle, на новое
    местоположение , которое определяется смещением offset байтов от
    origin. Следующая операция с файлом начинается с нового
    местоположения. Origin должен быть одним из следующих констант.
         0       Начало файла
         1       Текущая позиция указателя файла
         2       Конец файла.
    Lseek используется, чтобы переместить указатель в файле.Указатель
    может быть перемещен за конец файла. Однако, попытка определить
    указатель до начала файла приведет к ошибке.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Смещение в байтах новой позиции указателя от начала файла.
     -1L, индицирует об ошибке, при этом errno устанавливается в одно
           из следующих значений:
      EBADF     НЕдействительный файл handle
      EINVAL    Недействительное значение для origin, или позиция,
                определяемое смещением offset, указывает до начала
                файла

      Для устройств терминала и принтера возвращаемое значение
      неопределено.

    СМОТРИ ТАКЖЕ

    fseek, tell
                            141

    ПРИМЕР


  #include <io.h>
  #include <fcntl.h>
  #include <stdlib.h>

  int fh;
  long position;

  fh = open("data", O_RDONLY);
  .
  .
  .
  /* Смещение от начала файла */

  position = lseek (fh, 0L, SEEK_SET);
  if (position == -1L)
          perror("перемещение на начало неудачно");
  .
  .
  .
  /* найти текущую позицию */
  position = lseek (fh, 0L, SEEK_CUR);
  if (position == -1L)
          perror ("перемещение на текущую позицию неудачна");
  .
  .
  .
  /* идти на конец файла */
  position = lseek( fh, 0L,SEEK_END);
  if (position == -1L)
          perror("перемещение на конец неудачна");
                            142

                            LTOA

    ФОРМАТ

  #include <stdlib.h> /* используется только для описания функции */

    char ltoa( value, string,radix);
    long value;
    char *string;
    int radix;

    ОПИСАНИЕ

    Функция преобразует цифры заданного value в символьную строку,
    завершающихся нулевым символом , и помещает результат в
    string. Аргумент radix определяет основаниие числа value; он
    должен быть в пределах от 2 до 36. Если radix равно 10 и value
    отрицательно, первым символом в строку помещается знак (-).

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

     Указатель на строку.
     Нет ошибочных кодов возврата.

     Замечание:
      Область памяти, отводимой для string, должна быть достаточной,
      чтобы поместить возвращаемую строку. Функция может  возвратить
      33 байта.

    СМОТРИ ТАКЖЕ

    itoa, ultoa

    ПРИМЕР

  #include <stdlib.h>

  int radix = 10;
  char buffer[20];
  char *p;

  p = ltoa(-344115L, buffer, radix);   /* p = "-344115" */

                            143

                           MALLOC

    ФОРМАТ

  #include <malloc.h>  /* используется только для описания функции */
    char  *malloc(size);
    unsigned  size;


    ОПИСАНИЕ

  Функция получает блок памяти, как минимум, size байтов. (Блок может
  быть больше чем size байтов в результате выравнивания).

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Символьный указатель на полученную память. Область памяти, на которую
  указывает возвращаемое значение, является выровненной для любого типа
  обьектов. Чтобы получить указатель, отличного от char, используйте
  перекидывание типа в возвращаемом значении.
  NULL, если нет достаточной памяти.

    СМОТРИ ТАКЖЕ

  calloc,free,realloc

    ПРИМЕР

  #include <malloc.h>
     int *intarray;

     /* Получить память для 20 целых */

     intarray = (int *)malloc(20*sizeof(int));
                           144

                          MATHERR

    ФОРМАТ

  #include <math.h>

  int matherr(x);
  struct exeption *x;

    ОПИСАНИЕ

    Функция обрабатывает ошибки, сгенерированные функциями из
    math библиотеки. Math функции вызывают matherr, когда ошибка
    обнаружилась. Пользователь может обеспечить различные определения
    matherr функции, чтобы позаботиться о специальной обработке
    ошибки.
    Когда ошибка встретилась в math команде, matherr вызывается с
    указателем на следующую структуру (определенную в math.h),
    как к аргументу.
          struct exception {
               int type;
               char *name;
               double arg1, arg2, retval;
               };
    Type определяет тип ошибки и принимает одно из следующих
    значений, в math.h.
    DOMAIN      ошибка в области аргумента
    SING        особенность аргумента
    OVERFLOW    переполнение
    UNDERFLOW   недополнение
    TLOSS       полная потеря значимости
    PLOSS       частичная потеря значимости

    Name указывает на строку, содержащую имя функции, которая
    привела к ошибке. Arg1, arg2 устанавливаются в значения
    аргументов, которые привели к ошибке. ( Если только один
    аргумент задан, он помещается в arg1 ).
    Retval является возвращаемым значением по умолчанию для
    этой ошибки; пользователь может изменить возвращаемое значение.
    Возвращаемое значение matherr определяет, встретилась ли
    действительно ошибка. Если matherr возвратила ноль, ошибочное
    сообщение появляятся и errno устанавливается в соответствующее
    значение ошибки. Если matherr возвращает ненулевое значение,
    ошибочное сообщение не появляется и errno остается
    неизменным.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, индицирует об ошибке
    Ненулевое значение, об успешном выполнении действия.

    СМОТРИ ТАКЖЕ

    acos, asin, atan, atan2, bessel, cabs, cos, cosh, exp,
    hypot, log, pow, sin, sinh, sqrt, tan
                            145

    ПРИМЕР

  #include <math.h>
  #include <string.h>

  /* Обработка ошибок при вызове log или log10 команд. Если
  * ошибка есть результат отрицательного аргумент (DOMAIN
  * error), абсолютное значение аргумента возвращается
  * (в отличие от HUGE, по умолчанию).
  * Ошибочное сообщение предполагается. Если ошибкой является
  * нулевой аргумент или ошибка была сгенерирована любой другой
  * командой выполняются действия по умолчанию */

  int matherr(x)
  struct exeption *x;
         {
         if (X->type == DOMAIN)  {
                if (strcmp(x->name, "log") == 0)   {
                return(1);
                }
         else if (strcmp(x->name, "log10") == 0)    {
                 x->retval = log10(-(x->arg1));
                 return(1);
                 }
              }
         return (0);            /* use default actions */
         }

                            146

                           _MEMAVL

    ФОРМАТ

  #include <malloc.h>    /* используется только для описания функции */

  unsigned int _memavl();


    ОПИСАНИЕ

  Функция возвращает апроксемированный размер, в байтах памяти,
  доступной для динамического получения памяти, в данном сегменте.
  Эта функция может быть использована с calloc, malloc, или realloc
  в малой и средней модели памяти, и с _nmalloc во всех моделях
  памяти.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Размер байтов, как беззнаковое целое.

    СМОТРИ ТАКЖЕ

  calloc, malloc, _freect, realloc, stackavail

    ПРИМЕР

  main()

    {
    long *longptr;

    printf("Доступная память до malloc = %u\n", _memavl());
    longptr = (long*)malloc(5000*sizeof(long));
    printf(Доступная память после malloc = %u\n", _memavl());
    }


                           147

                          MEMCCPY

    ФОРМАТ

  #include <memory.h> /* используется только для описания функции */
  #include <string.h> /* используйте либо string.h либо memory.h */

  char *memccpy(dest, src, C, cnt);
  char *dest;
  char *src;
  int C;
  unsigned cnt;

    ОПИСАНИЕ

    Функция копирует нуль или более байтов из sre в dest до тех
    пор,пока не будет скопирован символ С или не будет скопировано
    cnt байтов.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Если символ С был скопирован, функция возвращает указатель
    на следующий байт за скопированным символом.
    NULL, если символ С не был скопирован

    СМОТРИ ТАКЖЕ

    memchr, memcmp,memcpy, memset


    ПРИМЕР

  #include <memory.h>

  char buffer[100], source[100];
  char *resalt;
  .
  .
  .
  /* Копировать байты из source в buffer пока '\n' не будет
  ** скопирован, но не более чем 100 байтов
  */

  result = memccpy (buffer, source, '\n', 100);

                           148

                          MEMCHR

    ФОРМАТ

  #include <memory.h> /* используется только для описания функции */
  #include <string.h> /* используйте либо string.h либо memory.h */

  char *memchr(buf, C, cnt);
  char *buf;
  int C;
  unsigned cnt;

    ОПИСАНИЕ

    Функция ведет поиск символа С в первых ent байтах buf.
    Поиск продолжается до тех пор, пока С найдено или cnt байтов
    проверено.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указать на расположение С в buf:
    NULL, если С не найден в пределах первых cnt байтов buf.

    СМОТРИ ТАКЖЕ

    memccpy, memcmp, memcpy, memset

    ПРИМЕР

  #include <memory.h>

  char buffer[100];
  char *result;
  .
  .
  .
  /* Найти первое месторасположение 'a' в buffer. Если 'a' не
  ** не найдено в первых 100 байтах возвратить NULL.
  */

  result = memchr (buffer, 'a', 100);



                           149

                          MEMCMP

    ФОРМАТ

  #include <memory.h> /* используется только для описания функции */
  #include <string.h> /* используйте либо string.h либо memory.h */

  int memcmp (buf1, buf2,cnt);
  char *buf1;
  char *buf2;
  unsigned cnt;

    ОПИСАНИЕ

    Функция сравнивает первые cnt байтов buf1 и buf2 лексико-
    графически и возвращает значение, индицирующее их
    взаимоотношение, как следующее.

           Меньше 0, если buf1 меньше чем buf2.
           0, если buf1 идентично buf2.
           Больше 0,если buf1 больше чем buf2.


    СМОТРИ ТАКЖЕ

    memccpy,memchr, memcpy, memset

    ПРИМЕР

  #include <memory.h>

  char first[100], second[100];
  int result;

  /* Следующее утверждение сравнивает first[ ] and second[ ]
  */

  result = memcmp (first, second, 100);


                           150

                          MEMCPY

    ФОРМАТ

  #include <memory.h> /* используется только для описания функции */
  #include <string.h> /* используйте либо string.h лиьо memory,h */

  char memcpy (dest, src, cnt);
  char *dest;
  char *src;
  unsigned cnt;

    ОПИСАНИЕ

    Функция копирует cnt байтов из src в dest. Если некоторые
    участки src и dest перекрываются, memery гарантирует, что
    src байты в перекрывающемся участке скопируются раньше, чем
    будут перекрыты.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на dest.

    СМОТРИ ТАКЖЕ

    memccpy, memchr, memcmp, memset

    ПРИМЕР

  #include <memory.h>

  char source[200], destination[200];
  .
  .
  .
  /* Переслать 200 байтов из sourse в destination, и
  ** возвратить указатель на destination.
  */

  memcpy (destination, sourse,200);


                           151

                          MEMICMP

    ФОРМАТ

  #include <memory.h> /* используется только для описания функции */
  #include <string.h> /* используйте либо string.h либо memory,h */
    int  memicmp (buf1,buf2,cnt);
    char  *buf1;
    char  *buf2;
    unsigned  cnt;


    ОПИСАНИЕ

  Функция сравнивает первые cnt байтоа buf1 и buf2 лексографически,
  считая заглавные и прописные буквы эквивалентными. Функция
  возвращает значение, индицирующее взаимоотношение buf1 и buf2,
  как следующее:
      Меньше 0          buf1 меньше buf2
      0                 buf1 идентично buf2
      Больше 0          buf1 больше buf2


    СМОТРИ ТАКЖЕ

  memccpy,memchr,memcmp,memcpy,memset

    ПРИМЕР

  #include <memory.h>

    char  first[100],second[100];
    int  result;

    strcpy(first,"Those Who Will Not Learn from history");
    strcpy(second,"THOSE WHO WILL NOT LEARN their mistakes");
    result = memicmp(first.second,29);  /* result = 0 */
                           152

                          MEMSET

    ФОРМАТ

  #include <memory.h> /* используется только для описания функции */
  #include <string.h> /* одно из двух */

  char *memset (dest, c , cnt);
  char *dest;
  int c;
  unsigned cnt;

    ОПИСАНИЕ

    Функция устанавливает первые cnt байтов dest в с.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на dest.

    СМОТРИ ТАКЖЕ

    memccpy, memchr, memcmp, memcpy

    ПРИМЕР

  #include <memory.h>

  char buffer[100];

  /* Установить первые 100 байтов buffer в нули.
  */

  memset (buffer, '\0', 100);
                          153

                          MKDIR

    ФОРМАТ

  #include <direct.h> /* используется только для описания функции */

  nit mkdir (pathname);
  char *pathname;


    ОПИСАНИЕ

    Функция создает новый каталог, определяемый в pathname.
    Только один каталог может быть создан за один вызов,
    поэтому только последним компонентом pathname можно
    проименовать новый каталог.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, если новый каталог был создан
    -1, индицирует от ошибки; при этом errno устанавливается
    в одно из следующих значений.

          EACCES  Каталог не создан; заданное имя является
                  именем существующего файла, каталога или
                  устройства.
          ENOENT  pathname не найдено.

    СМОТРИ ТАКЖЕ

    chdir, rmdir

    ПРИМЕР

  #include <direct.h>

  int result;

  /* Следующие два утверждения создают два новых каталога:
  ** один в корневом в драйвере b; другой в подкаталоге tmp
  ** текущего рабочего каталога. */

  result = mkdir("b:/tmp");   /* "b:\\tmp" также возможно */

  result = mkdir("tmp/sub");  /* "tmp\\sub" также возможно */



                           154

                          MKTEMP

    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */

   char *mktemp(template);
   char *template;

    ОПИСАНИЕ

    Функция создает уникальное имя файла посредством
    модификации заданного template. Аргумент template имеет форму

                       base хххххх
    где base есть часть нового имени файла, предпологаемого
    пользователем, а х является местодержателем для части имени,
    предполагаемого mktemp. Mktemp сохраняет base и заменяет
    шесть х-ов алфавитно-цифровым символом, за которым следует
    значение из 5-ти цифр. Пяти-цифровое значение  есть
    уникальное число, определяющее вызванный процесс.
    Алфавитно-цифровой символ есть ноль('0 '), когда mktemp
    вызывается в первый раз с заданным template.
    При последующих вызовах из того же процесса с тем же
    template mktemp проверяет, чтобы выяснить, было ли
    предыдущее имя использовано, чтобы создать файлы. Если файл
    не существует для заданного имени, mktemp возвращает это
    имя. Если файлы  существуют для всех предыдуще
    возвращенных имен, mktemp создает новое имя, заменив
    алфавитно-цифровой символ в имени на следующую букву.
    Например, если первым возвращенным именем было "t012345"и
    это использовалось для создания файла, следующим
    возвращаемым именем будет "ta12345". При создании новых имен
    mktemp использует, как правило, '0' и буквы от 'a'до 'z'.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указатель на модифицированный template.
    NULL, если аргумент template плохо сформирован, или нет
          этого template.

    Замечание:
    Mktemp генерирует уникальные имена файлов, а не создает или
    открывает файлы.

    СМОТРИ ТАКЖЕ

    fopen, getpid, open

    ПРИМЕР

  #include <io.h>

  char *template = "fnXXXXXX";
  char *result;

  /* Следующее утверждение генерирует уникальное имя файла
  */
  result = mktemp (template);

                            155

                            MODF

    ФОРМАТ

  #include <math.h>

  double modf (x, intptr);
  double x;
  double *intptr;

    ОПИСАНИЕ

    Функция делит значение числа с плавающей точкой х на дробную
    и целую части. Целая часть помещается, как число с
    плавающей точкой, в infptr.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Дробная часть со знаком.
    Нет ошибочных кодов возврата

    СМОТРИ ТАКЖЕ

    frexp, ldexp

    ПРИМЕР

  #include <math.h>

  double x, y, n;

  x = -14.87654321;
  y = modf(x, &n);      /* y = -0.87654321, n = -14.0 */

                            156

                          MOVEDATA

    ФОРМАТ

  #include <memory.h> /* используется только для описания функции */
  #include <string.h> /* одно из двух */

  void movedata (srcseg, srcoff, destseg, destoff, nbytes);
  int srcseg;
  int srcoff;
  int destseg;
  int destoff;
  unsigned nbytes;

    ОПИСАНИЕ

    Функция копирует nbytes из исходного адреса, определяемого
    как sreseg: sreoff, в конечный пункт, определяемый как
    destseg: destoff.
    Функция предназначена, чтобы перемещать далекие данные
    в программах малой и средней модели, где сегмент адресов
    данных не  является известным косвенным образом.
   В программах больщой модели memcpy функция может быть
    использована, т.к. сегмент адресов известен неявно.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Нет кодов возврата

    Замечание:
    Значения сегмента для sreseg и destseg аргументов могут быть
    получены с использованием segread функции или FR-SEG макроса.
    Movedata функция не может управлять в случаях перекрывающихся
    перемещений (когда часть конечного пункта является тем же
    участком памяти, что и часть исходного). Перекрывающиеся
    перемещения управляются корректно в memcpy функции.

    СМОТРИ ТАКЖЕ

    memcpy, segread, FR-SEG

    ПРИМЕР

  #include <memory.h>
  #include <dos.h>

  char far *src;
  char far *dest;
  .
  .
  .
  /* Следующее утверждение пересылает 512 байтов данных из
  ** src в dest:
  */

  movedata (FP-SEG(src), FR-OFF(src), FR-SEG(dest),
            FR-OFF(dest), 512);

                          157

                          MSIZE

    ФОРМАТ

  #include <malloc.h>  /* используется только для описания функции */

    ОПИСАНИЕ

    Функция возвращает размер в байтах блока памяти,
    полученного по вызову calloc, malloc или realloc.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Размер в байтах как беззнаковое целое.

    СМОТРИ ТАКЖЕ

    ПРИМЕР

  #include <stdio.h>
  #include <malloc.h>

    main()
    {
    long *oldptr;
    unsigned  int newsize = 64000;

    oldptr = (long *)malloc(10000*sizeof(long));
    printf ("Размер блока памяти, на которую указывает oldptr = %u\n,
             _msize(oldptr));
    if (_expand(oldptr,newsize) != NULL)
       printf ("Размер блока увеличен до %u\n",_msize(oldptr));
    else
       printf ("Размер блока увеличен только до %u\n",_msize(oldptr));
    }

                          158

                         _NFREE

    ФОРМАТ

  #include <malloc.h> /* используется только для описания функции */

  void _nfree (ptr);
  char near *ptr;

    ОПИСАНИЕ

    Функция освобождает  блок памяти. Аргумент ptr указывает на
    блок памяти, предыдуще полученный по вызову _nmalloc.
    Число освобождаемых байтов есть число байтов, которые были
    определены, когда блок был получен. После вызова,
    освобожденный блок снова доступен для получения.

    ВОЗВРАЩАЕМОЕ  ЗНАЧЕНИЕ

    Нет кодов возврата.

    Замечание
    Попытка освободить недействительный ptr (указатель, не
    получаемый посредством _nmalloc) может влиять на последующее
    получение и привести к ошибкам.

    СМОТРИ ТАКЖЕ

    _nmalloc, free, malloc


    ПРИМЕР

  #include <malloc.h>
  #include <stdio.h>

  char near *alloc;

  /* Получить 100 байтов и затем освободить их */

  if ((alloc = _nmalloc(100)) == NULL)
          printf("невозможно получить память\n");
  else    {
          .
          .
          .
          _nfree (alloc);
          }

                           159

                          NMALLOC

    ФОРМАТ

  #include <malloc.h> /* используется только для описания функции */

  char near *_nmalloc (size);
  unsigned size;


    ОПИСАНИЕ

    Функция получает блок памяти минимум size байтов внутри
    сегмента данных. (Блок может быть более чем nsize байтов в
    результате выравнивания).

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Символьный указатель на полученный блок. Область памяти, на
    которую указывает возвращаемое значение, является выравненной для
    определяемого типа обьектов. Чтобы получить указатель типа
    отличного от char, используйте преобразование возвращаемого
    значения.
    NULL, если нет достаточной доступной памяти.

    СМОТРИ ТАКЖЕ

    _nfree, _nmsize, malloc, realloc

    ПРИМЕР

  #include <malloc.h>

  int *intarray;

  /* Получить память для 20 целых */

  intarray = (int *)_nmalloc(20*sizeof (int));


                           160

                          _NMSIZE

    ФОРМАТ

  #include <malloc.h> /* используется только для описания функции */

  unsigned _nmsize(ptr);
  char near ptr;

    ОПИСАНИЕ

    Функция возвращает размер в байтах блока памяти, полученного
    при вызове _nmalloc.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Размер в байтах ,как беззнаковое целое.

    СМОТРИ ТАКЖЕ

    _ffree, _fmalloc, _fmsize, malloc, _msize, _nfree, _nmalloc

    ПРИМЕР

  #include <malloc.h>
  #include <stdio.h>

  main( )
       {
       char near *stringarray;

       stringarray = _nmalloc (200*sizeof(char));
       if (stringarray != NULL)
            printf("%u получено байтов\n", _nmsize(stringarray));
       else
            printf("запрос на память неудачен.\n");
       }
                           161

                          ONEXIT

    ФОРМАТ

  #include <stdlib.h> /* используется только для описания функции */

  onexit_t onexit(func);
  onexit_t func;

    ОПИСАНИЕ

    Функция берет адрес функции func, которая была вызвана, когда
    программа нормально завершилась. Вызовы onexit создают
    регистр функции, которая выполняется. Не более чем 32
    функции могут быть зарегистрированны с onexit; onexit
    возвращает значение NULL, если число функции превышает 32.
    Функции, передаюшиеся onexit, не могут брать параметры.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Указать на функцию.
    NULL, если нет памяти, чтобы поместить указатель функции.

    СМОТРИ ТАКЖЕ

    exit

    ПРИМЕР

  #include <stdlib.h>
  main( )
         {
         int fn1 ( ), fn2( ), fn3( ), fn4( );
         onexit (fn1);
         onexit (fn2);
         onexit (fn3);
         onexit (fn4);
         printf ("Это выполняется вначале.\n");
         }
  int fn1( )
         {
         printf("следующим\n");
         }
  int fn2( )
         {
         printf("выполняется ");
         }
  int fn3( )
         {
         printf(" ");
         }
  int fn4( )
         {
         printf("Это");
         }

  ВЫВОД:

    Это выполняется вначале
    Это выполняется следующим
                          162

                          OPEN

    ФОРМАТ

  #include <fentl.h>
  #include <sys\types.h>
  #include <sys\stat.h>
  #include <io.h>

  int open (pathname, oflag[, pmode]);
  char *pathname;
  int oflag;
  int pmode;

    ОПИСАНИЕ

    Функция открывает файл, определенный в pathname, и подготавливает
    файл для чтения или записи, как определено в oflag.
    Аргумент oflag является целым выражением, сформированным
    комбинациией одной или более следующих заглавных констант,
    определенных в fcntl.h.; когда задается более одной заглавной
    константы, они разделяются операторами ИЛИ (|).

               O_APPEND  Перерасположить указатель файла на конец
                         файла перед каждой операцией записи.
               O_CREAT   Создать и открыть новый файл для записи;
                         не дает результата, если файл уже
                         существует.
               O_EXCL    Возвращает ошибочный код, если файл,
                         определенный в pathname уже существует.
                         Применяется только вместе с O_CREAT.
               O_RDONLY  Открыть файл только для чтения; если этот
                         флаг задан, ни O_RDWR ни O_WRONLY не
                         могут быть заданы.
               O_RDWR    Открыть файл для чтения и записи;если этот
                         флаг задан, ни O_RDONLY ни O_WRONLY не
                         могут быть заданы.
               O_TRUNE   Открыть и сузить существующий файл до
                         нулевой длины; файл должен иметь доступ
                         для записи. Содержимое файла теряется.
               O_WHONLY  Открыть файл только для записи; если этот
                         флаг задан, ни O_RDONLY ни O_RDWR не могут
                         быть заданы.
               O_BINARY  Открыть файл в бинарном виде.
                         (Смотри FOPEN для описания  бинарного вида).
               O_TEXT    Открыть файл в текстовом виде
                         (Смотри FOPEN для описания текстового вида).

       Замечание:
                 O_TRUNE полностью затирает содержимое существующего
                 файла. Будьте с ним осторожны.
                           163

    Аргумент pmode требуется только тогда, когда O_CREAT определено.
    Если файл существует pmode игнорируется. В другом случае, pmode
    определяет способ доступа к файлу, который устанавливается,
    когда новый файл закрывается впервые. Pmode есть целое
    выражение, содержащее одну или обе константы S_IWRITE и
    S_IREAD, определенных в SYS\ STAT.h. Когда обе константы
    задаются, они разделяются оператором ИЛИ(|). Суть pmode
    аргумента в следующем.

              S-IWRITE   Доступ для записи
              S-IREAD    Доступ для чтения
              S-IREAD | S-IWRITE   Доступ для чтения и записи.

    Если доступ для записи не задан, файл только для чтения.
    Под MS-DOS все файлы доступны для чтения; поэтому нет
    необходимости задавать только доступ для записи. Таким
    образом виды S_IWRITE и S_IREAD|S_IWRITE эквивалентны.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Файл handle для открытого файла.
    -1, индицирует об ошибке; при этом errno устанавливается в одно из
    следующих значений.

             EACCES  Заданное имя пути является каталогом, или
                     попытка открыть для записи файл, который только
                     для чтения, или встретилось нарушение
                     распределения.

             EEXIST  Определены O_CREAT и O_EXECL флаги, но файл
                     уже существует.
             EMFILE  Нет больше доступных файл handle
                     (слишком много открытых файлов).
             ENOENT  Файл или имя пути не найдены.

    СМОТРИ ТАКЖЕ

    access, chmod, close, creat, dup, dup2, ,fopen, sopen, umask

    ПРИМЕР

  #include <fcntl.h>
  #include <sys\types.h>
  #include <sys\stat.h>
  #include <io.h>
  #include <stdlib.h>

  main( )
          {
          int fn1, fn2;
          fn1 = open("data1", O_RDONLY);
          if (fn1 == -1)
                  perror("попытка открыть вводной файл неудачна");
          fn2 = open("data2, O_WRONLY|O_TRUNC|O_CREAT,
                              S_IREAD|S_IWRITE);
          if (fn2 == -1)
                  perror("попытка открыть выводноЙ файл неудачна");
          .
          .
          }
                          164

                          OUTP

    ФОРМАТ

  #include <conio.h> /* используется только для описания функции */

  int outp (port, value);
  unsigned port;
  int value;

    ОПИСАНИЕ

    Функция записывает определяемое в value значение в выводной
    порт, определяемый в port. Аргумент port может быть
    беззнаковым целым в пределах от 0 до 65535; value может быть
    целым от 0 до 255.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Значение value.
    Нет кодов ошибок.

    СМОТРИ ТАКЖЕ

    inp

    ПРИМЕР

  # include <conio.h>

  int part, byte_val;
  .
  .
  .
  /* Следующее утверждение выводит байт в порт,
  ** в который 'port' текуще установлен
  */

  outp (port, byte_val);
                           165

                          PERROR

    ФОРМАТ

  #include <stdlib.h> /* используется только для описания функции */

  void perror (string);
  char *string;
  int errno;
  int sys_nerr;
  char sys_errlist[sys_nerr];

    ОПИСАНИЕ

    Функция печатает сообщение об ошибке на stderr. Вначале печатается
    аргумент string, за которой следует двоеточие, системное
    ошибочное сообщение для последнего вызова библиотеки,
    которая дала ошибку, и новая строка.
    Действительный код ошибки помещается в переменную errno,
    которая должна быть описана на верхнем уровне. Системное ошибочное
    сообщение достигается через переменную sys-errlist, которая
    является массивом сообщений, упорядоченных по
    соответствующим кодам ошибок. Perror функций печатает
    соответствующее ошибочное сообщение, используя значение errno,
    как индекс для sys-errlist.
    Значение переменной sys-nerr устанавливается, как максимальное
    число элементов в sys-errlist массиве. Для правильной работы
    perror должна быть вызвана сразу после библиотечной команды,
    которая возвратила код ошибки. В другом случае значение
    errno может быть затерто при последующих вызовах.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Нет кодов возврата.

  Замечание:
    Под MS-DOS некоторые значения errno из списка errno.h не
    используются. Смотри приложение А "Сообщения об ошибках" для получения
    списка значения errno, используемых под MS-DOS. Функция печатает
    пустую строку для errno значений, не используемых под MS-DOS.

    СМОТРИ ТАКЖЕ

    clearerr, ferror, strerror

    ПРИМЕР

  #include <fcntl.h>
  #include <sys\types.h>
  #include <sys\stat.h>
  #include <io.h>
  #include <stdlib.h>
  int fn1, fn2;
  fn1 = open ("data1", O_RDONLY);
  if (fn1 == -1)
          perror("попытка открыть вводной файл неудачна");
  fn2 = open ("data2", O_WRONLY|O_TRUNC|O_CREAT,S_IREAD|S_IWRITE);
  if (fn2 == -1)
          perror("попытка открыть выводной файл неудачна");
                            166

                             POW

    ФОРМАТ

  #include <math.h>

  double pow (x, y);
  double x;
  double y;

    ОПИСАНИЕ

    Функция вычисляет х в степени у.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Х в степени у.
    1, если значение у нулевое.
    NUGE, если х равно 0 и у отрицательно; при этом errno
          устанавливается в ERANGE.
    0, если х отрицательное и у не целое; при этом errno
       устанавливается в EDOM и печатается ошибочное сообщение DOMAIN
       в stderr.
    HUGE, отрицательное или положительное, если переполнение;
          при этом errno устанавливается в ERANGE.

    СМОТРИ ТАКЖЕ

    exp, log, sqrt

    ПРИМЕР

  #include <math.h>

  double x = 2.0, y = 3.0, z;
  .
  .
  .
  z = pow (x, y);      /* z = 8.0 */
                           167

                          PRINTF

    ФОРМАТ

  #include <stdio.h>

  int printf (format-string[, argument...]);
  char *format-string;

  ОПИСАНИЕ

    Функция формирует и печатает наборы символов и значений в
    стандартный выводной поток, stdout. Format-string состоит из
    обычных символов, escape последовательностей, и, если за
    format-string следуют аргументы, спецификации форматов.
    Обычные символы и escape последовательности просто копируются
    в stdout в порядке их появления. Например, строка
          printf(" Первая строка\n\t\t Вторая строка\n");
    выводит
          Первая строка
                        Вторая строка

     Если за format-string следуют аргументы arguments, то
    format-string должен содержать спецификацию форматов,
    определяющих выводной формат для этих аргументов. Спецификации
    форматов начинаются с символа процента (%) и описываются ниже.
    Format-string считывается слева направо. Когда первая
    спецификация формата (если несколько) встречается, значение
    первого аргумента после format-string преобразуется и выводится
    согласно спецификации формата. Вторая спецификация формата
    преобразует и выводит второй аргумент, и таким образом
    продолжается до конца format-string. Если задано больше аргументов
    чем спецификация формата, лишние аргументы игнорируются.
    Результат будет неопределенным, если нет достаточно аргументов
    для всей спецификации форматов.
    Спецификация формата имеет следующую форму:
        % [flags] [width] [.precision] [{F!h!e!}] type
    Каждое поле спецификации формата есть одиночный символ или
    число, означающие частичную опцию формата. Символ type, который
    появляется после последнего поля формата, определяет, как
    будет интерпретироваться связанный аргумент: как символ, строка
    или число( смотри таблица R.1). Самая простая спецификация
    формата содержит только знак процента и символ type
    ( например, %S). Необязательные поля управляют другими
    аспектами форматирования, такими как:
      flags         Включение выводных и печатных знаков, пробелов,
                    десятичных точек, восьмеричных и шестнадцате-
                    ричных префиксов (смотри таблица R.2)
      width         Минимальное число выводных символов
      precision    Максимальное число символов, которые будут
                    напечатаны, для всех или части выводных
                    полей; или минимальное число цифр, которые
                    будут печататься, для значения целого
                    (смотри таблица R.3).
                            168

      F,N          Префиксы, которые позволяют пользователю не
                   принимать во внимание способы адресации,
                   модели памяти, которые используются:

                   F    Используется в малой модели для печати
                        значений, которые описаны как far.
                   N    Используется в средней, большой и верхней
                        моделях для значений near.
                   F,N должны быть использованы только с типами
                  s и p, так как они уместны  только с аргументами,
                  которые задаются, как указатель.

    h,l           Допустимый размер аргумента:

                  h     Используется как префикс с целыми типами
                        d,i,o,u,x и X, чтобы определить, что
                        аргумент является коротким целым
                        (short int).
                  l     Используется как префикс с d,i,o,u,x, и X
                        типами, чтобы определить, что аргумент
                        является длинным целым (long int); также
                        используется как префикс с с,e,f,g или G
                        типами, чтобы показать, аргументы
                        являются double, а не float.

    Если за символом процента (%) следует символ, который не
    является полем формата, символ просто копируется в stdout.

                       ТАБЛИЦА R.1
    Символы type
    __________________________________________________________________
    Символ         тип аргумента      выводной формат
    __________________________________________________________________
    d                 целое           десятичное целое со знаком
    i                 целое           десятичное целое со знаком
    u                 целое           десятичное целое без знака
    o                 целое           восьмеричное целое без знака
    x                 целое           шестнадцатеричное целое без
                                      знака, использующее "abcdef"
    X                 целое           шестнадцатеричное целое без
                                      знака, использующее"ABCDEF"

    f      с плавающей точкой         Значение со знаком имеет
                                      форму [-]dddd.dddd, где dddd
                                      есть одно и более десятичных
                                      цифр. Число цифр до десятич-
                                      ной точки зависит от значимости
                                      числа, а число цифр после
                                      десятичной точки зависит от
                                      требуемой точности.
                            169

    e      с плавающей точкой         Значение со знаком имеет
                                      форму [-]d. dddde[segn]ddd,
                                      где d есть одна десятичная
                                      цифра, dddd одно или более
                                      десятичных цифр, ddd ровно
                                      три десятичные цифры, и
                                      sign есть + или -.

    E      с плавающей точкой         Идентично "e" формату, но
                                      знак "E" заменяет "e".

    g      с плавающей точкой         Значение со знаком печатается
                                      в "f"или "e"формате, однако
                                      является более компактным для
                                      заданного значения и точности
                                      peecision (смотри ниже).
                                      Формат "e" используется
                                      только тогда, когда экспонента
                                      значения меньше,чем -4 или
                                      больше, чем precision. Незна-
                                      чащие нули сужаются и десятичная
                                      точка только в том случае, если
                                      одна или более цифр следуют за
                                      ней.

    G      с плавающей точкой         Идентично "g"формату, но знак
                                      "E"означает экспоненту
                                      вместо "e"
    C      символ                     Одиночный символ.

    S      строка                     Символы печатаются до первого
                                      нулевого символа (\0) или
                                      до тех пор, пока precision
                                      будет достигнут.
    n      указатель на целое         Число символов, записанных в
                                      далекий (far) поток или буфер;
                                      это значение помещается как
                                      целое,адрес которого задается
                                      как аргумент.
    p      далекий указатель          Печатает адрес, указанный
                                      аргументом, в виде хххх:уууу,
                                      где хххх есть сегмент, уууу
                                      есть смещение, и цифры х и у
                                      есть шестнадцатеричные цифры;
                                      %Np печатает только смещение
                                      адреса, уууу. Так как %p
                                      исключает указатель,аргумент p,
                                      должен относиться к far в
                                      программах малой модели.

_____________________________________________________________________
                           170

                         ТАБЛИЦА R.2
 Символы flag.
 ____________________________________________________________________

 Flag       Суть                                   по умолчанию
 ___________________________________________________________________

 _       Результат отсекается слева в пределах    Отсекание справа.
         размера(width) поля.
 +       Добавляет префикс знака(+ или-) для      Знак появляется
         выводного значения,если выводное зна-    только для отрица-
         чение является знаковым типом.           тельных значений.
 ' '     Добавляет префикс пробел для выводно-
         го значения, если выводное значение       Нет пробела.
         со знаком и положительно; '+' преобла-
         дает над пробельным флагом, если оба
         появились.

  #      Когда используется 0,х или Х формат,
         '#'флаг добавляет префикс ненулевому      Нет префикса.
         выводному значению 0, 0х или 0Х соот-
         ветственно.
         Когда используется е,Е или f формат,
         выводное значение содержит десятичную
         точку во всех случаях.
         Когда используется g или G формат,вы-
         водное значение содержит десятичную
         точку и незначащие нули не подавляются.

 Width является неотрицательным десятичным целым, контролируещее
 печать минимального числа символов.
 Если число символов в выводном значении меньше, чем определено в
 width, пробелы добавляются слева или справа ( в зависимости от того,
 определен ли флаг'-') до тех пор, пока width не будет достигнут.
 Спецификация width никогда не сужает значение; если число символов
 в выводном значении больше, чем определено в width, или width не
 задано, все символы печатаются( поджчиняются precision специфимкации).
 Спецификация width может быть задана,как звездочка (*); в этом
 случае сам аргумент из списка аргументов предполагается как
 значение. Width аргумент должен предшествовать значению, которое
 будет форматироваться из списка аргументов.
 Спецификация precision является неотрицательным десятичным числом,
 следующим точкой(.), который определяет число символов, которые должны
 быть напечатаны, или число десятичного расположения. Precision
 может сузить выводное значение или округлить в случае значения с
 плавающей точкой.
 Спецификация precision может быть задана звездочкой(*); в этом
 случае сам арогумент из списка аргументов предполагается как
 значение. Precision аргумент должен предшествовать значению,кото-
 рое будет форматировано, из списка аргументов.
 Интерпретация значения precision в зависимости от заданного типа
 type показана в таблице R.3.
______________________________________________________________________
                           171

                         ТАБЛИЦА R.3
______________________________________________________________________

 Type         Суть                               По умолчанию
 _____________________________________________________________________

 d         Precision определяет минимальное     Если precision есть 0,
 i          число цифр, которые будут напеча-   или отсутствует или то-
 u          таны. Если число цифр в аргуцменте  чка появилась без числа
 0          меньше, чем precision, выводное     следующего за ним,
 x          значение добавляется слева нулями.  precision устанавливае-
 X          Значение не сжимается, когда число  тся в 1.
            цифр превышает precision.


 e          Precision определяет число цифр,    По умолчанию precision
 E          которые будут напечатаны после де-  есть 6. Если precision
 f          сятичной точки. Последняя напеча-   0 десятичная точка не
            танная цифра округляется.           печатается.

 g          Precision определяет максимальное   Все десятичные
 G          число значимых цифр, которые будут  цифры печатаются.
            напечатаны.

 С          Нет действия                        Символ печатается.

 S          Precision определяет максимальное   Символы печатаются до
            число символов, которые будут на-   тех пор, пока символ
            печатаны. Символы лишние не печа-   конца строки не будет
            таются.                             напечатан.

          ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Число напечатанных символов.

    СМОТРИ ТАКЖЕ

    fprintf, scanf, sprintf, vfprintf, vprintf, vsprintf
                            172

    ПРИМЕР

  #include <stdio.h>

  main( )          /* Форматировать и печатать различные данные */
       {
       char ch = 'h', *string = "computer";
       int count = 234, *ptr, hex = 0x10, oct = 010, dec = 10;
       double fp = 251.7366;

       printf ("%d   %+d   %06d   %X    %x    %0\n\n",
               count, count,count,count,count, count);

       printf ("1234567890123%n45678901234567890\n\n", &count);
       printf ("Value of count should be 13; count = %d\n\n", count);
       printf ("%10c%5c\n\n", ch, ch);

       printf ("%f   %.2f   %e   %E\n\n", fp, fp, fp, fp);

       printf ("%i   %i     %i\n\n", hex, oct, dec);

       ptr = &count;
       printf ("%Np   %p     %Fp\n",
            ptr,  (int far *) ptr,  (int far *) ptr );
       }


  ВЫВОД:

  234    +234   000234   EA   ea   352

  123456789012345678901234567890

  value of count shold be 13; count = 13

           h    h

                    computer
                        comp

  251.736600   251.74   2.517366e+002   2.517366E+002
  16    8    10

  127A    1328:127A    1328:127A















                            173

                          PUTC-PUTCHAR

    ФОРМАТ

  #include <stdio.h>

  int putc (c, stream);
  int c;
  FILE *stream;

  int putchar (c);
  int c;

    ОПИСАНИЕ

    Команда записывает одиночный символ c в выводной поток stream в
    текущую позицию.  Putchar команда идентично putc(c,stdout).

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Записанный символ.
    EOF, индицирует об ошибке; ferror функция должна быть использо-
    вана, чтобы определить, какая ошибка встретилась.

     Замечание:

    Pute и putchar команды идентичны frute и frutchar, но являются
    макросами, а не функциями.

    СМОТРИ ТАКЖЕ

    frutc, frutchar, getc, getchar

    ПРИМЕР

  #include <stdio.h>

  FILE *stream;
  char buffer[81];
  int i, ch;
  .
  .
  .
  /* Следующее утверждение записывает buffer в  stream:
  */

  for (i = 0; (i<81) && ((ch = putc (buffer[i], stream)) != EOF);)
          ++i;

                            174

                            PUTCH

    ФОРМАТ

  #include <conio.h> /* используется только для описания функции */

  void putch (c);
  int c;

    ОПИСАНИЕ

    Функция записывает символ с на консоль

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Нет кодов возврата

    СМОТРИ ТАКЖЕ

    cprintf, getch, getche

    ПРИМЕР

  #include <conio.h>

  /* Следующее утверждение показывает, как getche функция может быть
  ** определена, используя putch и getch:
  */

  int getche( )
  {
          int ch;

          ch = getch ( );
          putch (ch);
          return (ch);
  }
                           175

                          PUTENV

    ФОРМАТ

  #include <stdlib.h> /* используется только для описания функции */

  int putenv (envstring);
  char *envstring;

    ОПИСАНИЕ

    Функция добавляет новые переменные окружения или модифицирует
    существующире переменные окружения. Переменные окружения уста-
    навливают окружение, в котором процесс выполняется(например,
    по умолчанию путь для библиотек связан с программой).
    Аргумент envstring должен быть указателем на строку, имеющий
    форму
          varname=string
    где varname имя переменной окружения, которая будет добавлена
    или модифицирована, а string значение переменной. Если varname
    уже существует в окружении. то ее значение будет string; иначе,
    новое значение string будет добавлено в окружение. Переменная
    может быть установлена в пустое значение, если определен пустой
    string.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, если успешно
    -1, индицирует об ошибке

   Замечание:
     Getenv и putenv функции используют глобальную  переменную
     environ, чтобы получить доступ к таблице окружения. Putenv
     функция может изменить значение environ таки образом, что
     сделает неправильным 'envp' аргумент для 'main' функции.

    СМОТРИ ТАКЖЕ

    getenv

    ПРИМЕР

  #include <stdlib.h>
  #include <stdio.h>
  #include <process.h>

  /* Попытка изменить переменную окружения. */

  if (putenv("PATH=a:\\bin;b:\\tmp") == -1)  {
          printf("putenv неудачна");
          exit(1);
          }

                            176

                            PUTS

    ФОРМАТ

  #include <stdio.h>

  int puts(string);
  char  *string;


    ОПИСАНИЕ

  Функция записывает заданную строку string в стандартный выводной
  поток stdout, помещая завершающий строку нулевой символ ('\0') и
  символ конца строки ('\n') в выводной поток.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  Последний записанный символ, который всегда является символом '\n'.
  EOF, индицирует об ошибке.

    СМОТРИ ТАКЖЕ

  fputs,gets


    ПРИМЕР

  #include <stdio.h>

  /* Следующее утверждение записывает предложение в stdout */

  result = puts("Установите дискету и нажмите любую клавишу");

                            177

                            PUTW

    ФОРМАТ

  #include <stdio.h>

  int putw (binint, stream);
  int binint;
  FILE *stream;

    ОПИСАНИЕ

    Записывает двоичное значение типа int в текущую позицию опреде-
    ленного потока stream. Функция не делает выравнивания знаков в
    потоке, так как это предполагает специальное выравнивание.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Записанное значение.
    EOF, индицирует об ошибке; ferror должно быть использовано, чтобы
    различить ошибку.

      Замечание:

    Putw функция предназначалась вначале для работы с предыдущими
    библиотеками. Проблемы переноса могут встретиться, так как размер
    int и старшинство битов в int различаются при переходе от системы  системе
    к системе.

    СМОТРИ ТАКЖЕ

    getw

    ПРИМЕР

  #include <stdio.h>
  #include <stdlib.h>

  FILE *stream;
  .
  .
  .
  /* Следующее утверждение записывает слово в stream
  ** и проверяет на ошибку:
  */

  putw(0345, stream);

  if (ferror (stream))  {
          fprintf (stderr,"putw failed\n");
          clearerr (stream);
          }
                          178

                          QSORT

    ФОРМАТ

  #include <search.h>  /* используется только для описания функции */

  void qsort (base, num, width, compare);
  char *base;
  unsigned num, width;
  int (*compare)( );

    ОПИСАНИЕ

    Функция выполняет алгоритм быстрой сортировки, чтобы отсортировать
    массив num элементов, каждый элемент которого размером width
    байтов. Аргумент base является указателем на начало массива,
    который сортируется. Qsort функция переписывает этот массив
    с отсортированнными элементами. Аргумент compare является указа-
    телем на предполагаемую пользователем команду, которая сравнивает
    два элемента массива и возвращает значение,определяющее их
    взаимоотношение. Функция будет вызывать compare команду один или
    более раз в течение сортировки, проходя указателем к двум
    элементам массива при каждом вызове. Команда должна сравнивать
    элементы, потом возвращать одно из следующих значений:
         меньше 0     элемент 1 меньше элемент 2;
                0     элемент 1 эквивалентно элемент 2;
         больше 0     элемент 1 больше элемент 2;

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Нет кодов возврата.

    СМОТРИ ТАКЖЕ

    bsearch, lsearch
                            179

    ПРИМЕР

  #include <search.h>
  #include <string.h>
  #include <stdio.h>

  int compare( );

  main (argc, argv)
          int argc;
          char **argv;

          {
          .
          .
          .
          /* Следующее утверждение сортирует командную строку
          ** аргументов в лексографическом порядке
          */

          qsort ((char *)argv, argc, sizeof (char *), compare);
          for (i = 0; i<argc;++i)
                  printf ("%s\n",argv [i]);
                  .
                  .
                  .
                  }

  int compare (arg1, arg2)
          char **arg1, **arg2;

          {
          return (strcmp (*arg1, arg2));
          }
                          180

                          RAND

    ФОРМАТ

  #include <stdlib.h> /* используется только для описания функции */

  int rand( );

    ОПИСАНИЕ

    Функция возвращает случайное целое в пределах от 0 до 32767

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Случайное число.
    Нет ошибочных кодов возврата.

    СМОТРИ ТАКЖЕ

    srand

    ПРИМЕР

  #include <stdlib.h>
  #include <stdio.h>

  int x;

  /* Напечатать первые 20 сгенерированных случайных чисел
  */

  for (x = 1; x <= 20; x++)
          printf ("iteration %d, rand=%d\n",x, rand ( ));

                          181

                          READ

    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */

  int read (handle, buffer, count);
  int handle;
  char *buffer;
  unsigned int count;

    ОПИСАНИЕ

    Функция пытается прочитать count  байтов из файла, связанного
    с handle, в buffer. Операция чтения начинается с текущей позиции
    указателя файла, связанного с заданным файлом. После чтения
    указатель файла указывает на следующий непрочитанный символ.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Число действительно прочитанных символов, которое может быть
          меньше, чем count, если в файле оставалось меньше байтов, чем
          count, или файл был открыт в текстовом виде (смотри ниже).
    0, если была попытка прочитать конец файла
    -1, индицирует об ошибке; при этом errno устанавливается
        в следующее значение:
              EVADF   Заданное hanhle недействительно; или файл
                       не был открыт для чтения; или файл защищен
                       (MS-DOS З.О и позже)
    Если было прочитано более 32К (максимальный размер для int),
    возвращаемое значение должно быть типа unsigned int. Однако
    максимальное число байтов, которые могут быть прочитаны из
    файла, есть 65534, так как 65535 (0хffff) есть граница от -1
    и должно возвратить ошибку .
    Если файл был открыт в текстовом виде, возвращаемое значение может не
    не соответствовать числу действительно прочитанных  байтов.
    Потому что каждая комбинация возврат-каретки/новая строка (LF)
    заменяеися символом новой строки (LF), и только символ новой строки
    засчитывается в возвращаемое значение.

    СМОТРИ ТАКЖЕ

    creat, fread, open, write
                            182

    ПРИМЕР

  #include <io.h>
  #include <stdio.h>
  #include <fcntl.h>

  char buffer [60000];

  main ( )
     {
     int fh;
     unsigned int nbytes = 60000, bytesread;

     if ((fh = open ("c:/data/conf.dat", O_RDONLY)) == -1)  {
             perror ("попытка открыть вводной файл неудачна");
             exit (1);
             }
     if ((bytesread = read (fh, buffer, nbytes)) == -1)
             perror (" ");
     else
             printf ("прочитано %u байтов из файла\n", bytesread);
     .
     .
     .
     }

                           183

                          REALLOC

    ФОРМАТ

  #include <malloc.h>  /* используется только для описания функции */

  char *realloc (ptr, size);
  char *ptr;
  unsigned *size;

    ОПИСАНИЕ

    Функция изменяет размер предыдуще полученного блока памяти.
    Аргумент ptr указывает на начало блока. Аргумент size задает новый
    размер блока в байтах. Содержимое блока не изменяется, за
    исключением промежутка между новыми и старыми размерами.
    Аргумент ptr может также указывать на блок, который был освобожден
    до тех пор, пока не будут вызваны calloc, malloc, halloc или
    realloc.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Символьный указатель на переопределенный блок памяти.
   NULL, если нет достаточной доступной памяти для расширения блока
   до заданного размера size. Исходный блок освобождается, когда
   это происходит.
   Память, на которую указывает возвращаемое значение, является
   выравненной для памяти определенного типа обьектов. Чтобы по-
   лучить указатель отличного от char типа, его необходимо преоб-
   разовать.

    СМОТРИ ТАКЖЕ

    calloc, free, halloc, malloc

    ПРИМЕР

  #include <malloc.h>
  #include <stdio.h>

  char *alloc

  /* Получить блок для 50 символов.
  */

  alloc = malloc (50*sizeof (char));
  .
  .
  .
  /* Переопределить блок до 100 символов */

  if (alloc != NULL)
          alloc = realloc (alloc, 100*sizeof (char));
                          184

                          REMOVE

    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */
  #include <stdio.h> /* одно из двух */

  int remove (pathname);
  char *pathname;

    ОПИСАНИЕ

    Функция удаляет файл, определенный в pathname.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, если успешно.
    -1, индицирует об ошибке; при этом errno устанавливается в
        одно из следующих значений:
         EACCES      имя пути определяет каталог или файл только
                     для чтения.
         ENOENT      Файл или путь не найдены.

    СМОТРИ ТАКЖЕ

    close, unlink

    ПРИМЕР

  #include <io.h>
  #include <stdlib.h>

  int result;

  result = remove ("tmpfile");
  if (result == -1)
          perror ("невозможно удалить tmpfile");
                           185

                          RENAME

    ФОРМАТ

  #include <io.h>    /* используется только для описания функции */
  #include <stdio.h> /* одно из двух */

  int rename (oldname, newname);
  char *oldname;
  char *newname;

    ОПИСАНИЕ

    Функция переименует файл или каталог, определенный в oldname, на
    новое имя , заданное в newname. Oldname должен определить имя пути существующего файла
    существующего файла или каталога. Newname не должен определять
    имя существующего файла или каталога.
    Функция может быть использована, чтобы переместить файл из одного
    каталога в другой, задав различные имя пути в newname аргументе.
    Однако файлы не могут быть перемещены из одного устройства в другой
    (например, из драйвера А в драйвер В).
    Каталоги могут только переименовываться.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    0, если успешно.
    Ненулевое значение,индицирует об ошибке; при этом errno устанав-
    ливается в одно из следующих значений:
        EACCES    Файл или каталог, определенный в pathname,
                  уже существует или не может быть создан (непра-
                  вильный путь); или oldname является каталогом, а
                  newname определяет другой путь.
        ENOENT    Файл или путь, определенные в oldname не найдены.
        EXDEV     Попытка переместить файл на другое устройство.

    СМОТРИ ТАКЖЕ

    creat, fopen, open

    ПРИМЕР

  #include <io.h>

  int result;

  /* Сдедующее утверждение переименует файл "input" в "data":
  */
  result = rename ("input", "data");
                           186

                          REWIND

    ФОРМАТ

  #include <stdio.h>    /* используется только для описания функции */

  void rewind (stream);
  FILE *stream;

    ОПИСАНИЕ

    Функция перерасполагает указатель файла, связанного с потоком
    stream, на начало файла. Вызов REWIND эквивалентно
        fseek (stream, 0L, SEEK-SET)
    за исключением того, что rewind очищает индикаторы конца файла
    и ошибки, а fseek этого не делает; однако, fseek возвращает
    значение, которое индицирует, был ли указатель успешно перемещен,
    а rewind не возвращает такого значения.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

    Нет кодов возврата.

    СМОТРИ ТАКЖЕ

    fseek, ftell

    ПРИМЕР

  #include <stdio.h>

  FILE *stream;
  int data1, data2;
  .
  .
  .
  fprintf (stream, "%d %d", data1, data2);  /* Данные в файл */

  rewind (stream);                      /* Прочитать данные из файла */
  fscanf (stream, "%d", &data1);

                            187

                            RMDIR

    ФОРМАТ

    #include <direct.h> /* используется только для описания функции */

    int rmdir(pathname);
    char *pathname;


    ОПИСАНИЕ

  Функция удаляет каталог,определенный в pathname.
  Каталог должен быть пустым, и не должен быть текущим рабочим
   каталогом или корневым каталогом.


    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

  0, если каталог успешно удален.
  1, индицирует об ошибке; при этом errno  устанавливается в одно
     из следующих значений:
     EACCES - Заданное имя пути не является каталогом;
              или каталог не пустой; или каталог является текущим
              рабочим каталогом или корневым каталогом.
     ENOENT - Имя пути не найдено.


    СМОТРИ ТАКЖЕ

    chdir,mkdir

    ПРИМЕР

    #include <direct.h>
    int result1, result2;
    /* Следующие утверждения удаляют 2 каталога:
    ** первый - в корневом, второй - в текущем рабочем каталоге
     */
     result1 = rmdir("/data1");
     result2 = rmdir("data2");



                           188

                           RMTMP

    ФОРМАТ

  #include <stdio.h>

    int rmtmp();


    ОПИСАНИЕ

  Функция используется,чтобы очистить все временные файлы в текущем
  каталоге; rmtmp убирает только файлы, созданные посредством tmpfile.
  Функция должна быть использована только в тех каталогах,в которых
  были созданы временные файлы.

    ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ

   Число закрытых и удаленных временных файлов.

    СМОТРИ ТАКЖЕ

   flushall,tmpfile,tmpnam

    ПРИМЕР

  #include <stdio.h>
    main()
          {
          int numdeleted;
          .
          .
          .
          if ((stream = tmpfile( )) == NULL)
                   perror("Невозможно открыть новый временный файл");
                   .
                   .
                   .
                   numdeleted = rmtmp();
                   printf("Число закрытых и удаленных файлов в\
                   текущем каталоге = %d\n", numdeleted);
          }


